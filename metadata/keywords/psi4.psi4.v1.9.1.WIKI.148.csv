id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/master/autodir_options_c/pe__pe_ecp.html:408,Deployability,update,updated,408,"﻿. PE_ECP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; PE_ECP. PE_ECP¶. use PE(ECP) repulsive potentials. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; PE_ECP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/pe__pe_ecp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/pe__pe_ecp.html
https://psicode.org/psi4manual/master/autodir_options_c/pe__potfile.html:478,Deployability,update,updated,478,"﻿. POTFILE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; POTFILE. POTFILE¶. Name of the potential file OR contents of potential file to be written anonymously on-the-fly. Type: string; Default: potfile.pot. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; POTFILE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/pe__potfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/pe__potfile.html
https://psicode.org/psi4manual/master/autodir_options_c/pe__summation_fields.html:507,Deployability,update,updated,507,"﻿. SUMMATION_FIELDS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; SUMMATION_FIELDS. SUMMATION_FIELDS¶. Summation scheme for field computations, can be direct or fmm. Type: string; Possible Values: DIRECT, FMM; Default: DIRECT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; SUMMATION_FIELDS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/pe__summation_fields.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/pe__summation_fields.html
https://psicode.org/psi4manual/master/autodir_options_c/pe__tree_expansion_order.html:469,Deployability,update,updated,469,"﻿. TREE_EXPANSION_ORDER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; TREE_EXPANSION_ORDER. TREE_EXPANSION_ORDER¶. Expansion order of the multipoles for FMM. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; TREE_EXPANSION_ORDER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/pe__tree_expansion_order.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/pe__tree_expansion_order.html
https://psicode.org/psi4manual/master/autodir_options_c/pe__tree_theta.html:408,Deployability,update,updated,408,"﻿. TREE_THETA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; TREE_THETA. TREE_THETA¶. Opening angle theta. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PE; TREE_THETA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/pe__tree_theta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/pe__tree_theta.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__cc_num_threads.html:431,Deployability,update,updated,431,"﻿. CC_NUM_THREADS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CC_NUM_THREADS. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CC_NUM_THREADS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__cc_num_threads.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_ansatz.html:476,Deployability,update,updated,476,"﻿. CORR_ANSATZ. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_ANSATZ. CORR_ANSATZ¶. The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_ANSATZ. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__corr_ansatz.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_ansatz.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_ccsd_t.html:486,Deployability,update,updated,486,"﻿. CORR_CCSD_T. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CCSD_T. CORR_CCSD_T¶. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CCSD_T. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__corr_ccsd_t.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_ccsd_t.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_ccsd_t.html:196,Performance,perform,perform,196,"﻿. CORR_CCSD_T. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CCSD_T. CORR_CCSD_T¶. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CCSD_T. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__corr_ccsd_t.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_ccsd_t.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_charge.html:442,Deployability,update,updated,442,"﻿. CORR_CHARGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CHARGE. CORR_CHARGE¶. The molecular charge of the target state. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CHARGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__corr_charge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_charge.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_charge.html:175,Energy Efficiency,charge,charge,175,"﻿. CORR_CHARGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CHARGE. CORR_CHARGE¶. The molecular charge of the target state. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_CHARGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__corr_charge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_charge.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_multp.html:510,Deployability,update,updated,510,"﻿. CORR_MULTP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_MULTP. CORR_MULTP¶. The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_MULTP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__corr_multp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_multp.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_wfn.html:473,Deployability,update,updated,473,"﻿. CORR_WFN. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_WFN. CORR_WFN¶. The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; CORR_WFN. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__corr_wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__corr_wfn.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__coupling.html:504,Deployability,update,updated,504,"﻿. COUPLING. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; COUPLING. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; COUPLING. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__coupling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__coupling.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__coupling.html:165,Modifiability,coupling,coupling,165,"﻿. COUPLING. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; COUPLING. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; COUPLING. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__coupling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__coupling.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__coupling_terms.html:477,Deployability,update,updated,477,"﻿. COUPLING_TERMS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; COUPLING_TERMS. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; COUPLING_TERMS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__coupling_terms.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__coupling_terms.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html:243,Deployability,update,updates,243,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html:276,Deployability,update,update,276,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html:314,Deployability,update,update,314,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html:760,Deployability,update,updated,760,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diagonalize_heff.html:467,Deployability,update,updated,467,"﻿. DIAGONALIZE_HEFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIAGONALIZE_HEFF. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIAGONALIZE_HEFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__diagonalize_heff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diagonalize_heff.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diagonal_ccsd_t.html:477,Deployability,update,updated,477,"﻿. DIAGONAL_CCSD_T. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIAGONAL_CCSD_T. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIAGONAL_CCSD_T. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__diagonal_ccsd_t.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diagonal_ccsd_t.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_max_vecs.html:185,Availability,error,error,185,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_MAX_VECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_max_vecs.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_max_vecs.html:471,Deployability,update,updated,471,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_MAX_VECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_max_vecs.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_start.html:465,Deployability,update,updated,465,"﻿. DIIS_START. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_START. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_START. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__diis_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_start.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_start.html:216,Performance,perform,performed,216,"﻿. DIIS_START. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_START. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; DIIS_START. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__diis_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__diis_start.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__e_convergence.html:546,Deployability,update,updated,546,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; E_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__e_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__e_convergence.html:193,Energy Efficiency,energy,energy,193,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; E_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__e_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__favg_ccsd_t.html:478,Deployability,update,updated,478,"﻿. FAVG_CCSD_T. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; FAVG_CCSD_T. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; FAVG_CCSD_T. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__favg_ccsd_t.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__favg_ccsd_t.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__follow_root.html:462,Deployability,update,updated,462,"﻿. FOLLOW_ROOT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; FOLLOW_ROOT. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; FOLLOW_ROOT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__follow_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__follow_root.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__heff4.html:452,Deployability,update,updated,452,"﻿. HEFF4. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; HEFF4. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; HEFF4. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__heff4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__heff4.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__heff_print.html:437,Deployability,update,updated,437,"﻿. HEFF_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; HEFF_PRINT. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; HEFF_PRINT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__heff_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__heff_print.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__lock_singlet.html:438,Deployability,update,updated,438,"﻿. LOCK_SINGLET. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; LOCK_SINGLET. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; LOCK_SINGLET. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__lock_singlet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__lock_singlet.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__maxiter.html:444,Deployability,update,updated,444,"﻿. MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MAXITER. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__mp2_ccsd_method.html:482,Deployability,update,updated,482,"﻿. MP2_CCSD_METHOD. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MP2_CCSD_METHOD. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MP2_CCSD_METHOD. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__mp2_ccsd_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__mp2_ccsd_method.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__mp2_ccsd_method.html:180,Performance,perform,perform,180,"﻿. MP2_CCSD_METHOD. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MP2_CCSD_METHOD. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MP2_CCSD_METHOD. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__mp2_ccsd_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__mp2_ccsd_method.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__mp2_guess.html:423,Deployability,update,updated,423,"﻿. MP2_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MP2_GUESS. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; MP2_GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__mp2_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__mp2_guess.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__no_singles.html:453,Deployability,update,updated,453,"﻿. NO_SINGLES. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; NO_SINGLES. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; NO_SINGLES. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__no_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__no_singles.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__offdiagonal_ccsd_t.html:493,Deployability,update,updated,493,"﻿. OFFDIAGONAL_CCSD_T. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; OFFDIAGONAL_CCSD_T. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; OFFDIAGONAL_CCSD_T. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__offdiagonal_ccsd_t.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__offdiagonal_ccsd_t.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs.html:191,Availability,error,error,191,"﻿. PERTURB_CBS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS. PERTURB_CBS¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__perturb_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs.html:448,Deployability,update,updated,448,"﻿. PERTURB_CBS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS. PERTURB_CBS¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__perturb_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs_coupling.html:218,Availability,error,error,218,"﻿. PERTURB_CBS_COUPLING. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS_COUPLING. PERTURB_CBS_COUPLING¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS_COUPLING. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__perturb_cbs_coupling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs_coupling.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs_coupling.html:483,Deployability,update,updated,483,"﻿. PERTURB_CBS_COUPLING. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS_COUPLING. PERTURB_CBS_COUPLING¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PERTURB_CBS_COUPLING. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__perturb_cbs_coupling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__perturb_cbs_coupling.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__pt_energy.html:458,Deployability,update,updated,458,"﻿. PT_ENERGY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PT_ENERGY. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Default: SECOND_ORDER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PT_ENERGY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__pt_energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__pt_energy.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__pt_energy.html:202,Performance,perform,perform,202,"﻿. PT_ENERGY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PT_ENERGY. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Default: SECOND_ORDER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; PT_ENERGY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__pt_energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__pt_energy.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__r_convergence.html:465,Deployability,update,updated,465,"﻿. R_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; R_CONVERGENCE. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; R_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__r_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__small_cutoff.html:404,Deployability,update,updated,404,"﻿. SMALL_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; SMALL_CUTOFF. SMALL_CUTOFF¶. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; SMALL_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__small_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__small_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__tikhonow_max.html:517,Deployability,update,updated,517,"﻿. TIKHONOW_MAX. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TIKHONOW_MAX. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TIKHONOW_MAX. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__tikhonow_max.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__tikhonow_max.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__tikhonow_omega.html:508,Deployability,update,updated,508,"﻿. TIKHONOW_OMEGA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TIKHONOW_OMEGA. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TIKHONOW_OMEGA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__tikhonow_omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__tikhonow_omega.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__tikhonow_triples.html:477,Deployability,update,updated,477,"﻿. TIKHONOW_TRIPLES. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TIKHONOW_TRIPLES. TIKHONOW_TRIPLES¶. Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TIKHONOW_TRIPLES. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__tikhonow_triples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__tikhonow_triples.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__triples_algorithm.html:540,Deployability,update,updated,540,"﻿. TRIPLES_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TRIPLES_ALGORITHM. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TRIPLES_ALGORITHM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__triples_algorithm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__triples_algorithm.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__triples_diis.html:496,Deployability,update,updated,496,"﻿. TRIPLES_DIIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TRIPLES_DIIS. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; TRIPLES_DIIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__triples_diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__triples_diis.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_sym.html:488,Deployability,update,updated,488,"﻿. USE_SPIN_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYM. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__use_spin_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_sym.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html:226,Deployability,configurat,configurations,226,"﻿. USE_SPIN_SYMMETRY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYMMETRY. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYMMETRY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html:522,Deployability,update,updated,522,"﻿. USE_SPIN_SYMMETRY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYMMETRY. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYMMETRY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html:226,Modifiability,config,configurations,226,"﻿. USE_SPIN_SYMMETRY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYMMETRY. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; USE_SPIN_SYMMETRY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__use_spin_symmetry.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__wfn_sym.html:501,Deployability,update,updated,501,"﻿. WFN_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; WFN_SYM. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; WFN_SYM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__wfn_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__wfn_sym.html
https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__zero_internal_amps.html:526,Deployability,update,updated,526,"﻿. ZERO_INTERNAL_AMPS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; ZERO_INTERNAL_AMPS. ZERO_INTERNAL_AMPS¶. Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC; ZERO_INTERNAL_AMPS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/psimrcc__zero_internal_amps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/psimrcc__zero_internal_amps.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__aio_cphf.html:542,Deployability,update,updated,542,"﻿. AIO_CPHF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; AIO_CPHF. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; AIO_CPHF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__aio_cphf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__aio_cphf.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__aio_df_ints.html:553,Deployability,update,updated,553,"﻿. AIO_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; AIO_DF_INTS. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; AIO_DF_INTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__aio_df_ints.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__aio_df_ints.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__basis.html:470,Deployability,update,updated,470,"﻿. BASIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; BASIS. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; BASIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__basis.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_e_convergence.html:451,Deployability,update,updated,451,"﻿. CCD_E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_E_CONVERGENCE. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_E_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__ccd_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_e_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_maxiter.html:415,Deployability,update,updated,415,"﻿. CCD_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_MAXITER. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__ccd_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_t_convergence.html:188,Availability,toler,tolerance,188,"﻿. CCD_T_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_T_CONVERGENCE. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_T_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__ccd_t_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_t_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_t_convergence.html:467,Deployability,update,updated,467,"﻿. CCD_T_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_T_CONVERGENCE. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CCD_T_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__ccd_t_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__ccd_t_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__coupled_induction.html:268,Availability,avail,available,268,"﻿. COUPLED_INDUCTION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; COUPLED_INDUCTION. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; COUPLED_INDUCTION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__coupled_induction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__coupled_induction.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__coupled_induction.html:714,Deployability,update,updated,714,"﻿. COUPLED_INDUCTION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; COUPLED_INDUCTION. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; COUPLED_INDUCTION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__coupled_induction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__coupled_induction.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__coupled_induction.html:437,Energy Efficiency,energy,energy,437,"﻿. COUPLED_INDUCTION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; COUPLED_INDUCTION. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; COUPLED_INDUCTION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__coupled_induction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__coupled_induction.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__cphf_r_convergence.html:662,Deployability,update,updated,662,"﻿. CPHF_R_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CPHF_R_CONVERGENCE. CPHF_R_CONVERGENCE¶. Convergence criterion for residual of the CPHF/CPKS coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. This applies to wavefunction-based SAPT or SAPT(DFT). See CPHF_R_CONVERGENCE for fragment-partitioned or intramolecular SAPT. Type: conv double; Default: 1e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; CPHF_R_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__cphf_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__cphf_r_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_algorithm.html:566,Deployability,update,updated,566,"﻿. DENOMINATOR_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_ALGORITHM. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_ALGORITHM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__denominator_algorithm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_algorithm.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_algorithm.html:268,Energy Efficiency,efficient,efficient,268,"﻿. DENOMINATOR_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_ALGORITHM. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_ALGORITHM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__denominator_algorithm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_algorithm.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html:184,Availability,error,error,184,"﻿. DENOMINATOR_DELTA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__denominator_delta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html:203,Availability,error,error,203,"﻿. DENOMINATOR_DELTA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__denominator_delta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html:602,Deployability,update,updated,602,"﻿. DENOMINATOR_DELTA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__denominator_delta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html:250,Energy Efficiency,energy,energy,250,"﻿. DENOMINATOR_DELTA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DENOMINATOR_DELTA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__denominator_delta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__denominator_delta.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__df_basis_elst.html:661,Deployability,update,updated,661,"﻿. DF_BASIS_ELST. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DF_BASIS_ELST. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to a JKFIT basis. Previous to v1.6, defaulted to DF_BASIS_SAPT See fitting notes . Type: string; Possible Values: basis string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DF_BASIS_ELST. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__df_basis_elst.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__df_basis_elst.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__df_basis_sapt.html:524,Deployability,update,updated,524,"﻿. DF_BASIS_SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DF_BASIS_SAPT. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DF_BASIS_SAPT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__df_basis_sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__df_basis_sapt.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_ccd_disp.html:461,Deployability,update,updated,461,"﻿. DO_CCD_DISP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_CCD_DISP. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_CCD_DISP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__do_ccd_disp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_ccd_disp.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_disp_exch_sinf.html:514,Deployability,update,updated,514,"﻿. DO_DISP_EXCH_SINF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_DISP_EXCH_SINF. DO_DISP_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_DISP_EXCH_SINF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__do_disp_exch_sinf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_disp_exch_sinf.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_ind30_exch_sinf.html:505,Deployability,update,updated,505,"﻿. DO_IND30_EXCH_SINF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_IND30_EXCH_SINF. DO_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_IND30_EXCH_SINF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__do_ind30_exch_sinf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_ind30_exch_sinf.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_ind_exch_sinf.html:509,Deployability,update,updated,509,"﻿. DO_IND_EXCH_SINF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_IND_EXCH_SINF. DO_IND_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_IND_EXCH_SINF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__do_ind_exch_sinf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_ind_exch_sinf.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_mbpt_disp.html:484,Deployability,update,updated,484,"﻿. DO_MBPT_DISP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_MBPT_DISP. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_MBPT_DISP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__do_mbpt_disp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_mbpt_disp.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_third_order.html:447,Deployability,update,updated,447,"﻿. DO_THIRD_ORDER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_THIRD_ORDER. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; DO_THIRD_ORDER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__do_third_order.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__do_third_order.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html:678,Deployability,update,updated,678,"﻿. EXCH_SCALE_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html:191,Performance,perform,perform,191,"﻿. EXCH_SCALE_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html:297,Performance,perform,performs,297,"﻿. EXCH_SCALE_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html:375,Performance,perform,performs,375,"﻿. EXCH_SCALE_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; EXCH_SCALE_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__exch_scale_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__freeze_core.html:586,Deployability,update,updated,586,"﻿. FREEZE_CORE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; FREEZE_CORE. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; FREEZE_CORE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__freeze_core.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__freeze_core.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__ints_tolerance.html:687,Deployability,update,updated,687,"﻿. INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; INTS_TOLERANCE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; INTS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__ints_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__maxiter.html:414,Deployability,update,updated,414,"﻿. MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; MAXITER. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__max_ccd_diisvecs.html:459,Deployability,update,updated,459,"﻿. MAX_CCD_DIISVECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; MAX_CCD_DIISVECS. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; MAX_CCD_DIISVECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__max_ccd_diisvecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__max_ccd_diisvecs.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__min_ccd_diisvecs.html:458,Deployability,update,updated,458,"﻿. MIN_CCD_DIISVECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; MIN_CCD_DIISVECS. MIN_CCD_DIISVECS¶. Minimum number of vectors used in CCD-DIIS. Type: integer; Default: 4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; MIN_CCD_DIISVECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__min_ccd_diisvecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__min_ccd_diisvecs.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__nat_orbs_t2.html:580,Deployability,update,updated,580,"﻿. NAT_ORBS_T2. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; NAT_ORBS_T2. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; NAT_ORBS_T2. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__nat_orbs_t2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__nat_orbs_t2.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__nat_orbs_t3.html:567,Deployability,update,updated,567,"﻿. NAT_ORBS_T3. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; NAT_ORBS_T3. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; NAT_ORBS_T3. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__nat_orbs_t3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__nat_orbs_t3.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__nat_orbs_v4.html:571,Deployability,update,updated,571,"﻿. NAT_ORBS_V4. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; NAT_ORBS_V4. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; NAT_ORBS_V4. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__nat_orbs_v4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__nat_orbs_v4.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__occ_tolerance.html:555,Deployability,update,updated,555,"﻿. OCC_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; OCC_TOLERANCE. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; OCC_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__occ_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__occ_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__print.html:590,Deployability,update,updated,590,"﻿. PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; PRINT. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; PRINT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__print.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt0_e10.html:591,Deployability,update,updated,591,"﻿. SAPT0_E10. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT0_E10. SAPT0_E10¶. For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT0_E10. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt0_e10.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt0_e10.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt0_e20disp.html:589,Deployability,update,updated,589,"﻿. SAPT0_E20DISP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT0_E20DISP. SAPT0_E20DISP¶. For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT0_E20DISP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt0_e20disp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt0_e20disp.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt0_e20ind.html:585,Deployability,update,updated,585,"﻿. SAPT0_E20IND. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT0_E20IND. SAPT0_E20IND¶. For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT0_E20IND. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt0_e20ind.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt0_e20ind.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_do_dhf.html:447,Deployability,update,updated,447,"﻿. SAPT_DFT_DO_DHF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_DO_DHF. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_DO_DHF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_do_dhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_do_dhf.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_do_hybrid.html:470,Deployability,update,updated,470,"﻿. SAPT_DFT_DO_HYBRID. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_DO_HYBRID. SAPT_DFT_DO_HYBRID¶. Enables the hybrid xc kernel in dispersion?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_DO_HYBRID. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_do_hybrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_do_hybrid.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_exch_disp_fixed_scale.html:765,Deployability,update,updated,765,"﻿. SAPT_DFT_EXCH_DISP_FIXED_SCALE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_EXCH_DISP_FIXED_SCALE. SAPT_DFT_EXCH_DISP_FIXED_SCALE¶. Exch-disp scaling factor for FIXED scheme for SAPT_DFT_EXCH_DISP_SCALE_SCHEME Default value of 0.770 suggested in Y. Xie, D. G. A. Smith and C. D. Sherrill, 2022 (submitted). Previous to Nov 2022, default value was 0.686 suggested by Hesselmann and Korona, J. Chem. Phys. 141, 094107 (2014). Type: double; Default: 0.770. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_EXCH_DISP_FIXED_SCALE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_exch_disp_fixed_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_exch_disp_fixed_scale.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_exch_disp_scale_scheme.html:814,Deployability,update,updated,814,"﻿. SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. SAPT_DFT_EXCH_DISP_SCALE_SCHEME¶. Scheme for approximating exchange-dispersion for SAPT-DFT. Previous to Nov 2022, default was FIXED with Hesselmann value. NONE Use unscaled Exch-Disp2,u . FIXED Use a fixed factor SAPT_DFT_EXCH_DISP_FIXED_SCALE to scale Exch-Disp2,u . DISP Use the ratio of Disp2,r and Disp2,u to scale Exch-Disp2,u . Type: string; Possible Values: NONE, FIXED, DISP; Default: FIXED. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_exch_disp_scale_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_exch_disp_scale_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_functional.html:472,Deployability,update,updated,472,"﻿. SAPT_DFT_FUNCTIONAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_FUNCTIONAL. SAPT_DFT_FUNCTIONAL¶. Underlying funcitonal to use for SAPT(DFT). Type: string; Default: PBE0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_FUNCTIONAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_functional.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_determination.html:525,Deployability,update,updated,525,"﻿. SAPT_DFT_GRAC_DETERMINATION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_GRAC_DETERMINATION. SAPT_DFT_GRAC_DETERMINATION¶. How is the GRAC correction determined?. Type: string; Possible Values: INPUT; Default: INPUT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_GRAC_DETERMINATION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_determination.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_determination.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_shift_a.html:468,Deployability,update,updated,468,"﻿. SAPT_DFT_GRAC_SHIFT_A. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_GRAC_SHIFT_A. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift in Hartree. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_GRAC_SHIFT_A. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_shift_a.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_shift_a.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_shift_b.html:468,Deployability,update,updated,468,"﻿. SAPT_DFT_GRAC_SHIFT_B. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_GRAC_SHIFT_B. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift in Hartree. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_GRAC_SHIFT_B. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_shift_b.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_grac_shift_b.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_mp2_disp_alg.html:503,Deployability,update,updated,503,"﻿. SAPT_DFT_MP2_DISP_ALG. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_MP2_DISP_ALG. SAPT_DFT_MP2_DISP_ALG¶. Which MP2 Exch-Disp module to use?. Type: string; Possible Values: FISAPT, SAPT; Default: SAPT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_DFT_MP2_DISP_ALG. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_dft_mp2_disp_alg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_dft_mp2_disp_alg.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html:264,Deployability,integrat,integration,264,"﻿. SAPT_FDDS_DISP_LEG_LAMBDA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_LEG_LAMBDA. SAPT_FDDS_DISP_LEG_LAMBDA¶. Lambda shift in the space morphing for the FDDS Dispersion time integration. Type: double; Default: 0.3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_LEG_LAMBDA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html:528,Deployability,update,updated,528,"﻿. SAPT_FDDS_DISP_LEG_LAMBDA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_LEG_LAMBDA. SAPT_FDDS_DISP_LEG_LAMBDA¶. Lambda shift in the space morphing for the FDDS Dispersion time integration. Type: double; Default: 0.3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_LEG_LAMBDA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html:264,Integrability,integrat,integration,264,"﻿. SAPT_FDDS_DISP_LEG_LAMBDA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_LEG_LAMBDA. SAPT_FDDS_DISP_LEG_LAMBDA¶. Lambda shift in the space morphing for the FDDS Dispersion time integration. Type: double; Default: 0.3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_LEG_LAMBDA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_leg_lambda.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html:254,Deployability,integrat,integration,254,"﻿. SAPT_FDDS_DISP_NUM_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_NUM_POINTS. SAPT_FDDS_DISP_NUM_POINTS¶. Number of points in the Legendre FDDS Dispersion time integration. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_NUM_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html:518,Deployability,update,updated,518,"﻿. SAPT_FDDS_DISP_NUM_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_NUM_POINTS. SAPT_FDDS_DISP_NUM_POINTS¶. Number of points in the Legendre FDDS Dispersion time integration. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_NUM_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html:254,Integrability,integrat,integration,254,"﻿. SAPT_FDDS_DISP_NUM_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_NUM_POINTS. SAPT_FDDS_DISP_NUM_POINTS¶. Number of points in the Legendre FDDS Dispersion time integration. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_DISP_NUM_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_disp_num_points.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_v2_rho_cutoff.html:502,Deployability,update,updated,502,"﻿. SAPT_FDDS_V2_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_V2_RHO_CUTOFF. SAPT_FDDS_V2_RHO_CUTOFF¶. Minimum rho cutoff for the in the LDA response for FDDS. Type: double; Default: 1.e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_FDDS_V2_RHO_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_fdds_v2_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_fdds_v2_rho_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_level.html:471,Deployability,update,updated,471,"﻿. SAPT_LEVEL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_LEVEL. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_LEVEL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_level.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_level.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_check.html:515,Deployability,update,updated,515,"﻿. SAPT_MEM_CHECK. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_CHECK. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_CHECK. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_mem_check.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_check.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_factor.html:191,Availability,avail,available,191,"﻿. SAPT_MEM_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_FACTOR. SAPT_MEM_FACTOR¶. Proportion of memory available for the DF-MP2 three-index integral buffers used to evaluate dispersion. Type: double; Default: 0.9. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_FACTOR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_mem_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_factor.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_factor.html:515,Deployability,update,updated,515,"﻿. SAPT_MEM_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_FACTOR. SAPT_MEM_FACTOR¶. Proportion of memory available for the DF-MP2 three-index integral buffers used to evaluate dispersion. Type: double; Default: 0.9. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_FACTOR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_mem_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_factor.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_safety.html:426,Deployability,update,updated,426,"﻿. SAPT_MEM_SAFETY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_SAFETY. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_SAFETY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_mem_safety.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_safety.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_safety.html:177,Safety,safe,safety,177,"﻿. SAPT_MEM_SAFETY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_SAFETY. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_MEM_SAFETY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_mem_safety.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_mem_safety.html
https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_quiet.html:432,Deployability,update,updated,432,"﻿. SAPT_QUIET. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_QUIET. SAPT_QUIET¶. Interior option to clean up printing. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SAPT; SAPT_QUIET. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/sapt__sapt_quiet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/sapt__sapt_quiet.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__basis.html:426,Deployability,update,updated,426,"﻿. BASIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; BASIS. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; BASIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__basis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__basis_guess.html:629,Deployability,update,updated,629,"﻿. BASIS_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; BASIS_GUESS. BASIS_GUESS¶. Accelerate convergence by performing a preliminary SCF with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the Defaults small basis set 3-21G, pcseg-0, or def2-SV(P). Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; BASIS_GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__basis_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__basis_guess.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__basis_guess.html:183,Performance,perform,performing,183,"﻿. BASIS_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; BASIS_GUESS. BASIS_GUESS¶. Accelerate convergence by performing a preliminary SCF with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the Defaults small basis set 3-21G, pcseg-0, or def2-SV(P). Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; BASIS_GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__basis_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__basis_guess.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cholesky_tolerance.html:483,Deployability,update,updated,483,"﻿. CHOLESKY_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; CHOLESKY_TOLERANCE. CHOLESKY_TOLERANCE¶. Tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1e-4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; CHOLESKY_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cholesky_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cholesky_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_basis_tolerance.html:498,Deployability,update,updated,498,"﻿. COSX_BASIS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_BASIS_TOLERANCE. COSX_BASIS_TOLERANCE¶. Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_BASIS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_basis_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_basis_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_density_tolerance.html:499,Deployability,update,updated,499,"﻿. COSX_DENSITY_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_DENSITY_TOLERANCE. COSX_DENSITY_TOLERANCE¶. Screening criteria for shell-pair densities in COSX. Type: conv double; Default: 1.0e-10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_DENSITY_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_density_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_density_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_ints_tolerance.html:494,Deployability,update,updated,494,"﻿. COSX_INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_INTS_TOLERANCE. COSX_INTS_TOLERANCE¶. Screening criteria for integrals and intermediates in COSX. Type: conv double; Default: 1.0e-11. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_INTS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_ints_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html:366,Availability,failure,failure,366,"﻿. COSX_MAXITER_FINAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_MAXITER_FINAL. COSX_MAXITER_FINAL¶. Controls SCF iteration behavior for the larger (i.e., final) COSX grid. -1 fully converges the SCF on the final grid if possible, ending early if MAXITER total SCF iterations are reached (failure). 0 disables the final COSX grid entirely. n runs up to n iterations on the final COSX grid, ending early if SCF convergence is reached (success) or if MAXITER total SCF iterations are reached (failure). Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_MAXITER_FINAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html:568,Availability,failure,failure,568,"﻿. COSX_MAXITER_FINAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_MAXITER_FINAL. COSX_MAXITER_FINAL¶. Controls SCF iteration behavior for the larger (i.e., final) COSX grid. -1 fully converges the SCF on the final grid if possible, ending early if MAXITER total SCF iterations are reached (failure). 0 disables the final COSX grid entirely. n runs up to n iterations on the final COSX grid, ending early if SCF convergence is reached (success) or if MAXITER total SCF iterations are reached (failure). Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_MAXITER_FINAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html:820,Deployability,update,updated,820,"﻿. COSX_MAXITER_FINAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_MAXITER_FINAL. COSX_MAXITER_FINAL¶. Controls SCF iteration behavior for the larger (i.e., final) COSX grid. -1 fully converges the SCF on the final grid if possible, ending early if MAXITER total SCF iterations are reached (failure). 0 disables the final COSX grid entirely. n runs up to n iterations on the final COSX grid, ending early if SCF convergence is reached (success) or if MAXITER total SCF iterations are reached (failure). Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_MAXITER_FINAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_maxiter_final.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html:209,Availability,error,errors,209,"﻿. COSX_OVERLAP_FITTING. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_OVERLAP_FITTING. COSX_OVERLAP_FITTING¶. Do reduce numerical COSX errors with overlap fitting?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_OVERLAP_FITTING. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html:486,Deployability,update,updated,486,"﻿. COSX_OVERLAP_FITTING. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_OVERLAP_FITTING. COSX_OVERLAP_FITTING¶. Do reduce numerical COSX errors with overlap fitting?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_OVERLAP_FITTING. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html:187,Energy Efficiency,reduce,reduce,187,"﻿. COSX_OVERLAP_FITTING. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_OVERLAP_FITTING. COSX_OVERLAP_FITTING¶. Do reduce numerical COSX errors with overlap fitting?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_OVERLAP_FITTING. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_overlap_fitting.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_pruning_scheme.html:459,Deployability,update,updated,459,"﻿. COSX_PRUNING_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_PRUNING_SCHEME. COSX_PRUNING_SCHEME¶. Pruning scheme for COSX grids. Type: string; Default: ROBUST. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_PRUNING_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_pruning_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_pruning_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_radial_points_final.html:489,Deployability,update,updated,489,"﻿. COSX_RADIAL_POINTS_FINAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_RADIAL_POINTS_FINAL. COSX_RADIAL_POINTS_FINAL¶. Number of radial points in final COSX grid. Type: integer; Default: 35. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_RADIAL_POINTS_FINAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_radial_points_final.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_radial_points_final.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_radial_points_initial.html:499,Deployability,update,updated,499,"﻿. COSX_RADIAL_POINTS_INITIAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_RADIAL_POINTS_INITIAL. COSX_RADIAL_POINTS_INITIAL¶. Number of radial points in initial COSX grid. Type: integer; Default: 25. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_RADIAL_POINTS_INITIAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_radial_points_initial.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_radial_points_initial.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_spherical_points_final.html:505,Deployability,update,updated,505,"﻿. COSX_SPHERICAL_POINTS_FINAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_SPHERICAL_POINTS_FINAL. COSX_SPHERICAL_POINTS_FINAL¶. Number of spherical points in final COSX grid. Type: integer; Default: 110. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_SPHERICAL_POINTS_FINAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_spherical_points_final.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_spherical_points_final.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_spherical_points_initial.html:514,Deployability,update,updated,514,"﻿. COSX_SPHERICAL_POINTS_INITIAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_SPHERICAL_POINTS_INITIAL. COSX_SPHERICAL_POINTS_INITIAL¶. Number of spherical points in initial COSX grid. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; COSX_SPHERICAL_POINTS_INITIAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__cosx_spherical_points_initial.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__cosx_spherical_points_initial.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_convergence.html:669,Deployability,update,updated,669,"﻿. DAMPING_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_CONVERGENCE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__damping_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_convergence.html:248,Performance,perform,performed,248,"﻿. DAMPING_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_CONVERGENCE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__damping_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html:243,Deployability,update,updates,243,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html:276,Deployability,update,update,276,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html:314,Deployability,update,update,314,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html:742,Deployability,update,updated,742,"﻿. DAMPING_PERCENTAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DAMPING_PERCENTAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__damping_percentage.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__damping_percentage.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_alpha.html:419,Deployability,update,updated,419,"﻿. DFT_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_ALPHA. DFT_ALPHA¶. The DFT Exact-exchange parameter. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_alpha_c.html:431,Deployability,update,updated,431,"﻿. DFT_ALPHA_C. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_ALPHA_C. DFT_ALPHA_C¶. The DFT Correlation hybrid parameter. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_ALPHA_C. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_alpha_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_alpha_c.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_basis_tolerance.html:452,Deployability,update,updated,452,"﻿. DFT_BASIS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BASIS_TOLERANCE. DFT_BASIS_TOLERANCE¶. DFT basis cutoff. Type: conv double; Default: 1.0e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BASIS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_basis_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_basis_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_max_points.html:486,Deployability,update,updated,486,"﻿. DFT_BLOCK_MAX_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_MAX_POINTS. DFT_BLOCK_MAX_POINTS¶. The maximum number of grid points per evaluation block. Type: integer; Default: 256. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_MAX_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_block_max_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_max_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_max_radius.html:498,Deployability,update,updated,498,"﻿. DFT_BLOCK_MAX_RADIUS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_MAX_RADIUS. DFT_BLOCK_MAX_RADIUS¶. The maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_MAX_RADIUS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_block_max_radius.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_max_radius.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_min_points.html:486,Deployability,update,updated,486,"﻿. DFT_BLOCK_MIN_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_MIN_POINTS. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_MIN_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_block_min_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_min_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_scheme.html:485,Deployability,update,updated,485,"﻿. DFT_BLOCK_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_SCHEME. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Type: string; Possible Values: NAIVE, OCTREE, ATOMIC; Default: OCTREE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BLOCK_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_block_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_block_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_bs_radius_alpha.html:472,Deployability,update,updated,472,"﻿. DFT_BS_RADIUS_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BS_RADIUS_ALPHA. DFT_BS_RADIUS_ALPHA¶. Factor for effective BS radius in radial grid. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_BS_RADIUS_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_bs_radius_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_bs_radius_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_density_tolerance.html:533,Deployability,update,updated,533,"﻿. DFT_DENSITY_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_DENSITY_TOLERANCE. DFT_DENSITY_TOLERANCE¶. density cutoff for LibXC. A negative value turns the feature off and LibXC defaults are used. Type: conv double; Default: -1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_DENSITY_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_density_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_density_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_dispersion_parameters.html:699,Deployability,update,updated,699,"﻿. DFT_DISPERSION_PARAMETERS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_DISPERSION_PARAMETERS. DFT_DISPERSION_PARAMETERS¶. Parameters defining the dispersion correction. See Table -D Functionals for default values and Table Dispersion Corrections for the order in which parameters are to be specified in this array option. Unused for functionals constructed by user. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_DISPERSION_PARAMETERS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_dispersion_parameters.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_dispersion_parameters.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_alpha.html:465,Deployability,update,updated,465,"﻿. DFT_GRAC_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_ALPHA. DFT_GRAC_ALPHA¶. The gradient regularized asymptotic correction alpha value. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_grac_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_beta.html:461,Deployability,update,updated,461,"﻿. DFT_GRAC_BETA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_BETA. DFT_GRAC_BETA¶. The gradient regularized asymptotic correction beta value. Type: double; Default: 40.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_BETA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_grac_beta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_beta.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_c_func.html:487,Deployability,update,updated,487,"﻿. DFT_GRAC_C_FUNC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_C_FUNC. DFT_GRAC_C_FUNC¶. The gradient regularized asymptotic correction functional corr form. Type: string; Default: XC_LDA_C_VWN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_C_FUNC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_grac_c_func.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_c_func.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_shift.html:465,Deployability,update,updated,465,"﻿. DFT_GRAC_SHIFT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_SHIFT. DFT_GRAC_SHIFT¶. The gradient regularized asymptotic correction shift value. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_SHIFT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_grac_shift.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_shift.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_x_func.html:486,Deployability,update,updated,486,"﻿. DFT_GRAC_X_FUNC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_X_FUNC. DFT_GRAC_X_FUNC¶. The gradient regularized asymptotic correction functional exch form. Type: string; Default: XC_GGA_X_LB. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRAC_X_FUNC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_grac_x_func.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grac_x_func.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grid_name.html:476,Deployability,update,updated,476,"﻿. DFT_GRID_NAME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRID_NAME. DFT_GRID_NAME¶. The DFT grid specification, such as SG1. Type: string; Possible Values: SG0, SG1; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_GRID_NAME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_grid_name.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_grid_name.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_nuclear_scheme.html:502,Deployability,update,updated,502,"﻿. DFT_NUCLEAR_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_NUCLEAR_SCHEME. DFT_NUCLEAR_SCHEME¶. Nuclear Scheme. Type: string; Possible Values: TREUTLER, BECKE, NAIVE, STRATMANN, SBECKE; Default: TREUTLER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_NUCLEAR_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_nuclear_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_nuclear_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_omega.html:421,Deployability,update,updated,421,"﻿. DFT_OMEGA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_OMEGA. DFT_OMEGA¶. The DFT Range-separation parameter. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_OMEGA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_omega.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_omega_c.html:441,Deployability,update,updated,441,"﻿. DFT_OMEGA_C. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_OMEGA_C. DFT_OMEGA_C¶. The DFT Correlation Range-separation parameter. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_OMEGA_C. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_omega_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_omega_c.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_pruning_alpha.html:455,Deployability,update,updated,455,"﻿. DFT_PRUNING_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_pruning_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_pruning_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_pruning_alpha.html:192,Testability,log,logarithmic,192,"﻿. DFT_PRUNING_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_pruning_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_pruning_alpha.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_pruning_scheme.html:685,Deployability,update,updated,685,"﻿. DFT_PRUNING_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_SCHEME. DFT_PRUNING_SCHEME¶. Select approach for pruning. Options ROBUST and TREUTLER prune based on regions (proximity to nucleus) while FLAT P_GAUSSIAN D_GAUSSIAN P_SLATER D_SLATER LOG_GAUSSIAN LOG_SLATER prune based on decaying functions (experts only!). The recommended scheme is ROBUST. Type: string; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_pruning_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_pruning_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_radial_points.html:442,Deployability,update,updated,442,"﻿. DFT_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_POINTS. DFT_RADIAL_POINTS¶. Number of radial points. Type: integer; Default: 75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_radial_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_radial_scheme.html:491,Deployability,update,updated,491,"﻿. DFT_RADIAL_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_SCHEME. DFT_RADIAL_SCHEME¶. Radial Scheme. Type: string; Possible Values: TREUTLER, BECKE, MULTIEXP, EM, MURA; Default: TREUTLER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_radial_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_radial_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_remove_distant_points.html:545,Deployability,update,updated,545,"﻿. DFT_REMOVE_DISTANT_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_REMOVE_DISTANT_POINTS. DFT_REMOVE_DISTANT_POINTS¶. Remove points from the quadrature grid that exceed the spatial extend of the basis functions. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_REMOVE_DISTANT_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_remove_distant_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_remove_distant_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_remove_distant_points.html:262,Modifiability,extend,extend,262,"﻿. DFT_REMOVE_DISTANT_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_REMOVE_DISTANT_POINTS. DFT_REMOVE_DISTANT_POINTS¶. Remove points from the quadrature grid that exceed the spatial extend of the basis functions. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_REMOVE_DISTANT_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_remove_distant_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_remove_distant_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_spherical_points.html:484,Deployability,update,updated,484,"﻿. DFT_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_POINTS. DFT_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number). Type: integer; Default: 302. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_spherical_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_spherical_scheme.html:477,Deployability,update,updated,477,"﻿. DFT_SPHERICAL_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_SCHEME. DFT_SPHERICAL_SCHEME¶. Spherical Scheme. Type: string; Possible Values: LEBEDEV; Default: LEBEDEV. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_spherical_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_spherical_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_v2_rho_cutoff.html:260,Availability,toler,tolerance,260,"﻿. DFT_V2_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. DFT_V2_RHO_CUTOFF¶. Minima spin-summed density cutoff for the second derivative. Defaults to the density tolerance. Type: double; Default: -1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_v2_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_v2_rho_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_v2_rho_cutoff.html:514,Deployability,update,updated,514,"﻿. DFT_V2_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. DFT_V2_RHO_CUTOFF¶. Minima spin-summed density cutoff for the second derivative. Defaults to the density tolerance. Type: double; Default: -1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_v2_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_v2_rho_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_b.html:414,Deployability,update,updated,414,"﻿. DFT_VV10_B. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_B. DFT_VV10_B¶. Define VV10 parameter b. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_B. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_b.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_b.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_c.html:414,Deployability,update,updated,414,"﻿. DFT_VV10_C. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_C. DFT_VV10_C¶. Define VV10 parameter C. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_C. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_c.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_postscf.html:442,Deployability,update,updated,442,"﻿. DFT_VV10_POSTSCF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_POSTSCF. DFT_VV10_POSTSCF¶. post-scf VV10 correction. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_POSTSCF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_postscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_postscf.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html:226,Deployability,integrat,integration,226,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html:486,Deployability,update,updated,486,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html:226,Integrability,integrat,integration,226,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_radial_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html:204,Deployability,integrat,integration,204,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html:463,Deployability,update,updated,463,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html:204,Integrability,integrat,integration,204,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_rho_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html:264,Deployability,integrat,integration,264,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html:528,Deployability,update,updated,528,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html:264,Integrability,integrat,integration,264,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_vv10_spherical_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_weights_tolerance.html:481,Deployability,update,updated,481,"﻿. DFT_WEIGHTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_WEIGHTS_TOLERANCE. DFT_WEIGHTS_TOLERANCE¶. grid weight cutoff. Disable with -1.0. Type: conv double; Default: 1.0e-15. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_WEIGHTS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__dft_weights_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__dft_weights_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_basis_guess.html:669,Deployability,update,updated,669,"﻿. DF_BASIS_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_GUESS. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_basis_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_basis_guess.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_basis_sad.html:467,Deployability,update,updated,467,"﻿. DF_BASIS_SAD. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SAD. DF_BASIS_SAD¶. Density fitting basis used in SAD. Type: string; Possible Values: basis string; Default: SAD-FIT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SAD. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_basis_sad.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_basis_sad.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_basis_scf.html:520,Deployability,update,updated,520,"﻿. DF_BASIS_SCF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SCF. DF_BASIS_SCF¶. Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SCF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_basis_scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_basis_scf.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_bump_r0.html:415,Deployability,update,updated,415,"﻿. DF_BUMP_R0. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R0. DF_BUMP_R0¶. Bump function min radius. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R0. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_bump_r0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_bump_r0.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_bump_r1.html:415,Deployability,update,updated,415,"﻿. DF_BUMP_R1. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R1. DF_BUMP_R1¶. Bump function max radius. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R1. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_bump_r1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_bump_r1.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_domains.html:483,Deployability,update,updated,483,"﻿. DF_DOMAINS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_DOMAINS. DF_DOMAINS¶. FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_DOMAINS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_domains.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_domains.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_fitting_condition.html:518,Deployability,update,updated,518,"﻿. DF_FITTING_CONDITION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_FITTING_CONDITION. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_FITTING_CONDITION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_fitting_condition.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_fitting_condition.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_ints_io.html:561,Deployability,update,updated,561,"﻿. DF_INTS_IO. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_IO. DF_INTS_IO¶. IO caching for CP corrections, etc. Changing this selects Disk_DF over Mem_DF. Note that setting this forces DiskDFJK when SCF_TYPE=DF. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_IO. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_ints_io.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_ints_io.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_ints_num_threads.html:228,Availability,down,down,228,"﻿. DF_INTS_NUM_THREADS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_ints_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_ints_num_threads.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_ints_num_threads.html:512,Deployability,update,updated,512,"﻿. DF_INTS_NUM_THREADS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_ints_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_ints_num_threads.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_metric.html:454,Deployability,update,updated,454,"﻿. DF_METRIC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_METRIC. DF_METRIC¶. FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_METRIC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_metric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_metric.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_scf_guess.html:542,Deployability,update,updated,542,"﻿. DF_SCF_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_SCF_GUESS. DF_SCF_GUESS¶. Do a density fitting SCF calculation to converge the orbitals before switching to the use of exact integrals in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_SCF_GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_scf_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_scf_guess.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__df_theta.html:432,Deployability,update,updated,432,"﻿. DF_THETA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_THETA. DF_THETA¶. FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DF_THETA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__df_theta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__df_theta.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis.html:421,Deployability,update,updated,421,"﻿. DIIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_max_vecs.html:181,Availability,error,error,181,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_max_vecs.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_max_vecs.html:464,Deployability,update,updated,464,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_max_vecs.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_min_vecs.html:181,Availability,error,error,181,"﻿. DIIS_MIN_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Will be removed in v1.7. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_min_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_min_vecs.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_min_vecs.html:488,Deployability,update,updated,488,"﻿. DIIS_MIN_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Will be removed in v1.7. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_min_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_min_vecs.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html:174,Availability,error,error,174,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html:200,Availability,robust,robust,200,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html:216,Availability,error,error,216,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html:465,Deployability,update,updated,465,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_start.html:468,Deployability,update,updated,468,"﻿. DIIS_START. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. DIIS_START¶. The minimum iteration to start storing DIIS vectors and performing ADIIS/EDIIS. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_start.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_start.html:210,Performance,perform,performing,210,"﻿. DIIS_START. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. DIIS_START¶. The minimum iteration to start storing DIIS vectors and performing ADIIS/EDIIS. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__diis_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__diis_start.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__distributed_matrix.html:474,Deployability,update,updated,474,"﻿. DISTRIBUTED_MATRIX. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DISTRIBUTED_MATRIX. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; DISTRIBUTED_MATRIX. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__distributed_matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__distributed_matrix.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__d_convergence.html:677,Deployability,update,updated,677,"﻿. D_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; D_CONVERGENCE. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; D_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__d_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__d_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__extern.html:432,Deployability,update,updated,432,"﻿. EXTERN. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; EXTERN. EXTERN¶. An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; EXTERN. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__extern.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__extern.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__e_convergence.html:549,Deployability,update,updated,549,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__e_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__e_convergence.html:193,Energy Efficiency,energy,energy,193,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__e_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__fail_on_maxiter.html:457,Deployability,update,updated,457,"﻿. FAIL_ON_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FAIL_ON_MAXITER. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FAIL_ON_MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__fail_on_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__fail_on_maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__follow_step_increment.html:560,Deployability,update,updated,560,"﻿. FOLLOW_STEP_INCREMENT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_INCREMENT. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_INCREMENT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__follow_step_increment.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__follow_step_increment.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__follow_step_scale.html:563,Deployability,update,updated,563,"﻿. FOLLOW_STEP_SCALE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_SCALE. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_SCALE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__follow_step_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__follow_step_scale.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_diis.html:449,Deployability,update,updated,449,"﻿. FRAC_DIIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_DIIS. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_DIIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__frac_diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_diis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_load.html:430,Deployability,update,updated,430,"﻿. FRAC_LOAD. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_LOAD. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_LOAD. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__frac_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_load.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_occ.html:474,Deployability,update,updated,474,"﻿. FRAC_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_OCC. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_OCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__frac_occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_occ.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_renormalize.html:218,Availability,checkpoint,checkpoint,218,"﻿. FRAC_RENORMALIZE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__frac_renormalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_renormalize.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_renormalize.html:474,Deployability,update,updated,474,"﻿. FRAC_RENORMALIZE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__frac_renormalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_renormalize.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_start.html:480,Deployability,update,updated,480,"﻿. FRAC_START. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_START. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_START. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__frac_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_start.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_val.html:474,Deployability,update,updated,474,"﻿. FRAC_VAL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_VAL. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\le {\rm occ} \le 1.0\)). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_VAL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__frac_val.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__frac_val.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__guess.html:553,Deployability,update,updated,553,"﻿. GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. GUESS¶. The type of guess orbitals. See Initial Guess for what the options mean and what the defaults are. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, SAPGAU, HUCKEL, MODHUCKEL, READ; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__guess.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__guess_mix.html:592,Deployability,update,updated,592,"﻿. GUESS_MIX. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_MIX. GUESS_MIX¶. Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_MIX. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__guess_mix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__guess_mix.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__guess_persist.html:522,Deployability,update,updated,522,"﻿. GUESS_PERSIST. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__guess_persist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__guess_persist.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__guess_persist.html:267,Performance,optimiz,optimization,267,"﻿. GUESS_PERSIST. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__guess_persist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__guess_persist.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock.html:416,Deployability,update,updated,416,"﻿. INCFOCK. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK. INCFOCK¶. Do perform incremental Fock build?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__incfock.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock.html:148,Performance,perform,perform,148,"﻿. INCFOCK. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK. INCFOCK¶. Do perform incremental Fock build?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__incfock.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_convergence.html:512,Deployability,update,updated,512,"﻿. INCFOCK_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_CONVERGENCE. INCFOCK_CONVERGENCE¶. The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__incfock_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html:326,Availability,error,error,326,"﻿. INCFOCK_FULL_FOCK_EVERY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_FULL_FOCK_EVERY. INCFOCK_FULL_FOCK_EVERY¶. Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_FULL_FOCK_EVERY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html:611,Deployability,update,updated,611,"﻿. INCFOCK_FULL_FOCK_EVERY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_FULL_FOCK_EVERY. INCFOCK_FULL_FOCK_EVERY¶. Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_FULL_FOCK_EVERY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html:307,Safety,avoid,avoid,307,"﻿. INCFOCK_FULL_FOCK_EVERY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_FULL_FOCK_EVERY. INCFOCK_FULL_FOCK_EVERY¶. Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INCFOCK_FULL_FOCK_EVERY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__incfock_full_fock_every.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__ints_tolerance.html:535,Deployability,update,updated,535,"﻿. INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INTS_TOLERANCE. INTS_TOLERANCE¶. Screening threshold for the chosen screening method (SCHWARZ, CSAM, DENSITY) Absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; INTS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__ints_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__level_shift.html:416,Deployability,update,updated,416,"﻿. LEVEL_SHIFT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__level_shift.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__level_shift.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__level_shift_cutoff.html:183,Availability,error,error,183,"﻿. LEVEL_SHIFT_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__level_shift_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__level_shift_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__level_shift_cutoff.html:476,Deployability,update,updated,476,"﻿. LEVEL_SHIFT_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__level_shift_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__level_shift_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__link_ints_tolerance.html:195,Availability,toler,tolerance,195,"﻿. LINK_INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LINK_INTS_TOLERANCE. LINK_INTS_TOLERANCE¶. The screening tolerance used for ERI/Density sparsity in the LinK algorithm. Type: conv double; Default: 1.0e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LINK_INTS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__link_ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__link_ints_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__link_ints_tolerance.html:511,Deployability,update,updated,511,"﻿. LINK_INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LINK_INTS_TOLERANCE. LINK_INTS_TOLERANCE¶. The screening tolerance used for ERI/Density sparsity in the LinK algorithm. Type: conv double; Default: 1.0e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LINK_INTS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__link_ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__link_ints_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__local_convergence.html:479,Deployability,update,updated,479,"﻿. LOCAL_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_CONVERGENCE. LOCAL_CONVERGENCE¶. The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__local_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__local_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__local_maxiter.html:453,Deployability,update,updated,453,"﻿. LOCAL_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_MAXITER. LOCAL_MAXITER¶. The maxiter on the orbital localization procedure. Type: integer; Default: 200. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__local_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__local_maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__maxiter.html:467,Deployability,update,updated,467,"﻿. MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAXITER. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__max_attempts.html:515,Deployability,update,updated,515,"﻿. MAX_ATTEMPTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__max_attempts.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__max_attempts.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__max_attempts.html:224,Performance,optimiz,optimization,224,"﻿. MAX_ATTEMPTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__max_attempts.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__max_attempts.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__max_mem_buf.html:454,Deployability,update,updated,454,"﻿. MAX_MEM_BUF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_MEM_BUF. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_MEM_BUF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__max_mem_buf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__max_mem_buf.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__molden_write.html:610,Deployability,update,updated,610,"﻿. MOLDEN_WRITE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOLDEN_WRITE. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOLDEN_WRITE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__molden_write.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__molden_write.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__mom_occ.html:460,Deployability,update,updated,460,"﻿. MOM_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_OCC. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_OCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__mom_occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__mom_occ.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__mom_start.html:433,Deployability,update,updated,433,"﻿. MOM_START. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_START. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_START. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__mom_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__mom_start.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__mom_vir.html:458,Deployability,update,updated,458,"﻿. MOM_VIR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_VIR. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_VIR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__mom_vir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__mom_vir.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__nl_dispersion_parameters.html:522,Deployability,update,updated,522,"﻿. NL_DISPERSION_PARAMETERS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; NL_DISPERSION_PARAMETERS. NL_DISPERSION_PARAMETERS¶. Parameters defining the -NL/-V dispersion correction. First b, then C. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; NL_DISPERSION_PARAMETERS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__nl_dispersion_parameters.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__nl_dispersion_parameters.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__onepot_grid_read.html:463,Deployability,update,updated,463,"﻿. ONEPOT_GRID_READ. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; ONEPOT_GRID_READ. ONEPOT_GRID_READ¶. Read an external potential from the .dx file?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; ONEPOT_GRID_READ. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__onepot_grid_read.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__onepot_grid_read.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__orbitals_write.html:488,Deployability,update,updated,488,"﻿. ORBITALS_WRITE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; ORBITALS_WRITE. ORBITALS_WRITE¶. File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; ORBITALS_WRITE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__orbitals_write.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__orbitals_write.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__parallel.html:405,Deployability,update,updated,405,"﻿. PARALLEL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PARALLEL. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PARALLEL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__parallel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__parallel.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_dipole.html:523,Deployability,update,updated,523,"﻿. PERTURB_DIPOLE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_DIPOLE. PERTURB_DIPOLE¶. An array of length three describing the magnitude (atomic units) of the dipole field in the {x,y,z} directions. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_DIPOLE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__perturb_dipole.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_dipole.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_h.html:417,Deployability,update,updated,417,"﻿. PERTURB_H. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_H. PERTURB_H¶. Do perturb the Hamiltonian?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_H. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__perturb_h.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_h.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_magnitude.html:523,Deployability,update,updated,523,"﻿. PERTURB_MAGNITUDE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_MAGNITUDE. PERTURB_MAGNITUDE¶. Size of the perturbation (applies only to dipole perturbations). Deprecated - use PERTURB_DIPOLE instead. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_MAGNITUDE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__perturb_magnitude.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_magnitude.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_with.html:628,Deployability,update,updated,628,"﻿. PERTURB_WITH. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_WITH. PERTURB_WITH¶. The operator used to perturb the Hamiltonian, if requested. DIPOLE_X, DIPOLE_Y and DIPOLE_Z will be removed in favor of the DIPOLE option in the future. Type: string; Possible Values: DIPOLE, DIPOLE_X, DIPOLE_Y, DIPOLE_Z, EMBPOT, SPHERE, DX; Default: DIPOLE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_WITH. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__perturb_with.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__perturb_with.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__phi_points.html:210,Deployability,integrat,integration,210,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__phi_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__phi_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__phi_points.html:459,Deployability,update,updated,459,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__phi_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__phi_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__phi_points.html:210,Integrability,integrat,integration,210,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__phi_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__phi_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__pk_all_nonsym.html:460,Deployability,update,updated,460,"﻿. PK_ALL_NONSYM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALL_NONSYM. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALL_NONSYM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__pk_all_nonsym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__pk_all_nonsym.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__pk_max_buckets.html:457,Deployability,update,updated,457,"﻿. PK_MAX_BUCKETS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PK_MAX_BUCKETS. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PK_MAX_BUCKETS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__pk_max_buckets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__pk_max_buckets.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__print_basis.html:421,Deployability,update,updated,421,"﻿. PRINT_BASIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_BASIS. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_BASIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__print_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__print_basis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__print_mos.html:422,Deployability,update,updated,422,"﻿. PRINT_MOS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_MOS. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_MOS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__print_mos.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__print_mos.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__process_grid.html:446,Deployability,update,updated,446,"﻿. PROCESS_GRID. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PROCESS_GRID. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; PROCESS_GRID. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__process_grid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__process_grid.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__qchf.html:400,Deployability,update,updated,400,"﻿. QCHF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__qchf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__qchf.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__qchf.html:139,Performance,perform,perform,139,"﻿. QCHF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__qchf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__qchf.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__radius.html:425,Deployability,update,updated,425,"﻿. RADIUS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; RADIUS. RADIUS¶. Radius (bohr) of a hard-sphere external potential. Type: double; Default: 10.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; RADIUS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__radius.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__radius.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__reference.html:521,Deployability,update,updated,521,"﻿. REFERENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; REFERENCE. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; REFERENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__reference.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__r_points.html:201,Deployability,integrat,integration,201,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__r_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__r_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__r_points.html:448,Deployability,update,updated,448,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__r_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__r_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__r_points.html:201,Integrability,integrat,integration,201,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__r_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__r_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_chol_tolerance.html:470,Deployability,update,updated,470,"﻿. SAD_CHOL_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_CHOL_TOLERANCE. SAD_CHOL_TOLERANCE¶. SAD guess density decomposition threshold. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_CHOL_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_chol_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_chol_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_d_convergence.html:507,Deployability,update,updated,507,"﻿. SAD_D_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_D_CONVERGENCE. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in the SAD guess, analogous to D_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_D_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_d_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_d_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_e_convergence.html:506,Deployability,update,updated,506,"﻿. SAD_E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_e_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_e_convergence.html:205,Energy Efficiency,energy,energy,205,"﻿. SAD_E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_e_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_frac_occ.html:495,Deployability,update,updated,495,"﻿. SAD_FRAC_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_FRAC_OCC. SAD_FRAC_OCC¶. Do force an even distribution of occupations across the last partially occupied orbital shell?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_FRAC_OCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_frac_occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_frac_occ.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_maxiter.html:445,Deployability,update,updated,445,"﻿. SAD_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_MAXITER. SAD_MAXITER¶. Maximum number of atomic SCF iterations within SAD. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_print.html:438,Deployability,update,updated,438,"﻿. SAD_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_PRINT. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_PRINT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_print.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_scf_type.html:523,Deployability,update,updated,523,"﻿. SAD_SCF_TYPE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SCF_TYPE. SAD_SCF_TYPE¶. SCF type used for atomic calculations in SAD guess. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: DF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SCF_TYPE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_scf_type.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_scf_type.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_spin_average.html:504,Deployability,update,updated,504,"﻿. SAD_SPIN_AVERAGE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SPIN_AVERAGE. SAD_SPIN_AVERAGE¶. Do use spin-averaged occupations instead of atomic ground spin state in fractional SAD?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SPIN_AVERAGE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sad_spin_average.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sad_spin_average.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sapgau_basis.html:461,Deployability,update,updated,461,"﻿. SAPGAU_BASIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAPGAU_BASIS. SAPGAU_BASIS¶. The potential basis set used for the SAPGAU guess. Type: string; Default: sap_helfem_large. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAPGAU_BASIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sapgau_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sapgau_basis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__sapt.html:408,Deployability,update,updated,408,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAPT. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAPT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__sapt.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__save_jk.html:411,Deployability,update,updated,411,"﻿. SAVE_JK. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_JK. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_JK. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__save_jk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__save_jk.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__save_uhf_nos.html:418,Deployability,update,updated,418,"﻿. SAVE_UHF_NOS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_UHF_NOS. SAVE_UHF_NOS¶. Save the UHF NOs. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_UHF_NOS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__save_uhf_nos.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__save_uhf_nos.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_accelerator.html:711,Deployability,update,updated,711,"﻿. SCF_INITIAL_ACCELERATOR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_ACCELERATOR. SCF_INITIAL_ACCELERATOR¶. Use a method to accelerate initial SCF convergence? Use NONE for DIIS alone (if enabled) and EDIIS or ADIIS to have both the chosen accelerator and DIIS (if enabled). For restricted-open references, EDIIS and ADIIS have no effect. Type: string; Possible Values: NONE, EDIIS, ADIIS; Default: ADIIS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_ACCELERATOR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_initial_accelerator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_accelerator.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_finish_diis_transition.html:230,Availability,error,error,230,"﻿. SCF_INITIAL_FINISH_DIIS_TRANSITION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_FINISH_DIIS_TRANSITION. SCF_INITIAL_FINISH_DIIS_TRANSITION¶. SCF error at which to complete the linear interpolation between DIIS steps and steps of the initial SCF accelerator Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_FINISH_DIIS_TRANSITION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_initial_finish_diis_transition.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_finish_diis_transition.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_finish_diis_transition.html:665,Deployability,update,updated,665,"﻿. SCF_INITIAL_FINISH_DIIS_TRANSITION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_FINISH_DIIS_TRANSITION. SCF_INITIAL_FINISH_DIIS_TRANSITION¶. SCF error at which to complete the linear interpolation between DIIS steps and steps of the initial SCF accelerator Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_FINISH_DIIS_TRANSITION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_initial_finish_diis_transition.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_finish_diis_transition.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_start_diis_transition.html:227,Availability,error,error,227,"﻿. SCF_INITIAL_START_DIIS_TRANSITION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_START_DIIS_TRANSITION. SCF_INITIAL_START_DIIS_TRANSITION¶. SCF error at which to start the linear interpolation between DIIS steps and steps of the initial SCF accelerator. Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_START_DIIS_TRANSITION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_initial_start_diis_transition.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_start_diis_transition.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_start_diis_transition.html:659,Deployability,update,updated,659,"﻿. SCF_INITIAL_START_DIIS_TRANSITION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_START_DIIS_TRANSITION. SCF_INITIAL_START_DIIS_TRANSITION¶. SCF error at which to start the linear interpolation between DIIS steps and steps of the initial SCF accelerator. Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_INITIAL_START_DIIS_TRANSITION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_initial_start_diis_transition.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_initial_start_diis_transition.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_mem_safety_factor.html:474,Deployability,update,updated,474,"﻿. SCF_MEM_SAFETY_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_mem_safety_factor.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_mem_safety_factor.html:194,Safety,safe,safety,194,"﻿. SCF_MEM_SAFETY_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_mem_safety_factor.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_properties.html:524,Deployability,update,updated,524,"﻿. SCF_PROPERTIES. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_properties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_properties.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_properties.html:203,Energy Efficiency,energy,energy,203,"﻿. SCF_PROPERTIES. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_properties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_properties.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_subtype.html:236,Availability,avail,available,236,"﻿. SCF_SUBTYPE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_SUBTYPE. SCF_SUBTYPE¶. For certain SCF_TYPE algorithms that have internal sub-algorithms depending on available memory or other hardware constraints, allow the best sub-algorithm for the molecule and conditions (AUTO ; usual mode) or forcibly select a sub-algorithm (usually only for debugging or profiling). Presently, SCF_SUBTYPE=DF, SCF_SUBTYPE=MEM_DF, and SCF_SUBTYPE=DISK_DF can have INCORE and OUT_OF_CORE selected; and SCF_TYPE=PK can have INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, and REORDER_OUT_OF_CORE selected. Type: string; Possible Values: AUTO, INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, REORDER_OUT_OF_CORE; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_SUBTYPE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_subtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_subtype.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_subtype.html:984,Deployability,update,updated,984,"﻿. SCF_SUBTYPE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_SUBTYPE. SCF_SUBTYPE¶. For certain SCF_TYPE algorithms that have internal sub-algorithms depending on available memory or other hardware constraints, allow the best sub-algorithm for the molecule and conditions (AUTO ; usual mode) or forcibly select a sub-algorithm (usually only for debugging or profiling). Presently, SCF_SUBTYPE=DF, SCF_SUBTYPE=MEM_DF, and SCF_SUBTYPE=DISK_DF can have INCORE and OUT_OF_CORE selected; and SCF_TYPE=PK can have INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, and REORDER_OUT_OF_CORE selected. Type: string; Possible Values: AUTO, INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, REORDER_OUT_OF_CORE; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_SUBTYPE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_subtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_subtype.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_subtype.html:223,Integrability,depend,depending,223,"﻿. SCF_SUBTYPE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_SUBTYPE. SCF_SUBTYPE¶. For certain SCF_TYPE algorithms that have internal sub-algorithms depending on available memory or other hardware constraints, allow the best sub-algorithm for the molecule and conditions (AUTO ; usual mode) or forcibly select a sub-algorithm (usually only for debugging or profiling). Presently, SCF_SUBTYPE=DF, SCF_SUBTYPE=MEM_DF, and SCF_SUBTYPE=DISK_DF can have INCORE and OUT_OF_CORE selected; and SCF_TYPE=PK can have INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, and REORDER_OUT_OF_CORE selected. Type: string; Possible Values: AUTO, INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, REORDER_OUT_OF_CORE; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_SUBTYPE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__scf_subtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__scf_subtype.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_basis_tolerance.html:508,Deployability,update,updated,508,"﻿. SNLINK_BASIS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_BASIS_TOLERANCE. SNLINK_BASIS_TOLERANCE¶. Screening criteria for basis function values on snLinK grids. Type: conv double; Default: 1.0e-10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_BASIS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_basis_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_basis_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_density_tolerance.html:509,Deployability,update,updated,509,"﻿. SNLINK_DENSITY_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_DENSITY_TOLERANCE. SNLINK_DENSITY_TOLERANCE¶. Screening criteria for shell-pair densities in snLinK. Type: conv double; Default: 1.0e-10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_DENSITY_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_density_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_density_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_force_cartesian.html:483,Deployability,update,updated,483,"﻿. SNLINK_FORCE_CARTESIAN. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_FORCE_CARTESIAN. SNLINK_FORCE_CARTESIAN¶. Force snLinK to use cartesian coordinates. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_FORCE_CARTESIAN. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_force_cartesian.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_force_cartesian.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html:187,Availability,avail,available,187,"﻿. SNLINK_GPU_MEM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GPU_MEM. SNLINK_GPU_MEM¶. Proportion (in %) of available GPU memory to allocate to snLinK. Type: boolean; Default: 90. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GPU_MEM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html:470,Deployability,update,updated,470,"﻿. SNLINK_GPU_MEM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GPU_MEM. SNLINK_GPU_MEM¶. Proportion (in %) of available GPU memory to allocate to snLinK. Type: boolean; Default: 90. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GPU_MEM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html:211,Energy Efficiency,allocate,allocate,211,"﻿. SNLINK_GPU_MEM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GPU_MEM. SNLINK_GPU_MEM¶. Proportion (in %) of available GPU memory to allocate to snLinK. Type: boolean; Default: 90. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GPU_MEM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_gpu_mem.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_grid_batch_size.html:495,Deployability,update,updated,495,"﻿. SNLINK_GRID_BATCH_SIZE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GRID_BATCH_SIZE. SNLINK_GRID_BATCH_SIZE¶. Maximum number of grid points per grid block for GauXC. Type: integer; Default: 2048. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_GRID_BATCH_SIZE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_grid_batch_size.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_grid_batch_size.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_integrator_kernel.html:631,Deployability,update,updated,631,"﻿. SNLINK_INTEGRATOR_KERNEL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_INTEGRATOR_KERNEL. SNLINK_INTEGRATOR_KERNEL¶. Integrator execution kernel for snLinK GauXC also has SHELLBATCHED, but it is incompatible with Psi4 due to not being yet implemented with sn-LinK. Type: string; Possible Values: DEFAULT, INCORE; Default: DEFAULT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_INTEGRATOR_KERNEL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_integrator_kernel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_integrator_kernel.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_ints_tolerance.html:504,Deployability,update,updated,504,"﻿. SNLINK_INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_INTS_TOLERANCE. SNLINK_INTS_TOLERANCE¶. Screening criteria for integrals and intermediates in snLinK. Type: conv double; Default: 1.0e-11. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_INTS_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_ints_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_load_balancer_kernel.html:570,Deployability,update,updated,570,"﻿. SNLINK_LOAD_BALANCER_KERNEL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_LOAD_BALANCER_KERNEL. SNLINK_LOAD_BALANCER_KERNEL¶. Load Balancer kernel for snLinK. Type: string; Possible Values: DEFAULT, REPLICATED, REPLICATED-PETITE, REPLICATED-FILLIN; Default: DEFAULT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_LOAD_BALANCER_KERNEL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_load_balancer_kernel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_load_balancer_kernel.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_lwd_kernel.html:666,Deployability,update,updated,666,"﻿. SNLINK_LWD_KERNEL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_LWD_KERNEL. SNLINK_LWD_KERNEL¶. Integrator local work driver kernel for snLinK GauXC also has SCHEME1-CUTLASS, but it is disabled in Psi4 for now due to compile-time issues and requiring very modern CUDA CCs (>=80). Type: string; Possible Values: DEFAULT, REFERENCE, SCHEME1, SCHEME1-MAGMA; Default: DEFAULT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_LWD_KERNEL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_lwd_kernel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_lwd_kernel.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_mol_weights_kernel.html:516,Deployability,update,updated,516,"﻿. SNLINK_MOL_WEIGHTS_KERNEL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_MOL_WEIGHTS_KERNEL. SNLINK_MOL_WEIGHTS_KERNEL¶. Molecular Weights kernel for snLinK. Type: string; Possible Values: DEFAULT; Default: DEFAULT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_MOL_WEIGHTS_KERNEL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_mol_weights_kernel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_mol_weights_kernel.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_pruning_scheme.html:510,Deployability,update,updated,510,"﻿. SNLINK_PRUNING_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_PRUNING_SCHEME. SNLINK_PRUNING_SCHEME¶. Pruning scheme for snLinK grids. Type: string; Possible Values: ROBUST, TREUTLER, NONE; Default: ROBUST. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_PRUNING_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_pruning_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_pruning_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_radial_points.html:469,Deployability,update,updated,469,"﻿. SNLINK_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_RADIAL_POINTS. SNLINK_RADIAL_POINTS¶. Number of radial points in snLinK grid. Type: integer; Default: 70. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_RADIAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_radial_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_radial_scheme.html:559,Deployability,update,updated,559,"﻿. SNLINK_RADIAL_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_RADIAL_SCHEME. SNLINK_RADIAL_SCHEME¶. Radial Scheme for snLinK grid. MURA is default here as it matches the GauXC default option. Type: string; Possible Values: MURA, TREUTLER, EM; Default: MURA. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_RADIAL_SCHEME. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_radial_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_radial_scheme.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_reduction_kernel.html:596,Deployability,update,updated,596,"﻿. SNLINK_REDUCTION_KERNEL. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_REDUCTION_KERNEL. SNLINK_REDUCTION_KERNEL¶. Integrator reduction kernel for snLinK GauXC also has NCCL, but it is incompatible with Psi4 due to requiring MPI. Type: string; Possible Values: DEFAULT, BASICMPI; Default: DEFAULT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_REDUCTION_KERNEL. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_reduction_kernel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_reduction_kernel.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_spherical_points.html:485,Deployability,update,updated,485,"﻿. SNLINK_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_SPHERICAL_POINTS. SNLINK_SPHERICAL_POINTS¶. Number of spherical points in snLinK grid. Type: integer; Default: 302. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_SPHERICAL_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_spherical_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_use_debug_grid.html:521,Deployability,update,updated,521,"﻿. SNLINK_USE_DEBUG_GRID. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_USE_DEBUG_GRID. SNLINK_USE_DEBUG_GRID¶. Overwrite sn-LinK grid options with debug grid matching GauXC’s Ultrafine grid spec. Type: integer; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_USE_DEBUG_GRID. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_use_debug_grid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_use_debug_grid.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_use_gpu.html:428,Deployability,update,updated,428,"﻿. SNLINK_USE_GPU. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_USE_GPU. SNLINK_USE_GPU¶. Use GPU for GauXC?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SNLINK_USE_GPU. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__snlink_use_gpu.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__snlink_use_gpu.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_convergence.html:524,Deployability,update,updated,524,"﻿. SOLVER_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_CONVERGENCE. SOLVER_CONVERGENCE¶. Convergence threshold (max 2-norm) for numerical solvers (instability analysis and CPHF/CPKS). Type: conv double; Default: 1.0e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__solver_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_maxiter.html:485,Deployability,update,updated,485,"﻿. SOLVER_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_MAXITER. SOLVER_MAXITER¶. Maximum iterations for numerical solvers (instability analysis and CPHF/CPKS). Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__solver_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_n_guess.html:463,Deployability,update,updated,463,"﻿. SOLVER_N_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_N_GUESS. SOLVER_N_GUESS¶. Number of guess vectors per root for instability analysis. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_N_GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__solver_n_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_n_guess.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_n_root.html:513,Deployability,update,updated,513,"﻿. SOLVER_N_ROOT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_N_ROOT. SOLVER_N_ROOT¶. Number of roots to converge for all irreps during instability analysis. (Overridden by SOLVER_ROOTS_PER_IRREP.). Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_N_ROOT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__solver_n_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_n_root.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_roots_per_irrep.html:540,Deployability,update,updated,540,"﻿. SOLVER_ROOTS_PER_IRREP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_ROOTS_PER_IRREP. SOLVER_ROOTS_PER_IRREP¶. Number of roots to converge, per irrep, during instability analysis. (Overrides SOLVER_N_ROOT.). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOLVER_ROOTS_PER_IRREP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__solver_roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__solver_roots_per_irrep.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf.html:418,Deployability,update,updated,418,"﻿. SOSCF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_conv.html:469,Deployability,update,updated,469,"﻿. SOSCF_CONV. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_CONV. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_CONV. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf_conv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_conv.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_max_iter.html:463,Deployability,update,updated,463,"﻿. SOSCF_MAX_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf_max_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_max_iter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_max_iter.html:216,Performance,perform,perform,216,"﻿. SOSCF_MAX_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf_max_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_max_iter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_min_iter.html:463,Deployability,update,updated,463,"﻿. SOSCF_MIN_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf_min_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_min_iter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_min_iter.html:216,Performance,perform,perform,216,"﻿. SOSCF_MIN_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf_min_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_min_iter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_print.html:436,Deployability,update,updated,436,"﻿. SOSCF_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_PRINT. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_PRINT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_print.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_start_convergence.html:514,Deployability,update,updated,514,"﻿. SOSCF_START_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_START_CONVERGENCE. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_START_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__soscf_start_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__soscf_start_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html:829,Deployability,update,updated,829,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html:189,Performance,perform,perform,189,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html:264,Performance,perform,performed,264,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html:382,Performance,perform,perform,382,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__s_cholesky_tolerance.html:499,Deployability,update,updated,499,"﻿. S_CHOLESKY_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_CHOLESKY_TOLERANCE. S_CHOLESKY_TOLERANCE¶. Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_CHOLESKY_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__s_cholesky_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__s_cholesky_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__s_orthogonalization.html:547,Deployability,update,updated,547,"﻿. S_ORTHOGONALIZATION. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_ORTHOGONALIZATION. S_ORTHOGONALIZATION¶. SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_ORTHOGONALIZATION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__s_orthogonalization.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__s_orthogonalization.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__s_tolerance.html:476,Deployability,update,updated,476,"﻿. S_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__s_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__s_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__s_tolerance.html:208,Integrability,depend,dependencies,208,"﻿. S_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__s_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__s_tolerance.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_coeff_cutoff.html:508,Deployability,update,updated,508,"﻿. TDSCF_COEFF_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_COEFF_CUTOFF. TDSCF_COEFF_CUTOFF¶. Cutoff for printing excitations and de-excitations contributing to each excited state. Type: double; Default: 0.1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_COEFF_CUTOFF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_coeff_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_coeff_cutoff.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_guess.html:455,Deployability,update,updated,455,"﻿. TDSCF_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_GUESS. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_GUESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_guess.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_maxiter.html:444,Deployability,update,updated,444,"﻿. TDSCF_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_MAXITER. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_MAXITER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_maxiter.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_print.html:418,Deployability,update,updated,418,"﻿. TDSCF_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_PRINT. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_PRINT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_print.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_r_convergence.html:532,Deployability,update,updated,532,"﻿. TDSCF_R_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_R_CONVERGENCE. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_R_CONVERGENCE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_r_convergence.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_states.html:718,Deployability,update,updated,718,"﻿. TDSCF_STATES. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_STATES. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_STATES. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_states.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_tda.html:481,Deployability,update,updated,481,"﻿. TDSCF_TDA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDA. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_tda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_tda.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_tdm_print.html:653,Deployability,update,updated,653,"﻿. TDSCF_TDM_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDM_PRINT. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDM_PRINT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_tdm_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_tdm_print.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_triplets.html:816,Deployability,update,updated,816,"﻿. TDSCF_TRIPLETS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_triplets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_triplets.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_triplets.html:322,Energy Efficiency,energy,energy,322,"﻿. TDSCF_TRIPLETS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tdscf_triplets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tdscf_triplets.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__theta_points.html:217,Deployability,integrat,integration,217,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__theta_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__theta_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__theta_points.html:468,Deployability,update,updated,468,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__theta_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__theta_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__theta_points.html:217,Integrability,integrat,integration,217,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__theta_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__theta_points.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__thickness.html:440,Deployability,update,updated,440,"﻿. THICKNESS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THICKNESS. THICKNESS¶. Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; THICKNESS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__thickness.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__thickness.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__tile_sz.html:422,Deployability,update,updated,422,"﻿. TILE_SZ. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TILE_SZ. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; TILE_SZ. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__tile_sz.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__tile_sz.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__uhf_noons.html:427,Deployability,update,updated,427,"﻿. UHF_NOONS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; UHF_NOONS. UHF_NOONS¶. The number of NOONs to print in a UHF calc. Type: string; Default: 3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; UHF_NOONS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__uhf_noons.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__uhf_noons.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__wcombine.html:487,Deployability,update,updated,487,"﻿. WCOMBINE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; WCOMBINE. WCOMBINE¶. combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Disabled until fixed. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; WCOMBINE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__wcombine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__wcombine.html
https://psicode.org/psi4manual/master/autodir_options_c/scf__wfn.html:402,Deployability,update,updated,402,"﻿. WFN. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; WFN. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; SCF; WFN. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/scf__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/scf__wfn.html
https://psicode.org/psi4manual/master/autodir_options_c/thermo__p.html:455,Deployability,update,updated,455,"﻿. P. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; P. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; P. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/thermo__p.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/thermo__p.html
https://psicode.org/psi4manual/master/autodir_options_c/thermo__rotational_symmetry_number.html:970,Deployability,update,updated,970,"﻿. ROTATIONAL_SYMMETRY_NUMBER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/thermo__rotational_symmetry_number.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/thermo__rotational_symmetry_number.html
https://psicode.org/psi4manual/master/autodir_options_c/thermo__rotational_symmetry_number.html:589,Integrability,depend,dependent,589,"﻿. ROTATIONAL_SYMMETRY_NUMBER. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/thermo__rotational_symmetry_number.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/thermo__rotational_symmetry_number.html
https://psicode.org/psi4manual/master/autodir_options_c/thermo__t.html:457,Deployability,update,updated,457,"﻿. T. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; T. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; THERMO; T. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_options_c/thermo__t.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/thermo__t.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__adc.html:1364,Deployability,update,updated,1364,"﻿. ADC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; ADC. ADC¶; Performs Algebraic-Diagrammatic Construction (ADC) propagator computations for excited states. ADC ITERATIONS; ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY; ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL); ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY; ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL); ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL); ADC ROOT 0 -> ROOT n EXCITATION ENERGY; ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION; ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN); ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN) - h TRANSITION; ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL); ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION; ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL); ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION; CURRENT CORRELATION ENERGY; CURRENT ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; ADC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__adc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__adc.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__ccenergy.html:4562,Deployability,update,updated,4562," A (LEN); CCname ROOT m -> ROOT n EINSTEIN A (LEN) - h TRANSITION; CCname ROOT m -> ROOT n EINSTEIN B (LEN); CCname ROOT m -> ROOT n EINSTEIN B (LEN) - h TRANSITION; CCname ROOT m -> ROOT n OSCILLATOR STRENGTH (LEN); CCname ROOT m -> ROOT n OSCILLATOR STRENGTH (LEN) - h TRANSITION; CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN); CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION; CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL); CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION; CCname ROOT n (IN h) CORRELATION ENERGY; CCname ROOT n (IN h) TOTAL ENERGY; CCname ROOT n (h) CORRELATION ENERGY; CCname ROOT n (h) DIPOLE; CCname ROOT n (h) QUADRUPOLE; CCname ROOT n (h) TOTAL ENERGY; CCname ROOT n CORRELATION ENERGY; CCname ROOT n CORRELATION ENERGY - h TRANSITION; CCname ROOT n DIPOLE; CCname ROOT n DIPOLE - h TRANSITION; CCname ROOT n QUADRUPOLE; CCname ROOT n QUADRUPOLE - h TRANSITION; CCname ROOT n TOTAL ENERGY; CCname ROOT n TOTAL ENERGY - h TRANSITION; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCC2 (+LMP2) TOTAL ENERGY; LCCSD (+LMP2) TOTAL ENERGY; LEFT-RIGHT CC2 EIGENVECTOR OVERLAP; LEFT-RIGHT CC3 EIGENVECTOR OVERLAP; LEFT-RIGHT CCSD EIGENVECTOR OVERLAP; LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET PAIR ENERGIES (array); MP2 TOTAL ENERGY; MP2 TRIPLET PAIR ENERGIES (array); SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-CCSD CORRELATION ENERGY; SCS-CCSD TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; CCENERGY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__ccenergy.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__cfour.html:1001,Deployability,update,updated,1001,"﻿. CFOUR. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; CFOUR. CFOUR¶. (T) CORRECTION ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CFOUR ERROR CODE; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; HF TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; NUCLEAR REPULSION ENERGY; SCF TOTAL ENERGY; [T] CORRECTION ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; CFOUR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__cfour.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__dct.html:531,Deployability,update,updated,531,"﻿. DCT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DCT. DCT¶; Performs density cumulant (functional) theory computations. CURRENT ENERGY; DCT LAMBDA ENERGY; DCT SCF ENERGY; DCT THREE-PARTICLE ENERGY; DCT TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DCT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__dct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dct.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__ddx.html:443,Deployability,update,updated,443,"﻿. DDX. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DDX. DDX¶; Performs continuum solvation model computations using the domain-decomposition paradigm. DD SOLVATION ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DDX. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__ddx.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__ddx.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html:148,Deployability,configurat,configuration,148,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE; CI ROOT n -> ROOT m QUADRUPOLE; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n QUADRUPOLE; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html:289,Deployability,configurat,configuration,289,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE; CI ROOT n -> ROOT m QUADRUPOLE; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n QUADRUPOLE; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html:1401,Deployability,update,updated,1401,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE; CI ROOT n -> ROOT m QUADRUPOLE; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n QUADRUPOLE; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html:148,Modifiability,config,configuration,148,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE; CI ROOT n -> ROOT m QUADRUPOLE; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n QUADRUPOLE; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html:289,Modifiability,config,configuration,289,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE; CI ROOT n -> ROOT m QUADRUPOLE; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n QUADRUPOLE; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__dfmp2.html:730,Deployability,update,updated,730,"﻿. DFMP2. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DFMP2. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2 TOTAL GRADIENT; SCF TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DFMP2. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfmp2.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html:2687,Deployability,update,updated,2687,"RGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html:171,Performance,optimiz,optimized,171,﻿. DFOCC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (T) CORRECTION ENERGY; A-(T) CORRECTION ENERGY; A-CCSD(T) CORRELATION ENERGY; A-CCSD(T) TOTAL ENERGY; CCD CORRELATION ENERGY; CCD DOUBLES ENERGY; CCD SINGLES ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ,MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__dlpno.html:736,Deployability,update,updated,736,"﻿. DLPNO. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DLPNO. DLPNO¶; Performs DLPNO-MP2 computations for RHF reference wavefunctions. CURRENT CORRELATION ENERGY; CURRENT ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DLPNO. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__dlpno.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dlpno.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__dmrg.html:474,Deployability,update,updated,474,"﻿. DMRG. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DMRG. DMRG¶; Performs a DMRG computation through calls to Wouters’s CheMPS2 library. CURRENT ENERGY; DMRG-CASPT2 TOTAL ENERGY; DMRG-SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DMRG. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dmrg.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__efp.html:540,Deployability,update,updated,540,"﻿. EFP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; EFP. EFP¶; Performs effective fragment potential computations through calls to Kaliman’s libefp library. CURRENT ENERGY; EFP DISP ENERGY; EFP ELST ENERGY; EFP EXCH ENERGY; EFP IND ENERGY; EFP TORQUE; EFP TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; EFP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__efp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__efp.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__fisapt.html:1037,Deployability,update,updated,1037,"﻿. FISAPT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; FISAPT. FISAPT¶. CURRENT ENERGY; SAPT DISP ENERGY; SAPT DISP20 ENERGY; SAPT ELST ENERGY; SAPT ELST EXTERN-EXTERN ENERGY; SAPT ELST10,R ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP20(S^INF) ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT HF(2) ENERGY A(0); SAPT HF(2) ENERGY A(HF); SAPT HF(2) ENERGY AB(HF); SAPT HF(2) ENERGY ABC(HF); SAPT HF(2) ENERGY AC(0); SAPT HF(2) ENERGY AC(HF); SAPT HF(2) ENERGY B(0); SAPT HF(2) ENERGY B(HF); SAPT HF(2) ENERGY BC(0); SAPT HF(2) ENERGY BC(HF); SAPT HF(2) ENERGY C; SAPT HF(2) ENERGY HF; SAPT IND ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT TOTAL ENERGY; SAPT0 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; FISAPT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__fisapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__fisapt.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__fnocc.html:3479,Deployability,update,updated,3479," TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) DOUBLES ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) SINGLES ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET PAIR ENERGIES (array); MP2 TOTAL ENERGY; MP2 TRIPLET PAIR ENERGIES (array); MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; NAUX (CC); NAUX (SCF); QCISD CORRELATION ENERGY; QCISD OPPOSITE-SPIN CORRELATION ENERGY; QCISD SAME-SPIN CORRELATION ENERGY; QCISD TOTAL ENERGY; QCISD(T) CORRECTION ENERGY; QCISD(T) CORRELATION ENERGY; QCISD(T) TOTAL ENERGY; SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; FNOCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__fnocc.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__gdma.html:497,Deployability,update,updated,497,"﻿. GDMA. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; GDMA. GDMA¶; Performs distributed multipole analysis (DMA), using Anthony Stone’s GDMA program. See GDMA for more details. DMA DISTRIBUTED MULTIPOLES; DMA TOTAL MULTIPOLES. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; GDMA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__gdma.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__gdma.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__mcscf.html:580,Deployability,update,updated,580,"﻿. MCSCF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; MCSCF. MCSCF¶; Performs RHF/UHF/ROHF/TCSCF and more general MCSCF computations. Called as the starting point for multireference coupled cluster computations. CURRENT ENERGY; CURRENT REFERENCE ENERGY; MCSCF TOTAL ENERGY; SCF ITERATIONS; SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; MCSCF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__mcscf.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__mrcc.html:1677,Deployability,update,updated,1677,"﻿. MRCC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; MRCC. MRCC¶; Interface to MRCC program written by Mihály Kállay. CC(n-1)(n) CORRELATION ENERGY; CC(n-1)(n) TOTAL ENERGY; CC(n-1)(n)_L CORRELATION ENERGY; CC(n-1)(n)_L TOTAL ENERGY; CC2 CORRELATION ENERGY; CC2 TOTAL ENERGY; CC3 CORRELATION ENERGY; CC3 TOTAL ENERGY; CC4 CORRELATION ENERGY; CC4 TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CCSD(T)_L CORRELATION ENERGY; CCSD(T)_L TOTAL ENERGY; CCSDT CORRELATION ENERGY; CCSDT TOTAL ENERGY; CCSDT(Q) CORRELATION ENERGY; CCSDT(Q) TOTAL ENERGY; CCSDT(Q)/A CORRELATION ENERGY; CCSDT(Q)/A TOTAL ENERGY; CCSDT(Q)/B CORRELATION ENERGY; CCSDT(Q)/B TOTAL ENERGY; CCSDT(Q)_L CORRELATION ENERGY; CCSDT(Q)_L TOTAL ENERGY; CCSDT-1a CORRELATION ENERGY; CCSDT-1a TOTAL ENERGY; CCSDT-1b CORRELATION ENERGY; CCSDT-1b TOTAL ENERGY; CCSDT-3 CORRELATION ENERGY; CCSDT-3 TOTAL ENERGY; CCSDTQ CORRELATION ENERGY; CCSDTQ TOTAL ENERGY; CCSDTQ-1a CORRELATION ENERGY; CCSDTQ-1a TOTAL ENERGY; CCSDTQ-1b CORRELATION ENERGY; CCSDTQ-1b TOTAL ENERGY; CCSDTQ-3 CORRELATION ENERGY; CCSDTQ-3 TOTAL ENERGY; CCn CORRELATION ENERGY; CCn TOTAL ENERGY; CCn-1a CORRELATION ENERGY; CCn-1a TOTAL ENERGY; CCn-1b CORRELATION ENERGY; CCn-1b TOTAL ENERGY; CCn-3 CORRELATION ENERGY; CCn-3 TOTAL ENERGY; CCnn CORRELATION ENERGY; CCnn TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; MRCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__mrcc.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__occ.html:3202,Deployability,update,updated,3202,"N ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 SAME-SPIN CORRELATION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY; SOS-OMP3 CORRELATION ENERGY; SOS-OMP3 TOTAL ENERGY; SOS-PI-MP2 CORRELATION ENERGY; SOS-PI-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; OCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__occ.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__occ.html:150,Performance,optimiz,optimized,150,﻿. OCC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; OCC. OCC¶; Performs orbital-optimized MPn and CC computations and conventional MPn computations. CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CUSTOM SCS-LCCD CORRELATION ENERGY; CUSTOM SCS-LCCD TOTAL ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; CUSTOM SCS-MP2.5 CORRELATION ENERGY; CUSTOM SCS-MP2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; CUSTOM SCS-OREMP2 CORRELATION ENERGY; CUSTOM SCS-OREMP2 TOTAL ENERGY; CUSTOM SCS-REMP2 CORRELATION ENERGY; CUSTOM SCS-REMP2 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CO,MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__occ.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__oeprop.html:839,Deployability,update,updated,839,"﻿. OEPROP. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; OEPROP. OEPROP¶. CURRENT ENERGY; CURRENT GRADIENT (array); CURRENT HESSIAN (array); ESP AT CENTER n; LOWDIN CHARGES (array); MAYER INDICES (array); MBIS CHARGES (array); MBIS DIPOLES (array); MBIS FREE ATOM n VOLUME; MBIS OCTUPOLES (array); MBIS QUADRUPOLES (array); MBIS VALENCE CHARGES (array); MBIS VALENCE WIDTHS (array); MBIS VOLUME RATIOS (array); MULLIKEN CHARGES (array); WIBERG LOWDIN INDICES (array); mtd 128-POLE; mtd 32-POLE; mtd 64-POLE; mtd DIPOLE; mtd HEXADECAPOLE; mtd OCTUPOLE; mtd QUADRUPOLE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; OEPROP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__oeprop.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__pcm.html:415,Deployability,update,updated,415,"﻿. PCM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; PCM. PCM¶; Performs polarizable continuum model (PCM) computations. PCM POLARIZATION ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; PCM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__pcm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__pcm.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__pe.html:396,Deployability,update,updated,396,"﻿. PE. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; PE. PE¶; Performs polarizable embedding model (PE) computations. PE ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; PE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__pe.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__pe.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__psimrcc.html:590,Deployability,update,updated,590,"﻿. PSIMRCC. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; PSIMRCC. PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. CURRENT ENERGY; MP2-CCSD TOTAL ENERGY; MRCC TOTAL ENERGY; MRPT TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; PSIMRCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__psimrcc.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__sapt.html:3314,Deployability,update,updated,3314,"ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENERGY; SAPT2+3DMP2 EXCH ENERGY; SAPT2+3DMP2 IND ENERGY; SAPT2+3DMP2 TOTAL ENERGY; SAPT2+DMP2 DISP ENERGY; SAPT2+DMP2 ELST ENERGY; SAPT2+DMP2 EXCH ENERGY; SAPT2+DMP2 IND ENERGY; SAPT2+DMP2 TOTAL ENERGY; SSAPT0 DISP ENERGY; SSAPT0 ELST ENERGY; SSAPT0 EXCH ENERGY; SSAPT0 IND ENERGY; SSAPT0 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; SAPT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__sapt.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__sapt.html:154,Energy Efficiency,adapt,adapted,154,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; SAPT. SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze non-covalent interactions. CURRENT ENERGY; SAPT ALPHA; SAPT CT ENERGY; SAPT DISP ENERGY; SAPT DISP2(CCD) ENERGY; SAPT DISP20 ENERGY; SAPT DISP21 ENERGY; SAPT DISP22(S)(CCD) ENERGY; SAPT DISP22(SDQ) ENERGY; SAPT DISP22(T) ENERGY; SAPT DISP22(T)(CCD) ENERGY; SAPT DISP30 ENERGY; SAPT ELST ENERGY; SAPT ELST10,R ENERGY; SAPT ELST12,R ENERGY; SAPT ELST13,R ENERGY; SAPT ENERGY; SAPT EST.DISP22(T) ENERGY; SAPT EST.DISP22(T)(CCD) ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP30 ENERGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30(S^INF) ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH-IND30,R(S^INF) ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENER",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__sapt.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__sapt.html:154,Modifiability,adapt,adapted,154,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; SAPT. SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze non-covalent interactions. CURRENT ENERGY; SAPT ALPHA; SAPT CT ENERGY; SAPT DISP ENERGY; SAPT DISP2(CCD) ENERGY; SAPT DISP20 ENERGY; SAPT DISP21 ENERGY; SAPT DISP22(S)(CCD) ENERGY; SAPT DISP22(SDQ) ENERGY; SAPT DISP22(T) ENERGY; SAPT DISP22(T)(CCD) ENERGY; SAPT DISP30 ENERGY; SAPT ELST ENERGY; SAPT ELST10,R ENERGY; SAPT ELST12,R ENERGY; SAPT ELST13,R ENERGY; SAPT ENERGY; SAPT EST.DISP22(T) ENERGY; SAPT EST.DISP22(T)(CCD) ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP30 ENERGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30(S^INF) ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH-IND30,R(S^INF) ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENER",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__sapt.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__scf.html:2366,Deployability,update,updated,2366,"RRECTION ENERGY; DOUBLE-HYBRID CORRECTION ENERGY; GRID ELECTRONS ALPHA; GRID ELECTRONS BETA; GRID ELECTRONS TOTAL; HF KINETIC ENERGY; HF POTENTIAL ENERGY; HF TOTAL ENERGY; HF TOTAL GRADIENT; HF TOTAL HESSIAN; HF VIRIAL RATIO; NUCLEAR REPULSION ENERGY; ONE-ELECTRON ENERGY; SCF ITERATIONS; SCF STABILITY EIGENVALUES (array); SCF TOTAL ENERGY; SCF TOTAL GRADIENT; SCF TOTAL HESSIAN; TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY; TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY; TD-fctl ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY; TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION; TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION; TD-fctl ROOT n (IN h) TOTAL ENERGY; TD-fctl ROOT n (h) TOTAL ENERGY; TD-fctl ROOT n TOTAL ENERGY; TD-fctl ROOT n TOTAL ENERGY - h TRANSITION; TWO-ELECTRON ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; SCF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__scf.html
https://psicode.org/psi4manual/master/autodir_psivariables/module__thermo.html:491,Deployability,update,updated,491,"﻿. THERMO. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; THERMO. THERMO¶. ENTHALPY; ENTHALPY CORRECTION; GIBBS FREE ENERGY; GIBBS FREE ENERGY CORRECTION; THERMAL ENERGY; THERMAL ENERGY CORRECTION; ZERO K ENTHALPY; ZPVE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; THERMO. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/autodir_psivariables/module__thermo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__thermo.html
https://psicode.org/psi4manual/master/_modules/index.html:146,Availability,avail,available,146,"﻿. Overview: module code. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. All modules for which code is available; psi4.core; psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_findif; psi4.driver.driver_nbody; psi4.driver.frac; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.inpsight; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.optproc; psi4.driver.p4util.procutil; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.solvers; psi4.driver.p4util.spectrum; psi4.driver.p4util.text; psi4.driver.p4util.util; psi4.driver.pluginutil; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.task_planner; psi4.driver.wrapper_autofrag; psi4.driver.wrapper_database; psi4.extras; qcdb.vib; qcelemental.testing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/index.html
https://psicode.org/psi4manual/master/_modules/index.html:1358,Deployability,update,updated,1358,"﻿. Overview: module code. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. All modules for which code is available; psi4.core; psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_findif; psi4.driver.driver_nbody; psi4.driver.frac; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.inpsight; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.optproc; psi4.driver.p4util.procutil; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.solvers; psi4.driver.p4util.spectrum; psi4.driver.p4util.text; psi4.driver.p4util.util; psi4.driver.pluginutil; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.task_planner; psi4.driver.wrapper_autofrag; psi4.driver.wrapper_database; psi4.extras; qcdb.vib; qcelemental.testing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/index.html
https://psicode.org/psi4manual/master/_modules/index.html:838,Modifiability,plugin,pluginutil,838,"﻿. Overview: module code. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. All modules for which code is available; psi4.core; psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_findif; psi4.driver.driver_nbody; psi4.driver.frac; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.inpsight; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.optproc; psi4.driver.p4util.procutil; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.solvers; psi4.driver.p4util.spectrum; psi4.driver.p4util.text; psi4.driver.p4util.util; psi4.driver.pluginutil; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.task_planner; psi4.driver.wrapper_autofrag; psi4.driver.wrapper_database; psi4.extras; qcdb.vib; qcelemental.testing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/index.html
https://psicode.org/psi4manual/master/_modules/index.html:1178,Testability,test,testing,1178,"﻿. Overview: module code. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. All modules for which code is available; psi4.core; psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_findif; psi4.driver.driver_nbody; psi4.driver.frac; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.inpsight; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.optproc; psi4.driver.p4util.procutil; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.solvers; psi4.driver.p4util.spectrum; psi4.driver.p4util.text; psi4.driver.p4util.util; psi4.driver.pluginutil; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.task_planner; psi4.driver.wrapper_autofrag; psi4.driver.wrapper_database; psi4.extras; qcdb.vib; qcelemental.testing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Overview: module code. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/index.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:2764,Availability,error,error,2764,"t.register(clean_numpy_files). def exit_printing(start_time: datetime.datetime = None, success: bool = None) -> None:; """"""Prints the exit time and status. Parameters; ----------; start_time; starting time from which the elapsed time is computed.; success; Provides a success flag, otherwise uses the ``_success_flag_`` global variable. Returns; -------; None. """"""; end_time = datetime.datetime.now(); core.print_out(""\n Psi4 stopped on: {}"".format(end_time.strftime('%A, %d %B %Y %I:%M%p'))); if start_time is not None:; run_time = end_time - start_time; run_time = str(run_time).split('.'); # python ""helpfully"" truncates microseconds if zero. Undo that.; if len(run_time) == 1: run_time.append(""000000""); run_time = run_time[0] + '.' + run_time[1][:2]; core.print_out(""\n Psi4 wall time for execution: {}\n"".format(run_time)). if success is None:; success = _success_flag_. if success:; core.print_out(""\n*** Psi4 exiting successfully. Buy a developer a beer!\n""); else:; core.print_out(""\n*** Psi4 encountered an error. Buy a developer more coffee!\n""); core.print_out(""*** Resources and help at github.com/psi4/psi4.\n""). _success_flag_ = False. # Working directory; _input_dir_ = os.getcwd(). def get_input_directory():; return _input_dir_. # Add-Ons; def _CMake_to_Py_boolean(cmakevar):; if cmakevar.upper() in [""1"", ""ON"", ""YES"", ""TRUE"", ""Y""]:; return True; else:; return False. def psi4_which(command, *, return_bool: bool = False, raise_error: bool = False,; raise_msg: str = None) -> Union[bool, None, str]:; """"""Test to see if a command is available in Psi4 search path. Returns; -------; str or None; By default, returns command path if command found or `None` if not.; Environment is $PSIPATH:$PATH, less any None values.; bool; When `return_bool=True`, returns whether or not found. Raises; ------; ModuleNotFoundError; When `raises_error=True` and command not found. """"""; lenv = (os.pathsep.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(os.pathsep) if x != '']) +;",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:3297,Availability,avail,available,3297,"I:%M%p'))); if start_time is not None:; run_time = end_time - start_time; run_time = str(run_time).split('.'); # python ""helpfully"" truncates microseconds if zero. Undo that.; if len(run_time) == 1: run_time.append(""000000""); run_time = run_time[0] + '.' + run_time[1][:2]; core.print_out(""\n Psi4 wall time for execution: {}\n"".format(run_time)). if success is None:; success = _success_flag_. if success:; core.print_out(""\n*** Psi4 exiting successfully. Buy a developer a beer!\n""); else:; core.print_out(""\n*** Psi4 encountered an error. Buy a developer more coffee!\n""); core.print_out(""*** Resources and help at github.com/psi4/psi4.\n""). _success_flag_ = False. # Working directory; _input_dir_ = os.getcwd(). def get_input_directory():; return _input_dir_. # Add-Ons; def _CMake_to_Py_boolean(cmakevar):; if cmakevar.upper() in [""1"", ""ON"", ""YES"", ""TRUE"", ""Y""]:; return True; else:; return False. def psi4_which(command, *, return_bool: bool = False, raise_error: bool = False,; raise_msg: str = None) -> Union[bool, None, str]:; """"""Test to see if a command is available in Psi4 search path. Returns; -------; str or None; By default, returns command path if command found or `None` if not.; Environment is $PSIPATH:$PATH, less any None values.; bool; When `return_bool=True`, returns whether or not found. Raises; ------; ModuleNotFoundError; When `raises_error=True` and command not found. """"""; lenv = (os.pathsep.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(os.pathsep) if x != '']) +; os.pathsep + os.environ.get('PATH', '')). return which(command=command, return_bool=return_bool, raise_error=raise_error, raise_msg=raise_msg, env=lenv). _addons_ = {; ""adcc"": which_import(""adcc"", return_bool=True),; ""ambit"": _CMake_to_Py_boolean(""OFF""),; ""chemps2"": _CMake_to_Py_boolean(""OFF""),; ""dkh"": _CMake_to_Py_boolean(""OFF""),; ""ecpint"": _CMake_to_Py_boolean(""OFF""),; ""libefp"": which_import(""pylibefp"", return_bool=True),; ""gdma"": which_import(""gdma"", return_bool=True), # p",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:5765,Availability,avail,available,5765,"gpu_dfcc"": which_import(""gpu_dfcc"", return_bool=True),; ""forte"": which_import(""forte"", return_bool=True),; ""snsmp2"": which_import(""snsmp2"", return_bool=True),; ""resp"": which_import(""resp"", return_bool=True),; ""psi4fockci"": which_import(""psi4fockci"", return_bool=True),; ""mdi"": which_import(""mdi"", return_bool=True),; ""cct3"": which_import(""cct3"", return_bool=True),; ""dftd4"": which_import(""dftd4"", return_bool=True),; ""mp2d"": psi4_which(""mp2d"", return_bool=True),; ""openfermionpsi4"": which_import(""openfermionpsi4"", return_bool=True),; ""geometric"": which_import(""geometric"", return_bool=True),; #""optking"": which_import(""optking"", return_bool=True),; ""psixas"": which_import(""psixas"", return_bool=True),; #""mctc-gcp"": psi4_which(""mctc-gcp"", return_bool=True),; ""bse"": which_import(""basis_set_exchange"", return_bool=True),; ""einsums"": _CMake_to_Py_boolean(""OFF""),; ""gauxc"": _CMake_to_Py_boolean(""OFF""),; }. def addons(request: str = None) -> Union[bool, List[str]]:; """"""Returns boolean of whether Add-On *request* is available to Psi4,; either compiled in or searchable in $PSIPATH:$PATH, as relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-wo",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:5892,Availability,avail,available,5892,"n_bool=True),; ""resp"": which_import(""resp"", return_bool=True),; ""psi4fockci"": which_import(""psi4fockci"", return_bool=True),; ""mdi"": which_import(""mdi"", return_bool=True),; ""cct3"": which_import(""cct3"", return_bool=True),; ""dftd4"": which_import(""dftd4"", return_bool=True),; ""mp2d"": psi4_which(""mp2d"", return_bool=True),; ""openfermionpsi4"": which_import(""openfermionpsi4"", return_bool=True),; ""geometric"": which_import(""geometric"", return_bool=True),; #""optking"": which_import(""optking"", return_bool=True),; ""psixas"": which_import(""psixas"", return_bool=True),; #""mctc-gcp"": psi4_which(""mctc-gcp"", return_bool=True),; ""bse"": which_import(""basis_set_exchange"", return_bool=True),; ""einsums"": _CMake_to_Py_boolean(""OFF""),; ""gauxc"": _CMake_to_Py_boolean(""OFF""),; }. def addons(request: str = None) -> Union[bool, List[str]]:; """"""Returns boolean of whether Add-On *request* is available to Psi4,; either compiled in or searchable in $PSIPATH:$PATH, as relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6692,Availability,redundant,redundant,6692,",; }. def addons(request: str = None) -> Union[bool, List[str]]:; """"""Returns boolean of whether Add-On *request* is available to Psi4,; either compiled in or searchable in $PSIPATH:$PATH, as relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.exten",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9703,Availability,avail,available,9703,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7194,Deployability,install,installed,7194,"can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7216,Deployability,install,install,7216,"eturn ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncatin",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:10439,Deployability,update,updated,10439,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9406,Integrability,message,message,9406,"r than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Las",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9565,Integrability,message,message,9565,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:2074,Modifiability,variab,variable,2074,"02110-1301 USA.; #; # @END LICENSE; #. import atexit; import datetime; import itertools; import os; from pathlib import Path; from typing import List, Optional, Union. from qcelemental.util import which, which_import. from . import core; from .header import print_header as _print_header. # Numpy place holder for files and cleanup; numpy_files = []. def register_numpy_file(filename):; if not filename.endswith('.npy'): filename += '.npy'; if filename not in numpy_files:; numpy_files.append(filename). def register_scratch_file(filename):; if filename not in numpy_files:; numpy_files.append(filename). def clean_numpy_files():; for nfile in numpy_files:; try:; os.unlink(nfile); except OSError:; pass. atexit.register(clean_numpy_files). def exit_printing(start_time: datetime.datetime = None, success: bool = None) -> None:; """"""Prints the exit time and status. Parameters; ----------; start_time; starting time from which the elapsed time is computed.; success; Provides a success flag, otherwise uses the ``_success_flag_`` global variable. Returns; -------; None. """"""; end_time = datetime.datetime.now(); core.print_out(""\n Psi4 stopped on: {}"".format(end_time.strftime('%A, %d %B %Y %I:%M%p'))); if start_time is not None:; run_time = end_time - start_time; run_time = str(run_time).split('.'); # python ""helpfully"" truncates microseconds if zero. Undo that.; if len(run_time) == 1: run_time.append(""000000""); run_time = run_time[0] + '.' + run_time[1][:2]; core.print_out(""\n Psi4 wall time for execution: {}\n"".format(run_time)). if success is None:; success = _success_flag_. if success:; core.print_out(""\n*** Psi4 exiting successfully. Buy a developer a beer!\n""); else:; core.print_out(""\n*** Psi4 encountered an error. Buy a developer more coffee!\n""); core.print_out(""*** Resources and help at github.com/psi4/psi4.\n""). _success_flag_ = False. # Working directory; _input_dir_ = os.getcwd(). def get_input_directory():; return _input_dir_. # Add-Ons; def _CMake_to_Py_boolean(cmakevar",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7406,Modifiability,extend,extend,7406,"_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the lo",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7472,Modifiability,extend,extend,7472,"nt: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whethe",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7546,Modifiability,extend,extend,7546,"rough pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable i",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7644,Modifiability,extend,extend,7644,"ces are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not i",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7668,Modifiability,extend,extend,7668," be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; I",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8766,Modifiability,inherit,inherited,8766,"f set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = loggin",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6692,Safety,redund,redundant,6692,",; }. def addons(request: str = None) -> Union[bool, List[str]]:; """"""Returns boolean of whether Add-On *request* is available to Psi4,; either compiled in or searchable in $PSIPATH:$PATH, as relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.exten",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6486,Testability,test,test,6486,"mport(""basis_set_exchange"", return_bool=True),; ""einsums"": _CMake_to_Py_boolean(""OFF""),; ""gauxc"": _CMake_to_Py_boolean(""OFF""),; }. def addons(request: str = None) -> Union[bool, List[str]]:; """"""Returns boolean of whether Add-On *request* is available to Psi4,; either compiled in or searchable in $PSIPATH:$PATH, as relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower()",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6553,Testability,test,test,6553,"mport(""basis_set_exchange"", return_bool=True),; ""einsums"": _CMake_to_Py_boolean(""OFF""),; ""gauxc"": _CMake_to_Py_boolean(""OFF""),; }. def addons(request: str = None) -> Union[bool, List[str]]:; """"""Returns boolean of whether Add-On *request* is available to Psi4,; either compiled in or searchable in $PSIPATH:$PATH, as relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower()",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6760,Testability,test,test,6760,"r Add-On *request* is available to Psi4,; either compiled in or searchable in $PSIPATH:$PATH, as relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); ret",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6840,Testability,test,tests,6840,"relevant. If; *request* not passed, returns list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6875,Testability,test,test,6875,"list of available Add-Ons: `['adcc', 'ambit', 'c̶c̶t̶3̶', ...` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:6952,Testability,test,test,6952,"..` . """"""; def strike(text):; if os.name == ""nt"":; # Windows has a probably correctable problem with unicode, but I can't iterate it quickly, so use tilde for strike.; # UnicodeEncodeError: 'charmap' codec can't encode character '\u0336' in position 3: character maps to <undefined>; return ""~"" + text + ""~""; else:; return ''.join(itertools.chain.from_iterable(zip(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) ->",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7313,Testability,test,tests,7313,"(text, itertools.repeat('\u0336')))). if request is None:; return [(k if v else strike(k)) for k, v in sorted(_addons_.items())]; return _addons_[request.lower()]. # Testing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7827,Testability,log,loglevel,7827,"est suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:7982,Testability,log,logging,7982,"est suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8079,Testability,log,logging,8079," try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8126,Testability,log,log,8126,"tError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8180,Testability,log,logging,8180,"a install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create for",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8238,Testability,log,loglevel,8238,"a install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create for",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8282,Testability,log,log,8282,"a install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create for",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8423,Testability,log,logger,8423,"if extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8707,Testability,log,loglevel,8707,"dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:8790,Testability,log,logger,8790,"f set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = loggin",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9019,Testability,log,logging,9019,"d logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None an",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9052,Testability,log,log,9052,"tput file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not p",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9076,Testability,log,log,9076,"logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9100,Testability,log,logger,9100,"m this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9115,Testability,log,logging,9115,"m this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9141,Testability,log,logger,9141,"Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for han",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9175,Testability,log,logger,9175,"Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for han",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9191,Testability,log,loglevel,9191,"es rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handl",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9325,Testability,log,logging,9325,"ult), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9532,Testability,log,logging,9532,"r than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Las",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9674,Testability,log,logger,9674,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9762,Testability,log,logging,9762,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9782,Testability,log,log,9782,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:9817,Testability,log,logging,9817,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:10079,Testability,log,logging,10079,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:10160,Testability,log,logger,10160,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/psi4/extras.html:10223,Testability,log,logger,10223,"der to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = logging.FileHandler(log, filemode); f_handler.setLevel(logging.DEBUG); f_handler.setFormatter(f_format_detailed). if execute:; core.set_output_file(str(out), append); if print_header is True or (print_header is None and not append):; _print_header(); # Warning: baseFilename is not part of the documented API for the logging module and could change.; filenames = [handle.baseFilename for handle in logger.handlers]; if not f_handler.baseFilename in filenames:; logger.addHandler(f_handler); return out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.extras. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/extras.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/extras.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:1359,Availability,toler,tolerance,1359,"is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental import Datum. import psi4 # for typing. from .constants import constants; from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:1865,Availability,toler,tolerance,1865,"HANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental import Datum. import psi4 # for typing. from .constants import constants; from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when fun",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:2072,Availability,toler,tolerance,2072,"mport collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental import Datum. import psi4 # for typing. from .constants import constants; from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:2112,Availability,error,error,2112,"; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental import Datum. import psi4 # for typing. from .constants import constants; from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:2254,Availability,failure,failure,2254,"ntal import Datum. import psi4 # for typing. from .constants import constants; from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; che",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:2489,Availability,toler,tolerance,2489,"r_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:10889,Availability,toler,tolerance,10889,"s in diff (xyz) arrangements); idx_sort_wi_degen = np.lexsort(; (idx_max_elem_each_normco[istart:istart + degree], max_elem_each_normco[istart:istart + degree])); idx_vib_reordering[istart:istart + degree] = np.arange(istart, istart + degree)[idx_sort_wi_degen]. arr2 = arr[:, idx_vib_reordering]. reorderings = ['{}-->{}'.format(i, v) for i, v in enumerate(idx_vib_reordering) if (i != v)]; if reorderings and verbose >= 2:; print('Degenerate modes reordered:', ', '.join(reorderings)). return arr2. def _phase_cols_to_max_element(arr, tol=1.e-2, verbose=1):; """"""Returns copy of 2D `arr` scaled such that, within cols, max(fabs); element is positive. If max(fabs) is pos/neg pair, scales so first; element (within `tol`) is positive. """"""; arr2 = np.copy(arr). rephasing = []; for v in range(arr.shape[1]):; vextreme = 0.0; iextreme = None. # find most extreme value; for varr in arr[:, v]:; vextreme = max(np.absolute(varr), vextreme). # find the first index whose fabs equals that value, w/i tolerance; for iarr, varr in enumerate(arr[:, v]):; if (vextreme - np.absolute(varr)) < tol:; iextreme = iarr; break. sign = np.sign(arr[iextreme, v]); if sign == -1.:; rephasing.append(str(v)); arr2[:, v] *= sign. if rephasing and verbose >= 2:; print('Negative modes rephased:', ', '.join(rephasing)). return arr2. def harmonic_analysis(hess: np.ndarray, geom: np.ndarray, mass: np.ndarray, basisset: psi4.core.BasisSet, irrep_labels: List[str], dipder: np.ndarray = None, project_trans: bool = True, project_rot: bool = True) -> Tuple[Dict[str, Datum], str]:; """"""Extract frequencies, normal modes and other properties from electronic Hessian. Like so much other Psi4 goodness, originally by @andysim. Parameters; ----------; hess; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; geom; (nat, 3) geometry [a0] at which Hessian computed.; mass; (nat,) atomic masses [u].; basisset; Basis set object (can be dummy, e.g., STO-3G) for SALCs.; irrep_labels; Irreducible representation la",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:18935,Availability,down,downhill,18935,"conv_cm_1 = (np.sqrt(constants.na * constants.hartree2J * 1.0e19) /; (2 * np.pi * constants.c * constants.bohr2angstroms)); pre_frequency_cm_1 = np.lib.scimath.sqrt(pre_force_constant_au) * uconv_cm_1. pre_lowfreq = np.where(np.real(pre_frequency_cm_1) < 100.0)[0]; pre_lowfreq = np.append(pre_lowfreq, np.arange(nrt_expected)) # catch at least nrt modes; for lf in set(pre_lowfreq):; vlf = pre_frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' pre-proj low-frequency mode: {:9.4f}i [cm^-1]'.format(vlf.real, vlf.imag)); else:; text.append(' pre-proj low-frequency mode: {:9.4f} [cm^-1]'.format(vlf.real, '')); text.append(' pre-proj all modes:' + str(_format_omega(pre_frequency_cm_1, 4))). # project & solve; mwhess_proj = np.dot(P.T, mwhess).dot(P); text.append(mat_symm_info(mwhess_proj, lbl='projected mass-weighted Hessian') + f' ({nrt})'). #print('projhess = ', np.array_repr(mwhess_proj)); force_constant_au, qL = np.linalg.eigh(mwhess_proj). # expected order for vibrations is steepest downhill to steepest uphill; idx = np.argsort(force_constant_au); force_constant_au = force_constant_au[idx]; qL = qL[:, idx]; qL = _phase_cols_to_max_element(qL); vibinfo['q'] = Datum('normal mode', 'a0 u^1/2', qL, comment='normalized mass-weighted'). # frequency, LAB II.17; frequency_cm_1 = np.lib.scimath.sqrt(force_constant_au) * uconv_cm_1; vibinfo['omega'] = Datum('frequency', 'cm^-1', frequency_cm_1). # degeneracies; ufreq, uinv, ucts = np.unique(np.around(frequency_cm_1, 1), return_inverse=True, return_counts=True); vibinfo['degeneracy'] = Datum('degeneracy', '', ucts[uinv]). # look among the symmetry subspaces h for one to which the normco; # of vib does *not* add an extra dof to the vector space; active = []; irrep_classification = []; for idx, vib in enumerate(frequency_cm_1):. if vec_in_space(qL[:, idx], TRspace, 1.0e-4):; active.append('TR'); irrep_classification.append(None). else:; active.append('V'). for h in Uh.keys():; if vec_in_space(qL[:, idx], Uh[h], 1.0e-4):; ir",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:43744,Deployability,update,updated,43744," np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcdb.vib. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:14169,Energy Efficiency,reduce,reduced,14169," +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | x | normal mode, normalized un-mass-weighted | a0 | ndarray(ndof, ndof) float |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | degeneracy | degree of degeneracy | | ndarray(ndof) int |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | TRV | translation/rotation/vibration | | ndarray(ndof) str 'TR' or 'V' or '-' for partial |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | gamma | irreducible representation | | ndarray(ndof) str irrep or None if unclassifiable |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | mu | reduced mass | u | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | k | force constant | mDyne/A | ndarray(ndof) float (+/-) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | DQ0 | RMS deviation v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(n",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:15595,Energy Efficiency,energy,energy,15595," | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.li",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:21334,Energy Efficiency,reduce,reduced,21334,".append(lowfreq, np.arange(nrt_expected)) # catch at least nrt modes; for lf in set(lowfreq):; vlf = frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' post-proj low-frequency mode: {:9.4f}i [cm^-1] ({})'.format(vlf.imag, active[lf])); else:; text.append(' post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (constants.h * constants.na * 1.0e21) / (8 * np.pi * np.pi * constants.c); uconv_S = np.sqrt((constants.c * (2 * np.pi * constants.bohr2angstroms)**2) /; (constants.h * constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (constants.get(""Avogadro constant"") * np.pi * 1.e-3 * constants.get(""electron mass in u"") *; constants.get(""fine-structure constant"")**2 * constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (constants.get('atomic unit of electric dipole mom.') * 1.e11 /; constants.get('hertz-inverse meter relationship') /; constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:21573,Energy Efficiency,reduce,reduced,21573,"active[lf])); else:; text.append(' post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (constants.h * constants.na * 1.0e21) / (8 * np.pi * np.pi * constants.c); uconv_S = np.sqrt((constants.c * (2 * np.pi * constants.bohr2angstroms)**2) /; (constants.h * constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (constants.get(""Avogadro constant"") * np.pi * 1.e-3 * constants.get(""electron mass in u"") *; constants.get(""fine-structure constant"")**2 * constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (constants.get('atomic unit of electric dipole mom.') * 1.e11 /; constants.get('hertz-inverse meter relationship') /; constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_i",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:22079,Energy Efficiency,meter,meter,22079,"l conversion factors, LAB II.11; uconv_K = (constants.h * constants.na * 1.0e21) / (8 * np.pi * np.pi * constants.c); uconv_S = np.sqrt((constants.c * (2 * np.pi * constants.bohr2angstroms)**2) /; (constants.h * constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (constants.get(""Avogadro constant"") * np.pi * 1.e-3 * constants.get(""electron mass in u"") *; constants.get(""fine-structure constant"")**2 * constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (constants.get('atomic unit of electric dipole mom.') * 1.e11 /; constants.get('hertz-inverse meter relationship') /; constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_intens_D2A2u); ir_intensity_kmmol = ir_intensity * uconv_kmmol; vibinfo['IR_intensity'] = Datum('infrared intensity', 'km/mol', ir_intensity_kmmol). # force constants, LAB II.16 (real compensates for earlier sqrt); uconv_mdyne_a = (0.1 * (2 * np.pi * constants.c)**2) / constants.na; force_constant_mdyne_a = reduced_mass_u * (frequency_cm_1 * frequency_cm_1).real * uconv_mdyne_a; vibinfo['k'] = Datum('force constant', 'mDyne/A', force_constant_mdyne_a). force_constant_cm_1_bb = reduced_mass_u * (frequency_cm_1 * fr",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:25197,Energy Efficiency,reduce,reduced,25197,"h * constants.c / constants.kb; vib_temperature_K = frequency_cm_1.real * uconv_K; vibinfo['theta_vib'] = Datum('char temp', 'K', vib_temperature_K). return vibinfo, '\n'.join(text). def _br(string):; return '[' + string + ']'. def _format_omega(omega, decimals):; """"""Return complex frequencies in `omega` into strings showing only real or imag (""i""-labeled); to `decimals` precision. """"""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(""""""{:.{prec}f}i"""""".format(fr.imag, prec=decimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requeste",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:25677,Energy Efficiency,reduce,reduced,25677,"rec=decimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:30729,Energy Efficiency,energy,energy,30729,"om_lbl[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:33409,Energy Efficiency,reduce,reduced,33409,"stants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * constants.c * constants.h / constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * constants.R * constants.hartree2wavenumbers * 0.001 /; constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'r",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:36897,Energy Efficiency,energy,energy,36897," uconv = np.asarray([constants.hartree2kcalmol, constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <==""""""; text += """"""\n\n Raw electronic energy, E_e""""""; text += f""""""\n Total E_e, Electronic energy at well bottom {E0:15.8f} [Eh]"""""". text += """"""\n\n Zero-point vibrational energy, ZPVE = Sum_i omega_i / 2, E_0 = E_e + ZPVE""""""; ; for term in terms:; if term in ['vib']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE to E_e', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); text += """"""\n Total E_0, Enthalpy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]) ; text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***""""""; ; text += """"""\n\n Thermal (internal) energy, E (includes ZPVE and finite-temperature corrections)""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E beyond E_e',",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:36950,Energy Efficiency,energy,energy,36950," uconv = np.asarray([constants.hartree2kcalmol, constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <==""""""; text += """"""\n\n Raw electronic energy, E_e""""""; text += f""""""\n Total E_e, Electronic energy at well bottom {E0:15.8f} [Eh]"""""". text += """"""\n\n Zero-point vibrational energy, ZPVE = Sum_i omega_i / 2, E_0 = E_e + ZPVE""""""; ; for term in terms:; if term in ['vib']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE to E_e', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); text += """"""\n Total E_0, Enthalpy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]) ; text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***""""""; ; text += """"""\n\n Thermal (internal) energy, E (includes ZPVE and finite-temperature corrections)""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E beyond E_e',",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:37031,Energy Efficiency,energy,energy,37031," """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <==""""""; text += """"""\n\n Raw electronic energy, E_e""""""; text += f""""""\n Total E_e, Electronic energy at well bottom {E0:15.8f} [Eh]"""""". text += """"""\n\n Zero-point vibrational energy, ZPVE = Sum_i omega_i / 2, E_0 = E_e + ZPVE""""""; ; for term in terms:; if term in ['vib']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE to E_e', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); text += """"""\n Total E_0, Enthalpy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]) ; text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***""""""; ; text += """"""\n\n Thermal (internal) energy, E (includes ZPVE and finite-temperature corrections)""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E beyond E_e', *sm[('E', term)] * uconv) ; elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:37712,Energy Efficiency,energy,energy,37712,"t(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <==""""""; text += """"""\n\n Raw electronic energy, E_e""""""; text += f""""""\n Total E_e, Electronic energy at well bottom {E0:15.8f} [Eh]"""""". text += """"""\n\n Zero-point vibrational energy, ZPVE = Sum_i omega_i / 2, E_0 = E_e + ZPVE""""""; ; for term in terms:; if term in ['vib']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE to E_e', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); text += """"""\n Total E_0, Enthalpy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]) ; text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***""""""; ; text += """"""\n\n Thermal (internal) energy, E (includes ZPVE and finite-temperature corrections)""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E beyond E_e', *sm[('E', term)] * uconv) ; elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E', *sm[('E', term)] * uconv). text += """"""\n Total E, Thermal (internal) energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T = E_trans + P * V""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f}",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:38163,Energy Efficiency,energy,energy,38163,"E_H_G.format(terms[term] + ' ZPVE', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE to E_e', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); text += """"""\n Total E_0, Enthalpy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]) ; text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***""""""; ; text += """"""\n\n Thermal (internal) energy, E (includes ZPVE and finite-temperature corrections)""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E beyond E_e', *sm[('E', term)] * uconv) ; elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E', *sm[('E', term)] * uconv). text += """"""\n Total E, Thermal (internal) energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T = E_trans + P * V""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]); text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***"""""". text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G beyond E_e', *sm[('G', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); else:; text += format_ZPE_E_H",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:38848,Energy Efficiency,energy,energy,38848,"beyond E_e', *sm[('E', term)] * uconv) ; elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E', *sm[('E', term)] * uconv). text += """"""\n Total E, Thermal (internal) energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T = E_trans + P * V""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]); text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***"""""". text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G beyond E_e', *sm[('G', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G', *sm[('G', term)] * uconv); text += """"""\n Total G, Gibbs energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('G', 'tot')]); text += """"""\n *** Absolute Gibbs energy, not a free energy of formation ***\n\n"""""" . return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes rem",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:39246,Energy Efficiency,energy,energy,39246,"at(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T = E_trans + P * V""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]); text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***"""""". text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G beyond E_e', *sm[('G', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G', *sm[('G', term)] * uconv); text += """"""\n Total G, Gibbs energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('G', 'tot')]); text += """"""\n *** Absolute Gibbs energy, not a free energy of formation ***\n\n"""""" . return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs['gamma'].data) ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:39349,Energy Efficiency,energy,energy,39349,"elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]); text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***"""""". text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G beyond E_e', *sm[('G', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G', *sm[('G', term)] * uconv); text += """"""\n Total G, Gibbs energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('G', 'tot')]); text += """"""\n *** Absolute Gibbs energy, not a free energy of formation ***\n\n"""""" . return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs['gamma'].data) if d != 'A1']). """"""; work = {}; if remove is None:; remove = [idx for idx, dat in enumerate(vibinfo['TRV'].data) if dat != 'V']; for asp,",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:39368,Energy Efficiency,energy,energy,39368,"elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]); text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***"""""". text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G beyond E_e', *sm[('G', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G', *sm[('G', term)] * uconv); text += """"""\n Total G, Gibbs energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('G', 'tot')]); text += """"""\n *** Absolute Gibbs energy, not a free energy of formation ***\n\n"""""" . return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs['gamma'].data) if d != 'A1']). """"""; work = {}; if remove is None:; remove = [idx for idx, dat in enumerate(vibinfo['TRV'].data) if dat != 'V']; for asp,",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:2118,Integrability,message,messages,2118,"; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental import Datum. import psi4 # for typing. from .constants import constants; from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:41095,Integrability,depend,dependencies,41095,"lvibs, remove=[i for i, d in enumerate(allvibs['gamma'].data) if d != 'A1']). """"""; work = {}; if remove is None:; remove = [idx for idx, dat in enumerate(vibinfo['TRV'].data) if dat != 'V']; for asp, oasp in vibinfo.items():; if asp in ['q', 'w', 'x']:; axis = 1; else:; axis = 0; work[asp] = Datum(oasp.label, oasp.units, np.delete(oasp.data, remove, axis=axis), comment=oasp.comment, numeric=False). return work. def filter_omega_to_real(omega: np.ndarray) -> np.ndarray:; """"""Returns ndarray (float) of `omega` (complex) where imaginary entries are converted to negative reals.""""""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(-1 * fr.imag); else:; freqs.append(fr.real); return np.asarray(freqs). def _get_TR_space(m: np.ndarray, geom: np.ndarray, space: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); as",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:3261,Modifiability,extend,extend,3261,"red; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and asp in toldict:; ktol = toldict[asp]; else:; ktol = tol. if asp in 'qwx':; ccnc = _phase_cols_to_max_element(computed[asp].data); eenc = _phase_cols_to_max_element(expected[asp].data); ccnc = _check_degen_modes(ccnc, computed['omega'].data); eenc = _check_degen_modes(eenc, expected['omega'].data); same = np.allclose(eenc, ccnc, atol=ktol); print_stuff(asp=asp, same=same, ref=eenc, val=ccnc, space='\n'); same = _check_rank_degen_modes(ccnc, computed[""omega""].data, eenc, difftol=ktol, svdtol=svdtol). elif asp in ['gamma', 'TRV']:; same = all([computed[asp].data[idx] == val for idx, val in enumerate(expected[asp].data)]); print_stuff(asp=asp, same=same, ref=expected[asp].data, val=computed[asp].data). elif isinstance(expected[asp].data, float):; same = abs(expected[asp].data - computed[asp].data) < ktol; ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:5683,Testability,test,tested,5683,"metrize(hess: np.ndarray, mol: psi4.core.Molecule) -> np.ndarray:; """"""Apply Abelian symmetry of `mol` to Hessian `hess`. Parameters; ----------; hess; (3 * nat, 3 * nat) Hessian array perhaps with jitter unbecoming a symmetric molecule.; mol; Molecule at which Hessian computed. Returns; -------; numpy.ndarray; (3 * nat, 3 * nat) symmetrized Hessian array. """"""; ct = mol.point_group().char_table(). # Obtain atom mapping of atom * symm op to atom; atom_map = compute_atom_map(mol). syms = []; smap = []; for g in range(ct.order()):; syms.append(np.asarray(ct.symm_operation(g).d)); smap.append([atom_map[at][g] for at in range(mol.natom())]). np.set_printoptions(formatter={'float': '{: 16.12f}'.format}); b_hess = blockwise_expand(hess, (3, 3), False). bDG = []; nat = b_hess.shape[0]; for iat in range(nat):; for jat in range(nat):; for sym in range(len(syms)):; bDG.append(np.zeros_like(b_hess)); bDG[sym][iat, jat] = syms[sym].dot(b_hess[iat, jat].dot(syms[sym])); # Note that tested syms all diagonal, so above may be off by some transposes. for sym in range(len(syms)):; bDG[sym] = bDG[sym][:, smap[sym]]; bDG[sym] = bDG[sym][smap[sym], :]; tot = np.sum(bDG, axis=0); tot = np.divide(tot, len(syms)). print('symmetrization diff:', np.linalg.norm(tot - b_hess)); m_tot = blockwise_contract(tot); return m_tot. def print_molden_vibs(vibinfo: Dict[str, Datum], atom_symbol: Union[np.ndarray, List[str]], geom: Union[np.ndarray, List[List[float]]], standalone: bool = True) -> str:; """"""Format vibrational analysis for Molden. Parameters; ----------; vibinfo; Holds results of vibrational analysis.; atom_symbol; (nat,) element symbols for geometry of vibrational analysis.; geom; (nat, 3) geometry of vibrational analysis [a0].; standalone; Whether returned string prefixed ""[Molden Format]"" for standalone rather than append. Returns; -------; str; `vibinfo` formatted for Molden, including FREQ, FR-COORD, & FR-NORM-COORD fields. Notes; -----; Molden format spec from http://www.cmbi.ru.nl/molde",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:31873,Testability,log,log,31873,"ty of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * constants.amu2kg /; (beta * constants.h * constants.h))**1.5 * constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * constants.c * constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * constants.c * constants.h / constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:32100,Testability,log,log,32100,"l stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * constants.amu2kg /; (beta * constants.h * constants.h))**1.5 * constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * constants.c * constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * constants.c * constants.h / constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if le",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:32441,Testability,log,log,32441,"t). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * constants.amu2kg /; (beta * constants.h * constants.h))**1.5 * constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * constants.c * constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * constants.c * constants.h / constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:32724,Testability,log,log,32724,"pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * constants.amu2kg /; (beta * constants.h * constants.h))**1.5 * constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * constants.c * constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * constants.c * constants.h / constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')]",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:33685,Testability,log,log,33685,"; sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * constants.R * constants.hartree2wavenumbers * 0.001 /; constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uconv_R_EhK = cons",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:33961,Testability,assert,assert,33961,"vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * constants.R * constants.hartree2wavenumbers * 0.001 /; constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uconv_R_EhK = constants.R / constants.hartree2kJmol; for piece in ['S', 'Cv', 'Cp']:; sm[(piece, term)] *= uconv_R_EhK # [mEh/K] <-- []; for piece in ['ZPE', 'E', 'H', 'G']:; sm[(piece, term)] *= uconv_R_EhK * 0.001 # [Eh] <-- [K]. # sum corrections and totals; for piece in ['S', 'Cv', 'Cp']:; for term in ['elec',",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:41906,Testability,assert,assert,41906,"e: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in sp",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:41954,Testability,assert,assert,41954,"se: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:42001,Testability,assert,assert,42001,"zed translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if ",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:42048,Testability,assert,assert,42048,"geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it run",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:42096,Testability,assert,assert,42096,"encies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]).",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:42143,Testability,assert,assert,42143,"toms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:42191,Testability,assert,assert,42191,") otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=Fals",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcdb/vib.html:42323,Testability,assert,assert,42323,"ray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps",MatchSource.WIKI,psi4manual/master/_modules/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcdb/vib.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:763,Availability,error,error,763,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:802,Availability,error,error,802,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:1508,Availability,toler,tolerance,1508,"ap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When ret",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:1731,Availability,toler,tolerance,1731,"}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, unifor",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:1791,Availability,error,error,1791,"}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed typ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:1858,Availability,toler,tolerance,1858,", message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2316,Availability,toler,tolerance,2316,"ssnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quie",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2408,Availability,error,error,2408," = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.ar",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6359,Availability,error,error,6359,")""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expecte",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6734,Availability,error,error,6734,"]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xp",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:9097,Availability,error,errors,9097,"; xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; erro",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:9401,Availability,error,errors,9401,"- xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k]",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:9566,Availability,error,errors,9566,"on=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, co",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:9701,Availability,error,errors,9701,"; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; error",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:9849,Availability,error,errors,9849,"ssage = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, m",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:10076,Availability,error,errors,10076,"refix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:10170,Availability,error,errors,10170,"e + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not compute",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:10304,Availability,error,errors,10304,":; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive c",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:10636,Availability,error,errors,10636,"puted):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive:",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:11035,Availability,error,errors,11035,"_len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is comp",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:11152,Availability,error,errors,11152,"ormat(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formul",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:11208,Availability,error,errors,11208,""".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:11310,Availability,error,errors,11310,"s.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive;",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12099,Availability,toler,tolerance,12099,"d, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if retu",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12159,Availability,error,error,12159," errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12226,Availability,toler,tolerance,12226,"ype {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12399,Availability,failure,failure,12399,"ected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_er",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12657,Availability,toler,tolerance,12657,": bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(erro",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12749,Availability,error,error,12749,"uple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; ph",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:13160,Availability,error,errors,13160," function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:13234,Availability,error,errors,13234,"orgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:13472,Availability,error,errors,13472,"e computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:13619,Availability,error,errors,13619,"uted` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:13746,Availability,error,errors,13746,"ssed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:13929,Availability,error,errors,13929," 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; #",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:14022,Availability,error,errors,14022,"*-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:14297,Availability,error,errors,14297,"xpected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecul",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:15224,Availability,error,errors,15224,"0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecular_multiplicity'] = int(dicary['molecular_multiplicity']); # if 'fragment_multiplicities' in dicary:; # dicary['fragment_multiplicities'] = [(m if m is None else int(m)); # for m in dicary['fragment_multiplicities']]; if ""fragment_separators"" in dicary:; dicary[""fragment_separators""] = [(s if s is None else int(s)) for s in dicary[""fragment_separators""]]; # forgive generator version changes; if ""provenance"" in dicary:; dicary[""provenance""].pop(""version""); # regularize connectivity ordering; if ""connectivity"" in dicary:; conn = [(min(at1, at2), max(at1, at2), bo) for (at1, at2, bo) in dicary[""connectivity""]]; conn.sort(key=lambda tup: tup[0]); dicary[""connectivity""] = conn. return dicary. xptd = massage_dicts(xptd); cptd = massage_dicts(cptd). if relative_geoms == ""exact"":; pass; elif relative_geoms == ""align"":; # can't just expect geometries to match, so we'll align them, check that; # they overlap and that the translation/rotation arrays jibe with; # fix_com/orientation, then attach the oriented geom to computed befo",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:17499,Deployability,update,updated,17499,"[(s if s is None else int(s)) for s in dicary[""fragment_separators""]]; # forgive generator version changes; if ""provenance"" in dicary:; dicary[""provenance""].pop(""version""); # regularize connectivity ordering; if ""connectivity"" in dicary:; conn = [(min(at1, at2), max(at1, at2), bo) for (at1, at2, bo) in dicary[""connectivity""]]; conn.sort(key=lambda tup: tup[0]); dicary[""connectivity""] = conn. return dicary. xptd = massage_dicts(xptd); cptd = massage_dicts(cptd). if relative_geoms == ""exact"":; pass; elif relative_geoms == ""align"":; # can't just expect geometries to match, so we'll align them, check that; # they overlap and that the translation/rotation arrays jibe with; # fix_com/orientation, then attach the oriented geom to computed before the; # recursive dict comparison.; from .molutil.align import B787. cgeom = np.array(cptd[""geom""]).reshape((-1, 3)); rgeom = np.array(xptd[""geom""]).reshape((-1, 3)); rmsd, mill = B787(; rgeom=rgeom,; cgeom=cgeom,; runiq=None,; cuniq=None,; atoms_map=True,; mols_align=True,; run_mirror=False,; verbose=0,; ); if cptd[""fix_com""]:; return compare(; True,; np.allclose(np.zeros((3)), mill.shift, atol=atol),; ""null shift"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); if cptd[""fix_orientation""]:; return compare(; True,; np.allclose(np.identity(3), mill.rotation, atol=atol),; ""null rotation"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); ageom = mill.align_coordinates(cgeom); cptd[""geom""] = ageom.reshape((-1)). return compare_recursive(; xptd,; cptd,; atol=atol,; rtol=rtol,; label=label,; forgive=forgive,; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:563,Integrability,message,message,563,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:812,Integrability,message,message,812,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:866,Integrability,message,message,866,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:1797,Integrability,message,messages,1797,"}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed typ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2160,Integrability,message,message,2160,"array],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2345,Integrability,message,message,2345," = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.ar",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2414,Integrability,message,message,2414," = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.ar",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:4197,Integrability,message,message,4197,"d is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.array(expected, dtype=dtype), np.array(computed, dtype=dtype); except Exception:; return return_handler(; False, label, f""""""\t{label}: inputs not cast-able to ndarray of {dtype}."""""", return_message, quiet; ). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). digits1 = abs(int(np.log10(atol))) + 2; digits_str = f""to atol={atol}""; if rtol > 1.0e-12:; digits_str += f"", rtol={rtol}"". isclose = np.isclose(cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(isclose)). if not allclose and equal_phase and hasattr(cptd, ""__neg__""):; n_isclose = np.isclose(-cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(n_isclose)). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{float(xptd):.{digits1}f}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{float(cptd):.{digits1}f}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); di",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:4751,Integrability,message,message,4751,"nt(np.log10(atol))) + 2; digits_str = f""to atol={atol}""; if rtol > 1.0e-12:; digits_str += f"", rtol={rtol}"". isclose = np.isclose(cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(isclose)). if not allclose and equal_phase and hasattr(cptd, ""__neg__""):; n_isclose = np.isclose(-cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(n_isclose)). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{float(xptd):.{digits1}f}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{float(cptd):.{digits1}f}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); diffraw = cptd - xptd; digits_str += f"" (o-e: RMS {_rms(diffraw):.1e}, MAX {np.amax(np.absolute(diffraw)):.1e}, RMAX {np.amax(np.absolute(diffrel)):.1e})""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; com",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:5355,Integrability,message,message,5355,"True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{float(cptd):.{digits1}f}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); diffraw = cptd - xptd; digits_str += f"" (o-e: RMS {_rms(diffraw):.1e}, MAX {np.amax(np.absolute(diffraw)):.1e}, RMAX {np.amax(np.absolute(diffrel)):.1e})""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Def",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:5592,Integrability,message,message,5592,"ss_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); diffraw = cptd - xptd; digits_str += f"" (o-e: RMS {_rms(diffraw):.1e}, MAX {np.amax(np.absolute(diffraw)):.1e}, RMAX {np.amax(np.absolute(diffrel)):.1e})""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allcl",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6365,Integrability,message,messages,6365,")""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expecte",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6503,Integrability,message,message,6503,""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6671,Integrability,message,message,6671,"]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xp",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6740,Integrability,message,message,6740,"]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xp",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:7913,Integrability,message,message,7913,"tems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.all()). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_s",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:8642,Integrability,message,message,8642," quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.all()). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expecte",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:8780,Integrability,message,message,8780,"ual_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.all()). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:8973,Integrability,message,message,8973,"d_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = compu",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12165,Integrability,message,messages,12165," errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12501,Integrability,message,message,12501,"r = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys());",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12686,Integrability,message,message,12686,"uple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; ph",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12755,Integrability,message,message,12755,"uple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; ph",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:14267,Integrability,message,message,14267,"xpected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecul",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:14307,Integrability,message,message,14307,"xpected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecul",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:14329,Integrability,message,message,14329,"tol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecular_multiplicity'] = int(dicary['mol",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:14381,Integrability,message,message,14381,"al_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecular_multiplicity'] = int(dicary['molecular_multiplicity']); # if 'fragment_multiplicities' in",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:9708,Modifiability,extend,extend,9708,"ssage = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, m",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:10311,Modifiability,extend,extend,10311,":; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:15,Testability,test,testing,15,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:116,Testability,test,testing,116,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:153,Testability,test,testing,153,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:182,Testability,log,logging,182,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:672,Testability,log,log,672,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:710,Testability,log,logging,710,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:755,Testability,log,logging,755,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:794,Testability,log,logging,794,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:979,Testability,test,test,979,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2145,Testability,log,log,2145,"array],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2505,Testability,log,logging,2505," element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.array(expected, dtype=dtype), np.array(computed, dtype=dtype); except Exception:; return return_han",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:2580,Testability,test,testing,2580,"t array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.array(expected, dtype=dtype), np.array(computed, dtype=dtype); except Exception:; return return_handler(; False, label, f""""""\t{label}: inputs not cast-able to ndarray of {dtype}."""""", ret",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6488,Testability,log,log,6488,""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6831,Testability,log,logging,6831,"ol, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:6906,Testability,test,testing,6906,"uiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.al",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:12486,Testability,log,log,12486,"r = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys());",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:17443,Testability,test,testing,17443,"[(s if s is None else int(s)) for s in dicary[""fragment_separators""]]; # forgive generator version changes; if ""provenance"" in dicary:; dicary[""provenance""].pop(""version""); # regularize connectivity ordering; if ""connectivity"" in dicary:; conn = [(min(at1, at2), max(at1, at2), bo) for (at1, at2, bo) in dicary[""connectivity""]]; conn.sort(key=lambda tup: tup[0]); dicary[""connectivity""] = conn. return dicary. xptd = massage_dicts(xptd); cptd = massage_dicts(cptd). if relative_geoms == ""exact"":; pass; elif relative_geoms == ""align"":; # can't just expect geometries to match, so we'll align them, check that; # they overlap and that the translation/rotation arrays jibe with; # fix_com/orientation, then attach the oriented geom to computed before the; # recursive dict comparison.; from .molutil.align import B787. cgeom = np.array(cptd[""geom""]).reshape((-1, 3)); rgeom = np.array(xptd[""geom""]).reshape((-1, 3)); rmsd, mill = B787(; rgeom=rgeom,; cgeom=cgeom,; runiq=None,; cuniq=None,; atoms_map=True,; mols_align=True,; run_mirror=False,; verbose=0,; ); if cptd[""fix_com""]:; return compare(; True,; np.allclose(np.zeros((3)), mill.shift, atol=atol),; ""null shift"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); if cptd[""fix_orientation""]:; return compare(; True,; np.allclose(np.identity(3), mill.rotation, atol=atol),; ""null rotation"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); ageom = mill.align_coordinates(cgeom); cptd[""geom""] = ageom.reshape((-1)). return compare_recursive(; xptd,; cptd,; atol=atol,; rtol=rtol,; label=label,; forgive=forgive,; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:1528,Deployability,integrat,integrated,1528,"terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in rang",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:8104,Deployability,update,updated,8104," scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta2 = { # CCSD(T) - CCSD; 'wfn': kwargs.pop('delta2_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta2_wfn_lesser', 'ccsd'),; 'basis': kwargs.pop('delta2_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta2_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta3 = { # CCSDT - CCSD(T); 'wfn': kwargs.pop('delta3_wfn', 'ccsdt'),; 'wfn_lesser': kwargs.pop('delta3_wfn_lesser', 'ccsd(t)'),; 'basis': kwargs.pop('delta3_basis', 'cc-pVTZ'),; 'scheme': kwargs.pop('delta3_scheme', 'xtpl_highest_1'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta4 = { # CCSDT(Q) - CCSDT; 'wfn': kwargs.pop('delta4_wfn', 'ccsdt(q)'),; 'wfn_lesser': kwargs.pop('delta4_wfn_lesser', 'ccsdt'),; 'basis': kwargs.pop('delta4_basis', 'cc-pVDZ'),; 'scheme': kwargs.pop('delta4_scheme', 'xtpl_highest_1'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }. return [scf, corl, delta, delta2, delta3, delta4]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.aliases. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:1551,Energy Efficiency,energy,energy,1551,"terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in rang",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:2916,Energy Efficiency,energy,energy,2916,"aram filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:3243,Energy Efficiency,energy,energy,3243,"open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'opt",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:3280,Energy Efficiency,energy,energy,3280,"open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'opt",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:5415,Energy Efficiency,energy,energy,5415,"etadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:5452,Energy Efficiency,energy,energy,5452,"etadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:5504,Energy Efficiency,energy,energy,5504,"1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""q",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:5558,Energy Efficiency,energy,energy,5558,"1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""q",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:1145,Integrability,wrap,wrappers,1145,"code for psi4.driver.aliases; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=T",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:1528,Integrability,integrat,integrated,1528,"terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in rang",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:1566,Integrability,rout,routines,1566,"ation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:2826,Integrability,wrap,wrapper,2826,". .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis':",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:4577,Integrability,wrap,wrapper,4577,"sis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:4927,Integrability,wrap,wrapper,4927,"ions': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""o",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:5863,Integrability,interface,interface,5863,"s. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; del",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:2924,Performance,perform,performed,2924,"aram filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:3351,Performance,optimiz,optimization,3351,"olecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:3369,Performance,optimiz,optimize,3369,"olecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:3442,Performance,optimiz,optimization,3442,"n range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:3521,Performance,optimiz,optimize,3521,"n range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:4796,Performance,perform,performed,4796," {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which do",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:6031,Safety,safe,safe,6031,"s. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; del",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:6147,Testability,log,logic,6147,"xt{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta2 = { # CCSD(T) - CCSD; 'wfn': kwargs.pop('delta2_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta2_wfn_lesser', 'ccsd'),; 'basis': kwargs.pop('delta2_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta2_scheme', 'corl_xtpl_helgaker_2'),;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:1254,Usability,simpl,simple,1254,"tware package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:3393,Availability,avail,available,3393,"nerates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rval",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:7285,Deployability,install,installed,7285,"MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:10295,Deployability,update,updated,10295,"). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np.linspace(minR, maxR, 1000); xrel = xpts - re; xpows = xrel[:, None] ** range(5); fit2 = np.einsum('xd,d', xpows[:,0:3], dvals[0:3]); fit4 = np.einsum('xd,d', xpows, dvals). # Make / display the plot; plt.plot(xpts, fit2, 'b', linewidth=2.5, label='Harmonic (quadratic) fit'); plt.plot(xpts, fit4, 'g', linewidth=2.5, label='Anharmonic (quartic) fit'); plt.plot([re, re], [minE, maxE], 'b--', linewidth=0.5); plt.plot([r0, r0], [minE, maxE], 'g--', linewidth=0.5); plt.scatter(rvals, energies, c='Black', linewidth=3, label='Input Data'); plt.legend(). plt.xlabel('Bond length (Angstroms)'); plt.ylabel('Energy (Eh)'); plt.xlim(minR, maxR); plt.ylim(minE, maxE); if plot_fit == 'screen':; plt.show(); else:; plt.savefig(plot_fit); core.print_out(""\n\tPES fit saved to %s.\n\n"" % plot_fit). core.print_out(""\nre = %10.6f A check: %10.6f\n"" % (re, recheck)); core.print_out(""r0 = %10.6f A\n"" % r0); core.print_out(""E at re = %17.10f Eh\n"" % e); core.print_out(""we = %10.4f cm-1\n"" % we); core.print_out(""wexe = %10.4f cm-1\n"" % wexe); core.print_out(""nu = %10.4f cm-1\n"" % nu); core.print_out(""ZPVE(we) = %10.4f cm-1\n"" % zpve_we); core.print_out(""ZPVE(nu) = %10.4f cm-1\n"" % zpve_nu); core.print_out(""Be = %10.4f cm-1\n"" % B); core.print_out(""B0 = %10.4f cm-1\n"" % B0); core.print_out(""ae = %10.4f cm-1\n"" % ae); core.print_out(""De = %10.7f cm-1\n"" % de); results = {; ""re"" : re,; ""r0"" : r0,; ""we"" : we,; ""wexe"" : wexe,; ""nu"" : nu,; ""E(re)"" : e,; ""ZPVE(harmonic)"" : zpve_we,; ""ZPVE(anharmonic)"" : zpve_nu,; ""Be"" : B,; ""B0"" : B0,; ""ae"" : ae,; ""De"" : de; }; return results. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.diatomic. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:2392,Energy Efficiency,energy,energy,2392,"float,; no_factorials: bool = True,; weighted: bool = True,; polynomial_order: int = 4,; ):; """"""Performs an unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]; def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:2530,Energy Efficiency,energy,energy,2530,"ed order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]; def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supp",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:3360,Energy Efficiency,energy,energy,3360,"nerates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rval",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:5644,Energy Efficiency,energy,energy,5644,"ule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifu",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:5774,Energy Efficiency,energy,energy,5774,"ergies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (pl",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:7549,Energy Efficiency,energy,energy,7549,"meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:7677,Energy Efficiency,energy,energy,7677,"((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np.linspace(minR, maxR, 1000); xrel = xpts - re; xpows = xrel[:, None] ** range(5); fit2 = np.einsum('xd,d', xpows[:,0:3], dvals[0:3]); fit4 = np.e",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html:5494,Performance,optimiz,optimization,5494,"t_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:39525,Availability,avail,available,39525,"-- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:; core.set_local_option('SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:40493,Availability,checkpoint,checkpoint,40493," if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:; core.set_local_option('SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:57207,Availability,avail,available,57207," 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimiz",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64006,Availability,avail,available,64006,"zation engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64467,Availability,avail,available,64467,"p_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_b3lyp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_hf>` |; +-----------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:75523,Availability,error,error,75523,"np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:76057,Availability,failure,failure,76057,"ng to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:85274,Availability,avail,available,85274,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:85335,Availability,avail,available,85335,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:85803,Availability,avail,available,85803,"ates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:85919,Availability,avail,availability,85919,"gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_w",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:86632,Availability,avail,available,86632,"``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:87730,Availability,avail,available,87730,"printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perfo",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:94278,Availability,checkpoint,checkpoint,94278,"n(filename, 'w') as handle:; handle.write(qcdb.vib.print_molden_vibs(vibinfo, symbols, geom, standalone=True)). return vibinfo. [docs]; def gdma(wfn, datafile=""""):; """"""Function to use wavefunction information in *wfn* and, if specified,; additional commands in *filename* to run GDMA analysis with A. J. Stone's program. .. versionadded:: 0.6. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate DMA analysis. :type datafile: str; :param datafile: optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, the File keyword must be set to read; a filename.fchk, where filename is provided by :term:`WRITER_FILE_LABEL <WRITER_FILE_LABEL (GLOBALS)>` . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except IndexError:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.wri",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:97091,Availability,avail,available,97091,".get_order(site) for site in range(1, nsites + 1)). nvals = (maxorder + 1) * (maxorder + 1); dmavals = np.zeros((nsites, nvals)); for site in range(1, nsites + 1):; site_order = gdma.get_order(site); site_nvals = (site_order + 1) * (site_order + 1); for n in range(1, site_nvals + 1):; dmavals[site - 1][n - 1] = gdma.get_dma_value(site, n); dmavals = core.Matrix.from_array(dmavals); dmavals.name = ""Spherical Harmonic DMA for each site"". totvals = np.zeros((1, nvals)); for n in range(1, nvals + 1):; totvals[0][n - 1] = gdma.get_tot_value(n); totvals = core.Matrix.from_array(totvals); totvals.name = ""Total multipoles, translated to the origin"". wfn.set_variable(""DMA DISTRIBUTED MULTIPOLES"", dmavals) # P::e GDMA; wfn.set_variable(""DMA TOTAL MULTIPOLES"", totvals) # P::e GDMA; core.set_variable(""DMA DISTRIBUTED MULTIPOLES"", dmavals) # P::e GDMA; core.set_variable(""DMA TOTAL MULTIPOLES"", totvals) # P::e GDMA; core.print_out(""""""; DMA results are available in the Python driver through the commands:; variable('DMA DISTRIBUTED MULTIPOLES'); variable('DMA TOTAL MULTIPOLES'). """"""). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]; def fchk(wfn: core.Wavefunction, filename: str, *, debug: bool = False, strict_label: bool = True):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for met",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:21796,Deployability,configurat,configuration,21796,"les :ref:`[manual] <sec:cc>` :ref:`[details] <dd_bccd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-ccsd(t) | CCSD(T) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc3 | approximate CC singles, doubles, and triples (CC3) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_cc3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccenergy | **expert** full control over ccenergy module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+--------------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:23081,Deployability,configurat,configuration,23081,"ISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_fci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | gaussian-2, g2 | Gaussian-2 composite method :ref:`[manual] <sec:fnogn>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | casscf | complete active space self consistent field (CASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | rasscf | restricted active space s",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:50408,Deployability,configurat,configurational,50408,"-----------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | adc(0), adc(1), | Algebraic-diagrammatic construction methods | RHF/UHF | dipole, transition_dipole, oscillator_strength, |; | ..., adc(3), | :ref:`[manual] <sec:adc>` | | rotational_strength |; | cvs-adc(0), ... | | | |; | cvs-adc(3) | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+. :type name: str; :param name: ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type properties: List[str]; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. Defaults to dipole and quadrupole. :type molecule: :ref:`molecule <op_py_molecule>`; :param mole",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:54267,Deployability,install,installing,54267," driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:54289,Deployability,install,install,54289," driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:54331,Deployability,install,install,54331," driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:72735,Deployability,update,update,72735,"; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:75055,Deployability,update,update,75055,"local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, fai",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:91396,Deployability,update,update,91396,"g to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:92137,Deployability,update,update,92137,"ss(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, ind",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:95583,Deployability,install,installing,95583,".dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except IndexError:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""). # from outside the Psi4 ecosystem; from qcelemental.util import which_import; if not which_import(""gdma"", return_bool=True):; raise ModuleNotFoundError('Python module gdma not found. Solve by installing it: `conda install -c conda-forge gdma` or recompile with `-DENABLE_gdma`'); import gdma. min_version = ""2.3.3""; from qcelemental.util import parse_version; if parse_version(gdma.__version__) < parse_version(min_version):; raise ModuleNotFoundError(f""GDMA version {min_version} is required at least. Version {gdma.__version__} was found.""). core.prepare_options_for_module(""GDMA""). gof = core.get_output_file(); gdma.run_gdma(gof, commands); core.set_output_file(gof, True); core.reopen_outfile(). nsites = gdma.get_nsites(); maxorder = max(gdma.get_order(site) for site in range(1, nsites + 1)). nvals = (maxorder + 1) * (maxorder + 1); dmavals = np.zeros((nsites, nvals)); for site in range(1, nsites + 1):; site_order = gdma.get_order(site); site_nvals = (site_order + 1) * (site_order + 1); for n in range(1, site_nvals + 1):; dmavals[site - 1][n - 1] = gdma.get_dma_value(site, n); dmavals = core.Matrix.from_array(dmavals); dmavals.name = ""Spherical Harmonic DMA for each site"". totvals = np.zeros((1, nvals)); for n in range(1,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:95605,Deployability,install,install,95605,".dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except IndexError:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""). # from outside the Psi4 ecosystem; from qcelemental.util import which_import; if not which_import(""gdma"", return_bool=True):; raise ModuleNotFoundError('Python module gdma not found. Solve by installing it: `conda install -c conda-forge gdma` or recompile with `-DENABLE_gdma`'); import gdma. min_version = ""2.3.3""; from qcelemental.util import parse_version; if parse_version(gdma.__version__) < parse_version(min_version):; raise ModuleNotFoundError(f""GDMA version {min_version} is required at least. Version {gdma.__version__} was found.""). core.prepare_options_for_module(""GDMA""). gof = core.get_output_file(); gdma.run_gdma(gof, commands); core.set_output_file(gof, True); core.reopen_outfile(). nsites = gdma.get_nsites(); maxorder = max(gdma.get_order(site) for site in range(1, nsites + 1)). nvals = (maxorder + 1) * (maxorder + 1); dmavals = np.zeros((nsites, nvals)); for site in range(1, nsites + 1):; site_order = gdma.get_order(site); site_nvals = (site_order + 1) * (site_order + 1); for n in range(1, site_nvals + 1):; dmavals[site - 1][n - 1] = gdma.get_dma_value(site, n); dmavals = core.Matrix.from_array(dmavals); dmavals.name = ""Spherical Harmonic DMA for each site"". totvals = np.zeros((1, nvals)); for n in range(1,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:106553,Deployability,update,updated,106553,"Ca = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]; def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:2781,Energy Efficiency,energy,energy,2781,"ger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals:",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:2858,Energy Efficiency,energy,energy,2858,"ger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals:",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:2908,Energy Efficiency,energy,energy,2908,"):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |d",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:2958,Energy Efficiency,energy,energy,2958,"rn whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn con",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:3030,Energy Efficiency,energy,energy,3030," coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour|",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:3776,Energy Efficiency,energy,energy,3776,"ced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless |PSIfour| is called with `-m` flag. :type restart_file: str; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. .. _`table:energy_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+============================================================================",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:25932,Energy Efficiency,adapt,adapted,25932,-----------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-scf | (with CheMPS2) density matrix renormalization group SCF :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-caspt2 | (with CheMPS2) density matrix renormalization group CASPT2 :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-ci | (with CheMPS2) density matrix renormalization group CI :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt0 | 0th-order symmetry adapted perturbation theory (SAPT) :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ssapt0 | 0th-order SAPT with special exchange scaling :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fisapt0 | 0th-order functional and/or intramolecular SAPT :ref:`[manual] <sec:fisapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sf-sapt | 0th-order spin-flip SAPT :ref:`[manual] <sec:sfsapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt(dft) | 0th-order SAPT upo,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:30494,Energy Efficiency,charge,charge,30494,-------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+(ccd)dmp2 | SAPT2+ with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+(3)(ccd)dmp2 | SAPT2+(3) with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+3(ccd)dmp2 | SAPT2+3 with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt0-ct | 0th-order SAPT plus charge transfer (CT) calculation :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2-ct | SAPT2 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+-ct | SAPT2+ plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+(3)-ct | SAPT2+(3) plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+3-ct | SAPT2+3 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+--,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:35767,Energy Efficiency,energy,energy,35767,"---------------------------------------------------------+; | eom-cc2 | equation of motion (EOM) CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:35999,Energy Efficiency,energy,energy,35999,"---------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36066,Energy Efficiency,energy,energy,36066,"CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for mo",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36383,Energy Efficiency,energy,energy,36383,"--------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nSc",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36501,Energy Efficiency,energy,energy,36501,"om-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.po",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36693,Energy Efficiency,energy,energy,36693,">>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36730,Energy Efficiency,energy,energy,36730,">>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36838,Energy Efficiency,energy,energy,36838," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _fil",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:37086,Energy Efficiency,energy,energy,37086,">> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we plannin",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:37834,Energy Efficiency,energy,energy,37834,"s; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:38121,Energy Efficiency,energy,energy,38121,", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:38690,Energy Efficiency,energy,energy,38690,"-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent w",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:38766,Energy Efficiency,energy,energy,38766,"l.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:40938,Energy Efficiency,energy,energy,40938,"int_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in l",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41236,Energy Efficiency,energy,energy,41236," os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41318,Energy Efficiency,energy,energy,41318,"ot item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.drive",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41392,Energy Efficiency,energy,energy,41392,"lenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :re",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41548,Energy Efficiency,energy,energy,41548,"ct(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41570,Energy Efficiency,energy,energy,41570," psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:44915,Energy Efficiency,energy,energy,44915," lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); opts",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:54444,Energy Efficiency,energy,energy,54444,"ption('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kw",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:55437,Energy Efficiency,energy,energy,55437,"nally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61150,Energy Efficiency,energy,energy,61150,"nvergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicat",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61671,Energy Efficiency,energy,energy,61671,"tep_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* ene",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61778,Energy Efficiency,energy,energy,61778,"mizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |d",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:62290,Energy Efficiency,energy,energy,62290,"d return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the Ge",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:62668,Energy Efficiency,energy,energy,62668,"oat* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63532,Energy Efficiency,energy,energy,63532,"rn_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in th",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63671,Energy Efficiency,energy,energy,63671,"e. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63964,Energy Efficiency,energy,energy,63964,"ype engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64554,Energy Efficiency,energy,energy,64554,"dicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_b3lyp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_hf>` |; +-------------------------+-------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:70022,Energy Efficiency,energy,energy,70022,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:70084,Energy Efficiency,energy,energy,70084,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:74237,Energy Efficiency,energy,energy,74237," are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Pr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:76786,Energy Efficiency,energy,energy,76786,"_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('O",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:81355,Energy Efficiency,energy,energy,81355,"chem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername},",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:82800,Energy Efficiency,energy,energy,82800,"on_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibratio",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:82999,Energy Efficiency,energy,energy,82999,"ranslations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified.",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:83455,Energy Efficiency,energy,energy,83455,"'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate t",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:83567,Energy Efficiency,energy,energy,83567,"ormat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:83902,Energy Efficiency,energy,energy,83902,"(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:83986,Energy Efficiency,energy,energy,83986,"rgy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nest",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:84584,Energy Efficiency,energy,energy,84584,"GY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrd",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:84772,Energy Efficiency,energy,energy,84772,"ef frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:84911,Energy Efficiency,energy,energy,84911,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:85232,Energy Efficiency,energy,energy,85232,"hod; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=====",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:92120,Energy Efficiency,energy,energy,92120,".asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sor",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:98663,Energy Efficiency,energy,energy,98663,"hk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFM",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:100428,Energy Efficiency,energy,energy,100428,"currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! met",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:100787,Energy Efficiency,energy,energy,100787,"fn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:100981,Energy Efficiency,reduce,reduced,100981,"efwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:101922,Energy Efficiency,energy,energy,101922,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]; def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis t",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:102390,Energy Efficiency,energy,energy,102390,":; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]; def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbital",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:103377,Energy Efficiency,energy,energy,103377,"n addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:103952,Energy Efficiency,energy,energy,103952,"nsity_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 4. Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO). >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_V",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:104325,Energy Efficiency,energy,energy,104325,"DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 4. Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO). >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:1757,Integrability,wrap,wrappers,1757,"NESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import copy; import json; import logging; import os; import re; import shutil; from typing import Dict, Optional, Union. import numpy as np. from psi4 import core # for typing. from . import driver_cbs, driver_findif, driver_nbody, driver_util, p4util, qcdb, task_planner; from .constants import constants, nppp, nppp10, pp; from .mdi_engine import mdi_run; from .p4util.exceptions import *; from .procrouting import *; from .task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'."")",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:37239,Integrability,interface,interface,37239,"ci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:43361,Integrability,wrap,wrapper,43361,"psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""ret",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:44859,Integrability,depend,dependent,44859," lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); opts",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:57244,Integrability,interface,interface,57244," 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimiz",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:73301,Integrability,depend,dependent,73301,"t_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_da",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:73713,Integrability,depend,dependent,73713,"v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.he",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:79372,Integrability,wrap,wrapper,79372,"atrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; ## First half of this fn -- entry means user wants a 2nd derivative by any means. kwargs = p4util.kwargs_lower(kwargs); basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowernam",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:81299,Integrability,depend,dependent,81299,"chem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername},",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:3090,Modifiability,variab,variables,3090,"adient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Tur",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:21796,Modifiability,config,configuration,21796,"les :ref:`[manual] <sec:cc>` :ref:`[details] <dd_bccd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-ccsd(t) | CCSD(T) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc3 | approximate CC singles, doubles, and triples (CC3) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_cc3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccenergy | **expert** full control over ccenergy module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+--------------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:23081,Modifiability,config,configuration,23081,"ISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_fci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | gaussian-2, g2 | Gaussian-2 composite method :ref:`[manual] <sec:fnogn>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | casscf | complete active space self consistent field (CASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | rasscf | restricted active space s",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:25932,Modifiability,adapt,adapted,25932,-----------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-scf | (with CheMPS2) density matrix renormalization group SCF :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-caspt2 | (with CheMPS2) density matrix renormalization group CASPT2 :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-ci | (with CheMPS2) density matrix renormalization group CI :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt0 | 0th-order symmetry adapted perturbation theory (SAPT) :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ssapt0 | 0th-order SAPT with special exchange scaling :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fisapt0 | 0th-order functional and/or intramolecular SAPT :ref:`[manual] <sec:fisapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sf-sapt | 0th-order spin-flip SAPT :ref:`[manual] <sec:sfsapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt(dft) | 0th-order SAPT upo,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:33141,Modifiability,extend,extended,33141,"plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc | 2nd-order algebraic diagrammatic construction (ADC), deprecated :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(1) | (with ADCC) 1st-order algebraic diagrammatic construction (ADC) :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(2) | (with ADCC) 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(2)-x | (with ADCC) extended 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(3) | (with ADCC) 3rd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(1) | (with ADCC) core-valence separation (CVS) 1st-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2) | (with ADCC) CVS 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2)-x | (with ADCC) CVS extended 2nd-order A",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:34126,Modifiability,extend,extended,34126,with ADCC) extended 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(3) | (with ADCC) 3rd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(1) | (with ADCC) core-valence separation (CVS) 1st-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2) | (with ADCC) CVS 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2)-x | (with ADCC) CVS extended 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(3) | (with ADCC) CVS 3rd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ep2 | 2nd-order electron propagator theory |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc2 | equation of motion (EOM) CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+-------------------,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41334,Modifiability,variab,variable,41334,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:42148,Modifiability,variab,variable,42148,"EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:42201,Modifiability,variab,variable,42201,")); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the m",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:45814,Modifiability,variab,variable,45814," derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +-",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:50408,Modifiability,config,configurational,50408,"-----------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | adc(0), adc(1), | Algebraic-diagrammatic construction methods | RHF/UHF | dipole, transition_dipole, oscillator_strength, |; | ..., adc(3), | :ref:`[manual] <sec:adc>` | | rotational_strength |; | cvs-adc(0), ... | | | |; | cvs-adc(3) | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+. :type name: str; :param name: ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type properties: List[str]; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. Defaults to dipole and quadrupole. :type molecule: :ref:`molecule <op_py_molecule>`; :param mole",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:53840,Modifiability,variab,variable,53840,"turn plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:53942,Modifiability,variab,variable,53942,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:53995,Modifiability,variab,variable,53995,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:55400,Modifiability,variab,variable,55400,"nally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61997,Modifiability,variab,variables,61997,"'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:74435,Modifiability,variab,variable,74435,"ption(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); exce",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:76576,Modifiability,variab,variables,76576,"= 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Op",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:88438,Modifiability,variab,variable,88438,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull inform",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:88491,Modifiability,variab,variable,88491,"= kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:88918,Modifiability,variab,variables,88918,"otations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`. """""". if hess is None:; nmwhes",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:89968,Modifiability,variab,variables,89968,". Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`. """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impost",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:92077,Modifiability,variab,variable,92077,"y()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:97145,Modifiability,variab,variable,97145,".get_order(site) for site in range(1, nsites + 1)). nvals = (maxorder + 1) * (maxorder + 1); dmavals = np.zeros((nsites, nvals)); for site in range(1, nsites + 1):; site_order = gdma.get_order(site); site_nvals = (site_order + 1) * (site_order + 1); for n in range(1, site_nvals + 1):; dmavals[site - 1][n - 1] = gdma.get_dma_value(site, n); dmavals = core.Matrix.from_array(dmavals); dmavals.name = ""Spherical Harmonic DMA for each site"". totvals = np.zeros((1, nvals)); for n in range(1, nvals + 1):; totvals[0][n - 1] = gdma.get_tot_value(n); totvals = core.Matrix.from_array(totvals); totvals.name = ""Total multipoles, translated to the origin"". wfn.set_variable(""DMA DISTRIBUTED MULTIPOLES"", dmavals) # P::e GDMA; wfn.set_variable(""DMA TOTAL MULTIPOLES"", totvals) # P::e GDMA; core.set_variable(""DMA DISTRIBUTED MULTIPOLES"", dmavals) # P::e GDMA; core.set_variable(""DMA TOTAL MULTIPOLES"", totvals) # P::e GDMA; core.print_out(""""""; DMA results are available in the Python driver through the commands:; variable('DMA DISTRIBUTED MULTIPOLES'); variable('DMA TOTAL MULTIPOLES'). """"""). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]; def fchk(wfn: core.Wavefunction, filename: str, *, debug: bool = False, strict_label: bool = True):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for met",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:97185,Modifiability,variab,variable,97185,".get_order(site) for site in range(1, nsites + 1)). nvals = (maxorder + 1) * (maxorder + 1); dmavals = np.zeros((nsites, nvals)); for site in range(1, nsites + 1):; site_order = gdma.get_order(site); site_nvals = (site_order + 1) * (site_order + 1); for n in range(1, site_nvals + 1):; dmavals[site - 1][n - 1] = gdma.get_dma_value(site, n); dmavals = core.Matrix.from_array(dmavals); dmavals.name = ""Spherical Harmonic DMA for each site"". totvals = np.zeros((1, nvals)); for n in range(1, nvals + 1):; totvals[0][n - 1] = gdma.get_tot_value(n); totvals = core.Matrix.from_array(totvals); totvals.name = ""Total multipoles, translated to the origin"". wfn.set_variable(""DMA DISTRIBUTED MULTIPOLES"", dmavals) # P::e GDMA; wfn.set_variable(""DMA TOTAL MULTIPOLES"", totvals) # P::e GDMA; core.set_variable(""DMA DISTRIBUTED MULTIPOLES"", dmavals) # P::e GDMA; core.set_variable(""DMA TOTAL MULTIPOLES"", totvals) # P::e GDMA; core.print_out(""""""; DMA results are available in the Python driver through the commands:; variable('DMA DISTRIBUTED MULTIPOLES'); variable('DMA TOTAL MULTIPOLES'). """"""). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]; def fchk(wfn: core.Wavefunction, filename: str, *, debug: bool = False, strict_label: bool = True):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for met",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:100389,Modifiability,variab,variable,100389,"currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! met",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:1210,Performance,optimiz,optimizations,1210,"n-source quantum chemistry software package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import copy; import json; import logging; import os; import re; import shutil; from typing import Dict, Optional, Union. import numpy as np. from psi4 import core # for typing. from . import driver_cbs, driver_findif, driver_nbody, driver_util, p4util, qcdb, task_planner; from .constants import constants, nppp, nppp10, pp; from .mdi_engine import mdi_run; from .p4util.exceptions import *; from .procrouting import *; from .task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_pres",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:12082,Performance,optimiz,optimized,12082,--------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-mp4 | full MP4 with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order |MollerPlesset| (MP) perturbation theory :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_mp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_zapt2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+------------------------------------------------------------------------------------------------------------------,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:12842,Performance,optimiz,optimized,12842,tails] <dd_mp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_zapt2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2.,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:13603,Performance,optimiz,optimized,13603,"in-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccsd, cepa(0) | coupled electron pair approximation variant 0 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <dd_lccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccsd, fno-cepa(0) | CEPA(0) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cepa(1) | coupled electron pair approximation variant 1 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <dd_cepa_pr1_pr>` |; +-------------------------+--------------------------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:17341,Performance,optimiz,optimized,17341,-----------+---------------------------------------------------------------------------------------------------------------------------------------+; | qcisd | quadratic CI singles doubles (QCISD) :ref:`[manual] <sec:fnocc>` :ref:`[details] <dd_qcisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-qcisd | QCISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | remp2 | 2nd-order retaining-the-excitation-degree MP hybrid perturbation theory :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_remp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccd | LCCD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_olccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc2 | approxi,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:18091,Performance,optimiz,optimized,18091,ef:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_remp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccd | LCCD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_olccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc2 | approximate coupled cluster singles and doubles (CC2) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_cc2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_ccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+--------------------------------------------------------------------------------------,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36791,Performance,perform,perform,36791," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _fil",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:36893,Performance,perform,perform,36893,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_glob",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:42321,Performance,optimiz,optimize,42321," {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); mole",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:45308,Performance,perform,perform,45308,"rname, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords s",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:48307,Performance,optimiz,optimized,48307,"------------------+; | hf | HF Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | mp2 | MP2 with density fitting only (mp2_type df) | RHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | ccsd | Coupled cluster singles and doubles (CCSD) | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:48641,Performance,optimiz,optimized,48641,"------------------+; | hf | HF Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | mp2 | MP2 with density fitting only (mp2_type df) | RHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | ccsd | Coupled cluster singles and doubles (CCSD) | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:48976,Performance,optimiz,optimized,48976,"----------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+--------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:49270,Performance,optimiz,optimized,49270,"--------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+---",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:58151,Performance,optimiz,optimizer,58151,"se ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_ener",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:58188,Performance,optimiz,optimize,58188,"ns are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Conver",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:58230,Performance,optimiz,optimizer,58230," the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Conver",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:58252,Performance,optimiz,optimize,58252," Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.C",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:58378,Performance,optimiz,optimizer,58378," system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n -----------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:58407,Performance,optimiz,optimizer,58407,"s.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n ------------------------------------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:58450,Performance,optimiz,optimizer,58450,"ict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). cor",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59458,Performance,optimiz,optimizer,59458,"mizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{o",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59483,Performance,optimiz,optimizer,59483,"_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59606,Performance,optimiz,optimizer,59606,"ms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59635,Performance,optimiz,optimize,59635,"in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_e",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59730,Performance,optimiz,optimizer,59730,"rked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.f",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59759,Performance,optimiz,optimize,59759," ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.appe",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59855,Performance,optimiz,optimizer,59855,"---------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59873,Performance,optimiz,optimizer,59873,"------------ ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Ma",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59902,Performance,optimiz,optimizer,59902,"print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimize",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59941,Performance,optimiz,optimizer,59941,"lta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_g",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:59990,Performance,optimiz,optimize,59990,"(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_o",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60014,Performance,optimiz,optimizer,60014,"--------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Ene",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60027,Performance,optimiz,optimizer,60027,"-------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60073,Performance,optimiz,optimizer,60073,"---------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60087,Performance,optimiz,optimizer,60087,"-- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60404,Performance,optimiz,optimizer,60404,"------------------------------ ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (r",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60429,Performance,optimiz,optimizer,60429,"---- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif r",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60454,Performance,optimiz,optimizer,60454,"\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not retur",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60466,Performance,optimiz,optimizer,60466,"eration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60655,Performance,optimiz,optimizer,60655,"NVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Tot",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60716,Performance,optimiz,optimizer,60716,"); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :r",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60790,Performance,optimiz,optimizer,60790,"re.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and w",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60839,Performance,optimiz,optimizer,60839,"erge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :ra",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:60890,Performance,optimiz,optimizer,60890,"ergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceEr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61536,Performance,optimiz,optimize,61536,"2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally ret",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61579,Performance,perform,perform,61579,"2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally ret",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61598,Performance,optimiz,optimization,61598,"2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally ret",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:61681,Performance,optimiz,optimized,61681,"tep_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* ene",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:62910,Performance,optimiz,optimization,62910,"iver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` i",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63016,Performance,optimiz,optimization,63016," :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63087,Performance,optimiz,optimizer,63087," :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63231,Performance,optimiz,optimizers,63231,"he computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational metho",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63302,Performance,optimiz,optimizer,63302,"`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where t",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63330,Performance,optimiz,optimization,63330,"`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where t",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63593,Performance,perform,performed,63593,"`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63699,Performance,perform,performs,63699,"e. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64039,Performance,optimiz,optimization,64039,"zation engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64061,Performance,perform,performed,64061,"zation engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64198,Performance,perform,perform,64198,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64248,Performance,optimiz,optimization,64248,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64946,Performance,optimiz,optimizations,64946,r all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_b3lyp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_hf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dct | density cumulant (functional) theory :ref:`[manual] <sec:dct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <dd_mp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+-------------------------,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:66586,Performance,optimiz,optimized,66586,------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <dd_mp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+-------------------------------------------,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:66849,Performance,optimiz,optimized,66849,------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <dd_mp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+-------------------------------------------,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:67113,Performance,optimiz,optimized,67113,on theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_olccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cc2 | approximate coupled cluster singles and doubles (CC2) :ref:`[manual] <sec:cc>` :r,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:67350,Performance,optimiz,optimized,67350,,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:67809,Performance,optimiz,optimized,67809,,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:69369,Performance,optimiz,optimization,69369,"d>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:69387,Performance,optimiz,optimize,69387,"d>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:69435,Performance,optimiz,optimization,69435,"----------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.po",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:69596,Performance,perform,perform,69596,"sd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Opt",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:69643,Performance,optimiz,optimize,69643,"sd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Opt",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:69704,Performance,perform,perform,69704,"------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__ca",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:69897,Performance,optimiz,optimize,69897,"-----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', Fals",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:70050,Performance,optimiz,optimization,70050,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:70134,Performance,optimiz,optimization,70134,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:70221,Performance,optimiz,optimization,70221,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:70255,Performance,optimiz,optimize,70255,"include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:71232,Performance,optimiz,optimize,71232,"ion step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well teste",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:72186,Performance,optimiz,optimization,72186,"('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmet",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:72402,Performance,load,load,72402," 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slight",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:72485,Performance,optimiz,optimization,72485,"vided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERAN",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:73966,Performance,optimiz,optimize,73966,"ore.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_wi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:75135,Performance,optimiz,optimizing,75135,"he gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last i",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:76357,Performance,optimiz,optimized,76357,"s molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:76553,Performance,optimiz,optimized,76553,"= 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Op",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:76653,Performance,optimiz,optimize,76653,"ing resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.updat",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:77041,Performance,optimiz,optimize,77041,"gence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n');",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:77972,Performance,optimiz,optimization,77972,"story.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n'); molecule.print_in_input_format(). n += 1. optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]; def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:78160,Performance,optimiz,optimization,78160,"RITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n'); molecule.print_in_input_format(). n += 1. optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]; def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; ## First half of this fn -- entry means user wants a 2nd derivative by any means. kwargs = p4util.kwargs_lower(kwargs); basisstash = p4util.OptionsS",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:82636,Performance,perform,perform,82636,"ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:84833,Performance,perform,performed,84833,". :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and U",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:84939,Performance,perform,performs,84939,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:85389,Performance,perform,performed,85389,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:87259,Performance,optimiz,optimize,87259,"========================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:88764,Performance,perform,perform,88764,"ally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dicti",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:98499,Performance,optimiz,optimized,98499,"on in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset(",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:100191,Performance,optimiz,optimized,100191," This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:106300,Performance,optimiz,optimize,106300,"Ca = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]; def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41555,Safety,safe,safer,41555,"ct(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:101913,Safety,detect,detected,101913,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]; def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis t",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:63641,Security,access,accesses,63641,"e. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:77025,Security,validat,validated,77025,"gence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n');",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:84650,Security,access,accessed,84650,"write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:84881,Security,access,accesses,84881,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:1316,Testability,log,logging,1316,"rties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import copy; import json; import logging; import os; import re; import shutil; from typing import Dict, Optional, Union. import numpy as np. from psi4 import core # for typing. from . import driver_cbs, driver_findif, driver_nbody, driver_util, p4util, qcdb, task_planner; from .constants import constants, nppp, nppp10, pp; from .mdi_engine import mdi_run; from .p4util.exceptions import *; from .procrouting import *; from .task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:1793,Testability,log,logger,1793,"the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import copy; import json; import logging; import os; import re; import shutil; from typing import Dict, Optional, Union. import numpy as np. from psi4 import core # for typing. from . import driver_cbs, driver_findif, driver_nbody, driver_util, p4util, qcdb, task_planner; from .constants import constants, nppp, nppp10, pp; from .mdi_engine import mdi_run; from .p4util.exceptions import *; from .procrouting import *; from .task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwarg",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:1802,Testability,log,logging,1802,"the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import copy; import json; import logging; import os; import re; import shutil; from typing import Dict, Optional, Union. import numpy as np. from psi4 import core # for typing. from . import driver_cbs, driver_findif, driver_nbody, driver_util, p4util, qcdb, task_planner; from .constants import constants, nppp, nppp10, pp; from .mdi_engine import mdi_run; from .p4util.exceptions import *; from .procrouting import *; from .task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwarg",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:35536,Testability,test,tested,35536,"-------------------------------------------------+; | ep2 | 2nd-order electron propagator theory |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc2 | equation of motion (EOM) CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_w",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:38162,Testability,log,logger,38162,", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:38191,Testability,log,logger,38191,"il.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restar",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:40916,Testability,log,logger,40916,"'SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wave",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41131,Testability,log,logger,41131,"i_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavef",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:41297,Testability,log,logger,41297," os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:44340,Testability,log,logger,44340,"ule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:44371,Testability,log,logger,44371,"rapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:44895,Testability,test,test,44895," lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); opts",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:45390,Testability,log,logger,45390,"er.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +-",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:45607,Testability,log,logger,45607,"esults(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +========",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:45775,Testability,log,logger,45775,"_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===========================================================",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:45845,Testability,log,logger,45845," derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +-",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:52617,Testability,log,logger,52617,":examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). """"""; kwargs = p4util.kwargs_lower(kwargs). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(args[0]). _filter_renamed_methods(""properties"", lowername). props = kwargs.get('properties', ['dipole', 'quadrupole']); if len(args) > 1:; props += args[1:]; kwargs['properties'] = p4util.drop_duplicates(props). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""properties"", lowername, molecule, **kwargs); logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else mo",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:52650,Testability,log,logger,52650,"n; >>> properties('cc2', properties=['rotation']). """"""; kwargs = p4util.kwargs_lower(kwargs). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(args[0]). _filter_renamed_methods(""properties"", lowername). props = kwargs.get('properties', ['dipole', 'quadrupole']); if len(args) > 1:; props += args[1:]; kwargs['properties'] = p4util.drop_duplicates(props). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""properties"", lowername, molecule, **kwargs); logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:53410,Testability,log,logger,53410,"get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""properties"", lowername, molecule, **kwargs); logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.En",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:53629,Testability,log,logger,53629,"logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:53799,Testability,log,logger,53799,"rn plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).ca",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:72225,Testability,test,tested,72225,"('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmet",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:80615,Testability,log,logger,80615,"ption(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradien",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:80645,Testability,log,logger,80645,"size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwar",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:81335,Testability,test,test,81335,"chem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername},",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:82300,Testability,log,logger,82300,"endent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0);",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:82516,Testability,log,logger,82516,"ary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:82763,Testability,log,logger,82763,", None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:82813,Testability,log,logger,82813,"on_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibratio",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:64229,Usability,guid,guide,64229,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:3024,Availability,redundant,redundant,3024,"rmat (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:4241,Availability,avail,available,4241,"D/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_proced",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:4467,Availability,avail,available,4467,"---; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:10078,Availability,avail,available,10078,"pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" %; (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(f""""""Basis set '{basis}' not available for molecule.""""""). return (BSET, ZSET). def _contract_bracketed_basis(basisarray: List[str]) -> str:; """"""Function to re-form a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Returns; -------; str; A nicely formatted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]; pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in othe",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:27054,Availability,avail,available,27054,"s``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :para",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:27097,Availability,avail,available,27097,"orl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:32785,Availability,avail,available,32785,"lied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; * ```options_lo```: special options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_sc",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:44441,Availability,redundant,redundant,44441,"tadata[0][""alpha""], NEED, +1,; 0.0, None, None, None, None; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], delta[""alpha""], NEED, +1, 0.0,; None, None, None, None; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis_lo""][0]), delta[""wfn_lo""], delta[""alpha""], NEED, -1,; 0.0, None, None, None, None; ]))). # MODELCHEM is unordered, possibly redundant list of single result *entries* needed to satisfy full CBS; # JOBS is subset of MODELCHEM with minimal list of single result *jobs* needed to satisfy full CBS; # TROVE is superset of JOBS with maximal list of single result *entries* resulting from JOBS; # ""entry"" here is a mtd-bas-opt spec that can support E/G/H data; # ""job"" here is an entry on which to sic Psi4 that, through VARH, may fill in multiple entries. MODELCHEM = []; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; MODELCHEM.append(lvl). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]; listfmt = """""" {:>12} / {:24} for {}{}\n"""""". # TODO: In the ""naive"" and ""enlightened"" loops below, I had to remove condition `and (job['f_options'] is not False))`; # to get them working, and I feel like they were added to fix the same thing. someday, seek to understand. # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if ((job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']); and (job['f_options'] == mc['f_options'])):; dups += 1; if dups >= 1:; del JOBS[indx_job]. instructions += """""" N",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:15990,Deployability,update,update,15990,"bccd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['cisd'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisd': 'CISD TOTAL ENERGY'}; VARH['cisdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisdt': 'CISDT TOTAL ENERGY'}; VARH['cisdtq'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisdtq': 'CISDTQ TOTAL ENERGY'}; VARH['fci'] = {; 'hf': 'HF TOTAL ENERGY',; 'fci': 'FCI TOTAL ENERGY'}; VARH['ccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY'}; VARH['ccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY',; 'ccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]; def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _va",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:40530,Deployability,update,updated,40530,"c: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we ar",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:48945,Deployability,update,update,48945," == job['f_wfn']) or (lvl['f_wfn'] == ('c4-' + job['f_wfn']))); and (lvl['f_basis'] == job['f_basis']) and (lvl['f_options'] == job['f_options'])):; lvl['f_energy'] = job['f_energy']; lvl['f_gradient'] = job['f_gradient']; lvl['f_hessian'] = job['f_hessian']; lvl['f_dipole'] = job['f_dipole']; lvl['f_dipder'] = job['f_dipder']. # Make xtpl() call; finalenergy = 0.0; finalgradient = None; finalhessian = None; finaldipole = None; finaldipder = None. for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha'], 'verbose': verbose}. grad_available = all([lmh['f_gradient'] is not None for lmh in stage['d_need'].values()]); hess_available = all([lmh['f_hessian'] is not None for lmh in stage['d_need'].values()]); dipole_available = all([lmh['f_dipole'] is not None for lmh in stage['d_need'].values()]); dipder_available = all([lmh['f_dipder'] is not None for lmh in stage['d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if fina",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:49242,Deployability,update,update,49242,"_dipder'] = job['f_dipder']. # Make xtpl() call; finalenergy = 0.0; finalgradient = None; finalhessian = None; finaldipole = None; finaldipder = None. for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha'], 'verbose': verbose}. grad_available = all([lmh['f_gradient'] is not None for lmh in stage['d_need'].values()]); hess_available = all([lmh['f_hessian'] is not None for lmh in stage['d_need'].values()]); dipole_available = all([lmh['f_dipole'] is not None for lmh in stage['d_need'].values()]); dipder_available = all([lmh['f_dipder'] is not None for lmh in stage['d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:49554,Deployability,update,update,49554,"eed'].values()]); hess_available = all([lmh['f_hessian'] is not None for lmh in stage['d_need'].values()]); dipole_available = all([lmh['f_dipole'] is not None for lmh in stage['d_need'].values()]); dipder_available = all([lmh['f_dipder'] is not None for lmh in stage['d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:49825,Deployability,update,update,49825,"d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tabl",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:50101,Deployability,update,update,50101,"one:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tables += delimit. required = []; finalenergy = 0.0; for stage in GRAND_NEED:; finalenergy += stage['d_energy'] * stage['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:62373,Deployability,update,updated,62373,"'ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_cbs. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:1361,Energy Efficiency,energy,energy,1361,"ponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain composite method, basis, & options treatments. ========; CBS Flow; ========; Bullet points are major actions; Lines of dashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:2664,Energy Efficiency,energy,energy,2664,"ing into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:4596,Energy Efficiency,energy,energy,4596,"h job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:5827,Energy Efficiency,energy,energy,5827,"xcept ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:16341,Energy Efficiency,energy,energy,16341,": 'HF TOTAL ENERGY',; 'fci': 'FCI TOTAL ENERGY'}; VARH['ccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY'}; VARH['ccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY',; 'ccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]; def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_meta",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:21921,Energy Efficiency,energy,energy,21921," sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a fiel",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:22144,Energy Efficiency,energy,energy,22144,":; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is t",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:22652,Energy Efficiency,energy,energy,22652,"""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0);",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:22784,Energy Efficiency,energy,energy,22784,"########################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:22808,Energy Efficiency,energy,energy,22808,"########################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:22855,Energy Efficiency,energy,energy,22855,"########################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:23260,Energy Efficiency,energy,energy,23260,"ariables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn key",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:23476,Energy Efficiency,energy,energy,23476," - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixe",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24057,Energy Efficiency,energy,energy,24057,"t. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24281,Energy Efficiency,energy,energy,24281,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta cor",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24319,Energy Efficiency,energy,energy,24319,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta cor",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24605,Energy Efficiency,energy,energy,24605,"omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set thro",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24645,Energy Efficiency,energy,energy,24645,"omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set thro",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24862,Energy Efficiency,energy,energy,24862,"rccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24925,Energy Efficiency,energy,energy,24925,"rccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:25072,Energy Efficiency,energy,energy,25072,"med,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:25135,Energy Efficiency,energy,energy,25135,"med,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:25264,Energy Efficiency,energy,energy,25264," which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:25334,Energy Efficiency,energy,energy,25334," which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:25488,Energy Efficiency,energy,energy,25488," corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:25558,Energy Efficiency,energy,energy,25558," corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:25927,Energy Efficiency,energy,energy,25927,"ection; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; se",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:26232,Energy Efficiency,energy,energy,26232," ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtp",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:26477,Energy Efficiency,energy,energy,26477," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.drive",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:26731,Energy Efficiency,energy,energy,26731,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:26773,Energy Efficiency,energy,energy,26773,"|| ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:27302,Energy Efficiency,energy,energy,27302,"sis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if t",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:28179,Energy Efficiency,energy,energy,28179,"am scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :pa",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:28755,Energy Efficiency,energy,energy,28755,_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :param delta2_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type ,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:29341,Energy Efficiency,energy,energy,29341,"resent in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :param delta2_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type scf_alpha: float; :param scf_alpha: |dl| ``1.63`` |dr|. Overrides the default \alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` and :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:31412,Energy Efficiency,energy,energy,31412,"driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; * ```options_lo```: special options for lower method in a given stage",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33445,Energy Efficiency,energy,energy,33445,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33464,Energy Efficiency,energy,energy,33464,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33611,Energy Efficiency,energy,energy,33611,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33630,Energy Efficiency,energy,energy,33630,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33731,Energy Efficiency,energy,energy,33731,"of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33743,Energy Efficiency,energy,energy,33743,"of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33879,Energy Efficiency,energy,energy,33879,"od from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33915,Energy Efficiency,energy,energy,33915,"od from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:34111,Energy Efficiency,energy,energy,34111,"e <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:34165,Energy Efficiency,energy,energy,34165,"e <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:34280,Energy Efficiency,energy,energy,34280,"e <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:34598,Energy Efficiency,energy,energy,34598,"c-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:34634,Energy Efficiency,energy,energy,34634,"c-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:35040,Energy Efficiency,energy,energy,35040,"TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:40839,Energy Efficiency,energy,energy,40839,"list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:41262,Energy Efficiency,energy,energy,41262,"p/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treat",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:43117,Energy Efficiency,energy,energy,43117,"['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treatment'] = ""corl""; metadata.append(stage). # ""method/basis"" syntax only allows for one delta correction; # via ""method/basis+D:delta/basis"". Maximum length of method_list is 2.; if len(method_list) == 2:; stage = {}; stage['wfn'] = method_list[1]; stage['basis'] = basis_list[1]; if 'delta_scheme' in kwargs:; stage['scheme'] = kwargs.pop('delta_scheme'); stage['stage'] = ""delta1""; stage['treatment'] = ""corl""; metadata.append(stage). cbs_kwargs[""cbs_metadata""] = metadata. return cbs_kwargs. def _build_cbs_compute(metameta: Dict[str, Any], metadata: CBSMetadata):; label = metameta['label']; ptype = metameta['ptype']; verbose = metameta['verbose']. # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n"". # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_alpha', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_dipole', 'd_dipder'; ]; GRAND_NEED = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf', metadata[0][""scheme""],; _contract_bracketed_basis(metadata[0][""basis""][0]), metadata[0][""wfn""], metadata[0][""alpha""], NEED, +1,; 0.0, None, None, None, None; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], delta[""alpha""], NEED, +1, 0.0,; None, None, None, None; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""]); GRAND_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:45920,Energy Efficiency,energy,energy,45920," JOBS = MODELCHEM[:]; listfmt = """""" {:>12} / {:24} for {}{}\n"""""". # TODO: In the ""naive"" and ""enlightened"" loops below, I had to remove condition `and (job['f_options'] is not False))`; # to get them working, and I feel like they were added to fix the same thing. someday, seek to understand. # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if ((job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']); and (job['f_options'] == mc['f_options'])):; dups += 1; if dups >= 1:; del JOBS[indx_job]. instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if ((VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]); and (mc['f_basis'] == job['f_basis']); and not (mc['f_wfn'] == job['f_wfn']); and (mc['f_options'] == job['f_options'])):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Expand listings to all that will be obtained; TROVE = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; TROVE.append(dict(zip(_f_fields, [wfn, job['f_basis'], job['f_zeta'], job['f_options'], 0.0, None, None, None, None]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in TROVE:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]); if verbose:; core.print_out(instructions); logger.info(instructions). r",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:50317,Energy Efficiency,energy,energy,50317," * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tables += delimit. required = []; finalenergy = 0.0; for stage in GRAND_NEED:; finalenergy += stage['d_energy'] * stage['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]', 'Variable'); tables += delimit; for job in TROVE:; star = ''; for mc in required:; if (job['f_wfn'], job['f_basis'], job['f_options']) == mc:; star = '*'; tables += linefmt.format('', job['",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:50406,Energy Efficiency,energy,energy,50406," * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tables += delimit. required = []; finalenergy = 0.0; for stage in GRAND_NEED:; finalenergy += stage['d_energy'] * stage['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]', 'Variable'); tables += delimit; for job in TROVE:; star = ''; for mc in required:; if (job['f_wfn'], job['f_basis'], job['f_options']) == mc:; star = '*'; tables += linefmt.format('', job['",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:56086,Energy Efficiency,energy,energy,56086,": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRA",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:56705,Energy Efficiency,energy,energy,56705,"s); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:57412,Energy Efficiency,energy,energy,57412,"; modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_r",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:58673,Energy Efficiency,energy,energy,58673,"y data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:61379,Energy Efficiency,energy,energy,61379,"deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_cbs. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursd",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:31084,Integrability,interface,interface,31084,"_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculatin",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:31261,Integrability,interface,interface,31261,"r| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise no",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:36271,Integrability,depend,dependent,36271,"cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); # exec(commands); #; # psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). def _expand_scheme_orders(scheme: str, basisname: List[str], basiszeta: List[int], wfnname: str, options: Dict) -> Dict[str, Dict[str, Any]]:; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). try:; scheme.split(); except AttributeError:; raise UpgradeHelper(scheme, repr(scheme.__name__), 1.6, ' Replace extrapolation function with funct",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:39214,Integrability,wrap,wrapper,39214,"len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. def _parse_cbs_gufunc_string(method_name: str):; """""" A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:41563,Integrability,wrap,wrapper,41563,"None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treatment'] = ""corl""; metadata.append(stage). # ""method/basis"" syntax only allows for one delta correction; # via ""method/basis+D:delta/basis"". Maximum length of method_list is 2.; if len(method_list) == 2:; stage = {}; stage['wfn'] = method_list[1]; stage['basis'] = basis_list[1]; if 'delta_scheme' in kwargs:; sta",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:60859,Integrability,interface,interface,60859,"essian""] = H0. D0 = assembled_results[""dipole""]; if D0 is not None:; qcvars[""CURRENT DIPOLE""] = D0; qcvars[""CBS DIPOLE""] = D0. DD0 = assembled_results[""dipole gradient""]; if DD0 is not None:; qcvars[""CURRENT DIPOLE GRADIENT""] = DD0; qcvars[""CBS DIPOLE GRADIENT""] = DD0. cbs_model = AtomicResult(; **{; 'driver': self.driver,; #'keywords': self.keywords,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:22169,Modifiability,variab,variables,22169," stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:24098,Performance,perform,performed,24098,"t. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:30890,Performance,perform,performed,30890,"bs_helper.xtpl_highest_1` and :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```:",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:35514,Performance,optimiz,optimize,35514," atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:35535,Performance,optimiz,optimize,35535," atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:36038,Performance,optimiz,optimize,36038,", and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); # exec(commands); #; # psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). def _expand_scheme_orders(scheme: str, basisname: List[str], basiszeta: List[int], wfnname: str, options: Dict) -> Dict[str, Dict[str, Any]]:; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszet",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:56491,Performance,load,load,56491,"= self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); an",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:58685,Performance,load,load,58685,"(mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CB",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:3024,Safety,redund,redundant,3024,"rmat (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:41181,Safety,detect,detected,41181,"and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis']",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:44441,Safety,redund,redundant,44441,"tadata[0][""alpha""], NEED, +1,; 0.0, None, None, None, None; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], delta[""alpha""], NEED, +1, 0.0,; None, None, None, None; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis_lo""][0]), delta[""wfn_lo""], delta[""alpha""], NEED, -1,; 0.0, None, None, None, None; ]))). # MODELCHEM is unordered, possibly redundant list of single result *entries* needed to satisfy full CBS; # JOBS is subset of MODELCHEM with minimal list of single result *jobs* needed to satisfy full CBS; # TROVE is superset of JOBS with maximal list of single result *entries* resulting from JOBS; # ""entry"" here is a mtd-bas-opt spec that can support E/G/H data; # ""job"" here is an entry on which to sic Psi4 that, through VARH, may fill in multiple entries. MODELCHEM = []; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; MODELCHEM.append(lvl). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]; listfmt = """""" {:>12} / {:24} for {}{}\n"""""". # TODO: In the ""naive"" and ""enlightened"" loops below, I had to remove condition `and (job['f_options'] is not False))`; # to get them working, and I feel like they were added to fix the same thing. someday, seek to understand. # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if ((job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']); and (job['f_options'] == mc['f_options'])):; dups += 1; if dups >= 1:; del JOBS[indx_job]. instructions += """""" N",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:56233,Safety,avoid,avoid,56233,"elf, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars'",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:2300,Security,validat,validate,2300,"ashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:4981,Security,validat,validator,4981,"----------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder'",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:5041,Security,validat,validator,5041,"----------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder'",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:6636,Security,validat,validate,6636,"portal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule; This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Returns; -------; tuple; Tuple in the ``([basis set names], [basis set zetas])`` format. """"""; BSET = []; ZSET = []; legit_compo",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:17158,Security,validat,validates,17158,"ine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:17533,Security,validat,validation,17533,"pl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xt",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:19885,Security,validat,validation,19885,"e[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = f""delta{len(metadata) - 1}""; stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:20091,Security,validat,validation,20091," stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis""",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:20245,Security,validat,validate,20245,"n(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwarg",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:53576,Security,validat,validator,53576,"t.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. [docs]; class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cbsrec: List[Dict[str, Any]] = []. # Maximal list of model chemistries extractable from running `compute_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:4807,Testability,log,logging,4807,"h job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:5627,Testability,log,logger,5627,"------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:5636,Testability,log,logging,5636,"------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:47012,Testability,log,logger,47012," enumerate(JOBS):; if ((VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]); and (mc['f_basis'] == job['f_basis']); and not (mc['f_wfn'] == job['f_wfn']); and (mc['f_options'] == job['f_options'])):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Expand listings to all that will be obtained; TROVE = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; TROVE.append(dict(zip(_f_fields, [wfn, job['f_basis'], job['f_zeta'], job['f_options'], 0.0, None, None, None, None]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in TROVE:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]); if verbose:; core.print_out(instructions); logger.info(instructions). return GRAND_NEED, JOBS, TROVE. def _assemble_cbs_components(metameta, TROVE, GRAND_NEED):; """"""Absorb job E/G/H results from `TROVE` into `GRAND_NEED`. Process; those into stage E/G/H in `GRAND_NEED`, returning the latter.; Accumulate into final E/G/H quantities, returning them in dict. """"""; label = metameta['label']; nat = metameta['molecule'].natom(); ptype = metameta['ptype']; verbose = metameta['verbose']. # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions); logger.info(instructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; for job in TROVE:; # Don't ask; if (((lvl['f_wfn'] == job['f_wfn']) or; ((lvl['f_wfn'][3:] == job['f_wfn']) and lvl['f_wfn'].startswith('c4-')) or; ((lvl['f_wfn'] == job['f_wfn'][3:]) and job['f_wfn'].startswith('c4",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:47627,Testability,log,logger,47627,"wfn, job['f_basis'], job['f_zeta'], job['f_options'], 0.0, None, None, None, None]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in TROVE:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]); if verbose:; core.print_out(instructions); logger.info(instructions). return GRAND_NEED, JOBS, TROVE. def _assemble_cbs_components(metameta, TROVE, GRAND_NEED):; """"""Absorb job E/G/H results from `TROVE` into `GRAND_NEED`. Process; those into stage E/G/H in `GRAND_NEED`, returning the latter.; Accumulate into final E/G/H quantities, returning them in dict. """"""; label = metameta['label']; nat = metameta['molecule'].natom(); ptype = metameta['ptype']; verbose = metameta['verbose']. # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions); logger.info(instructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; for job in TROVE:; # Don't ask; if (((lvl['f_wfn'] == job['f_wfn']) or; ((lvl['f_wfn'][3:] == job['f_wfn']) and lvl['f_wfn'].startswith('c4-')) or; ((lvl['f_wfn'] == job['f_wfn'][3:]) and job['f_wfn'].startswith('c4-')) or; (('c4-' + lvl['f_wfn']) == job['f_wfn']) or (lvl['f_wfn'] == ('c4-' + job['f_wfn']))); and (lvl['f_basis'] == job['f_basis']) and (lvl['f_options'] == job['f_options'])):; lvl['f_energy'] = job['f_energy']; lvl['f_gradient'] = job['f_gradient']; lvl['f_hessian'] = job['f_hessian']; lvl['f_dipole'] = job['f_dipole']; lvl['f_dipder'] = job['f_dipder']. # Make xtpl() call; finalenergy = 0.0; finalgradient = None; finalhessian = None; finaldipole = None; finaldipder = None. for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha'], 'verbose': verbose}. grad_available = all([lmh['f_gradient'] is no",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:53989,Testability,log,logger,53989,"nstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cbsrec: List[Dict[str, Any]] = []. # Maximal list of model chemistries extractable from running `compute_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""]",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:55235,Testability,log,logger,55235,"%; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:55688,Testability,log,logger,55688,"o""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; res",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:58008,Testability,log,logger,58008,"ENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CB",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:58241,Testability,log,logger,58241,"POLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0.",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:58270,Testability,log,logger,58270,"; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:58329,Testability,log,logger,58329,"T DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:60489,Testability,log,logger,60489,"""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CBS TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. D0 = assembled_results[""dipole""]; if D0 is not None:; qcvars[""CURRENT DIPOLE""] = D0; qcvars[""CBS DIPOLE""] = D0. DD0 = assembled_results[""dipole gradient""]; if DD0 is not None:; qcvars[""CURRENT DIPOLE GRADIENT""] = DD0; qcvars[""CBS DIPOLE GRADIENT""] = DD0. cbs_model = AtomicResult(; **{; 'driver': self.driver,; #'keywords': self.keywords,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result)",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:1724,Usability,simpl,simple,1724,"thout even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain composite method, basis, & options treatments. ========; CBS Flow; ========; Bullet points are major actions; Lines of dashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _con",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33391,Usability,simpl,simple,33391,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:33549,Usability,simpl,simple,33549,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:40127,Usability,simpl,simple,40127,"onError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; i",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html:61155,Usability,simpl,simple,61155," 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].ite",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:22256,Deployability,configurat,configuration,22256,"""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:22638,Deployability,update,updated,22638,"""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:2385,Energy Efficiency,energy,energy,2385,"_). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]; def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:4416,Energy Efficiency,energy,energy,4416,"ing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.uppe",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:6734,Energy Efficiency,power,power,6734," % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; --",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:8272,Energy Efficiency,power,power,8272,"larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:9134,Energy Efficiency,power,power,9134,"alueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:9955,Energy Efficiency,power,power,9955,"n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. Refe",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:11721,Energy Efficiency,power,power,11721,"s; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_karton_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 6.30. # prior to April 2022, this wrong expression was used; # beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_division = 1 / (math.exp(-1 * alpha * math.sqrt(zHI)) - math.exp(-1 * alpha * math.sqrt(zLO))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cb",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:12582,Energy Efficiency,power,power,12582,"valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CB",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:14704,Energy Efficiency,energy,energy,14704,"the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" B",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:16596,Energy Efficiency,power,power,16596,"scheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]; def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:18753,Energy Efficiency,energy,energy,18753,"ionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:19767,Energy Efficiency,energy,energy-only,19767,"l_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:17186,Integrability,rout,routines,17186,"ay):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]; def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; ext",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:22304,Integrability,wrap,wrapper,22304,"""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:22256,Modifiability,config,configuration,22256,"""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:1138,Testability,log,logging,1138,"river.driver_cbs_helper; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import logging; import math; from typing import Callable, Optional, Union. import numpy as np. from psi4 import core. from .aliases import allen_focal_point, sherrill_gold_standard; from .constants import nppp; from .p4util.exceptions import ValidationError. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equa",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:1390,Testability,log,logger,1390,"the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import logging; import math; from typing import Callable, Optional, Union. import numpy as np. from psi4 import core. from .aliases import allen_focal_point, sherrill_gold_standard; from .constants import nppp; from .p4util.exceptions import ValidationError. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs',",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:1399,Testability,log,logging,1399,"the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import logging; import math; from typing import Callable, Optional, Union. import numpy as np. from psi4 import core. from .aliases import allen_focal_point, sherrill_gold_standard; from .constants import nppp; from .p4util.exceptions import ValidationError. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs',",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:2730,Testability,log,logger,2730,"th a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]; def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valu",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:2985,Testability,log,logger,2985,"alueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]; def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ~numpy.ndarray; Epo",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:5695,Testability,log,logger,5695,"pha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Ex",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:6374,Testability,log,logger,6374,"a (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :mat",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:8920,Testability,log,logger,8920,"I)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolata",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:9592,Testability,log,logger,9592,""""""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:12369,Testability,log,logger,12369,"/ (math.exp(-1 * alpha * math.sqrt(zHI)) - math.exp(-1 * alpha * math.sqrt(zLO))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Opt",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:13040,Testability,log,logger,13040," """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:15113,Testability,log,log,15113," in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). r",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:16111,Testability,log,logger,16111,"-1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:16347,Testability,log,log,16347,"Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationEr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:17133,Testability,log,logger,17133,"bsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]; def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:20124,Testability,log,logger,20124,"zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_tr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:20863,Testability,log,logger,20863,"""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:3275,Availability,avail,available,3275," geometry by linear combination. * ... and collect geometry into a field of findifrec[""displacements""].<label>; * for (2, 0) also collect off-diagonal displacements; * also collect undisplaced geometry into field reference; * return findifrec. * form AtomicComputers for each displacement, particularly changing mol and driver, and possibly relaxing disp symm; * form dict task_list with keys findifrec labels and vals AtomicComputers. --------------------------------------; FiniteDifferenceComputer.build_tasks(); --------------------------------------; * pass. ----------------------------------; FiniteDifferenceComputer.compute(); ----------------------------------; * compute() for each job in task list. ------------------------------------------; FiniteDifferenceComputer.get_psi_results(); ------------------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields as available on each of reference and displacements entries. assemble_hessian_from_energies(); --------------------------------; assemble_hessian_from_gradients(); ---------------------------------. _process_hessian_symmetry_block(); ---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular);",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:3863,Availability,avail,available,3863,"te(); ----------------------------------; * compute() for each job in task list. ------------------------------------------; FiniteDifferenceComputer.get_psi_results(); ------------------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields as available on each of reference and displacements entries. assemble_hessian_from_energies(); --------------------------------; assemble_hessian_from_gradients(); ---------------------------------. _process_hessian_symmetry_block(); ---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:3977,Availability,avail,available,3977,"-----------------; FiniteDifferenceComputer.get_psi_results(); ------------------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields as available on each of reference and displacements entries. assemble_hessian_from_energies(); --------------------------------; assemble_hessian_from_gradients(); ---------------------------------. _process_hessian_symmetry_block(); ---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:6201,Availability,error,error,6201,"def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can handle; # an arbitrary number of SALCs.; for salc_index, disp_steps in i_m:; # * Python error if iterate through `salc_list`; for i in range(len(salc_list[salc_index])):; component = salc_list[salc_index][i]; disp_geom[component.atom, component.xyz] += disp_steps * step_size * component.coef / np.sqrt(mass[component.atom]); label.append(f""{salc_index}: {disp_steps}""). # salc_index is in descending order. We want the label in ascending order, so...; # ...add the new label part from the left of the string, not the right.; label = ', '.join(reversed(label)); return disp_geom, label. def _initialize_findif(mol: Union[""qcdb.Molecule"", core.Molecule],; freq_irrep_only: int,; mode: str,; stencil_size: int,; step_size: float,; initialize_string: Callable,; t_project: bool,; r_project: bool,; initialize: bool,; verbose: int = 0) -> Dict:; """"""Perform initialization tasks needed by all primary functions. Parameters; ----------; mol; The molecule to displace; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps.; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the derivative level d",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:10363,Availability,error,error,10363,"ements are the same for both.; pts_dict = {; 3: {; ""sym_irr"": ((-1, ), (1, )),; ""asym_irr"": ((-1, ), ),; ""off"": ((1, 1), (-1, -1)); },; 5: {; ""sym_irr"": ((-2, ), (-1, ), (1, ), (2, )),; ""asym_irr"": ((-2, ), (-1, )),; ""off"": ((-1, -2), (-2, -1), (-1, -1), (1, -1), (-1, 1), (1, 1), (2, 1), (1, 2)); }; }. try:; disps = pts_dict[stencil_size]; except KeyError:; raise ValidationError(f""FINDIF: Number of points ({stencil_size}) not among {pts_dict.keys()}!""). # Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.; salc_indices_pi = [[] for h in range(n_irrep)]. # Validate that we have an irrep matching the user-specified irrep, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if i",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:13694,Availability,avail,available,13694," instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec; Dictionary of finite difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time of writing. An example; is giving a displacement its own step dict.). step : dict; A descriptor for the finite difference step.; In future, this can be overriden by step fields for individual displacements. units : {'Bohr'}; The units for the displacement. The code currently assumes ""bohr,"" per MolSSI standards.; size : float; The step size for the displacement. stencil_size : {3, 5}; Number of points to evaluate at for each displacement basis vector. Count; includes the central reference point. displacement_space : {'CdSalc'}; A string specifying the vector space in which displacements are performed.; Currently, only CdSalc is supported. project_translations : bool; Whether translations are to be projected out of the displacements. project_rotations : bool; Whether rotations are to be pro",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:13797,Availability,avail,available,13797,"ies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec; Dictionary of finite difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time of writing. An example; is giving a displacement its own step dict.). step : dict; A descriptor for the finite difference step.; In future, this can be overriden by step fields for individual displacements. units : {'Bohr'}; The units for the displacement. The code currently assumes ""bohr,"" per MolSSI standards.; size : float; The step size for the displacement. stencil_size : {3, 5}; Number of points to evaluate at for each displacement basis vector. Count; includes the central reference point. displacement_space : {'CdSalc'}; A string specifying the vector space in which displacements are performed.; Currently, only CdSalc is supported. project_translations : bool; Whether translations are to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; htt",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:21973,Availability,error,error,21973,"ations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:23967,Availability,error,errors,23967,"-----\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symmetry_block(H_block: np.ndarray, B_block: np.ndarray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:49578,Availability,error,error,49578,"ec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to construct reference gradient from Hessian displacements.""); # TODO: this happens properly when the requested symmetry block; # of displacements don't have the totally symmetric displacements; # needed for gradient. For both this case; # and distributed computing are-we-there-yet? queries,; # should have a probe as to whether all the; # findif[displacement] labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:12131,Deployability,update,update,12131,"ep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Union[""qcdb.Molecule"", core.Molecule], freq_irrep_only: int, mode: str, *, t_project: bool = True, r_project: bool = True, stencil_size: int = 3, step_size: float = 0.005) -> Dict:; """"""; Generate geometries for the specified molecule and derivative levels.; You probably want to instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:45740,Deployability,update,update,45740,"ts""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:55123,Deployability,update,updated,55123," else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()),; filename,; dtype='GRD',; mol=wfn.molecule(),; energy=wfn.energy()). def _rms(arr: Union[core.Matrix, np.ndarray]) -> float:; """"""Compute root-mean-square of array, be it Psi4 or NumPy array.""""""; if isinstance(arr, np.ndarray):; return np.sqrt(np.mean(np.square(arr))); else:; return arr.rms(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_findif. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:1349,Energy Efficiency,energy,energy,1349,"he copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain derivatives by finite difference of lesser derivatives. ===========; FINDIF Flow; ===========; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. -----------------------------------; FiniteDifferenceComputer.__init__(); -----------------------------------; * collect findif_stencil_size, findif_step_size from initializer kwargs; * BaseComputer.__init__(); * negotiate safety and user wishes on translation and rotation projection. gradient_from_energies_geometries(); -----------------------------------; hessian_from_gradients_geometries(); -----------------------------------; hessian_from_energies_geometries(); ----------------------------------. _geom_generator(); -----------------. _initialize_findif(); --------------------; * initialize CdSalcs, partition them per irrep, apply user irreps. * start the governing dict findifrec with parameters, size, mol; * for each irrep, for each relevant salc ... _displace_cart(); ----------------; * form new geometry by linear combination. * ... and collect geometry into a field of findifrec[""d",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:15561,Energy Efficiency,energy,energy,15561," to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:15603,Energy Efficiency,energy,energy,15603," to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:15693,Energy Efficiency,energy,energy,15693,"ed out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will be {data[""step_size""]:6.2e}.\n"""""". # Genuine support for qcdb molecules would be nice. But that requires ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:20718,Energy Efficiency,energy,energy,20718,"r a gradient by finite difference of energies."" + _der_from_lesser_docstring; hessian_from_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessian_from_energies_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of energies."" + _der_from_lesser_docstring. def assemble_gradient_from_energies(findifrec: Dict) -> np.ndarray:; """"""Compute the gradient by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring. Returns; -------; gradient; (nat, 3) Cartesian gradient [Eh/a0].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). def init_string(data):; return f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # P",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:20812,Energy Efficiency,adapt,adapted,20812,"rom_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessian_from_energies_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of energies."" + _der_from_lesser_docstring. def assemble_gradient_from_energies(findifrec: Dict) -> np.ndarray:; """"""Compute the gradient by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring. Returns; -------; gradient; (nat, 3) Cartesian gradient [Eh/a0].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). def init_string(data):; return f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:21598,Energy Efficiency,energy,energy,21598,"eturn f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logg",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:21683,Energy Efficiency,energy,energy,21683,"eturn f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logg",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:24131,Energy Efficiency,adapt,adapted,24131,"darray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cart",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:30477,Energy Efficiency,adapt,adapted,30477,"dot(dipder_q.T, B); dipder_cart = dipder_cart.T.reshape(data[""n_atom""], 9). massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); dipder_cart = (dipder_cart.T * massweighter).T. dipder_cart = dipder_cart.reshape(3 * data[""n_atom""], 3); return dipder_cart. def assemble_hessian_from_gradients(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of gradients. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2]; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]. def init_string(data):; return ("" Computing second-derivative from gradients using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} gradients passed in, including the reference geometry.\n"".format(len(displacements) + 1)). data = _initialize_findif(mol, freq_irrep_only, ""2_1"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). # For non-totally symmetric CdSALCs, a symmetry operation can convert + and - displacements.; # Good News: By taking advantage of that, we (potentially) ran less computations.; # Bad News: We need to find the - displacements from the + computations now.; # The next ~80 lines of code are dedicated to that task.; if data[""print_lvl""]:; core.print_out("" Generating complete list of displacements from unique ones.\n\n""). pg = mol.point_group(); ct = pg.char_table(); order = pg.order(). # Determine what atoms map to what other atoms under the point group operations.; # The py-side compute_atom_map will work whether mol is a ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:36851,Energy Efficiency,energy,energy,36851,"* grads_adapted[1::4] + 8 * grads_adapted[2::4] -; grads_adapted[3::4]) / (12.0 * findifrec[""step""][""size""]). H_pi[-1] = _process_hessian_symmetry_block(H_pi[-1], B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""]). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). def assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irre",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:37106,Energy Efficiency,energy,energy,37106,"ef assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:37202,Energy Efficiency,adapt,adapted,37202,"ef assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:38324,Energy Efficiency,energy,energy,38324,"ithout displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal e",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:38395,Energy Efficiency,energy,energy,38395,"ithout displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal e",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:38417,Energy Efficiency,energy,energy,38417,"ithout displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal e",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:38565,Energy Efficiency,energy,energy,38565,"frec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:38696,Energy Efficiency,energy,energy,38696,"frec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:39375,Energy Efficiency,energy,energy,39375,"disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_en = lambda index: displacements[""{l}: {}, {k}: {}"".format(; k=salc, l=salc2, *data[""disps""][""off""][index])][""energy""]; if findifrec[""stencil_size""] == 3:; fc = (+offdiag_en(0) + offdiag_en(1) + 2 * ref_energy - E[i][0] - E[i][1] - E[j][0] -; E[j][1]) / (2 * findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1],",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:39705,Energy Efficiency,energy,energy,39705,"s = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_en = lambda index: displacements[""{l}: {}, {k}: {}"".format(; k=salc, l=salc2, *data[""disps""][""off""][index])][""energy""]; if findifrec[""stencil_size""] == 3:; fc = (+offdiag_en(0) + offdiag_en(1) + 2 * ref_energy - E[i][0] - E[i][1] - E[j][0] -; E[j][1]) / (2 * findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:40852,Energy Efficiency,energy,energy,40852,"difrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.ge",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:43262,Energy Efficiency,energy,energy,43262,"ions_projection_sound_grad = translations_projection_sound; rotations_projection_sound_hess = translations_projection_sound and stationary_point; if core.has_option_changed('FINDIF', 'FD_PROJECT'):; r_project_grad = core.get_option('FINDIF', 'FD_PROJECT'); r_project_hess = core.get_option('FINDIF', 'FD_PROJECT'); else:; r_project_grad = rotations_projection_sound_grad; r_project_hess = rotations_projection_sound_hess. for kwg in ['dft_functional']:; if kwg in data:; data['keywords']['function_kwargs'][kwg] = data.pop(kwg); # I have the feeling the keywords.function_kwargs should be all left over in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info)",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:43865,Energy Efficiency,energy,energy,43865,"in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:46026,Energy Efficiency,energy,energy,46026,"s on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47072,Energy Efficiency,energy,energy,47072,"bitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hes",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47093,Energy Efficiency,energy,energy,47093,"bitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hes",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47192,Energy Efficiency,energy,energy,47192,"nently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENER",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47320,Energy Efficiency,energy,energy,47320,"[docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if '",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47857,Energy Efficiency,energy,energy,47857,"ference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47881,Energy Efficiency,energy,energy,47881,"ference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47986,Energy Efficiency,energy,energy,47986," response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif s",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:48120,Energy Efficiency,energy,energy,48120,"'energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:49515,Energy Efficiency,energy,energy-or-gradient,49515,"ormulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to construct reference gradient from Hessian displacements.""); # TODO: this happens properly when the requested symmetry block; # of displacements don't have the totally symmetric displacements; # needed for gradient. For both this case; # and distributed computing are-we-there-yet? queries,; # should have a probe as to whether all the; # findif[displacement] labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:50565,Energy Efficiency,energy,energy,50565,"ot sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn an",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:51507,Energy Efficiency,energy,energy,51507,"ndifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ---------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:53495,Energy Efficiency,energy,energy,53495," in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:54688,Energy Efficiency,energy,energy,54688," else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()),; filename,; dtype='GRD',; mol=wfn.molecule(),; energy=wfn.energy()). def _rms(arr: Union[core.Matrix, np.ndarray]) -> float:; """"""Compute root-mean-square of array, be it Psi4 or NumPy array.""""""; if isinstance(arr, np.ndarray):; return np.sqrt(np.mean(np.square(arr))); else:; return arr.rms(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_findif. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:54699,Energy Efficiency,energy,energy,54699," else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()),; filename,; dtype='GRD',; mol=wfn.molecule(),; energy=wfn.energy()). def _rms(arr: Union[core.Matrix, np.ndarray]) -> float:; """"""Compute root-mean-square of array, be it Psi4 or NumPy array.""""""; if isinstance(arr, np.ndarray):; return np.sqrt(np.mean(np.square(arr))); else:; return arr.rms(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_findif. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:7609,Integrability,depend,dependent,7609,"e string, not the right.; label = ', '.join(reversed(label)); return disp_geom, label. def _initialize_findif(mol: Union[""qcdb.Molecule"", core.Molecule],; freq_irrep_only: int,; mode: str,; stencil_size: int,; step_size: float,; initialize_string: Callable,; t_project: bool,; r_project: bool,; initialize: bool,; verbose: int = 0) -> Dict:; """"""Perform initialization tasks needed by all primary functions. Parameters; ----------; mol; The molecule to displace; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps.; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the derivative level determined from; displacements, and the second number is the level determined at.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; [a0]; initialize_string; A function that returns the string to print to show the caller was entered.; The string is both caller-specific and dependent on values determined; in this function.; initialize; For printing, whether call is from generator or assembly stages.; verbose; Set to 0 to silence extra print information, regardless of the print level.; Used so the information is printed only during geometry generation, and not; during the derivative computation as well. Returns; -------; data; Miscellaneous information required by callers.; """""". info = """"""; ----------------------------------------------------------; FINDIF; R. A. King and Jonathon Misiewicz; ----------------------------------------------------------. """"""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option r",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:52493,Integrability,interface,interface,52493,"TAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavo",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:5113,Modifiability,variab,variable,5113,"_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:5176,Modifiability,variab,variable,5176," and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can handle; # an arbitrary number of SALCs.; for salc_index, disp_steps in",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:20812,Modifiability,adapt,adapted,20812,"rom_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessian_from_energies_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of energies."" + _der_from_lesser_docstring. def assemble_gradient_from_energies(findifrec: Dict) -> np.ndarray:; """"""Compute the gradient by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring. Returns; -------; gradient; (nat, 3) Cartesian gradient [Eh/a0].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). def init_string(data):; return f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:24131,Modifiability,adapt,adapted,24131,"darray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cart",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:30477,Modifiability,adapt,adapted,30477,"dot(dipder_q.T, B); dipder_cart = dipder_cart.T.reshape(data[""n_atom""], 9). massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); dipder_cart = (dipder_cart.T * massweighter).T. dipder_cart = dipder_cart.reshape(3 * data[""n_atom""], 3); return dipder_cart. def assemble_hessian_from_gradients(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of gradients. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2]; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]. def init_string(data):; return ("" Computing second-derivative from gradients using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} gradients passed in, including the reference geometry.\n"".format(len(displacements) + 1)). data = _initialize_findif(mol, freq_irrep_only, ""2_1"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). # For non-totally symmetric CdSALCs, a symmetry operation can convert + and - displacements.; # Good News: By taking advantage of that, we (potentially) ran less computations.; # Bad News: We need to find the - displacements from the + computations now.; # The next ~80 lines of code are dedicated to that task.; if data[""print_lvl""]:; core.print_out("" Generating complete list of displacements from unique ones.\n\n""). pg = mol.point_group(); ct = pg.char_table(); order = pg.order(). # Determine what atoms map to what other atoms under the point group operations.; # The py-side compute_atom_map will work whether mol is a ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:37202,Modifiability,adapt,adapted,37202,"ef assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:44275,Modifiability,variab,variables,44275,"_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:12899,Performance,perform,perform,12899,"ements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Union[""qcdb.Molecule"", core.Molecule], freq_irrep_only: int, mode: str, *, t_project: bool = True, r_project: bool = True, stencil_size: int = 3, step_size: float = 0.005) -> Dict:; """"""; Generate geometries for the specified molecule and derivative levels.; You probably want to instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec; Dictionary of finite difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:14491,Performance,perform,performed,14491,"e difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time of writing. An example; is giving a displacement its own step dict.). step : dict; A descriptor for the finite difference step.; In future, this can be overriden by step fields for individual displacements. units : {'Bohr'}; The units for the displacement. The code currently assumes ""bohr,"" per MolSSI standards.; size : float; The step size for the displacement. stencil_size : {3, 5}; Number of points to evaluate at for each displacement basis vector. Count; includes the central reference point. displacement_space : {'CdSalc'}; A string specifying the vector space in which displacements are performed.; Currently, only CdSalc is supported. project_translations : bool; Whether translations are to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molec",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:18948,Performance,perform,perform,18948,"ogger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec : dict; Dictionary of finite difference data, specified in _geom_generator docstring. """""". gradient_from_energies_geometries = partial(_geom_generator, freq_irrep_only=-1, mode=""1_0""); hessian_from_gradients_geometries = partial(_geom_generator, mode=""2_1""); hessian_from_energies_geometries = partial(_geom_generator, mode=""2_0""). gradient_from_energies_geometries.__doc__ = ""Generate geometries for a gradient by finite difference of energies."" + _der_from_lesser_docstring; hessian_from_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:25618,Performance,perform,perform,25618,"_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cartesians.; Each is (nsalc_in_irrep, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; print_lvl; The level of printing information requested by the user. Returns; -------; Hx; The Hessian in non-mass weighted cartesians.; """""". # Handle empty case (atom); if not H_blocks and not B_blocks:; nat3 = massweighter.size; return np.zeros((nat3, nat3), dtype=np.float64). # We have the Hessian in each irrep! The final task is to perform coordinate transforms.; H = p4util.block_diagonal_array(*H_blocks); B = np.vstack(B_blocks). if print_lvl >= 3:; core.print_out(""\n Force constant matrix for all computed irreps in mass-weighted SALCS.\n""); core.print_out(""\n{}\n"".format(nppp10(H))). # Transform the massweighted Hessian from the CdSalc basis to Cartesians.; # The Hessian is the matrix not of a linear transformation, but of a (symmetric) bilinear form; # As such, the change of basis is formula A' = Xt A X, no inverses!; # More conceptually, it's A'_kl = A_ij X_ik X_jl; Each index transforms linearly.; Hx = np.dot(np.dot(B.T, H), B); if print_lvl >= 3:; core.print_out(""\n Force constants in mass-weighted Cartesian coordinates.\n""); core.print_out(""\n{}\n"".format(nppp10(Hx))). # Un-massweight the Hessian.; Hx = np.transpose(Hx / massweighter) / massweighter. if print_lvl >= 3:; core.print_out(""\n Force constants in Cartesian coordinates.\n""); core.print_out(""\n{}\n"".format(nppp10(Hx))). if print_lvl:",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:46828,Performance,load,load,46828,"st[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:47651,Performance,load,load,47651," Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:48443,Performance,load,load,48443,".extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to construct reference gradient from Hessian displacements.""); # TODO: this happens properly when the requested symmetry block; # of displacements don't have the totally symmetric displacements; # needed for gradient. For both this case; # and distributed computing are-we-there-yet? queries,; # should have a probe as to whether all the; # findif[displacemen",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:50431,Performance,load,load,50431,"labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if i",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:1644,Safety,safe,safety,1644,"the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain derivatives by finite difference of lesser derivatives. ===========; FINDIF Flow; ===========; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. -----------------------------------; FiniteDifferenceComputer.__init__(); -----------------------------------; * collect findif_stencil_size, findif_step_size from initializer kwargs; * BaseComputer.__init__(); * negotiate safety and user wishes on translation and rotation projection. gradient_from_energies_geometries(); -----------------------------------; hessian_from_gradients_geometries(); -----------------------------------; hessian_from_energies_geometries(); ----------------------------------. _geom_generator(); -----------------. _initialize_findif(); --------------------; * initialize CdSalcs, partition them per irrep, apply user irreps. * start the governing dict findifrec with parameters, size, mol; * for each irrep, for each relevant salc ... _displace_cart(); ----------------; * form new geometry by linear combination. * ... and collect geometry into a field of findifrec[""displacements""].<label>; * for (2, 0) also collect off-diagonal displacements; * also collect undisplaced geometry into field reference; * return findifrec. * form AtomicComputers for each displacement, particularly changing mol and driver, and possibly relaxing disp symm; * form dict task_list with keys findifrec labels and vals AtomicComput",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:11525,Safety,safe,safe,11525,"n(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Unio",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:42244,Safety,safe,safe,42244,"ude; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary point.""""""); stationary_criterion = 1.e-2 # pulled out of a hat; stationary_point = _rms(data['ref_gradient']) < stationary_criterion; else:; stationary_point = False # unknown, so F to be safe; rotations_projection_sound_grad = translations_projection_sound; rotations_projection_sound_hess = translations_projection_sound and stationary_point; if core.has_option_changed('FINDIF', 'FD_PROJECT'):; r_project_grad = core.get_option('FINDIF', 'FD_PROJECT'); r_project_hess = core.get_option('FINDIF', 'FD_PROJECT'); else:; r_project_grad = rotations_projection_sound_grad; r_project_hess = rotations_projection_sound_hess. for kwg in ['dft_functional']:; if kwg in data:; data['keywords']['function_kwargs'][kwg] = data.pop(kwg); # I have the feeling the keywords.function_kwargs should be all left over in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_d",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:4642,Security,validat,validator,4642,"t_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:4702,Security,validat,validator,4702,"t_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:40793,Security,validat,validator,40793,"difrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.ge",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:41033,Security,validat,validator,41033,"ag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:4450,Testability,log,logging,4450,"---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:5036,Testability,log,logger,5036,"tras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.cop",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:5045,Testability,log,logging,5045,"tras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.cop",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:8239,Testability,log,logger,8239,"ative level determined from; displacements, and the second number is the level determined at.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; [a0]; initialize_string; A function that returns the string to print to show the caller was entered.; The string is both caller-specific and dependent on values determined; in this function.; initialize; For printing, whether call is from generator or assembly stages.; verbose; Set to 0 to silence extra print information, regardless of the print level.; Used so the information is printed only during geometry generation, and not; during the derivative computation as well. Returns; -------; data; Miscellaneous information required by callers.; """""". info = """"""; ----------------------------------------------------------; FINDIF; R. A. King and Jonathon Misiewicz; ----------------------------------------------------------. """"""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option returns an int, but CdSalcList expect a bool, so re-cast; salc_list = core.CdSalcList(mol, method_allowed_irreps, t_project, r_project). n_atom = mol.natom(); n_irrep = salc_list.nirrep(); n_salc = salc_list.ncd(). if print_lvl and verbose:; info = f"" Number of atoms is {n_atom}.\n""; if method_allowed_irreps != 0x1:; info += f"" Number of irreps is {n_irrep}.\n""; info += "" Number of {!s}SALCs is {:d}.\n"".format("""" if method_allowed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Repla",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:8462,Testability,log,logger,8462,"step_size; [a0]; initialize_string; A function that returns the string to print to show the caller was entered.; The string is both caller-specific and dependent on values determined; in this function.; initialize; For printing, whether call is from generator or assembly stages.; verbose; Set to 0 to silence extra print information, regardless of the print level.; Used so the information is printed only during geometry generation, and not; during the derivative computation as well. Returns; -------; data; Miscellaneous information required by callers.; """""". info = """"""; ----------------------------------------------------------; FINDIF; R. A. King and Jonathon Misiewicz; ----------------------------------------------------------. """"""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option returns an int, but CdSalcList expect a bool, so re-cast; salc_list = core.CdSalcList(mol, method_allowed_irreps, t_project, r_project). n_atom = mol.natom(); n_irrep = salc_list.nirrep(); n_salc = salc_list.ncd(). if print_lvl and verbose:; info = f"" Number of atoms is {n_atom}.\n""; if method_allowed_irreps != 0x1:; info += f"" Number of irreps is {n_irrep}.\n""; info += "" Number of {!s}SALCs is {:d}.\n"".format("""" if method_allowed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Replace with a generator from a stencil to a set of points.; # Diagonal displacements differ between the totally symmetric irrep, compared to all others.; # Off-diagonal displacements are the same for both.; pts_dict = {; 3: {; ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:9202,Testability,log,logger,9202,"""""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option returns an int, but CdSalcList expect a bool, so re-cast; salc_list = core.CdSalcList(mol, method_allowed_irreps, t_project, r_project). n_atom = mol.natom(); n_irrep = salc_list.nirrep(); n_salc = salc_list.ncd(). if print_lvl and verbose:; info = f"" Number of atoms is {n_atom}.\n""; if method_allowed_irreps != 0x1:; info += f"" Number of irreps is {n_irrep}.\n""; info += "" Number of {!s}SALCs is {:d}.\n"".format("""" if method_allowed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Replace with a generator from a stencil to a set of points.; # Diagonal displacements differ between the totally symmetric irrep, compared to all others.; # Off-diagonal displacements are the same for both.; pts_dict = {; 3: {; ""sym_irr"": ((-1, ), (1, )),; ""asym_irr"": ((-1, ), ),; ""off"": ((1, 1), (-1, -1)); },; 5: {; ""sym_irr"": ((-2, ), (-1, ), (1, ), (2, )),; ""asym_irr"": ((-2, ), (-1, )),; ""off"": ((-1, -2), (-2, -1), (-1, -1), (1, -1), (-1, 1), (1, 1), (2, 1), (1, 2)); }; }. try:; disps = pts_dict[stencil_size]; except KeyError:; raise ValidationError(f""FINDIF: Number of points ({stencil_size}) not among {pts_dict.keys()}!""). # Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.; salc_indices_pi = [[] for h in range(n_irrep)]. # Validate that we have an irrep matching the user-specified irrep, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise Validat",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:11077,Testability,log,logger,11077,"p, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:12017,Testability,log,logger,12017,"n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Union[""qcdb.Molecule"", core.Molecule], freq_irrep_only: int, mode: str, *, t_project: bool = True, r_project: bool = True, stencil_size: int = 3, step_size: float = 0.005) -> Dict:; """"""; Generate geometries for the specified molecule and derivative levels.; You probably want to instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choos",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:17922,Testability,log,logger,17922,"_only, mode, stencil_size, step_size, init_string, t_project, r_project,; True, 1). # We can finally start generating displacements.; ref_geom = np.array(mol.geometry()). # Now we generate the metadata...; findifrec = {; ""step"": {; ""units"": ""bohr"",; ""size"": data[""step_size""]; },; ""stencil_size"": data[""stencil_size""],; ""displacement_space"": ""CdSALC"",; ""project_translations"": data[""project_translations""],; ""project_rotations"": data[""project_rotations""],; ""molecule"": mol.to_schema(dtype=2, units='Bohr'),; ""displacements"": {},; ""reference"": {}; }. def append_geoms(indices, steps):; """"""Given a list of indices and a list of steps to displace each, append the corresponding geometry to the list."""""". # Next, to make this salc/magnitude composite.; disp_geom, label = _displace_cart(findifrec['molecule']['masses'], ref_geom, data[""salc_list""],; zip(indices, steps), data[""step_size""]); if data[""print_lvl""] > 2:; info = ""\nDisplacement '{}'\n{}\n"".format(label, nppp10(disp_geom)); core.print_out(info); logger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:18629,Testability,log,logger,18629,"# Next, to make this salc/magnitude composite.; disp_geom, label = _displace_cart(findifrec['molecule']['masses'], ref_geom, data[""salc_list""],; zip(indices, steps), data[""step_size""]); if data[""print_lvl""] > 2:; info = ""\nDisplacement '{}'\n{}\n"".format(label, nppp10(disp_geom)); core.print_out(info); logger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec : dict; Dictionary of finite difference data, specified in _geom_generator docstring. """""". gradient_from_energies_geometries = partial(_geom_generator, freq_irrep_only=-1, mode=""1_0""); hessian_from_gradients_geometries = partial(_geom_generator, mode=""2_1""); hessian_from_energies_geometries = partial(_geom_generator, mod",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:18762,Testability,log,logger,18762,"lc_list""],; zip(indices, steps), data[""step_size""]); if data[""print_lvl""] > 2:; info = ""\nDisplacement '{}'\n{}\n"".format(label, nppp10(disp_geom)); core.print_out(info); logger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec : dict; Dictionary of finite difference data, specified in _geom_generator docstring. """""". gradient_from_energies_geometries = partial(_geom_generator, freq_irrep_only=-1, mode=""1_0""); hessian_from_gradients_geometries = partial(_geom_generator, mode=""2_1""); hessian_from_energies_geometries = partial(_geom_generator, mode=""2_0""). gradient_from_energies_geometries.__doc__ = ""Generate geometries for a gradient by finite difference of energies."" + _der_f",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:22564,Testability,log,logger,22564,"isplacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symmetry_block(H_block: np.ndarray, B_block: np.ndarray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massw",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:23005,Testability,log,logger,23005,"een caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symmetry_block(H_block: np.ndarray, B_block: np.ndarray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_bloc",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:41991,Testability,log,logger,41991,"tion ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary point.""""""); stationary_criterion = 1.e-2 # pulled out of a hat; stationary_point = _rms(data['ref_gradient']) < stationary_criterion; else:; stationary_point = False # unknown, so F to be safe; rotations_projection_sound_grad = translations_projection_sound; rotations_projection_sound_hess = translations_projection_sound and stationary_point; if core.has_option_changed('FINDIF', 'FD_PROJECT'):; r_project_grad = core.get_option('FINDIF', 'FD_PROJECT'); r_project_hess = core.get_option('FINDIF', 'FD_PROJECT'); else:; r_project_grad = rotations_projection_sound_grad; r_project_hess = rotations_projection_sound_hess. for kwg in ['dft_functional']:; if kwg in data:; data['keywords']['function_kwargs'][kwg] = data.pop(kwg); # I have the feeling the keywords.function_kwargs should be all left over in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMET",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:44237,Testability,log,logger,44237,"f.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_f",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:45153,Testability,log,logger,45153,"ents""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwa",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:46507,Testability,log,logger,46507,"lone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:52105,Testability,log,logger,52105,"nt'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(fi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:11132,Usability,clear,clear,11132,"ror, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:11282,Usability,clear,clear,11282,"salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:52747,Usability,simpl,simple,52747,"olecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:1210,Availability,error,error,1210,"ver.driver_nbody; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_dat",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:4732,Availability,avail,available,4732,"orm `mc_(frag, bas)`; * construct a molecule appropriately real/ghosted from active-fragment info in (frag, bas); * if embedding_charges active, prepare external_potentials array for atoms not in bas fragments; * for any new `mc_(frag, bas)` index, append a new computer to self.task_list. --------------------------; ManyBodyComputer.compute(); --------------------------; * compute() for each job in self.task_list. ----------------------------------; ManyBodyComputer.get_psi_results(); ----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * if multiple modelchems (multilevel):. multilevel.prepare_results(); ----------------------------; * from the pool of calcs, partition them by modelchem treatment and call _prepare_results on each subpool; * sums modelchem levels and returns small dict back to get_results(). * call get_results() for each job in task list; * assemble all the computed energies, all the computed gradients, and all the computed hessians; * for each available derivative, call:. assemble_nbody_components(); ---------------------------; * re-call build_nbody_compute_list to get the cp/nocp/vmfc lists again. build_nbody_compute_list(); --------------------------. * slice up the supersystem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs ac",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:6536,Availability,avail,available,6536,"ype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models imp",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:6653,Availability,avail,available,6653," treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .dri",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:10873,Availability,error,error,10873,"corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:30744,Availability,error,error,30744,"nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbo",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:45413,Availability,avail,available,45413,Y THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY | |em| 1 | when cp in bsse_type & rtd=T | best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for c,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:46833,Availability,avail,available,46833, | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY | |em| 1 | when cp in bsse_type | best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:49944,Availability,avail,available,49944,UGH 2-BODY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY | |em| 1 | when nocp in bsse_type | best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body tota,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:51379,Availability,avail,available,51379,1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY | |em| 1 | when nocp in bsse_type | best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less ({max_,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:54504,Availability,avail,available,54504,UGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY | |em| 1 | when vmfc in bsse_type | best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body tota,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:55940,Availability,avail,available,55940,| when vmfc in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY | |em| 1 | when vmfc in bsse_type | best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less ({max_,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:39031,Deployability,update,update,39031,"e_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87307,Deployability,update,update,87307,")},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was i",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87528,Deployability,update,update,87528,"dy_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.re",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87625,Deployability,update,update,87625,"d-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.return_energy. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:93689,Deployability,update,updated,93689,"described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix.from_array(ret); wfn.set_gradient(ret); elif self.driver == 'hessian':; ret = core.Matrix.from_array(ret); grad = core.Matrix.from_array(nbody_model.properties.return_gradient); wfn.set_hessian(ret); wfn.set_gradient(grad). if return_wfn:; return (ret, wfn); else:; return ret. # TODO questions to check:; # * can work with supersystem and embedding_charges?; # * can levels work with same method, different basis?. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:1362,Energy Efficiency,energy,energy,1362,"sponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment level",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:1733,Energy Efficiency,energy,energy,1733,"e implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ---------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:5852,Energy Efficiency,energy,energy,5852,"------; * re-call build_nbody_compute_list to get the cp/nocp/vmfc lists again. build_nbody_compute_list(); --------------------------. * slice up the supersystem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_resul",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:5888,Energy Efficiency,energy,energy,5888,"------; * re-call build_nbody_compute_list to get the cp/nocp/vmfc lists again. build_nbody_compute_list(); --------------------------. * slice up the supersystem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_resul",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:6000,Energy Efficiency,energy,energy,6000,"stem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:6525,Energy Efficiency,energy,energy,6525,"ype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models imp",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:7056,Energy Efficiency,energy,energy,7056,"ummed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, Fin",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:8158,Energy Efficiency,energy,energy,8158,"uter"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpois",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:8437,Energy Efficiency,energy,energy,8437,"tic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, can",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:9098,Energy Efficiency,energy,energy,9098,"iteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:9649,Energy Efficiency,energy,energy,9649,":`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of char",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:10609,Energy Efficiency,charge,charges,10609," |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem comput",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:10667,Energy Efficiency,charge,charges,10667,"/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:10719,Energy Efficiency,charge,charges,10719,"'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that in",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:10951,Energy Efficiency,energy,energy,10951,"data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atom",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:11532,Energy Efficiency,energy,energy,11532,"of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:12358,Energy Efficiency,energy,energy,12358,"y computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl) + ""_"" + str((frag, bas)). if ptype == ""energy"":; ret = 0.0. for frag, bas in compute_list:; ene = ptype_dict[labeler(frag, bas)]. if vmfc:; sign = ((-1)**(nb - len(frag))). ret += sign * ene. return ret. elif ptype == 'gradient':; ret = np.zeros((nat, 3)). for frag, bas in compute_list:; grad = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). start = 0; for ifr in bas:; end = start + fragment_size_dict[ifr]; ret[fragment_slice_dict[ifr]] += sign * grad[start:end]; start += fragment_size_dict[ifr]. return ret. elif ptype == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:12627,Energy Efficiency,energy,energy,12627,"rag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl) + ""_"" + str((frag, bas)). if ptype == ""energy"":; ret = 0.0. for frag, bas in compute_list:; ene = ptype_dict[labeler(frag, bas)]. if vmfc:; sign = ((-1)**(nb - len(frag))). ret += sign * ene. return ret. elif ptype == 'gradient':; ret = np.zeros((nat, 3)). for frag, bas in compute_list:; grad = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). start = 0; for ifr in bas:; end = start + fragment_size_dict[ifr]; ret[fragment_slice_dict[ifr]] += sign * grad[start:end]; start += fragment_size_dict[ifr]. return ret. elif ptype == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start and end slices; abs_start, rel_start = 0, 0; abs_slices, rel_slices = [], []; for ifr in bas:; rel_end = rel_start + 3 * fragment_size_dict[ifr]; rel_slices.append(slice(rel_start, rel_end)); rel_start += 3 * fragment_size_dict[ifr]. tmp_slice = fragment_slice_dict[ifr]; abs_slices.",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:13902,Energy Efficiency,energy,energy,13902,"ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). start = 0; for ifr in bas:; end = start + fragment_size_dict[ifr]; ret[fragment_slice_dict[ifr]] += sign * grad[start:end]; start += fragment_size_dict[ifr]. return ret. elif ptype == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start and end slices; abs_start, rel_start = 0, 0; abs_slices, rel_slices = [], []; for ifr in bas:; rel_end = rel_start + 3 * fragment_size_dict[ifr]; rel_slices.append(slice(rel_start, rel_end)); rel_start += 3 * fragment_size_dict[ifr]. tmp_slice = fragment_slice_dict[ifr]; abs_slices.append(slice(tmp_slice.start * 3, tmp_slice.stop * 3)). for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):; for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):; ret[abs_sl1, abs_sl2] += sign * hess[rel_sl1, rel_sl2]. return ret. else:; raise KeyError(""ptype can only be energy, gradient, or hessian. How did you end up here?""). def _print_nbody_energy(energy_body_dict: Dict[int, float], header: str, nfragments: int, embedding: bool = False):; """"""Format output string for user for a single bsse_type. Prints to output and logger.; Called repeatedly by assemble_nbody_component."""""". info = f""""""\n ==> N-Body: {header} energies <==\n\n""""""; info += f"""""" {""n-Body"":>12} Total Energy Interaction Energy N-body Contribution to Interaction Energy\n""""""; info += f"""""" [Eh] [Eh] [kcal/mol] [Eh] [kcal/mol]\n""""""; previous_e = energy_body_dict[1]; tot_e = (previous_e != 0.0); nbody_range = list(energy_body_dict); nbody_range.sort(); for nb in range(1, nfragments + 1):; lbl = []; if nb == nfragments:; lbl.append(""FULL""); if nb == max(nbody_range):; lbl.append(""RTN""); lbl = ""/"".join(lbl). if nb in nbody_range:; delta_e = (energy_body_dict[nb] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; if embedding:; int_e = np.nan; int_e_kcal = np.nan; else:; in",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:16256,Energy Efficiency,energy,energy,16256,"ious_e = energy_body_dict[nb]; else:; info += f"""""" {lbl:>8} {nb:3} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20}\n"""""". info += ""\n""; core.print_out(info); logger.info(info). def build_nbody_compute_list(; bsse_type: List[BsseEnum],; nbodies: List[Union[int, Literal[""supersystem""]]],; nfragments: int,; return_total_data: bool,; verbose: int = 1,; ) -> Dict[str, Dict[int, Set[FragBasIndex]]]:; """"""Generates lists of N-Body computations needed for requested BSSE treatments. Parameters; ----------; bsse_type; Requested BSSE treatments.; nbodies; List of n-body levels (e.g., `[2]` or `[1, 2]` or `[""supersystem""]`) for which to generate tasks.; Often this value is an element of self.nbodies_per_mc_level.; Note the natural 1-indexing, so `[1]` covers one-body contributions.; Formerly nbody; nfragments; Number of distinct fragments comprising the full molecular supersystem. Usually self.nfragments.; Formerly max_frag; return_total_data; Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested, as opposed to interaction data (False).; verbose; Control volume of printing. Returns; -------; compute_dict; Dictionary containing subdicts enumerating compute lists for each possible BSSE treatment.; Subdict keys are n-body levels and values are sets of all the `mc_(frag, bas)` indices; needed to compute that n-body level. A given index can appear multiple times within a; subdict and among subdicts.; Formerly, the subdict values were sets of indices needed for given BSSE treatment _of_ given; n-body level. See current (left) and former (right) definitions below for CP dimer. compute_dict[""cp""] = { compute_dict[""cp""] = {; 1: set(), 1: {((1,), (1, 2)),; 2: {((1,), (1, 2)), ((2,), (1, 2))},; ((2,), (1, 2)), 2: {((1, 2), (1, 2))}; ((1, 2), (1, 2))} }; }. Subdicts below are always returned. Any may be empty if not requested through *bsse_type*. * ``'all'`` |w---w| full list of computations required; * ``'cp'`` |w---w| list of computations ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:20993,Energy Efficiency,energy,energy,20993,"o). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:21508,Energy Efficiency,charge,charges,21508,"ent(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; Note that this is the only arg that gets RESET. Happens for supersystem ""nbody"". Returns; -------; results; Dictionary of all N-body results. See contents at ManyBodyComputer.prepare_results docstring. """"""; # which level are we assembling?; mc_level_labels = {int(i.split(""_"")[0]) for i in component_results.keys()}. if len(mc_level_labels) != 1:; raise ValidationError(f""Something's wrong - this fn handles single-level (e.g., 1- & 2-body w/mp2) not multi-level (e.g., 1-body w/hf & ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:21976,Energy Efficiency,energy,energy,21976,"ield. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; Note that this is the only arg that gets RESET. Happens for supersystem ""nbody"". Returns; -------; results; Dictionary of all N-body results. See contents at ManyBodyComputer.prepare_results docstring. """"""; # which level are we assembling?; mc_level_labels = {int(i.split(""_"")[0]) for i in component_results.keys()}. if len(mc_level_labels) != 1:; raise ValidationError(f""Something's wrong - this fn handles single-level (e.g., 1- & 2-body w/mp2) not multi-level (e.g., 1-body w/hf & 2-body w/mp2) assembly: len({mc_level_labels}) != 1""). # get the range of nbodies for this level; # * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level; mc_level_lbl = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:23583,Energy Efficiency,energy,energy,23583,"nbodies for this level; # * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level; mc_level_lbl = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl]; metadata['bsse_type'] = ['nocp']. # regenerate per-bsse required calcs list; compute_dict = build_nbody_compute_list(; metadata['bsse_type'], nbodies, metadata['nfragments'], metadata[""return_total_data""], verbose=0; ). # Build size and slices dictionaries; fragment_size_dict = {}; fragment_slice_dict = {}; iat = 0; for ifr in range(1, metadata[""nfragments""] + 1):; nat = metadata[""molecule""].extract_subsets(ifr).natom(); fragment_size_dict[ifr] = nat; fragment_slice_dict[ifr] = slice(iat, iat + nat); iat += nat. def shaped_zero(der: DriverEnum):; if der == ""energy"":; return 0.0; elif der == ""gradient"":; arr_shape = (nat, 3); return np.zeros(arr_shape); elif der == 'hessian':; arr_shape = (nat * 3, nat * 3); return np.zeros(arr_shape). # Final dictionaries; if ptype == ""energy"":; cp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. else:; nat = sum(fragment_size_dict.values()); if ptype == 'gradient':; arr_shape = (nat, 3); elif ptype == 'hessian':; arr_shape = (nat * 3, nat * 3). cp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. cp_body_dict =",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:23799,Energy Efficiency,energy,energy,23799,"l = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl]; metadata['bsse_type'] = ['nocp']. # regenerate per-bsse required calcs list; compute_dict = build_nbody_compute_list(; metadata['bsse_type'], nbodies, metadata['nfragments'], metadata[""return_total_data""], verbose=0; ). # Build size and slices dictionaries; fragment_size_dict = {}; fragment_slice_dict = {}; iat = 0; for ifr in range(1, metadata[""nfragments""] + 1):; nat = metadata[""molecule""].extract_subsets(ifr).natom(); fragment_size_dict[ifr] = nat; fragment_slice_dict[ifr] = slice(iat, iat + nat); iat += nat. def shaped_zero(der: DriverEnum):; if der == ""energy"":; return 0.0; elif der == ""gradient"":; arr_shape = (nat, 3); return np.zeros(arr_shape); elif der == 'hessian':; arr_shape = (nat * 3, nat * 3); return np.zeros(arr_shape). # Final dictionaries; if ptype == ""energy"":; cp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. else:; nat = sum(fragment_size_dict.values()); if ptype == 'gradient':; arr_shape = (nat, 3); elif ptype == 'hessian':; arr_shape = (nat * 3, nat * 3). cp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. # Sum up ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:26136,Energy Efficiency,energy,energy,26136,"_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; cp_compute_list[nb],; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); nocp_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; nocp_compute_list[nb],; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); if nb in compute_dict[""vmfc_levels""]:; vmfc_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; compute_dict[""vmfc_levels""][nb],; fragment_slice_dict,; fragment_size_dict,; vmfc=True,; nb=nb,; mc_level_lbl=mc_level_lbl,; ). def labeler(item) -> str:; return str(mc_level_lbl) + ""_"" + str(item). # Extract data for monomers in monomer basis for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:26645,Energy Efficiency,energy,energy,26645,"_lbl,; ); if nb in compute_dict[""vmfc_levels""]:; vmfc_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; compute_dict[""vmfc_levels""][nb],; fragment_slice_dict,; fragment_size_dict,; vmfc=True,; nb=nb,; mc_level_lbl=mc_level_lbl,; ). def labeler(item) -> str:; return str(mc_level_lbl) + ""_"" + str(item). # Extract data for monomers in monomer basis for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-C",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:26993,Energy Efficiency,energy,energy,26993,"s for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_leve",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:27127,Energy Efficiency,energy,energy,27127," for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb]",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:27957,Energy Efficiency,energy,energy,27957,"sse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:28251,Energy Efficiency,energy,energy,28251,"RRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Funct",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:29039,Energy Efficiency,energy,energy,29039,"] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized ret",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:29234,Energy Efficiency,energy,energy,29234,"ody_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""ener",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:30310,Energy Efficiency,energy,energy,30310,"unction Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:30777,Energy Efficiency,energy,energy,30777,"NERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level int",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:32116,Energy Efficiency,energy,energy,32116,"et_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos'n/label indexing coincides. molecule: Any = Field(..., description=""The target molecule, if not the last molecule defined.""); basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum = Field(..., description=""The computation driver; i.e., energy, gradient, hessian.""); keywords: Dict[str, Any] = Field({}, description=""The computation keywords/options.""). bsse_type: List[BsseEnum] = Field([BsseEnum.cp], description=""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.""); nfragments: int = Field(-1, description=""Number of distinct fragments comprising full molecular supersystem."") # formerly max_frag; max_nbody: int = Field(-1, description=""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:32374,Energy Efficiency,energy,energy,32374,"# * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos'n/label indexing coincides. molecule: Any = Field(..., description=""The target molecule, if not the last molecule defined.""); basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum = Field(..., description=""The computation driver; i.e., energy, gradient, hessian.""); keywords: Dict[str, Any] = Field({}, description=""The computation keywords/options.""). bsse_type: List[BsseEnum] = Field([BsseEnum.cp], description=""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.""); nfragments: int = Field(-1, description=""Number of distinct fragments comprising full molecular supersystem."") # formerly max_frag; max_nbody: int = Field(-1, description=""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effe",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:33616,Energy Efficiency,charge,charges,33616,"in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:33765,Energy Efficiency,charge,charges,33765,"l[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:33891,Energy Efficiency,energy,energy,33891,"ll bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molec",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:34367,Energy Efficiency,energy,energy,34367,"s all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:38792,Energy Efficiency,charge,charges,38792,"self.nfragments}""; self.task_list[key] = mb_computer(**data); count += 1. compute_dict = build_nbody_compute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:38908,Energy Efficiency,charge,charges,38908,"ompute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to p",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:39062,Energy Efficiency,charge,charges,39062,"e_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:40781,Energy Efficiency,energy,energy,40781,"ponent molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client; QCFractal client if using QCArchive for distributed compute. Returns; -------; nbody_results; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +-------------------------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:42047,Energy Efficiency,energy,energy,42047,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:43634,Energy Efficiency,energy,energy,43634,"a) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_hessian | (nat * 3, nat * 3) | when driver is h | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | nbody | >=1 | always | energy n-body QCVariables to be set |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY | |em| 1 | when cp in bsse_type | MBE sum of subsystems of 1-body. summed are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:45429,Energy Efficiency,energy,energy,45429,DY | |em| 1 | when cp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY | |em| 1 | when cp in bsse_type & rtd=T | best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; i,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:46855,Energy Efficiency,energy,energy,46855,in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY | |em| 1 | when cp in bsse_type | best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE;,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:49960,Energy Efficiency,energy,energy,49960,em| 1 | when nocp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY | |em| 1 | when nocp in bsse_type | best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body total data for cumu,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:51401,Energy Efficiency,energy,energy,51401,e_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY | |em| 1 | when nocp in bsse_type | best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data f,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:54520,Energy Efficiency,energy,energy,54520,em| 1 | when vmfc in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY | |em| 1 | when vmfc in bsse_type | best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumu,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:55962,Energy Efficiency,energy,energy,55962,type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY | |em| 1 | when vmfc in bsse_type | best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data f,MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:79471,Energy Efficiency,energy,energy,79471,"----------------------------------------------------------+; | |em| {max_nbody}vmfc | |em| (nat*3, nat*3) | when driver is h; zeroed if vmfc not in bsse_type | cumulative through {max_nbody}-body total Hessians with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates | ntasks | always | all individual energies with nice labels |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (1, 2)@(1, 2) TOTAL ENERGY | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (3)@(2, 3) TOTAL ENERGY | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| .",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:79892,Energy Efficiency,energy,energy,79892,"----------------------------------------------------------+; | |em| {max_nbody}vmfc | |em| (nat*3, nat*3) | when driver is h; zeroed if vmfc not in bsse_type | cumulative through {max_nbody}-body total Hessians with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates | ntasks | always | all individual energies with nice labels |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (1, 2)@(1, 2) TOTAL ENERGY | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (3)@(2, 3) TOTAL ENERGY | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| .",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:81225,Energy Efficiency,energy,energy,81225,"-+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates_energy | ntasks | always | all individual energies |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 1_((1, 2), (1, 2)) | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 2_((3,), (2, 3)) | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+-------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:81632,Energy Efficiency,energy,energy,81632,"-+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates_energy | ntasks | always | all individual energies |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 1_((1, 2), (1, 2)) | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 2_((3,), (2, 3)) | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+-------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:86272,Energy Efficiency,energy,energy,86272,"gment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+. """"""; if results is None:; results = {}. # formerly nlevels; mc_level_labels = {i.split(""_"")[0] for i in self.task_list}; if len(mc_level_labels) > 1 and not results:; return driver_nbody_multilevel.prepare_results(self, client). results_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trov",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87071,Energy Efficiency,energy,energy,87071,"ts_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87124,Energy Efficiency,energy,energy,87124,"ts_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87140,Energy Efficiency,energy,energy,87140,"ts_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87249,Energy Efficiency,energy,energy,87249,"t.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermedia",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87265,Energy Efficiency,energy,energy,87265,"t.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermedia",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87470,Energy Efficiency,energy,energy,87470,".return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas =",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:87486,Energy Efficiency,energy,energy,87486,".return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas =",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:88625,Energy Efficiency,energy,energy,88625,"())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.return_energy. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x in trove[""gradient""].values()):; nbody_results[""intermediates_gradient""] = trove[""gradient""]. if not all(x is None for x in trove[""hessian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:92042,Energy Efficiency,energy,energy,92042,"_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:2583,Integrability,rout,routes,2583,"nts. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets; * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions); needed to compute the requested bsse treatments at the requested n-body levels.; * merge by n-body level the sets of indices for each bsse treatment into an ""all"" dict. return this and all the per-bs",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:2591,Integrability,depend,depending,2591,"nts. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets; * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions); needed to compute the requested bsse treatments at the requested n-body levels.; * merge by n-body level the sets of indices for each bsse treatment into an ""all"" dict. return this and all the per-bs",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:8187,Integrability,depend,depending,8187,"uter"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpois",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:36442,Integrability,wrap,wrappers,36442,"ding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include supersystem in count. """"""; # Get the n-body orders for this level; nbodies = self.nbodies_per_mc_level[mc_level_idx]. info = ""\n"" + p4util.banner(f"" ManyBody Setup: N-Body Levels {nbodies}"", strNotOutfile=True) + ""\n""; core.print_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:41597,Integrability,depend,depending,41597,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:41636,Integrability,depend,depending,41636,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:41697,Integrability,depend,depending,41697,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:42068,Integrability,depend,depending,42068,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:42513,Integrability,depend,depending,42513,"=====================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_hessian | (nat * 3, nat * 3) | when driver is h | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +--------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:42962,Integrability,depend,depending,42962,"-+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_hessian | (nat * 3, nat * 3) | when driver is h | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | nbody | >=1 | always | energy n-body QCVariables to be set |; +---------------------------------------------------------------+----------------------+----------------------------------",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:91375,Integrability,interface,interface,91375,"ype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__),; 'extras': {; 'qcvars': qcvars,; 'component_results': component_results,; },; 'return_result': ret_ptype,; 'success': True,; }). logger.debug('\nNBODY QCSchema:\n' + pp.pformat(nbody_model.dict())). return nbody_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""int",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:38916,Modifiability,extend,extend,38916,"(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. U",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:89776,Performance,load,load,89776,"ues()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties':",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:2090,Security,validat,validation,2090,"#; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:7406,Security,validat,validator,7406,"t key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction w",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:7466,Security,validat,validator,7466,"t key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction w",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:17931,Security,validat,validated,17931,"set(), 1: {((1,), (1, 2)),; 2: {((1,), (1, 2)), ((2,), (1, 2))},; ((2,), (1, 2)), 2: {((1, 2), (1, 2))}; ((1, 2), (1, 2))} }; }. Subdicts below are always returned. Any may be empty if not requested through *bsse_type*. * ``'all'`` |w---w| full list of computations required; * ``'cp'`` |w---w| list of computations required for CP procedure; * ``'nocp'`` |w---w| list of computations required for non-CP procedure; * ``'vmfc_compute'`` |w---w| list of computations required for VMFC procedure; * ``'vmfc_levels'`` |w---w| list of levels required for VMFC procedure. """"""; # What levels do we need?; fragment_range = range(1, nfragments + 1). # Need nbodies and all lower-body in full basis; cp_compute_list = {x: set() for x in nbodies}; nocp_compute_list = {x: set() for x in nbodies}; vmfc_compute_list = {x: set() for x in nbodies}; vmfc_level_list = {x: set() for x in nbodies} # Need to sum something slightly different. # Verify proper passing of bsse_type. already validated in Computer; bsse_type_remainder = set(bsse_type) - {e.value for e in BsseEnum}; if bsse_type_remainder:; raise ValidationError(""""""Unrecognized BSSE type(s): {bsse_type_remainder}""""""). # Build up compute sets; if 'cp' in bsse_type:; # Everything is in full n-mer basis; basis_tuple = tuple(fragment_range). for nb in nbodies:; if nb > 1:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; # below was `nbodies`, which would never hit. present is closest to pre-DDD. purpose unclear to me.; # if self.max_nbody == 1: break; cp_compute_list[nb].add((x, basis_tuple)). if 'nocp' in bsse_type or return_total_data:; # Everything in monomer basis; for nb in nbodies:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; nocp_compute_list[nb].add((x, x)). if 'vmfc' in bsse_type:; # Like a CP for all combinations of pairs or greater; for nb in nbodies:; for cp_combos in itertools.combinations(fragment_range, nb):; basis_tuple = tuple",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:34566,Security,validat,validation,34566,"point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:34619,Security,validat,validator,34619,"point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:34678,Security,validat,validator,34678," Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedd",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:34864,Security,validat,validator,34864,"ta (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:35006,Security,validat,validator,35006,"ation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:35130,Security,validat,validator,35130,"data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level speci",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:35298,Security,validat,validator,35298," used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~ps",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:35522,Security,validat,validator,35522,"nd validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersys",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:36239,Security,access,accessed,36239," if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:5985,Testability,log,logs,5985,"stem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:7484,Testability,log,logging,7484,"lts kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:7929,Testability,log,logger,7929,"; * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || `",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:7938,Testability,log,logging,7938,"; * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || `",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:14155,Testability,log,logger,14155,"type == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start and end slices; abs_start, rel_start = 0, 0; abs_slices, rel_slices = [], []; for ifr in bas:; rel_end = rel_start + 3 * fragment_size_dict[ifr]; rel_slices.append(slice(rel_start, rel_end)); rel_start += 3 * fragment_size_dict[ifr]. tmp_slice = fragment_slice_dict[ifr]; abs_slices.append(slice(tmp_slice.start * 3, tmp_slice.stop * 3)). for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):; for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):; ret[abs_sl1, abs_sl2] += sign * hess[rel_sl1, rel_sl2]. return ret. else:; raise KeyError(""ptype can only be energy, gradient, or hessian. How did you end up here?""). def _print_nbody_energy(energy_body_dict: Dict[int, float], header: str, nfragments: int, embedding: bool = False):; """"""Format output string for user for a single bsse_type. Prints to output and logger.; Called repeatedly by assemble_nbody_component."""""". info = f""""""\n ==> N-Body: {header} energies <==\n\n""""""; info += f"""""" {""n-Body"":>12} Total Energy Interaction Energy N-body Contribution to Interaction Energy\n""""""; info += f"""""" [Eh] [Eh] [kcal/mol] [Eh] [kcal/mol]\n""""""; previous_e = energy_body_dict[1]; tot_e = (previous_e != 0.0); nbody_range = list(energy_body_dict); nbody_range.sort(); for nb in range(1, nfragments + 1):; lbl = []; if nb == nfragments:; lbl.append(""FULL""); if nb == max(nbody_range):; lbl.append(""RTN""); lbl = ""/"".join(lbl). if nb in nbody_range:; delta_e = (energy_body_dict[nb] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; if embedding:; int_e = np.nan; int_e_kcal = np.nan; else:; int_e = energy_body_dict[nb] - energy_body_dict[1]; int_e_kcal = int_e * constants.hartree2kcalmol; if tot_e:; info += f"""""" {lbl:>8} {nb:3} {energy_body_dict[nb]:20.12f} {int_e:20.12f} {int_e_kcal:20.12f} {delta_e:20.12f} {delta_e_kcal:20.12f}\n""""""; else",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:15439,Testability,log,logger,15439," previous_e = energy_body_dict[1]; tot_e = (previous_e != 0.0); nbody_range = list(energy_body_dict); nbody_range.sort(); for nb in range(1, nfragments + 1):; lbl = []; if nb == nfragments:; lbl.append(""FULL""); if nb == max(nbody_range):; lbl.append(""RTN""); lbl = ""/"".join(lbl). if nb in nbody_range:; delta_e = (energy_body_dict[nb] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; if embedding:; int_e = np.nan; int_e_kcal = np.nan; else:; int_e = energy_body_dict[nb] - energy_body_dict[1]; int_e_kcal = int_e * constants.hartree2kcalmol; if tot_e:; info += f"""""" {lbl:>8} {nb:3} {energy_body_dict[nb]:20.12f} {int_e:20.12f} {int_e_kcal:20.12f} {delta_e:20.12f} {delta_e_kcal:20.12f}\n""""""; else:; info += f"""""" {lbl:>8} {nb:3} {""N/A"":20} {int_e:20.12f} {int_e_kcal:20.12f} {delta_e:20.12f} {delta_e_kcal:20.12f}\n""""""; previous_e = energy_body_dict[nb]; else:; info += f"""""" {lbl:>8} {nb:3} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20}\n"""""". info += ""\n""; core.print_out(info); logger.info(info). def build_nbody_compute_list(; bsse_type: List[BsseEnum],; nbodies: List[Union[int, Literal[""supersystem""]]],; nfragments: int,; return_total_data: bool,; verbose: int = 1,; ) -> Dict[str, Dict[int, Set[FragBasIndex]]]:; """"""Generates lists of N-Body computations needed for requested BSSE treatments. Parameters; ----------; bsse_type; Requested BSSE treatments.; nbodies; List of n-body levels (e.g., `[2]` or `[1, 2]` or `[""supersystem""]`) for which to generate tasks.; Often this value is an element of self.nbodies_per_mc_level.; Note the natural 1-indexing, so `[1]` covers one-body contributions.; Formerly nbody; nfragments; Number of distinct fragments comprising the full molecular supersystem. Usually self.nfragments.; Formerly max_frag; return_total_data; Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested, as opposed to interaction data (False).; verbose; Control volume of printing. Returns; -------; compute_dict;",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:19975,Testability,log,logger,19975,"bos); for interior_nbody in range(1, nb + 1):; for x in itertools.combinations(cp_combos, interior_nbody):; combo_tuple = (x, basis_tuple); vmfc_compute_list[nb].add(combo_tuple); vmfc_level_list[len(basis_tuple)].add(combo_tuple). # Build a comprehensive compute range; # * do not use list length to count number of {nb}-body computations; compute_list = {x: set() for x in nbodies}; for nb in nbodies:; compute_list[nb] |= cp_compute_list[nb]; compute_list[nb] |= nocp_compute_list[nb]; compute_list[nb] |= vmfc_compute_list[nb]. # Rearrange compute_list from key nb having values to compute all of that nb; # to key nb including values of that nb. Use for counting.; compute_list_count = {x: set() for x in nbodies}; for nb in nbodies:; for nbset in compute_list.values():; for item in nbset:; if len(item[0]) == nb:; compute_list_count[nb].add(item); if verbose >= 1:; info = ""\n"".join([f"" Number of {nb}-body computations: {len(compute_list_count[nb])}"" for nb in nbodies]); core.print_out(info + ""\n""); logger.info(info). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class fi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:20989,Testability,log,log,20989,"o). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:34346,Testability,log,log,34346,"s all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:37445,Testability,log,logger,37445,"n wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include supersystem in count. """"""; # Get the n-body orders for this level; nbodies = self.nbodies_per_mc_level[mc_level_idx]. info = ""\n"" + p4util.banner(f"" ManyBody Setup: N-Body Levels {nbodies}"", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). for kwg in ['dft_functional']:; if kwg in kwargs:; kwargs['keywords']['function_kwargs'][kwg] = kwargs.pop(kwg). count = 0; template = copy.deepcopy(kwargs). # Get compute list; if nbodies == [""supersystem""]:; # Add supersystem computation if requested -- always nocp; data = template; data[""molecule""] = self.molecule; key = f""supersystem_{self.nfragments}""; self.task_list[key] = mb_computer(**data); count += 1. compute_dict = build_nbody_compute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:39456,Testability,log,logger,39456,"[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client; QCFractal client if using QCArchive for distributed compute. Returns; -------; nbody_results; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:89580,Testability,log,logger,89580,"y. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x in trove[""gradient""].values()):; nbody_results[""intermediates_gradient""] = trove[""gradient""]. if not all(x is None for x in trove[""hessian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:90998,Testability,log,logger,90998,""": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__),; 'extras': {; 'qcvars': qcvars,; 'component_results': component_results,; },; 'return_result': ret_ptype,; 'success': True,; }). logger.debug('\nNBODY QCSchema:\n' + pp.pformat(nbody_model.dict())). return nbody_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be b",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:2604,Usability,simpl,simple,2604,"nts. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets; * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions); needed to compute the requested bsse treatments at the requested n-body levels.; * merge by n-body level the sets of indices for each bsse treatment into an ""all"" dict. return this and all the per-bs",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:20914,Usability,simpl,simply,20914,"utations: {len(compute_list_count[nb])}"" for nb in nbodies]); core.print_out(info + ""\n""); logger.info(info). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See c",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:92098,Usability,simpl,simple,92098,"_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:13820,Availability,down,down,13820,"; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:23540,Deployability,update,updated,23540,"cule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %6d %6d\n\n"""""" % (N - 1, Na1, Nb1, charge1, mult1)). core.print_out("""""" => Regula Falsi Iterations <=\n\n""""""); core.print_out("""""" %3s %11s %14s %14s %14s %s\n"""""" % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; core.print_out("""""" %3d %11.3E %14.6E %14.6E %14.6E %s\n"""""" %; (k + 1, omegas[k], IPs[k], kIPs[k], IPs[k] - kIPs[k], types[k])). optstash.restore(); if converged:; core.print_out(""""""\n IP Fitting Converged\n""""""); core.print_out("""""" Final omega = %14.6E\n"""""" % ((omega_l + omega_r) / 2)); core.print_out(""""""\n ""M,I. does the dying. Fleet just does the flying.""\n""""""); core.print_out("""""" -Starship Troopers\n""""""). else:; raise ConvergenceError(""""""IP Fitting """""", step + 1). return ((omega_l + omega_r) / 2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.frac. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:3685,Energy Efficiency,charge,chargep,3685,"ionary associating SCF energies with occupations. """"""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'REFERENCE'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; #[""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]); kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_traverse requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_traverse` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0; for A in range(molecule.natom()):; Z += molecule.Z(A); Z -= charge0; HOMO = kwargs.get('HOMO', (Z / 2 + 1 if (Z % 2) else Z / 2)); LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = Fals",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:3708,Energy Efficiency,charge,chargem,3708,"ionary associating SCF energies with occupations. """"""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'REFERENCE'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; #[""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]); kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_traverse requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_traverse` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0; for A in range(molecule.natom()):; Z += molecule.Z(A); Z -= charge0; HOMO = kwargs.get('HOMO', (Z / 2 + 1 if (Z % 2) else Z / 2)); LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = Fals",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:5374,Energy Efficiency,energy,energy,5374,"MO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = False; if core.get_local_option('SCF', 'REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). old_guess = core.get_local_option(""SCF"", ""GUESS""); if (neutral_guess):; if (hf_guess):; core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:5599,Energy Efficiency,charge,chargem,5599,"tral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = False; if core.get_local_option('SCF', 'REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). old_guess = core.get_local_option(""SCF"", ""GUESS""); if (neutral_guess):; if (hf_guess):; core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.ap",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:5764,Energy Efficiency,energy,energy,5764," True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). old_guess = core.get_local_option(""SCF"", ""GUESS""); if (neutral_guess):; if (hf_guess):; core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:6284,Energy Efficiency,energy,energy,6284,"ption(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:7246,Energy Efficiency,energy,energy,7246,"er.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_dii",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:7714,Energy Efficiency,energy,energy,7714,"n(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. core.print_out(""""""; You trying to be a hero Watkins?; Ju",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:10624,Energy Efficiency,charge,charge,10624,"re.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_nuke requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_nuke` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:11232,Energy Efficiency,energy,energy,11232,"t = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = w",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:11626,Energy Efficiency,charge,charge,11626,"= int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", f",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:11687,Energy Efficiency,charge,charge,11687,"electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:12099,Energy Efficiency,energy,energy,12099,"ials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:12683,Energy Efficiency,charge,charge,12683," charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:12726,Energy Efficiency,charge,charge,12726,".set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'M",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:13116,Energy Efficiency,charge,charge,13116,"iver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.wr",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:13177,Energy Efficiency,charge,charge,13177,"wargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k],",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:16833,Energy Efficiency,energy,energy,16833," molecule.molecular_charge() != 0:; raise ValidationError(""""""IP Fitting requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:17852,Energy Efficiency,energy,energy,17852,"SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOr = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:18450,Energy Efficiency,energy,energy,18450,"]; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOr = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if N",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:19324,Energy Efficiency,energy,energy,19324,"rge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOl = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1l = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Left Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; raise ValidationError(""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP: {} !< {}"""""".format(kIPl, IPl)). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.appen",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:19944,Energy Efficiency,energy,energy,19944,"ESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOl = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1l = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Left Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; raise ValidationError(""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP: {} !< {}"""""".format(kIPl, IPl)). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; for step in range(maxiter):. # Regula Falsi (modified); if repeat_l > 1:; delta_l /= 2.0; if repeat_r > 1:; delta_r /= 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True,",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:20953,Energy Efficiency,energy,energy,20953,"tting SCF: Cation, Left Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; raise ValidationError(""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP: {} !< {}"""""".format(kIPl, IPl)). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; for step in range(maxiter):. # Regula Falsi (modified); if repeat_l > 1:; delta_l /= 2.0; if repeat_r > 1:; delta_r /= 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Omega = {:11.3E}'.format(omega), **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:21571,Energy Efficiency,energy,energy,21571,"l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Omega = {:11.3E}'.format(omega), **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:6396,Modifiability,variab,variable,6396,"e=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI co",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:7826,Modifiability,variab,variable,7826,"re.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. core.print_out(""""""; You trying to be a hero Watkins?; Just trying to kill some bugs sir!; -Starship Troopers""""""). # Drop the files out; wi",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:12211,Modifiability,variab,variable,12211,".energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:1534,Performance,optimiz,optimized,1534,"; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core. from . import driver, p4util; from .p4util.exceptions import *. [docs]; def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:1652,Performance,tune,tuned,1652,"# Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core. from . import driver, p4util; from .p4util.exceptions import *. [docs]; def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before UKS?; continuous_guess : Optional[bool]; Do carry along guess rather than reguessing at each occupation?; filename : Optional[str",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:14717,Performance,optimiz,optimized,14717,"s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS referenc",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:14949,Performance,tune,tuned,14949,"). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS reference.\n""""""); core.set_local_option('SCF', 'REFERENCE', 'UKS'). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molec",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:17080,Performance,optimiz,optimize,17080,"ocedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; e",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:16466,Availability,error,error,16466,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:16654,Availability,error,error,16654,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:16815,Availability,error,error,16815,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:25813,Deployability,update,updated,25813,"ile('^from __future__ import .*$', flags=re.MULTILINE); temp = re.sub(future_string, future_replace, temp). # imports; imports = '\n'.join(future_imports) + '\n'; imports += 'import psi4\n'; imports += 'from psi4 import *\n'; imports += 'from psi4.core import *\n'; imports += 'from psi4.driver.diatomic import anharmonicity\n'; imports += 'from psi4.driver.gaussian_n import *\n'; imports += 'from psi4.driver.frac import ip_fitting, frac_traverse\n'; imports += 'from psi4.driver.aliases import *\n'; imports += 'from psi4.driver.driver_cbs import *\n'; imports += 'from psi4.driver.wrapper_database import database, db, DB_RGT, DB_RXN\n'; imports += 'from psi4.driver.wrapper_autofrag import auto_fragments\n'; imports += 'psi4_io = core.IOManager.shared_object()\n'. # psirc (a baby PSIthon script that might live in ~/.psi4rc); psirc_file = os.path.expanduser('~') + os.path.sep + '.psi4rc'; if os.path.isfile(psirc_file):; fh = open(psirc_file); psirc = fh.read(); fh.close(); psirc = psirc.replace('psi4.IOManager', 'psi4.core.IOManager'); psirc += ""\npsi4.core.print_out('Warning: As of v1.5, the ~/.psi4rc file will no longer be read into Psi4 input.\\n')\n""; else:; psirc = ''. temp = imports + psirc + temp. # Move up the psi4.core namespace; for func in dir(core):; temp = temp.replace(""psi4."" + func, ""psi4.core."" + func). # Move pseudonamespace for physconst into proper namespace; from psi4.driver import constants; for pc in dir(constants):; if not pc.startswith('__'):; temp = temp.replace('psi_' + pc, 'psi4.constants.' + pc). return temp. if __name__ == ""__main__"":; result = process_input(""""""; molecule h2 {; H; H 1 R. R = .9; }. set basis 6-31G**. """"""). print(""Result\n==========================""); print(result). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.inputparser. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:13486,Energy Efficiency,charge,charge,13486,"e:; lines2.append(line); lines = lines2. # 1. Look for units [ang|bohr|au|a.u.] defaults to ang; re_units = re.compile(r'^\s*units?[\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\.u\.))$\s*', re.IGNORECASE); units = 'ang'; lines2 = []; for line in lines:; mobj = re_units.match(line); if mobj:; unit = mobj.group(1); if unit in ['bohr', 'au', 'a.u.']:; units = 'bohr'; else:; units = 'ang'; else:; lines2.append(line); lines = lines2. # 2. Look for basis basisname, defaults to cc-pvdz; # 3. Look for df_basis_scf basisname, defaults to cc-pvdz-jkfit; re_basis = re.compile(r'\s*basis[\s=]+(\S+)\s*$', re.IGNORECASE); re_df_basis = re.compile(r'\s*df_basis_scf[\s=]+(\S+)\s*$', re.IGNORECASE); basis = 'cc-pvdz'; df_basis_scf = 'cc-pvdz-jkfit'; lines2 = []; for line in lines:; mobj = re_basis.match(line); if mobj:; basis = mobj.group(1); else:; mobj = re_df_basis.match(line); if mobj:; df_basis_scf = mobj.group(1); else:; lines2.append(line); lines = lines2. # 4. Look for charge lines Z x y z, convert according to unit convention; charge_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$'); lines2 = []; for line in lines:; mobj = charge_re.match(line); if mobj:; if units == 'ang':; extern += '%sqmmm.addChargeAngstrom(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2),; mobj.group(3), mobj.group(4)); if units == 'bohr':; extern += '%sqmmm.addChargeBohr(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2), mobj.group(3),; mobj.group(4)); else:; lines2.append(line); lines = lines2. # 5. Look for diffuse regions, which are XYZ molecules seperated by the usual -- lines; spacer_re = re.compile(r'^\s*--\s*$'); frags = []; frags.append([]); for line in lines:; mobj = spacer_re.match(line); if mobj:; if len(frags[len(frags) - 1]):; frags.append([]); else:; frags[len(frags) - 1].append(line). extern += '%sextern_mol_temp = core.get_active_molecule()\n' % (spaces). mol_re = re.compile(r'\s*\S+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + ",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:1724,Integrability,message,message,1724,"TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import uuid. from psi4 import core; from psi4.driver.p4util.exceptions import *; from psi4.driver.p4util.util import set_memory. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:1804,Integrability,message,message,1804,"TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import uuid. from psi4 import core; from psi4.driver.p4util.exceptions import *; from psi4.driver.p4util.util import set_memory. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve a",MatchSource.WIKI,psi4manual/master/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html
