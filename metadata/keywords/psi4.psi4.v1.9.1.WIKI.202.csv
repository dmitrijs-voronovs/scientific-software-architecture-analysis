id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:43682,Energy Efficiency,ENERGY,ENERGY,43682,"er_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); PsiMod.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], PsiMod.get_variable('NUCLEAR REPULSION ENERGY'), ; 4, '%s %.4f' % (rgt, PsiMod.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT:",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:43754,Energy Efficiency,ENERGY,ENERGY,43754," modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); PsiMod.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], PsiMod.get_variable('NUCLEAR REPULSION ENERGY'), ; 4, '%s %.4f' % (rgt, PsiMod.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:44772,Energy Efficiency,energy,energy,44772,"; ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' D",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:46265,Energy Efficiency,energy,energy,46265,"] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested proce",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:46349,Energy Efficiency,energy,energy,46349,"rs); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabu",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:47469,Energy Efficiency,ENERGY,ENERGY,47469," %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACT",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:48483,Energy Efficiency,energy,energy,48483,""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error)",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:48667,Energy Efficiency,Energy,Energy,48667," = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:51509,Energy Efficiency,Energy,Energy,51509,"_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psiv",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52324,Energy Efficiency,energy,energy,52324,"the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more ex",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52532,Energy Efficiency,energy,energy,52532,"ror'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment o",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52615,Energy Efficiency,ENERGY,ENERGY,52615,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52666,Energy Efficiency,ENERGY,ENERGY,52666,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52723,Energy Efficiency,ENERGY,ENERGY,52723,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52774,Energy Efficiency,ENERGY,ENERGY,52774,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52828,Energy Efficiency,ENERGY,ENERGY,52828,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52893,Energy Efficiency,ENERGY,ENERGY,52893,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53422,Energy Efficiency,energy,energy,53422,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; *",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53544,Energy Efficiency,energy,energy,53544,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; *",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53568,Energy Efficiency,energy,energy,53568,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; *",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53615,Energy Efficiency,energy,energy,53615,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; *",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53782,Energy Efficiency,Energy,Energy,53782,"RRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'c",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53965,Energy Efficiency,energy,energy,53965,"RRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'c",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54181,Energy Efficiency,energy,energy,54181,"ified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a d",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54688,Energy Efficiency,energy,energy,54688,"s only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54908,Energy Efficiency,energy,energy,54908," that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set se",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54948,Energy Efficiency,energy,energy,54948," that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set se",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55168,Energy Efficiency,energy,energy,55168,"e been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of b",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55231,Energy Efficiency,energy,energy,55231,"e been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of b",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55379,Energy Efficiency,energy,energy,55379,"df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55442,Energy Efficiency,energy,energy,55442,"df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55574,Energy Efficiency,energy,energy,55574,"ent, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55644,Energy Efficiency,energy,energy,55644,"ent, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55797,Energy Efficiency,energy,energy,55797,": string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:55867,Energy Efficiency,energy,energy,55867,": string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:56236,Energy Efficiency,energy,energy,56236,"ion; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; se",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:56541,Energy Efficiency,energy,energy,56541,": ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_h",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:56786,Energy Efficiency,energy,energy,56786," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:57040,Energy Efficiency,energy,energy,57040,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta c",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:57082,Energy Efficiency,energy,energy,57082,"|| ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1``",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:57607,Energy Efficiency,energy,energy,57607,":`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replica",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:57802,Energy Efficiency,energy,energy,57802," to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58024,Energy Efficiency,energy,energy,58024,"ets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtp",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58255,Energy Efficiency,energy,energy,58255,"; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58503,Energy Efficiency,energy,energy,58503,"est_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58653,Energy Efficiency,energy,energy,58653,"e: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58756,Energy Efficiency,energy,energy,58756,"be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58884,Energy Efficiency,energy,energy,58884,"|| etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:59095,Energy Efficiency,energy,energy,59095,"etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:59426,Energy Efficiency,energy,energy,59426,"s cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60153,Energy Efficiency,energy,energy,60153,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATIO",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60322,Energy Efficiency,energy,energy,60322,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATIO",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60505,Energy Efficiency,energy,energy,60505," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60619,Energy Efficiency,energy,energy,60619," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60784,Energy Efficiency,ENERGY,ENERGY,60784,"set=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELA",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60831,Energy Efficiency,ENERGY,ENERGY,60831,"set=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELA",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60869,Energy Efficiency,ENERGY,ENERGY,60869,"set=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELA",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60918,Energy Efficiency,ENERGY,ENERGY,60918,"ame.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRE",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60956,Energy Efficiency,ENERGY,ENERGY,60956,"ame.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRE",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60999,Energy Efficiency,ENERGY,ENERGY,60999,"e' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61038,Energy Efficiency,ENERGY,ENERGY,61038,"e' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61085,Energy Efficiency,ENERGY,ENERGY,61085,"e' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61123,Energy Efficiency,ENERGY,ENERGY,61123,"e' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61166,Energy Efficiency,ENERGY,ENERGY,61166,"gs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) COR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61205,Energy Efficiency,ENERGY,ENERGY,61205,"gs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) COR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61257,Energy Efficiency,ENERGY,ENERGY,61257,"gs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) COR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61295,Energy Efficiency,ENERGY,ENERGY,61295,"gs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) COR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61338,Energy Efficiency,ENERGY,ENERGY,61338,"to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61377,Energy Efficiency,ENERGY,ENERGY,61377,"to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61426,Energy Efficiency,ENERGY,ENERGY,61426,"to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61473,Energy Efficiency,ENERGY,ENERGY,61473,"to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61511,Energy Efficiency,ENERGY,ENERGY,61511,"to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61554,Energy Efficiency,ENERGY,ENERGY,61554,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61593,Energy Efficiency,ENERGY,ENERGY,61593,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61642,Energy Efficiency,ENERGY,ENERGY,61642,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61687,Energy Efficiency,ENERGY,ENERGY,61687,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61736,Energy Efficiency,ENERGY,ENERGY,61736,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61774,Energy Efficiency,ENERGY,ENERGY,61774,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61814,Energy Efficiency,ENERGY,ENERGY,61814,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61862,Energy Efficiency,ENERGY,ENERGY,61862,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61900,Energy Efficiency,ENERGY,ENERGY,61900,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61938,Energy Efficiency,ENERGY,ENERGY,61938,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61978,Energy Efficiency,ENERGY,ENERGY,61978,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62027,Energy Efficiency,ENERGY,ENERGY,62027,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62065,Energy Efficiency,ENERGY,ENERGY,62065,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62110,Energy Efficiency,ENERGY,ENERGY,62110,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62159,Energy Efficiency,ENERGY,ENERGY,62159,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62197,Energy Efficiency,ENERGY,ENERGY,62197,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62241,Energy Efficiency,ENERGY,ENERGY,62241,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62292,Energy Efficiency,ENERGY,ENERGY,62292,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62330,Energy Efficiency,ENERGY,ENERGY,62330,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62376,Energy Efficiency,ENERGY,ENERGY,62376,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62427,Energy Efficiency,ENERGY,ENERGY,62427,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62465,Energy Efficiency,ENERGY,ENERGY,62465,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62511,Energy Efficiency,ENERGY,ENERGY,62511,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62562,Energy Efficiency,ENERGY,ENERGY,62562,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62600,Energy Efficiency,ENERGY,ENERGY,62600,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62646,Energy Efficiency,ENERGY,ENERGY,62646,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62694,Energy Efficiency,ENERGY,ENERGY,62694,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62732,Energy Efficiency,ENERGY,ENERGY,62732,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62772,Energy Efficiency,ENERGY,ENERGY,62772,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62820,Energy Efficiency,ENERGY,ENERGY,62820,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62858,Energy Efficiency,ENERGY,ENERGY,62858,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62898,Energy Efficiency,ENERGY,ENERGY,62898,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62947,Energy Efficiency,ENERGY,ENERGY,62947,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:62985,Energy Efficiency,ENERGY,ENERGY,62985,"2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63027,Energy Efficiency,ENERGY,ENERGY,63027,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63065,Energy Efficiency,ENERGY,ENERGY,63065,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63113,Energy Efficiency,ENERGY,ENERGY,63113,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63155,Energy Efficiency,ENERGY,ENERGY,63155,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63202,Energy Efficiency,ENERGY,ENERGY,63202,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63240,Energy Efficiency,ENERGY,ENERGY,63240,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63278,Energy Efficiency,ENERGY,ENERGY,63278,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63326,Energy Efficiency,ENERGY,ENERGY,63326,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63364,Energy Efficiency,ENERGY,ENERGY,63364,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63404,Energy Efficiency,ENERGY,ENERGY,63404,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63452,Energy Efficiency,ENERGY,ENERGY,63452,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63490,Energy Efficiency,ENERGY,ENERGY,63490,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63530,Energy Efficiency,ENERGY,ENERGY,63530,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63577,Energy Efficiency,ENERGY,ENERGY,63577,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63615,Energy Efficiency,ENERGY,ENERGY,63615,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63653,Energy Efficiency,ENERGY,ENERGY,63653,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63708,Energy Efficiency,ENERGY,ENERGY,63708,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63746,Energy Efficiency,ENERGY,ENERGY,63746,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63793,Energy Efficiency,ENERGY,ENERGY,63793,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63850,Energy Efficiency,ENERGY,ENERGY,63850,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63888,Energy Efficiency,ENERGY,ENERGY,63888,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63928,Energy Efficiency,ENERGY,ENERGY,63928,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:63981,Energy Efficiency,ENERGY,ENERGY,63981,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64033,Energy Efficiency,ENERGY,ENERGY,64033,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64071,Energy Efficiency,ENERGY,ENERGY,64071,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64113,Energy Efficiency,ENERGY,ENERGY,64113,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64151,Energy Efficiency,ENERGY,ENERGY,64151,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64199,Energy Efficiency,ENERGY,ENERGY,64199,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64241,Energy Efficiency,ENERGY,ENERGY,64241,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64289,Energy Efficiency,ENERGY,ENERGY,64289,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64340,Energy Efficiency,ENERGY,ENERGY,64340,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64378,Energy Efficiency,ENERGY,ENERGY,64378,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64418,Energy Efficiency,ENERGY,ENERGY,64418,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64464,Energy Efficiency,ENERGY,ENERGY,64464,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64515,Energy Efficiency,ENERGY,ENERGY,64515,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64553,Energy Efficiency,ENERGY,ENERGY,64553,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64593,Energy Efficiency,ENERGY,ENERGY,64593,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64639,Energy Efficiency,ENERGY,ENERGY,64639,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64687,Energy Efficiency,ENERGY,ENERGY,64687,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64727,Energy Efficiency,ENERGY,ENERGY,64727,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64776,Energy Efficiency,ENERGY,ENERGY,64776,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64818,Energy Efficiency,ENERGY,ENERGY,64818,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64868,Energy Efficiency,ENERGY,ENERGY,64868,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64912,Energy Efficiency,ENERGY,ENERGY,64912,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64959,Energy Efficiency,ENERGY,ENERGY,64959,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:64997,Energy Efficiency,ENERGY,ENERGY,64997,"= { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:65093,Energy Efficiency,ENERGY,ENERGY,65093,"'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:65148,Energy Efficiency,ENERGY,ENERGY,65148,"'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66191,Energy Efficiency,energy,energy,66191,"ect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_global_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Est",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66645,Energy Efficiency,energy,energy,66645,"= PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:67285,Energy Efficiency,energy,energy,67285,orl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + ,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:68456,Energy Efficiency,energy,energy,68456,"t recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_ba",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:68722,Energy Efficiency,energy,energy,68722,"se ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 's",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:69082,Energy Efficiency,energy,energy,69082,"elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. #",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:69373,Energy Efficiency,energy,energy,69373,"2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:69636,Energy Efficiency,energy,energy,69636,"is sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:69846,Energy Efficiency,energy,energy,69846,"se:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:69996,Energy Efficiency,energy,energy,69996,"ablish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if d",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:70151,Energy Efficiency,energy,energy,70151,"basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:70515,Energy Efficiency,energy,energy,70515," long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(dict(zip(d_fields, ['corl', cbs_corl_scheme, reconstitute_bracketed_basis(NEED), cbs_corl_wfn, NEED, +1, 0.0]))). if do_delta:; NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnname=cbs_delta_wfn); GRAND_NEED.append(dict(zip(d_fields, ['delta', cbs_delta_scheme, reconstitute_bracketed_basis(NEED), cbs_delta_wfn, NEED, +1, 0.0]))). NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnn",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:75042,Energy Efficiency,energy,energy,75042,"s for %s\n"""""" % (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']+mc['f_portion']]); PsiMod.print_out(instructions). psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(PSIF_SCF_MOS, True). # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Computation: %s / %s ')\n"""""" % (mc['f_wfn'].upper(), mc['f_basis'].upper()); cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\nPsiMod.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""PsiMod.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()). exec(commands). # Make energy() call; mc['f_energy'] = call_function_in_1st_argument(func, **kwargs). # Fill in energies for subsumed methods; for menial in VARH[mc['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); for job in JOBS_EXT:; if (temp_wfn == job['f_wfn']) and (temp_portion == job['f_portion']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = PsiMod.get_variable(VARH[temp_wfn][menial]). PsiMod.clean(). psioh.set_specific_retention(PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in G",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:76507,Energy Efficiency,Energy,Energy,76507,"False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:77063,Energy Efficiency,Energy,Energy,77063,"ergy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', '', 'Energy [H]', 'Scheme'); tables += table_delimit; if do_scf:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'],; '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme'].__name__); if do_corl:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'],; '/', GRAND_NEED[1]['d_basis'], '', GRAND_NEED[1]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if do_delta:; tables += """""" %6s %20s %1s %-27s ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:77504,Energy Efficiency,Energy,Energy,77504,", 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', '', 'Energy [H]', 'Scheme'); tables += table_delimit; if do_scf:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'],; '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme'].__name__); if do_corl:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'],; '/', GRAND_NEED[1]['d_basis'], '', GRAND_NEED[1]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if do_delta:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[2]['d_stage'], GRAND_NEED[2]['d_wfn'] + ' - ' + GRAND_NEED[3]['d_wfn'],; '/', GRAND_NEED[2]['d_basis'], '', GRAND_NEED[2]['d_energy'] - GRAND_NEED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79127,Energy Efficiency,ENERGY,ENERGY,79127,"_wfn'],; '/', GRAND_NEED[2]['d_basis'], '', GRAND_NEED[2]['d_energy'] - GRAND_NEED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basi",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79201,Energy Efficiency,ENERGY,ENERGY,79201,"ED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrapper",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79283,Energy Efficiency,ENERGY,ENERGY,79283,"tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79345,Energy Efficiency,ENERGY,ENERGY,79345,"D[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79423,Energy Efficiency,ENERGY,ENERGY,79423,"D_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basi",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79503,Energy Efficiency,ENERGY,ENERGY,79503,"], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:82426,Energy Efficiency,energy,energypiece,82426,"z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (s",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83171,Energy Efficiency,energy,energy,83171," + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83179,Energy Efficiency,energy,energypiece,83179," + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83407,Energy Efficiency,Energy,Energy,83407,"n array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'r",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83457,Energy Efficiency,energy,energypiece,83457,".f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (funct",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83520,Energy Efficiency,Energy,Energy,83520,".f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (funct",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83570,Energy Efficiency,energy,energypiece,83570,"mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83620,Energy Efficiency,energy,energypiece,83620,"ionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; '",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:84089,Energy Efficiency,energy,energypiece,84089,"tract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:84929,Energy Efficiency,energy,energy,84929," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionna",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:84937,Energy Efficiency,energy,energypiece,84937," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionna",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:85220,Energy Efficiency,Energy,Energy,85220,".co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:85301,Energy Efficiency,Energy,Energy,85301,"me_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnn",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:85382,Energy Efficiency,Energy,Energy,85382,"s on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:85405,Energy Efficiency,energy,energypiece,85405,"\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0]",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:85520,Energy Efficiency,energy,energypiece,85520," the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:85781,Energy Efficiency,energy,energypiece,85781,"ay; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:86746,Energy Efficiency,energy,energy,86746,"-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:86884,Energy Efficiency,energy,energypiece,86884,"'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_nam",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87099,Energy Efficiency,Energy,Energy,87099," # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87180,Energy Efficiency,Energy,Energy,87180,"s sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87261,Energy Efficiency,Energy,Energy,87261,"s; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Retu",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87342,Energy Efficiency,Energy,Energy,87342,"MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname,",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87365,Energy Efficiency,energy,energypiece,87365,"ct(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87544,Energy Efficiency,energy,energypiece,87544,"y; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy'];",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87818,Energy Efficiency,energy,energypiece,87818," = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); ener",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:88717,Energy Efficiency,energy,energy,88717,"plete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:88819,Energy Efficiency,energy,energypiece,88819,"ypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations nee",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:89034,Energy Efficiency,Energy,Energy,89034,"NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = l",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:89115,Energy Efficiency,Energy,Energy,89115," zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:89196,Energy Efficiency,Energy,Energy,89196,"alid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:89219,Energy Efficiency,energy,energypiece,89219,"hat logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:89398,Energy Efficiency,energy,energypiece,89398,"ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functi",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3,Integrability,wrap,wrappers,3,". wrappers  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule();",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:131,Integrability,wrap,wrappers,131,". wrappers  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule();",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:645,Integrability,wrap,wrappers,645,". wrappers  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule();",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3928,Integrability,Wrap,Wrap,3928,"convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3992,Integrability,wrap,wrappers,3992,"convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:4371,Integrability,wrap,wrapper,4371,"group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:4449,Integrability,Wrap,Wrapper,4449,"ment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:18301,Integrability,Wrap,Wrap,18301," Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inq",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:18365,Integrability,wrap,wrappers,18365," Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inq",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:18728,Integrability,wrap,wrapper,18728,"rforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMo",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:18820,Integrability,Wrap,Wrapper,18820,"bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:25460,Integrability,wrap,wrappers,25460,"|dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-poin",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29225,Integrability,Wrap,Wrap,29225,"-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSear",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29289,Integrability,wrap,wrappers,29289,"-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSear",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29723,Integrability,wrap,wrapper,29723,"mputed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAG",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29803,Integrability,Wrap,Wrapper,29803,">>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:37395,Integrability,wrap,wrapper,37395,"('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comp",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:39054,Integrability,wrap,wrapper,39054,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(format_molecule_for_input(GEOS[rgt])); molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); b",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:39252,Integrability,wrap,wrapper,39252,"n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(format_molecule_for_input(GEOS[rgt])); molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); fo",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:41215,Integrability,wrap,wrapper,41215,"ctives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_global_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:41288,Integrability,depend,dependent,41288,"tives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_global_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:44210,Integrability,wrap,wrapper,44210,"ec(format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); PsiMod.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], PsiMod.get_variable('NUCLEAR REPULSION ENERGY'), ; 4, '%s %.4f' % (rgt, PsiMod.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:47503,Integrability,Depend,Depending,47503," PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minD",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:59976,Integrability,Wrap,Wrap,59976,"orrection atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENE",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60040,Integrability,wrap,wrappers,60040,"orrection atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENE",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60441,Integrability,wrap,wrapper,60441,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATIO",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60538,Integrability,Wrap,Wrapper,60538," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66562,Integrability,wrap,wrapper,66562,"siMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66869,Integrability,wrap,wrapper,66869,"LE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:67187,Integrability,wrap,wrapper,67187,rrelation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:67515,Integrability,wrap,wrapper,67515,"L method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC,",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:67840,Integrability,wrap,wrapper,67840," not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:74691,Integrability,depend,dependent,74691,"= []; for indx_job, job in enumerate(JOBS):; for menial in VARH[job['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); JOBS_EXT.append(dict(zip(f_fields, [temp_wfn, temp_portion, job['f_basis'], job['f_zeta'], 0.0]))). #instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; #for mc in JOBS_EXT:; # instructions += """""" %12s / %-24s for %s\n"""""" % (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']+mc['f_portion']]); PsiMod.print_out(instructions). psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(PSIF_SCF_MOS, True). # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Computation: %s / %s ')\n"""""" % (mc['f_wfn'].upper(), mc['f_basis'].upper()); cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\nPsiMod.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""PsiMod.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()). exec(commands). # Make energy() call; mc['f_energy'] = call_function_in_1st_argument(func, **kwargs). # Fill in energies for subsumed methods; for menial in VARH[mc['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); for job in JOBS_EXT:; if (temp_wfn == job['f_wfn']) and (temp_portion == job['f_portion']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = PsiMod.get_variable(VARH[temp_wfn][menial]). PsiMod.clean(). psioh.set_specific_retention(PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:80208,Integrability,wrap,wrappers,80208,"NERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:81563,Integrability,wrap,wrappers,81563," ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_por",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:82354,Integrability,wrap,wrappers,82354,"eted basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:83997,Integrability,wrap,wrappers,83997,"rtion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:85680,Integrability,wrap,wrappers,85680,"SET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = N",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:87702,Integrability,wrap,wrappers,87702,"LO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. #",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:89530,Integrability,wrap,wrappers,89530,"red energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:91269,Integrability,wrap,wrappers,91269,"if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:891,Modifiability,variab,variable,891,". wrappers  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule();",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:4821,Modifiability,config,configuration,4821,"(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf;",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:16587,Modifiability,variab,variables,16587," ""Delta E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_bsse[Ns[k]] - energies_n_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and `",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:16987,Modifiability,variab,variables,16987,"ean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basi",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:22813,Modifiability,variab,variables,22813,"):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:23752,Modifiability,variab,variable,23752,"; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:26953,Modifiability,variab,variables,26953,":`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]``",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:27027,Modifiability,variab,variable,27027,"|| ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:27159,Modifiability,flexible,flexible,27159,"e computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is c",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:31340,Modifiability,Config,Configuration,31340,"ror(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:32011,Modifiability,Config,Configuration,32011,"ER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:35176,Modifiability,variab,variables,35176,"tr(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getatt",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:45057,Modifiability,variab,variable,45057,"elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:45084,Modifiability,variab,variable,45084,"reagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:46404,Modifiability,variab,variable,46404,"ror:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' val",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:46571,Modifiability,variab,variable,46571,"; else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:47276,Modifiability,variab,variables,47276," %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACT",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:47310,Modifiability,VARIAB,VARIABLE,47310," %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACT",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:47534,Modifiability,variab,variable,47534," PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minD",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:48490,Modifiability,variab,variable,48490,""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error)",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:52557,Modifiability,variab,variables,52557,"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the corr",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53047,Modifiability,variab,variables,53047,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53058,Modifiability,config,configuration,53058,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:76521,Modifiability,Variab,Variable,76521,"False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:260,Performance,optimiz,optimize,260,". wrappers  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule();",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:667,Performance,optimiz,optimize,667,". wrappers  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule();",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:2243,Performance,Queue,Queue,2243,"287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # li",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:2559,Performance,Queue,Queue,2559,"symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:2644,Performance,Queue,Queue,2644,"):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:2701,Performance,Queue,Queue,2701,"):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:2748,Performance,Queue,Queue,2748,"):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3013,Performance,Queue,Queue,3013,"del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any p",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3124,Performance,Queue,Queue,3124," [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3160,Performance,Queue,Queue,3160,"mbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwar",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3325,Performance,Queue,Queue,3325,"numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationErr",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:3349,Performance,Queue,Queue,3349,"numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationErr",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:7200,Performance,LOAD,LOAD,7200,"BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # Append the current combo; combos[n].append(copy.deepcopy(reals)). #reset rank; rank = 0. #look for lexical promotion opportunity; #i.e.: [4 2 1] has a promotion opportunity at; # index 1 to produce [4 3 1]; for k in range(n - 2, -1, -1):; if (reals[k] != reals[k + 1] + 1):; rank = k + 1; break. #do the promotion; reals[rank] = reals[rank] + 1. #demote the right p",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:9232,Performance,LOAD,LOAD,9232," for k in range(n - 1, rank, -1):; reals[k] = val; val = val + 1. #boundary condition is promotion into; #[nfrag+1 nfrag-1 ...]; if (reals[0] > N):; break. # Hack for external; externNone = PsiMod.ExternalPotential(). # Run the clusters in the full basis; if bsse == 'on' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_full[n] = []; clusters = extract_clusters(molecule, True, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). # Run the clusters in the minimal cluster bases; PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.clean(). # Report the energies; PsiMod.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). PsiMod.print_out(' ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:17344,Performance,optimiz,optimize,17344,"e cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any po",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:17407,Performance,perform,performed,17407,"of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:17472,Performance,perform,performs,17472,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:17525,Performance,optimiz,optimize,17525,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:17555,Performance,optimiz,optimization,17555,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:17597,Performance,perform,performs,17597,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:19844,Performance,LOAD,LOAD,19844,"nterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_globa",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:24454,Performance,optimiz,optimize,24454,"ot yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:24517,Performance,perform,performed,24517," (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:24565,Performance,perform,performs,24565,"dded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:24618,Performance,optimiz,optimize,24618,"dded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:24648,Performance,optimiz,optimization,24648,"dded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:24691,Performance,perform,performs,24691,"dded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:28815,Performance,Optimiz,Optimize,28815,"r available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within databas",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:28917,Performance,optimiz,optimize,28917,"r available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within databas",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29945,Performance,load,load,29945,"tal energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:30242,Performance,load,load,30242,"ny positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_gl",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:30405,Performance,load,loading,30405,"db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:44470,Performance,load,loads,44470,"'NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], PsiMod.get_variable('NUCLEAR REPULSION ENERGY'), ; 4, '%s %.4f' % (rgt, PsiMod.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (r",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54729,Performance,perform,performed,54729,"s only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:90795,Performance,perform,performs,90795,"tion fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exist",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:1599,Safety,detect,detect,1599,"calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:1738,Safety,Detect,Detects,1738,"args):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment;",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:4307,Security,Validat,ValidationError,4307,"group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:4432,Security,Validat,ValidationError,4432,"ment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:5385,Security,Validat,ValidationError,5385,"aise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (extern",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:5480,Security,Validat,ValidationError,5480,"aise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (extern",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:5584,Security,Validat,ValidationError,5584,"vate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if r",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:18664,Security,Validat,ValidationError,18664,"rforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMo",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:18803,Security,Validat,ValidationError,18803,"bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:22636,Security,access,access,22636,"ster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:23171,Security,access,accessible,23171,"e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:23607,Security,access,access,23607,"; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29659,Security,Validat,ValidationError,29659,"mputed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAG",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29786,Security,Validat,ValidationError,29786,">>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASI",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:30374,Security,Validat,ValidationError,30374,"db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:31518,Security,Validat,ValidationError,31518,"base.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:32353,Security,Validat,ValidationError,32353,"sed upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); els",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:32862,Security,Validat,ValidationError,32862,shell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation ,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:32955,Security,Validat,ValidationError,32955,F/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM ,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:33260,Security,Validat,ValidationError,33260, symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deform,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:33433,Security,Validat,ValidationError,33433,whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if ,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:33826,Security,Validat,ValidationError,33826,e:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in,MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:34082,Security,Validat,ValidationError,34082,"bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for data",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:34257,Security,Validat,ValidationError,34257,"ionError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kw",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:34521,Security,Validat,ValidationError,34521,"-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HR",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:34645,Security,Validat,ValidationError,34645,"n kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' %",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:35037,Security,Validat,ValidationError,35037,"(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise V",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:35581,Security,Validat,ValidationError,35581,"elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:35793,Security,Validat,ValidationError,35793,"db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name)",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:36011,Security,Validat,ValidationError,36011," raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructi",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:36292,Security,Validat,ValidationError,36292," []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:36477,Security,Validat,ValidationError,36477,"_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:37339,Security,access,accessed,37339,"('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comp",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:38998,Security,access,accessed,38998,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(format_molecule_for_input(GEOS[rgt])); molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); b",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:41106,Security,Validat,ValidationError,41106,"ctives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_global_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:45956,Security,Validat,ValidationError,45956,"late:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:46114,Security,Validat,ValidationError,46114," % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60377,Security,Validat,ValidationError,60377,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATIO",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60521,Security,Validat,ValidationError,60521," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66479,Security,Validat,ValidationError,66479,"Mod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66785,Security,Validat,ValidationError,66785,"riter_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:67096,Security,Validat,ValidationError,67096,"od.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:67430,Security,Validat,ValidationError,67430,"in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:67748,Security,Validat,ValidationError,67748,":; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validat",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:68243,Security,Validat,ValidationError,68243,"or('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'de",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:68587,Security,Validat,ValidationError,68587,"lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Es",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:68890,Security,Validat,ValidationError,68890,"er)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if '",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:69216,Security,Validat,ValidationError,69216,"ise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme =",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:69512,Security,Validat,ValidationError,69512,"_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orde",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79562,Security,validat,validate,79562,"rgy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79716,Security,validat,validate,79716,"rgy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:80519,Security,Validat,ValidationError,80519,"finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NE",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:80685,Security,Validat,ValidationError,80685,"orm and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:80997,Security,Validat,ValidationError,80997,"' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetain",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:82738,Security,Validat,ValidationError,82738," [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:84401,Security,Validat,ValidationError,84401,") Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n""",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:86093,Security,Validat,ValidationError,86093,"ion parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Corr",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:88130,Security,Validat,ValidationError,88130,"O), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:89990,Security,Validat,ValidationError,89990,"); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Ca",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:90144,Security,Validat,ValidationError,90144,"sscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionnam",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:90310,Security,Validat,ValidationError,90310,"ficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scft",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:90476,Security,Validat,ValidationError,90476,"tion called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:90629,Security,Validat,ValidationError,90629,"t; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except Name",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:90970,Security,Validat,ValidationError,90970,"ame']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:91069,Security,Validat,ValidationError,91069," functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. m",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:16931,Testability,test,tested,16931,"_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:26556,Testability,benchmark,benchmark,26556," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:26582,Testability,benchmark,benchmark,26582," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:28606,Testability,benchmark,benchmark,28606,"librium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:28673,Testability,benchmark,benchmark,28673,"librium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; k",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:34730,Testability,benchmark,benchmark,34730,"buteError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:34839,Testability,benchmark,benchmark,34839,"buteError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:34885,Testability,benchmark,benchmark,34885,"buteError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:35062,Testability,benchmark,benchmark,35062,"(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise V",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:39347,Testability,benchmark,benchmark,39347,"ut file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(format_molecule_for_input(GEOS[rgt])); molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:39662,Testability,log,logic,39662,"al in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(format_molecule_for_input(GEOS[rgt])); molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_glo",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:82855,Testability,log,logs,82855,"= BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energi",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:84518,Testability,log,logs,84518,"']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helg",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:86210,Testability,log,logs,86210,"zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:86807,Testability,log,log,86807,"me().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypie",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:88247,Testability,log,logs,88247,"str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n""""",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:50869,Usability,clear,clear,50869,"""""""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:50906,Usability,clear,clear,50906,"ev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:51327,Usability,simpl,simple,51327,"DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define ",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58449,Usability,simpl,simple,58449,"est_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:58591,Usability,simpl,simple,58591,"e: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4manual/4.0b4/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/dbproc.html:428,Deployability,update,updated,428,". qcdb.dbproc  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.dbproc; r""""""File to. """""". [docs]def useful():; pass. [docs]def dictify_database_docstrings():; pass. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:248,Availability,Error,Error,248,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:334,Availability,Error,Error,334,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:658,Availability,Error,Error,658,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:716,Availability,error,error,716,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:939,Availability,Error,Error,939,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:1119,Availability,error,error,1119,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:1405,Deployability,update,updated,1405,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:722,Integrability,message,message,722,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:1069,Integrability,message,message,1069,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:965,Modifiability,variab,variables,965,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html:622,Security,Validat,ValidationError,622,". qcdb.exceptions  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.exceptions; """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:5175,Availability,ERROR,ERROR,5175,"n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(D",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:5427,Availability,ERROR,ERROR,5427,"n full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:5905,Availability,ERROR,ERROR,5905,"); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:8524,Deployability,update,updates,8524,"s = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(10); ystr = self.y.variable_to_string(10); zstr = self.z.variable_to_string(10); return ""\t%16s %16s %16s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Typ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:8912,Deployability,update,updated,8912,"init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(10); ystr = self.y.variable_to_string(10); zstr = self.z.variable_to_string(10); return ""\t%16s %16s %16s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rv",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:10425,Deployability,update,updated,10425,". [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\t%s\n"" % (self.symbol()); elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += ""\t%s %5d %s %5d %s\n"" % (self.symbol(), now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:11617,Deployability,update,updates,11617,"lf.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += ""\t%s %5d %s %5d %s\n"" % (self.symbol(), now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (self.symbol(), now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:12652,Deployability,update,update,12652,"ariables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.compute(). # place third atom pointing upwards; # this rTo rVal aTo aVal; # A B C; elif self.dto == None:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; cosABC =",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:15597,Deployability,update,updated,15597,"pi / 180.0; cosABC = math.cos(a); sinABC = math.sin(a); B = self.rto.compute(); C = self.ato.compute(). eCB = sub(B, C); eCB = normalize(eCB); eX = [0.0, 0.0, 0.0]; eY = [0.0, 0.0, 0.0]; if (math.fabs(1.0 - math.fabs(eCB[0])) < 1.0E-5):; # CB is collinear with X, start by finding Y; eY[1] = 1.0; eX = perp_unit(eY, eCB); eY = perp_unit(eX, eCB); else:; # CB is not collinear with X, we can safely find X first; eX[0] = 1.0; eY = perp_unit(eX, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eY[xyz] * sinABC - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. # The fourth, or subsequent, atom; #; # The atom specification is; # this rTo rVal aTo aVal dTo dVal; # A B C D; # which allows us to define the vector from C->B (eCB) as the +z axis, and eDC; # lies in the xz plane. Then eX, eY and eZ (=eBC) are the x, y, and z axes, respecively.; else:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; d = self.dval.compute() * math.pi / 180.0; B = self.rto.compute(); C = self.ato.compute(); D = self.dto.compute(). eDC = sub(C, D); eCB = sub(B, C); eDC = normalize(eDC); eCB = normalize(eCB); cosABC = math.cos(a); sinABC = math.sin(a); cosABCD = math.cos(d); sinABCD = math.sin(d); eY = perp_unit(eDC, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eX[xyz] * sinABC * cosABCD +; eY[xyz] * sinABC * sinABCD - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. self.computed = True; return self.coordinates. [docs] def everything(self):; CoordEntry.everything(self); print '\nZMatrixEntry\n Type = %s\n\n' % (self.type()); print self.print_in_input_format(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:4419,Energy Efficiency,charge,charge,4419,"set(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:4715,Energy Efficiency,Charge,Charge,4715,"docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:4765,Energy Efficiency,charge,charge,4765,"dent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:6841,Energy Efficiency,charge,charge,6841,"!= 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, includ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:6953,Energy Efficiency,charge,charge,6953,"CB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordE",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:6983,Energy Efficiency,charge,charge,6983,"CB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordE",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:7507,Energy Efficiency,Charge,Charge,7507,"s != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set o",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:7659,Energy Efficiency,charge,charge,7659,"osted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:7940,Energy Efficiency,charge,charge,7940,"ocs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format p",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:8023,Energy Efficiency,charge,charge,8023,"oses).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(10); ystr = self.y.var",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:9867,Energy Efficiency,charge,charge,9867,":; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(10); ystr = self.y.variable_to_string(10); zstr = self.z.variable_to_string(10); return ""\t%16s %16s %16s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\t%s\n"" % (self.symbol()); elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:9998,Energy Efficiency,charge,charge,9998,"ing(10); ystr = self.y.variable_to_string(10); zstr = self.z.variable_to_string(10); return ""\t%16s %16s %16s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\t%s\n"" % (self.symbol()); elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:2424,Integrability,depend,depends,2424,"t__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:8598,Integrability,depend,depend,8598,"s = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(10); ystr = self.y.variable_to_string(10); zstr = self.z.variable_to_string(10); return ""\t%16s %16s %16s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Typ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:11692,Integrability,depend,depend,11692,"lf.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += ""\t%s %5d %s %5d %s\n"" % (self.symbol(), now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (self.symbol(), now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:591,Modifiability,variab,variables,591,". qcdb.libmintscoordentry  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.libmintscoordentry; r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordV",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:2339,Modifiability,Variab,VariableValue,2339,"t__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:2616,Modifiability,variab,variable,2616," return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometr",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:2676,Modifiability,variab,variable,2676,"of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets spe",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:2810,Modifiability,variab,variable,2810,"ts specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, i",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:3023,Modifiability,Variab,Variable,3023,"inting.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everythin",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:3300,Modifiability,variab,variable,3300,"uted, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:3387,Modifiability,variab,variable,3387,"alization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class t",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:3713,Modifiability,Variab,VariableType,3713,"able names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic nu",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:3781,Modifiability,Variab,VariableValue,3781,"value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:8579,Modifiability,variab,variables,8579,"s = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(10); ystr = self.y.variable_to_string(10); zstr = self.z.variable_to_string(10); return ""\t%16s %16s %16s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Typ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:11673,Modifiability,variab,variables,11673,"lf.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += ""\t%s %5d %s %5d %s\n"" % (self.symbol(), now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (self.symbol(), now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:14045,Safety,safe,safely,14045,"f):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.compute(). # place third atom pointing upwards; # this rTo rVal aTo aVal; # A B C; elif self.dto == None:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; cosABC = math.cos(a); sinABC = math.sin(a); B = self.rto.compute(); C = self.ato.compute(). eCB = sub(B, C); eCB = normalize(eCB); eX = [0.0, 0.0, 0.0]; eY = [0.0, 0.0, 0.0]; if (math.fabs(1.0 - math.fabs(eCB[0])) < 1.0E-5):; # CB is collinear with X, start by finding Y; eY[1] = 1.0; eX = perp_unit(eY, eCB); eY = perp_unit(eX, eCB); else:; # CB is not collinear with X, we can safely find X first; eX[0] = 1.0; eY = perp_unit(eX, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eY[xyz] * sinABC - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. # The fourth, or subsequent, atom; #; # The atom specification is; # this rTo rVal aTo aVal dTo dVal; # A B C D; # which allows us to define the vector from C->B (eCB) as the +z axis, and eDC; # lies in the xz plane. Then eX, eY and eZ (=eBC) are the x, y, and z axes, respecively.; else:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; d = self.dval.compute() * math.pi / 180.0; B = self.rto.compute(); C = self.ato.compute(); D = self.dto.compute(). eDC = sub(C, D); eCB = sub(B, C); eDC = normalize(eDC); eCB = normalize(eCB); cosABC = math.cos(a); sinABC = math.sin(a); cosABCD = math.cos(d); sinABCD = math.sin(d); eY = perp_unit(eDC, eCB); eX = perp_unit(eY, eCB); for xyz in range",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:5158,Security,Validat,ValidationError,5158,"n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(D",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:5410,Security,Validat,ValidationError,5410,"n full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:5888,Security,Validat,ValidationError,5888,"); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:11951,Security,Validat,ValidationError,11951,"r() + 1; now_aval = self.aval.variable_to_string(6); text += ""\t%s %5d %s %5d %s\n"" % (self.symbol(), now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (self.symbol(), now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.d",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:12138,Security,Validat,ValidationError,12138,"y_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (self.symbol(), now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origi",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:12468,Security,Validat,ValidationError,12468,", now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.comp",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:634,Usability,simpl,simplifying,634,". qcdb.libmintscoordentry  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.libmintscoordentry; r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordV",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:1363,Usability,simpl,simply,1363,"s by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:17489,Availability,Error,Error,17489,"bel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X'",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:17985,Availability,Error,Error,17985,"(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:18165,Availability,Error,Error,18165,"# handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:18886,Availability,Error,Error,18886,"s) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:19066,Availability,Error,Error,19066,"ed yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specific",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:19246,Availability,Error,Error,19246,"ed yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Re",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:27595,Availability,echo,echoing,27595,"tom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(),",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:30897,Availability,toler,tolerance,30897,"y_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, v",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31091,Availability,ERROR,ERROR,31091,"c symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Set",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31776,Availability,ERROR,ERROR,31776,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:33155,Availability,error,error,33155,"), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [d",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:54404,Availability,checkpoint,checkpoint,54404,"le. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = '%d\n' % (self.natom()); text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.name()). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""Gh""), \; x * factor, y * factor, z * factor); return text. [docs] def save_xyz(self, filename):; """"""Save an XYZ file. >>> H2OH2O.save_xyz('h2o.xyz'). """"""; outfile = open(filename, 'w'); outfile.write(self.save_string_xyz()); outfile.close(). [docs] def save_to_checkpoint(self, chkpt, prefix=""""):; """""" **NYI** Save information to checkpoint file; (method name in libmints is save_to_chkpt). """"""; raise FeatureNotImplemented('Molecule::save_to_checkpoint') # FINAL. # <<< Methods for Symmetry >>>. [docs] def has_symmetry_element(self, op, tol=DEFAULT_SYM_TOL):; """""" **NYI** Whether molecule satisfies the vector symmetry operation *op* """"""; raise FeatureNotImplemented('Molecule::has_symmetry_element') # FINAL SYMM. [docs] def point_group(self):; """""" **NYI** Returns the point group (object) if set""""""; raise FeatureNotImplemented('Molecule::point_group') # FINAL SYMM. [docs] def set_point_group(self, pg):; """""" **NYI** Set the point group to object *pg* """"""; raise FeatureNotImplemented('Molecule::set_point_group') # FINAL SYMM. [docs] def set_full_point_group(self, tol=FULL_PG_TOL):; """""" **NYI** Determine and set FULL point group""""""; raise FeatureNotImplemented('Molecule::set_full_point_group') # FINAL SYMM. [docs] def has_inversion(self, origin, tol=DEFAULT_SYM_TOL):; """"""Does the molecule have an inversio",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:32221,Deployability,Update,Update,32221,") < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based co",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:41896,Deployability,Update,Updates,41896,"; self.atoms = []; for item in self.full_atoms:; item.invalidate(). temp_charge = self.PYmolecular_charge; temp_multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_fra",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:43274,Deployability,update,updated,43274,"tom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nucle",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:53225,Deployability,release,release,53225,"[0,-1,0],[-1,0,0],[0,0,1]]). """"""; new_geom = zero(3, self.nallatom()); geom = self.full_geometry(); new_geom = mult(geom, R); self.set_full_geometry(new_geom). [docs] def orientation_fixed(self):; """"""Get whether or not orientation is fixed. >>> H2OH2O.orientation_fixed(); True. """"""; return self.PYfix_orientation. [docs] def fix_orientation(self, _fix=True):; """"""Fix the orientation at its current frame; (method name in libmints is set_orientation_fixed). """"""; if _fix:; self.PYfix_orientation = True # tells update_geometry() not to change orientation; # Compute original cartesian coordinates - code coped from update_geometry(); self.atoms = []; for item in self.full_atoms:; item.invalidate(). for fr in range(self.nfragments()):; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]); else: # release orientation to be free; self.PYfix_orientation = False. # <<< Methods for Saving >>>. [docs] def save_string_xyz(self):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = '%d\n' % (self.natom()); text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.name()). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""Gh""), \; x * factor, y * factor, z * factor); return text. [docs] def save_xyz(self, filename):; """"""Save an XYZ file. >>> H2OH2O.save_xyz('h2o.xyz'). """"""; ou",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:67245,Deployability,Release,Release,67245," do; xaxis = perp_unit(zaxis, zaxis); elif have_sigma:; zaxis = copy.deepcopy(sigma); xaxis = perp_unit(zaxis, zaxis). # Clean up our z axis; if math.fabs(zaxis[0]) < NOISY_ZERO:; zaxis[0] = 0.0; if math.fabs(zaxis[1]) < NOISY_ZERO:; zaxis[1] = 0.0; if math.fabs(zaxis[2]) < NOISY_ZERO:; zaxis[2] = 0.0. # Clean up our x axis; if math.fabs(xaxis[0]) < NOISY_ZERO:; xaxis[0] = 0.0; if math.fabs(xaxis[1]) < NOISY_ZERO:; xaxis[1] = 0.0; if math.fabs(xaxis[2]) < NOISY_ZERO:; xaxis[2] = 0.0. # the y is then -x cross z; yaxis = scale(cross(xaxis, zaxis), -1.0). #print ""xaxis %20.14lf %20.14lf %20.14lf"" % (xaxis[0], xaxis[1], xaxis[2]); #print ""yaxis %20.14lf %20.14lf %20.14lf"" % (yaxis[0], yaxis[1], yaxis[2]); #print ""zaxis %20.14lf %20.14lf %20.14lf"" % (zaxis[0], zaxis[1], zaxis[2]). frame = zero(3, 3); for i in range(3):; frame[i][0] = xaxis[i]; frame[i][1] = yaxis[i]; frame[i][2] = zaxis[i]; return frame. [docs] def release_symmetry_information(self):; """""" **NYI** Release symmetry information""""""; raise FeatureNotImplemented('Molecule::release_symmetry_information') # FINAL SYMM. [docs] def form_symmetry_information(self, tol=DEFAULT_SYM_TOL):; """""" **NYI** Initialize molecular specific symmetry information.; Uses the point group object obtain by calling point_group(). """"""; raise FeatureNotImplemented('Molecule::form_symmetry_information') # FINAL SYMM. [docs] def sym_label(self):; """""" **NYI** Returns the symmetry label""""""; raise FeatureNotImplemented('Molecule::sym_label') # FINAL SYMM. [docs] def irrep_labels(self):; """""" **NYI** Returns the irrep labels""""""; raise FeatureNotImplemented('Molecule::irrep_labels') # FINAL SYMM. [docs] def symmetry_from_input(self):; """"""Returns the symmetry specified in the input. >>> print H2OH2O.symmetry_from_input(); C1. """"""; return self.PYsymmetry_from_input. [docs] def symmetrize(self):; """""" **NYI** Force the molecule to have the symmetry specified in pg.; This is to handle noise coming in from optking. """"""; raise FeatureNotImplemented('Mo",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:71234,Deployability,update,updated,71234,"_group') # FINAL SYMM. # <<< Methods for Uniqueness >>> (assume molecular point group has been determined). [docs] def nunique(self):; """""" **NYI** Return the number of unique atoms.""""""; #w#return PYnunique; raise FeatureNotImplemented('Molecule::nunique') # FINAL SYMM. [docs] def unique(self, iuniq):; """""" **NYI** Returns the overall number of the iuniq'th unique atom.""""""; #w#return self.equiv[iuniq][0]; raise FeatureNotImplemented('Molecule::unique') # FINAL SYMM. [docs] def nequivalent(self, iuniq):; """""" **NYI** Returns the number of atoms equivalent to iuniq.""""""; #w#return self.nequiv[iuniq]; raise FeatureNotImplemented('Molecule::nequivalent') # FINAL SYMM. [docs] def equivalent(self, iuniq, j):; """""" **NYI** Returns the j'th atom equivalent to iuniq.""""""; #w#return self.equiv[iuniq][j]; raise FeatureNotImplemented('Molecule::equivalent') # FINAL SYMM. [docs] def atom_to_unique(self, iatom):; """""" **NYI** Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). """"""; #w#return PYatom_to_unique[iatom]; raise FeatureNotImplemented('Molecule::atom_to_unique') # FINAL SYMM. [docs] def atom_to_unique_offset(self, iatom):; """""" **NYI** Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. """"""; raise FeatureNotImplemented('Molecule::atom_to_unique_offset') # FINAL SYMM. [docs] def max_nequivalent(self):; """""" **NYI** Returns the maximum number of equivalent atoms.""""""; raise FeatureNotImplemented('Molecule::max_nequivalent') # FINAL SYMM. # TODO outfile; # ignored =, +, 0, += assignment operators; # no pubchem; # no symmetry; # TODO rename save_string_for_psi4; # TODO add no_com no_reorint in save string for psi4. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:632,Energy Efficiency,charge,charge,632,". qcdb.libmintsmolecule  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.libmintsmolecule; import os; import re; import math; import copy; from periodictable import *; from physconst import *; from vecutil import *; from exceptions import *; from libmintscoordentry import *. LINEAR_A_TOL = 1.0E-2 # When sin(a) is below this, we consider the angle to be linear; DEFAULT_SYM_TOL = 1.0E-8; FULL_PG_TOL = 1.0e-8; ZERO = 1.0E-14; NOISY_ZERO = 1.0E-8. [docs]class LibmintsMolecule(object):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney with incremental; improvements by other psi4 developers. Major differences from the C++; class are: no basisset handling, no symmetry, no pubchem. This class; translated so that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:1694,Energy Efficiency,charge,charge,1694,"ates psi4's libmints; Molecule class, developed by Justin M. Turney with incremental; improvements by other psi4 developers. Major differences from the C++; class are: no basisset handling, no symmetry, no pubchem. This class; translated so that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = [];",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:1745,Energy Efficiency,charge,charge,1745,"ey with incremental; improvements by other psi4 developers. Major differences from the C++; class are: no basisset handling, no symmetry, no pubchem. This class; translated so that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # Th",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:2690,Energy Efficiency,charge,charge,2690,"ar charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to uni",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:4401,Energy Efficiency,charge,charge,4401,"rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(sel",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:4525,Energy Efficiency,charge,charge,4525,"oms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:4557,Energy Efficiency,charge,charge,4557,"oms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:4665,Energy Efficiency,charge,charge,4665,"ray; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise Validat",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:4724,Energy Efficiency,charge,charge,4724,"ay (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'An",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:5817,Energy Efficiency,charge,charge,5817,"lf.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, ato",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:7097,Energy Efficiency,charge,charge,7097,"mpute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[ato",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:7570,Energy Efficiency,charge,charge,7570,"(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dum",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:7602,Energy Efficiency,charge,charge,7602,"(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dum",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:7690,Energy Efficiency,charge,charge,7690,"compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:7735,Energy Efficiency,charge,charge,7735," >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_uni",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:7784,Energy Efficiency,charge,charge,7784,"emp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):;",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:9374,Energy Efficiency,charge,charge,9374,"r. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; print 'it lives', 'activate all'; for fr in range(self.nfragments()):; print 'reviving', fr; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:9531,Energy Efficiency,charge,charge,9531,"x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; print 'it lives', 'activate all'; for fr in range(self.nfragments()):; print 'reviving', fr; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags the fragments in array *reals* as composed of real atoms.""""""; self.lock_frame = False; for fr in reals:; ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:14937,Energy Efficiency,charge,charge,14937,"it('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; for line in glines:. # handle fragment marke",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:16766,Energy Efficiency,charge,charge,16766,"ugh the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabe",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:16813,Energy Efficiency,charge,charge,16813,"ugh the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabe",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:17069,Energy Efficiency,charge,charge,17069,"]. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:17270,Energy Efficiency,charge,charge,17270,"; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:17736,Energy Efficiency,charge,charge,17736,"= el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat;",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:18605,Energy Efficiency,charge,charge,18605,"2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_ato",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:19843,Energy Efficiency,charge,charge,19843,"atom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:23411,Energy Efficiency,charge,charge,23411," fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:24081,Energy Efficiency,charge,charge,24081,"e_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_in_bohr). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:25056,Energy Efficiency,charge,charge,25056,"ext += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_in_bohr). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:25985,Energy Efficiency,charge,charge,25985,""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """"""",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:26865,Energy Efficiency,charge,charge,26865,"DO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:28381,Energy Efficiency,charge,charge,28381,"ile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(flo",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:29938,Energy Efficiency,charge,charge,29938,"ts %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_po",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:30158,Energy Efficiency,charge,charge,30158,"ue(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERRO",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:30166,Energy Efficiency,charge,charge,30166,"ue(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERRO",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:30432,Energy Efficiency,charge,charge,30432,"TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper()",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:43967,Energy Efficiency,energy,energy,43967,"y_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:44325,Energy Efficiency,energy,energy,44325,"frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i) - self.x(j)) * Zi * Zj / temp; entry[1] -= (self.y(i) - self.y(j)) * Zi * Zj / temp; entry[2] -= (self.z(i) - self.z(j)) * Zi * Zj / temp; de.append(entry); return de. [docs] def nuclear_repulsion_energy_deriv2(self):; """""" **NYI** Computes nuclear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2'",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:45193,Energy Efficiency,energy,energy,45193,"yz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i) - self.x(j)) * Zi * Zj / temp; entry[1] -= (self.y(i) - self.y(j)) * Zi * Zj / temp; entry[2] -= (self.z(i) - self.z(j)) * Zi * Zj / temp; de.append(entry); return de. [docs] def nuclear_repulsion_energy_deriv2(self):; """""" **NYI** Computes nuclear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2') # FINAL. [docs] def set_basis_all_atoms(self, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms.""""""; raise FeatureNotImplemented('Molecule::set_basis_all_atoms') # FINAL. [docs] def set_basis_by_symbol(self, symbol, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all *symbol* atoms.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_symbol') # FINAL. [docs] def set_basis_by_number(self, number, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to atom number *number* (1-indexed, includes dummies).""""""; raise FeatureNotImplemented('Molecule::set_basis_by_number') # FINAL. [docs] def set_basis_by_label(self, label, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=""SMALL""):; """"""Number of frozen core for molecule given fre",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:11247,Integrability,Wrap,Wrapper,11247,"_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags the fragments in array *reals* as composed of real atoms.""""""; self.lock_frame = False; for fr in reals:; self.fragment_types[fr - 1] = 'Real'. [docs] def set_ghost_fragment(self, fr):; """"""Tags fragment index *fr* as composed of ghost atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Ghost'. [docs] def set_ghost_fragments(self, ghosts):; """"""Tags the fragments in array *ghosts* as composed of ghost atoms.""""""; self.lock_frame = False; print 'doomed', ghosts; for fr in ghosts:; print 'killing', fr - 1; self.fragment_types[fr - 1] = 'Ghost'. [docs] def deactivate_all_fragments(self):; """"""Sets all fragments in the molecule to be inactive.""""""; self.lock_frame = False; for fr in range(self.nfragments()):; self.fragment_types[fr] = 'Absent'. [docs] def extract_subsets(self, reals, ghosts=[]):; """"""Wrapper for :py:func:`~qcdb.molecule.extract_fragments`.; See note there. This function can be used as long as not; in psi4 input file. Use extract_fragments directly, then. >>> H2OH2O.extract_subsets(2) # monomer B, unCP-corrected; >>> H2OH2O.extract_subsets(2,1) # monomer B, CP-corrected; >>> obj.extract_subsets(1,[2,3]) # monomer A, CP-corrected if obj is tri-molecular complex. """"""; return self.extract_fragments(reals, ghosts=[]). [docs] def extract_fragments(self, reals, ghosts=[]):; """"""Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; *reals*: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; *ghosts*: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise t",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:33161,Integrability,message,message,33161,"), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [d",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:42073,Integrability,rout,routine,42073,"multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rath",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:2324,Modifiability,variab,variables,2324,"o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; s",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:2421,Modifiability,variab,variables,2421,", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # S",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:13778,Modifiability,variab,variable,13778,"ubset.set_active_fragment(fr + 1) # the active fragment code subtracts 1; for fr in lghosts:; subset.set_ghost_fragment(fr + 1) # the ghost fragment code subtracts 1. subset.update_geometry(); return subset. # <<< Methods for Construction >>>. [docs] def create_molecule_from_string(self, text):; """"""Given a string *geom* of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. """"""; comment = re.compile(r'^\s*#'); blank = re.compile(r'^\s*$'); bohr = re.compile(r'^\s*units?[\s=]+(bohr|au|a.u.)\s*$', re.IGNORECASE); ang = re.compile(r'^\s*units?[\s=]+(ang|angstrom)\s*$', re.IGNORECASE); orient = re.compile(r'^\s*(no_reorient|noreorient)\s*$', re.IGNORECASE); com = re.compile(r'^\s*(no_com|nocom)\s*$', re.IGNORECASE); symmetry = re.compile(r'^\s*symmetry[\s=]+(\w+)\s*$', re.IGNORECASE); atom = re.compile(r'^\s*(@?[A-Z]{1,2})\s*', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:14675,Modifiability,variab,variables,14675,"e.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifr",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:14691,Modifiability,variab,variable,14691,"e.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifr",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:14722,Modifiability,variab,variable,14722,"r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charg",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:14774,Modifiability,variab,variable,14774,"*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1)",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:27524,Modifiability,variab,variable,27524,"f):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:27639,Modifiability,variab,variables,27639,"tom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(),",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:27813,Modifiability,variab,variables,27813,"point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:29184,Modifiability,variab,variable,29184,"t += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:29409,Modifiability,variab,variable,29409," self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:29569,Modifiability,variab,variable,29569,"n %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationErr",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:29698,Modifiability,Variab,VariableValue,29698,""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:29770,Modifiability,variab,variable,29770,"? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:29834,Modifiability,Variab,VariableValue,29834,"es, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31323,Modifiability,variab,variable,31323,"to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __s",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31567,Modifiability,variab,variable,31567,"; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] =",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31792,Modifiability,variab,variable,31792,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31904,Modifiability,variab,variable,31904," tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__ge",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31954,Modifiability,variab,variables,31954," tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__ge",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:32118,Modifiability,variab,variable,32118,"ion() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier i",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:32423,Modifiability,variab,variable,32423,"se if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:32751,Modifiability,variab,variable,32751,"ometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geome",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:42009,Modifiability,variab,variables,42009,"; self.atoms = []; for item in self.full_atoms:; item.invalidate(). temp_charge = self.PYmolecular_charge; temp_multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_fra",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:27790,Performance,optimiz,optimized,27790,"point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:20805,Safety,detect,detected,20805,"self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:32284,Safety,safe,safe,32284,") < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based co",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:5651,Security,Validat,ValidationError,5651,"cs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = sca",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:12597,Security,Validat,ValidationError,12597," return self.extract_fragments(reals, ghosts=[]). [docs] def extract_fragments(self, reals, ghosts=[]):; """"""Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; *reals*: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; *ghosts*: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise to Boost:Python type conlicts.) See usage; at :py:func:`~qcdb.molecule.extract_fragments`. """"""; lreals = []; try:; for idx in reals:; lreals.append(idx - 1); except TypeError:; lreals = [reals - 1]; lghosts = []; try:; for idx in ghosts:; lghosts.append(idx - 1); except TypeError:; lghosts = [ghosts - 1]; if len(lreals) + len(lghosts) > self.nfragments():; raise ValidationError('The sum of real- and ghost-atom subsets is greater than the number of subsets'). subset = self.clone(); subset.deactivate_all_fragments(); for fr in lreals:; subset.set_active_fragment(fr + 1) # the active fragment code subtracts 1; for fr in lghosts:; subset.set_ghost_fragment(fr + 1) # the ghost fragment code subtracts 1. subset.update_geometry(); return subset. # <<< Methods for Construction >>>. [docs] def create_molecule_from_string(self, text):; """"""Given a string *geom* of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. """"""; comment = re.compile(r'^\s*#'); blank = re.compile(r'^\s*$'); bohr = re.compile(r'^\s*units?[\s=]+(bohr|au|a.u.)\s*$', re.IGNORECASE); ang = re.compile(r'^\s*units?[\s=]+(ang|angstrom)\s*$', re.IGNORECASE); orient = re.compile(r'^\s*(no_reorient|noreorient)\s*$', re.IGNORECASE); com = re.compile(r'^\s*(no_com|nocom)\s*$', re.IGNORECASE); symmetry = re.compile(r'^\s*symmetry[\s=]+(\w+)\s*$', re.IGNORECASE)",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:16662,Security,Validat,ValidationError,16662,"ment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rv",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:17472,Security,Validat,ValidationError,17472,"bel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X'",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:17968,Security,Validat,ValidationError,17968,"(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:18148,Security,Validat,ValidationError,18148,"# handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:18280,Security,Validat,ValidationError,18280,"l2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Ato",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:18869,Security,Validat,ValidationError,18869,"s) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:19049,Security,Validat,ValidationError,19049,"ed yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specific",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:19229,Security,Validat,ValidationError,19229,"ed yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Re",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:19414,Security,Validat,ValidationError,19414,"elf.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:20002,Security,Validat,ValidationError,20002," if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: g",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:20979,Security,Validat,ValidationError,20979,". else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:21125,Security,Validat,ValidationError,21125,"ments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2an",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:21648,Security,Validat,ValidationError,21648,"lecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:22289,Security,Validat,ValidationError,22289,""", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:22498,Security,Validat,ValidationError,22498,").group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:22615,Security,Validat,ValidationError,22615,"'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.5996",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:30592,Security,Validat,ValidationError,30592," minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31074,Security,Validat,ValidationError,31074,"c symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Set",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:31759,Security,Validat,ValidationError,31759,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:32693,Security,access,accessing,32693,"ometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geome",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:33524,Security,Validat,ValidationError,33524,"e(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [docs] def full_geometry(self):; """"""Returns the full (dummies included) geometry in Bohr as a N X 3 array. >>> print H2OH2O.full_geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [0.0, 0.0, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132,",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:42309,Security,Validat,ValidationError,42309,"ty += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:46724,Security,Validat,ValidationError,46724,"signs basis *name* to atom number *number* (1-indexed, includes dummies).""""""; raise FeatureNotImplemented('Molecule::set_basis_by_number') # FINAL. [docs] def set_basis_by_label(self, label, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=""SMALL""):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False:; return 0. elif depth == True or depth.upper() == 'TRUE' or depth.upper() == 'SMALL':; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2 and self.Z(A) <= 10:; nfzc += 1; elif self.Z(A) > 10:; nfzc += 2; return nfzc. elif depth.upper() == 'FALSE':; return 0. elif depth.upper() == 'LARGE':; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2 and self.Z(A) <= 10:; nfzc += 1; elif self.Z(A) > 10:; nfzc += 5; return nfzc. else:; raise ValidationError(""Frozen core '%s' is not supported, options are {true, false, small, large}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""Moves molecule to center of mass. """"""; com = scale(self.center_of_mass(), -1.0); self.translate(com). [docs] de",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:30828,Testability,Test,Tests,30828,"y_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, v",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:3826,Usability,Simpl,Simple,3826,"r of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def mul",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:5743,Usability,Simpl,Simple,5743," print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return tem",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:9547,Usability,Simpl,Simple,9547,"0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; print 'it lives', 'activate all'; for fr in range(self.nfragments()):; print 'reviving', fr; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags the fragments in array *reals* as composed of real atoms.""""""; self.lock_frame = False; for fr in reals:; self.fragment_types[fr - 1",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:42039,Usability,clear,cleared,42039,"multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rath",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html:43795,Usability,clear,clear,43795,"ntation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(se",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:1122,Availability,avail,available,1122,"a4]  ; Module code . Source code for qcdb.molecule; #import os; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:6251,Availability,fault,faulty,6251,"return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment;",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:8068,Deployability,update,updated,8068,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:1065,Energy Efficiency,Charge,Charge,1065,"a4]  ; Module code . Source code for qcdb.molecule; #import os; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:5078,Energy Efficiency,charge,charge,5078,"; @X 0.00000000 0.00000000 0.00000000; O 1.35062500 0.11146900 0.00000000; H 1.68039800 -0.37374100 -0.75856100; H 1.68039800 -0.37374100 0.75856100; units Angstrom. """"""; Nfr = 0; text = """"; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue; if Nfr != 0:; text += """"""--\n""""""; Nfr += 1; text += """"""%d %d\n"""""" % (self.fragment_charges[fr], self.fragment_multiplicities[fr]); for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; geom = self.full_atoms[at].compute(); text += """"""%-3s %16.8f %16.8f %16.8f\n"""""" % \; (("""" if self.fZ(at) else ""@"") + self.full_atoms[at].symbol(), \; geom[0], geom[1], geom[2]); text += """"""units %s\n"""""" % (self.units().lower()); return text. [docs] def format_string_for_qchem(self):; pass. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Pe",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:5021,Modifiability,variab,variable,5021,"H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000; --; 0 1; @X 0.00000000 0.00000000 0.00000000; O 1.35062500 0.11146900 0.00000000; H 1.68039800 -0.37374100 -0.75856100; H 1.68039800 -0.37374100 0.75856100; units Angstrom. """"""; Nfr = 0; text = """"; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue; if Nfr != 0:; text += """"""--\n""""""; Nfr += 1; text += """"""%d %d\n"""""" % (self.fragment_charges[fr], self.fragment_multiplicities[fr]); for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; geom = self.full_atoms[at].compute(); text += """"""%-3s %16.8f %16.8f %16.8f\n"""""" % \; (("""" if self.fZ(at) else ""@"") + self.full_atoms[at].symbol(), \; geom[0], geom[1], geom[2]); text += """"""units %s\n"""""" % (self.units().lower()); return text. [docs] def format_string_for_qchem(self):; pass. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:6093,Performance,Perform,Perform,6093,"self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) >",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:6719,Performance,Queue,Queue,6719,"se ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:6905,Performance,Queue,Queue,6905,"); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Qu",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7130,Performance,Queue,Queue,7130,". [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; La",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7206,Performance,Queue,Queue,7206,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7252,Performance,Queue,Queue,7252,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7468,Performance,Queue,Queue,7468,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7514,Performance,queue,queue,7514,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7578,Performance,Queue,Queue,7578,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7614,Performance,Queue,Queue,7614,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7791,Performance,Queue,Queue,7791,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7815,Performance,Queue,Queue,7815,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:1054,Safety,detect,detected,1054,"vigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.molecule; #import os; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'An",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:4900,Safety,Detect,Detects,4900," specified. >>> print H2OH2O.save_string_for_psi4(); 6; 0 1; O -1.55100700 -0.11452000 0.00000000; H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000; --; 0 1; @X 0.00000000 0.00000000 0.00000000; O 1.35062500 0.11146900 0.00000000; H 1.68039800 -0.37374100 -0.75856100; H 1.68039800 -0.37374100 0.75856100; units Angstrom. """"""; Nfr = 0; text = """"; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue; if Nfr != 0:; text += """"""--\n""""""; Nfr += 1; text += """"""%d %d\n"""""" % (self.fragment_charges[fr], self.fragment_multiplicities[fr]); for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; geom = self.full_atoms[at].compute(); text += """"""%-3s %16.8f %16.8f %16.8f\n"""""" % \; (("""" if self.fZ(at) else ""@"") + self.full_atoms[at].symbol(), \; geom[0], geom[1], geom[2]); text += """"""units %s\n"""""" % (self.units().lower()); return text. [docs] def format_string_for_qchem(self):; pass. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:1376,Security,Validat,ValidationError,1376,"ecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline =",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:1522,Security,Validat,ValidationError,1522,""""""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if x",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:2099,Security,Validat,ValidationError,2099,"led from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Mal",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:2844,Security,Validat,ValidationError,2844,"\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_for_psi4(self):; """"""Returns a string of Mol",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:3053,Security,Validat,ValidationError,3053,"; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_for_psi4(self):; """"""Returns a string of Molecule formatted for psi4.; Includes fragments and reorienting, if specified. >>> print H2OH2O.save_string_for_psi4(); 6; 0 1; O -1.55100700 -0.11452000 0.00000000; H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:3170,Security,Validat,ValidationError,3170,"to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_for_psi4(self):; """"""Returns a string of Molecule formatted for psi4.; Includes fragments and reorienting, if specified. >>> print H2OH2O.save_string_for_psi4(); 6; 0 1; O -1.55100700 -0.11452000 0.00000000; H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000; --; 0 1; @X 0.00000000 0.00000000 0.00000000; O 1.35062500 0.11146900 0.00000000; H 1.68039800 -0.373",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:6949,Usability,Simpl,Simply,6949,". [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; La",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:760,Availability,failure,failure,760,". qcdb.psiutil  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.psiutil; r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [do",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:1458,Availability,failure,failure,1458,"('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:3150,Deployability,update,updated,3150,"cs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). if default == None:; prompt = "" [y/n] ""; elif default == True:; prompt = "" [Y/n] ""; elif default == False:; prompt = "" [y/N] ""; else:; raise ValueError(""invalid default answer: '%s'"" % default). while True:; sys.stdout.write(question + prompt); choice = raw_input().strip().lower(); if default is not None and choice == """":; return default; elif yes.match(choice):; return True; elif no.match(choice):; return False; else:; sys.stdout.write("" Please respond with 'yes' or 'no'.\n""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:734,Performance,Perform,Performs,734,". qcdb.psiutil  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.psiutil; r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [do",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:1432,Performance,Perform,Performs,1432,"('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:796,Testability,test,test,796,". qcdb.psiutil  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.psiutil; r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [do",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:1554,Testability,test,test,1554,"ompare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). if default == None:; prompt = "" [y/n] ""; elif default == True:; pro",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:1904,Testability,Test,Test,1904,"gits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). if default == None:; prompt = "" [y/n] ""; elif default == True:; prompt = "" [Y/n] ""; elif default == False:; prompt = "" [y/N] ""; else:; raise ValueError(""invalid default answer: '%s'"" % default). while True:; sys.stdout.write(question + prompt); choice = raw_input().strip().lower(); if default is not None and choice == """":; return default; elif yes.match(choice):; return True; elif no.match(choice):; return False; else:; sys.stdout.write("" P",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:5113,Availability,error,error,5113," mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(A):; """"""Given an real symmetric 3x3 matrix A, compute the eigenvalues. """"""; if len(A) != 3 or len(A[0]) != 3 or len(A[1]) != 3 or len(A[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # I is the identity matrix; p = A[0][1] * A[0][1] + A[0][2] * A[0][2] + A[1][2] * A[1][2]; if p == 0:; # A is diagonal; eig1 = A[0][0]; eig2 = A[1][1]; eig3 = A[2][2]; else:; q = (A[0][0] + A[1][1] + A[2][2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return [eig1, eig2, eig3]. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct d",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:6739,Deployability,update,updated,6739,"2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return [eig1, eig2, eig3]. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:162,Security,access,accessory,162,". qcdb.vecutil  PSI4 [beta4] documentation. Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code . Source code for qcdb.vecutil; r""""""File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. """"""; import math; import copy; from exceptions import *. ZERO = 1.0E-14. [docs]def norm(v):; """"""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:1354,Security,Validat,ValidationError,1354,"""""""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or le",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:1656,Security,Validat,ValidationError,1656,"e of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('perp_unit() only defined for vectors of length 3\n'). # try cross product; result = cross(u, v); resultdotresult = dot(result, result). if resultdotresult < 1.E-16:; # cross product is too small to normalize; # find the ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:2430,Security,Validat,ValidationError,2430,"v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('perp_unit() only defined for vectors of length 3\n'). # try cross product; result = cross(u, v); resultdotresult = dot(result, result). if resultdotresult < 1.E-16:; # cross product is too small to normalize; # find the largest of this and v; dotprodt = dot(u, u); dotprodv = dot(v, v); if dotprodt < dotprodv:; d = copy.deepcopy(v); dotprodd = dotprodv; else:; d = copy.deepcopy(u); dotprodd = dotprodt. # see if d is big enough; if dotprodd < 1.e-16:; # choose an arbitrary vector, since the biggest vector is small; result = [1.0, 0.0, 0.0]; return result; else:; # choose a vector perpendicular to d; # choose it in one of the planes xy, xz, yz; # choose the plane to be that which contains the two largest components of d; absd = [math.fabs(d[0]), math.fabs(d[1]), math.fabs(d[2])]; if (absd[1] - absd[0]) > 1.0e-12:; #if absd[0] < absd[1]:; axis0 = 1; if (absd[2] - absd[0]) > 1.0e-12:; #if absd[0] < absd[2]:; axis1 = 2; else:; axis1 = 0; else:; axis0 = 0; if (absd[2] - absd[1]) > 1.0e-12:",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:3967,Security,Validat,ValidationError,3967,"small; result = [1.0, 0.0, 0.0]; return result; else:; # choose a vector perpendicular to d; # choose it in one of the planes xy, xz, yz; # choose the plane to be that which contains the two largest components of d; absd = [math.fabs(d[0]), math.fabs(d[1]), math.fabs(d[2])]; if (absd[1] - absd[0]) > 1.0e-12:; #if absd[0] < absd[1]:; axis0 = 1; if (absd[2] - absd[0]) > 1.0e-12:; #if absd[0] < absd[2]:; axis1 = 2; else:; axis1 = 0; else:; axis0 = 0; if (absd[2] - absd[1]) > 1.0e-12:; #if absd[1] < absd[2]:; axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(A):; """"""Given an real symmetric 3x3 matrix A, compute the eigenvalues. """"""; if len(A) != 3 or len(A[0]) != 3 or len(A[1]) != 3 or len(A[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # I is the identity matrix; p = A[0][1] * A[0][1] + A[0][2] * A[0][2] + A[1][2] * A[1][2]; if p == 0:; # A is diagonal; eig1 = A[0][0]; eig2 = A[1][1]; eig3 = A[2][2]; else:; q = (A[0][0] + A[1][1] + A[2][2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:4467,Security,Validat,ValidationError,4467,"; axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(A):; """"""Given an real symmetric 3x3 matrix A, compute the eigenvalues. """"""; if len(A) != 3 or len(A[0]) != 3 or len(A[1]) != 3 or len(A[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # I is the identity matrix; p = A[0][1] * A[0][1] + A[0][2] * A[0][2] + A[1][2] * A[1][2]; if p == 0:; # A is diagonal; eig1 = A[0][0]; eig2 = A[1][1]; eig3 = A[2][2]; else:; q = (A[0][0] + A[1][1] + A[2][2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:6005,Security,Validat,ValidationError,6005,"2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return [eig1, eig2, eig3]. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:6453,Security,Validat,ValidationError,6453,"2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return [eig1, eig2, eig3]. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta4]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html:562,Deployability,update,updated,562,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html:169,Performance,CACHE,CACHELEVEL,169,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html:189,Performance,cache,cache,189,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html:562,Deployability,update,updated,562,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html:169,Performance,CACHE,CACHELEVEL,169,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html:189,Performance,cache,cache,189,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory-1.html:195,Availability,avail,available,195,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory-1.html:568,Deployability,update,updated,568,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory-1.html:260,Performance,CACHE,CACHELEVEL,260,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory.html:195,Availability,avail,available,195,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory.html:568,Deployability,update,updated,568,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory.html:260,Performance,CACHE,CACHELEVEL,260,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__newton_convergence-1.html:599,Deployability,update,updated,599,". NEWTON_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . NEWTON_CONVERGENCE. The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. Previous topic; MEMORY; Next topic; NORM_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__newton_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__newton_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__newton_convergence.html:599,Deployability,update,updated,599,". NEWTON_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . NEWTON_CONVERGENCE. The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. Previous topic; MEMORY; Next topic; NORM_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__newton_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__newton_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__norm_tolerance-1.html:600,Deployability,update,updated,600,". NORM_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . NORM_TOLERANCE. The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. Previous topic; NEWTON_CONVERGENCE; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__norm_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__norm_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__norm_tolerance.html:600,Deployability,update,updated,600,". NORM_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . NORM_TOLERANCE. The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. Previous topic; NEWTON_CONVERGENCE; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__norm_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__norm_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__num_amps_print-1.html:594,Deployability,update,updated,594,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . NUM_AMPS_PRINT. Number of components of transition amplitudes printed. Type: integer; Default: 5. Previous topic; NORM_TOLERANCE; Next topic; POLE_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__num_amps_print.html:594,Deployability,update,updated,594,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . NUM_AMPS_PRINT. Number of components of transition amplitudes printed. Type: integer; Default: 5. Previous topic; NORM_TOLERANCE; Next topic; POLE_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__num_amps_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pole_maxiter-1.html:570,Deployability,update,updated,570,". POLE_MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . POLE_MAXITER. Maximum iteration number in pole searching. Type: integer; Default: 20. Previous topic; NUM_AMPS_PRINT; Next topic; PR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__pole_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pole_maxiter-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pole_maxiter.html:570,Deployability,update,updated,570,". POLE_MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . POLE_MAXITER. Maximum iteration number in pole searching. Type: integer; Default: 20. Previous topic; NUM_AMPS_PRINT; Next topic; PR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__pole_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pole_maxiter.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pr-1.html:592,Deployability,update,updated,592,". PR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . PR. Do use the partial renormalization scheme for the ground state wavefunction?. Type: boolean; Default: false. Previous topic; POLE_MAXITER; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__pr-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pr-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pr.html:592,Deployability,update,updated,592,". PR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . PR. Do use the partial renormalization scheme for the ground state wavefunction?. Type: boolean; Default: false. Previous topic; POLE_MAXITER; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__pr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__pr.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__reference-1.html:572,Deployability,update,updated,572,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. Previous topic; PR; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__reference.html:572,Deployability,update,updated,572,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. Previous topic; PR; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__roots_per_irrep-1.html:570,Deployability,update,updated,570,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . ROOTS_PER_IRREP. The poles per irrep vector. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; SEM_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__roots_per_irrep.html:570,Deployability,update,updated,570,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . ROOTS_PER_IRREP. The poles per irrep vector. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; SEM_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__sem_maxiter-1.html:591,Deployability,update,updated,591,". SEM_MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . SEM_MAXITER. Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. Previous topic; ROOTS_PER_IRREP; Next topic; CCDENSITY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__sem_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__sem_maxiter-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__sem_maxiter.html:591,Deployability,update,updated,591,". SEM_MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC . SEM_MAXITER. Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. Previous topic; ROOTS_PER_IRREP; Next topic; CCDENSITY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/adc__sem_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/adc__sem_maxiter.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ael-1.html:616,Deployability,update,updated,616,". AEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . AEL. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. Previous topic; CCDENSITY; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ael-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ael-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ael.html:616,Deployability,update,updated,616,". AEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . AEL. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. Previous topic; CCDENSITY; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ael.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ael.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis-1.html:601,Deployability,update,updated,601,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis-1.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis.html:601,Deployability,update,updated,601,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ao_basis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html:573,Deployability,update,updated,573,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html:175,Performance,CACHE,CACHELEVEL,175,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html:202,Performance,cache,cacheing,202,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html:222,Performance,perform,perform,222,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html:573,Deployability,update,updated,573,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html:175,Performance,CACHE,CACHELEVEL,175,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html:202,Performance,cache,cacheing,202,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html:222,Performance,perform,perform,222,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge-1.html:576,Deployability,update,updated,576,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge-1.html:266,Performance,CACHE,CACHELEVEL,266,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge.html:576,Deployability,update,updated,576,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge.html:266,Performance,CACHE,CACHELEVEL,266,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__gauge.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ints_tolerance-1.html:604,Deployability,update,updated,604,". INTS_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; GAUGE; Next topic; ONEPDM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ints_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ints_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ints_tolerance.html:604,Deployability,update,updated,604,". INTS_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; GAUGE; Next topic; ONEPDM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__ints_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm-1.html:586,Deployability,update,updated,586,". ONEPDM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM. Do compute one-particle density matrix?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; ONEPDM_GRID_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm.html:586,Deployability,update,updated,586,". ONEPDM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM. Do compute one-particle density matrix?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; ONEPDM_GRID_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html:634,Deployability,update,updated,634,". ONEPDM_GRID_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_CUTOFF. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. Previous topic; ONEPDM; Next topic; ONEPDM_GRID_DUMP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_cutoff.html:634,Deployability,update,updated,634,". ONEPDM_GRID_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_CUTOFF. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. Previous topic; ONEPDM; Next topic; ONEPDM_GRID_DUMP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_dump-1.html:632,Deployability,update,updated,632,". ONEPDM_GRID_DUMP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_DUMP. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_CUTOFF; Next topic; ONEPDM_GRID_STEPSIZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_dump-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_dump-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_dump.html:632,Deployability,update,updated,632,". ONEPDM_GRID_DUMP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_DUMP. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_CUTOFF; Next topic; ONEPDM_GRID_STEPSIZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_dump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_dump.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html:634,Deployability,update,updated,634,". ONEPDM_GRID_STEPSIZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_STEPSIZE. Stepsize (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. Previous topic; ONEPDM_GRID_DUMP; Next topic; OPDM_RELAX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_stepsize.html:634,Deployability,update,updated,634,". ONEPDM_GRID_STEPSIZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_STEPSIZE. Stepsize (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. Previous topic; ONEPDM_GRID_DUMP; Next topic; OPDM_RELAX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_stepsize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__onepdm_grid_stepsize.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__opdm_relax-1.html:592,Deployability,update,updated,592,". OPDM_RELAX  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . OPDM_RELAX. Do relax the one-particle density matrix?. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_STEPSIZE; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__opdm_relax-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__opdm_relax-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__opdm_relax.html:592,Deployability,update,updated,592,". OPDM_RELAX  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . OPDM_RELAX. Do relax the one-particle density matrix?. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_STEPSIZE; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__opdm_relax.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__opdm_relax.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_all-1.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ALL. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. Previous topic; OPDM_RELAX; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__prop_all-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_all-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_all.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ALL. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. Previous topic; OPDM_RELAX; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__prop_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_all.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_root-1.html:588,Deployability,update,updated,588,". PROP_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__prop_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_root.html:588,Deployability,update,updated,588,". PROP_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__prop_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_sym-1.html:555,Deployability,update,updated,555,". PROP_SYM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__prop_sym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_sym-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_sym.html:555,Deployability,update,updated,555,". PROP_SYM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__prop_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__prop_sym.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__reference-1.html:568,Deployability,update,updated,568,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROP_SYM; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__reference.html:568,Deployability,update,updated,568,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROP_SYM; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__roots_per_irrep-1.html:623,Deployability,update,updated,623,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__roots_per_irrep.html:623,Deployability,update,updated,623,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__wfn-1.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; ROOTS_PER_IRREP; Next topic; XI; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__wfn.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; ROOTS_PER_IRREP; Next topic; XI; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi-1.html:534,Deployability,update,updated,534,". XI  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . XI. Do compute Xi?. Type: boolean; Default: false. Previous topic; WFN; Next topic; XI_CONNECT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__xi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi.html:534,Deployability,update,updated,534,". XI  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . XI. Do compute Xi?. Type: boolean; Default: false. Previous topic; WFN; Next topic; XI_CONNECT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__xi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi_connect-1.html:560,Deployability,update,updated,560,". XI_CONNECT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . XI_CONNECT. Do require and to be connected?. Type: boolean; Default: false. Previous topic; XI; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__xi_connect-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi_connect-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi_connect.html:560,Deployability,update,updated,560,". XI_CONNECT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . XI_CONNECT. Do require and to be connected?. Type: boolean; Default: false. Previous topic; XI; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__xi_connect.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__xi_connect.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__zeta-1.html:541,Deployability,update,updated,541,". ZETA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; XI_CONNECT; Next topic; CCENERGY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__zeta-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__zeta-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__zeta.html:541,Deployability,update,updated,541,". ZETA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; XI_CONNECT; Next topic; CCENERGY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccdensity__zeta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccdensity__zeta.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__abcd-1.html:583,Deployability,update,updated,583,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCENERGY; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__abcd-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__abcd.html:583,Deployability,update,updated,583,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCENERGY; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__abcd.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__analyze-1.html:551,Deployability,update,updated,551,". ANALYZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . ANALYZE. Do analyze T2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__analyze-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__analyze-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__analyze.html:551,Deployability,update,updated,551,". ANALYZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . ANALYZE. Do analyze T2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__analyze.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__analyze.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ao_basis-1.html:1216,Deployability,update,updated,1216,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . AO_BASIS. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ANALYZE; Next topic; BRUECKNER_ORBS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ao_basis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ao_basis.html:1216,Deployability,update,updated,1216,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . AO_BASIS. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ANALYZE; Next topic; BRUECKNER_ORBS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ao_basis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html:728,Deployability,update,updated,728,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html:347,Integrability,depend,depending,347,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html:447,Performance,CACHE,CACHELEVEL,447,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html:728,Deployability,update,updated,728,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html:347,Integrability,depend,depending,347,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html:447,Performance,CACHE,CACHELEVEL,447,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:1013,Deployability,update,updated,1013,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html:733,Performance,CACHE,CACHETYPE,733,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:1013,Deployability,update,updated,1013,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html:733,Performance,CACHE,CACHETYPE,733,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html:915,Deployability,update,updated,915,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html:173,Performance,CACHE,CACHETYPE,173,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html:248,Performance,cache,cache,248,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html:367,Performance,cache,cache,367,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html:498,Performance,cache,cache,498,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html:606,Performance,CACHE,CACHELEVEL,606,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html:915,Deployability,update,updated,915,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html:173,Performance,CACHE,CACHETYPE,173,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html:248,Performance,cache,cache,248,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html:367,Performance,cache,cache,367,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html:498,Performance,cache,cache,498,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html:606,Performance,CACHE,CACHELEVEL,606,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads-1.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads-1.html:257,Performance,CACHE,CACHETYPE,257,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads.html:257,Performance,CACHE,CACHETYPE,257,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_num_threads.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_os_scale-1.html:589,Deployability,update,updated,589,". CC_OS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_OS_SCALE. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. Previous topic; CC_NUM_THREADS; Next topic; CC_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_os_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_os_scale-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_os_scale.html:589,Deployability,update,updated,589,". CC_OS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_OS_SCALE. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. Previous topic; CC_NUM_THREADS; Next topic; CC_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_os_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_os_scale.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_ss_scale-1.html:583,Deployability,update,updated,583,". CC_SS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_SS_SCALE. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. Previous topic; CC_OS_SCALE; Next topic; DF_BASIS_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_ss_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_ss_scale-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_ss_scale.html:583,Deployability,update,updated,583,". CC_SS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . CC_SS_SCALE. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. Previous topic; CC_OS_SCALE; Next topic; DF_BASIS_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__cc_ss_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__cc_ss_scale.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_basis_mp2-1.html:634,Deployability,update,updated,634,". DF_BASIS_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DF_BASIS_MP2. Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. Previous topic; CC_SS_SCALE; Next topic; DF_LMP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__df_basis_mp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_basis_mp2-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_basis_mp2.html:634,Deployability,update,updated,634,". DF_BASIS_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DF_BASIS_MP2. Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. Previous topic; CC_SS_SCALE; Next topic; DF_LMP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__df_basis_mp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_basis_mp2.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_lmp2-1.html:606,Deployability,update,updated,606,". DF_LMP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DF_LMP2. Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. Previous topic; DF_BASIS_MP2; Next topic; DIAG_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__df_lmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_lmp2-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_lmp2.html:606,Deployability,update,updated,606,". DF_LMP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DF_LMP2. Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. Previous topic; DF_BASIS_MP2; Next topic; DIAG_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__df_lmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__df_lmp2.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diag_method-1.html:609,Deployability,update,updated,609,". DIAG_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIAG_METHOD. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. Previous topic; DF_LMP2; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diag_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diag_method-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diag_method.html:609,Deployability,update,updated,609,". DIAG_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIAG_METHOD. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. Previous topic; DF_LMP2; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diag_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diag_method.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis-1.html:584,Deployability,update,updated,584,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; DIAG_METHOD; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis.html:584,Deployability,update,updated,584,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; DIAG_METHOD; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs-1.html:211,Availability,error,error,211,". DIIS_MAX_VECS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS_MAX_VECS. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. Previous topic; DIIS; Next topic; DIIS_START_ITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs-1.html:603,Deployability,update,updated,603,". DIIS_MAX_VECS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS_MAX_VECS. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. Previous topic; DIIS; Next topic; DIIS_START_ITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs.html:211,Availability,error,error,211,". DIIS_MAX_VECS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS_MAX_VECS. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. Previous topic; DIIS; Next topic; DIIS_START_ITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs.html:603,Deployability,update,updated,603,". DIIS_MAX_VECS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS_MAX_VECS. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. Previous topic; DIIS; Next topic; DIIS_START_ITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_max_vecs.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_start_iter-1.html:605,Deployability,update,updated,605,". DIIS_START_ITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS_START_ITER. Iteration at which to start DIIS extrapolation. Type: integer; Default: 3. Previous topic; DIIS_MAX_VECS; Next topic; DISTANT_PAIR_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis_start_iter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_start_iter-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_start_iter.html:605,Deployability,update,updated,605,". DIIS_START_ITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS_START_ITER. Iteration at which to start DIIS extrapolation. Type: integer; Default: 3. Previous topic; DIIS_MAX_VECS; Next topic; DISTANT_PAIR_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__diis_start_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__diis_start_iter.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__distant_pair_cutoff-1.html:582,Deployability,update,updated,582,". DISTANT_PAIR_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DISTANT_PAIR_CUTOFF. Distant pair cutoff. Type: double; Default: 8.0. Previous topic; DIIS_START_ITER; Next topic; DOMAIN_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__distant_pair_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__distant_pair_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__distant_pair_cutoff.html:582,Deployability,update,updated,582,". DISTANT_PAIR_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DISTANT_PAIR_CUTOFF. Distant pair cutoff. Type: double; Default: 8.0. Previous topic; DIIS_START_ITER; Next topic; DOMAIN_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__distant_pair_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__distant_pair_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domains-1.html:546,Deployability,update,updated,546,". DOMAINS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DOMAINS. Type: array; Default: No Default. Previous topic; DOMAIN_PRINT_EXIT; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__domains-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domains-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domains.html:546,Deployability,update,updated,546,". DOMAINS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DOMAINS. Type: array; Default: No Default. Previous topic; DOMAIN_PRINT_EXIT; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__domains.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domains.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print-1.html:582,Deployability,update,updated,582,". DOMAIN_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DOMAIN_PRINT. Do print the domains?. Type: boolean; Default: false. Previous topic; DISTANT_PAIR_CUTOFF; Next topic; DOMAIN_PRINT_EXIT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print.html:582,Deployability,update,updated,582,". DOMAIN_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DOMAIN_PRINT. Do print the domains?. Type: boolean; Default: false. Previous topic; DISTANT_PAIR_CUTOFF; Next topic; DOMAIN_PRINT_EXIT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print_exit-1.html:589,Deployability,update,updated,589,". DOMAIN_PRINT_EXIT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DOMAIN_PRINT_EXIT. Do exit after printing the domains?. Type: boolean; Default: false. Previous topic; DOMAIN_PRINT; Next topic; DOMAINS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print_exit-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print_exit-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print_exit.html:589,Deployability,update,updated,589,". DOMAIN_PRINT_EXIT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . DOMAIN_PRINT_EXIT. Do exit after printing the domains?. Type: boolean; Default: false. Previous topic; DOMAIN_PRINT; Next topic; DOMAINS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print_exit.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__domain_print_exit.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence-1.html:693,Deployability,update,updated,693,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . E_CONVERGENCE. Convergence criterion for energy (change). See Table// Post-SCF Convergence for default convergence// criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; DOMAINS; Next topic; FOCK_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence-1.html:219,Energy Efficiency,energy,energy,219,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . E_CONVERGENCE. Convergence criterion for energy (change). See Table// Post-SCF Convergence for default convergence// criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; DOMAINS; Next topic; FOCK_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence.html:693,Deployability,update,updated,693,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . E_CONVERGENCE. Convergence criterion for energy (change). See Table// Post-SCF Convergence for default convergence// criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; DOMAINS; Next topic; FOCK_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence.html:219,Energy Efficiency,energy,energy,219,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . E_CONVERGENCE. Convergence criterion for energy (change). See Table// Post-SCF Convergence for default convergence// criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; DOMAINS; Next topic; FOCK_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__e_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__fock_tolerance-1.html:629,Deployability,update,updated,629,". FOCK_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . FOCK_TOLERANCE. Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. Previous topic; E_CONVERGENCE; Next topic; FORCE_RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__fock_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__fock_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__fock_tolerance.html:629,Deployability,update,updated,629,". FOCK_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . FOCK_TOLERANCE. Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. Previous topic; E_CONVERGENCE; Next topic; FORCE_RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__fock_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__fock_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__force_restart-1.html:630,Deployability,update,updated,630,". FORCE_RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . FORCE_RESTART. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. Previous topic; FOCK_TOLERANCE; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__force_restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__force_restart-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__force_restart.html:630,Deployability,update,updated,630,". FORCE_RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . FORCE_RESTART. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. Previous topic; FOCK_TOLERANCE; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__force_restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__force_restart.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ints_tolerance-1.html:608,Deployability,update,updated,608,". INTS_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-7. Previous topic; FORCE_RESTART; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__ints_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ints_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ints_tolerance.html:608,Deployability,update,updated,608,". INTS_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-7. Previous topic; FORCE_RESTART; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__ints_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local-1.html:604,Deployability,update,updated,604,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; LOCAL_AMPS_PRINT_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local.html:604,Deployability,update,updated,604,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; LOCAL_AMPS_PRINT_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_amps_print_cutoff-1.html:609,Deployability,update,updated,609,". LOCAL_AMPS_PRINT_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_AMPS_PRINT_CUTOFF. Cutoff value for printing local amplitudes. Type: double; Default: 0.60. Previous topic; LOCAL; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_amps_print_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_amps_print_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_amps_print_cutoff.html:609,Deployability,update,updated,609,". LOCAL_AMPS_PRINT_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_AMPS_PRINT_CUTOFF. Cutoff value for printing local amplitudes. Type: double; Default: 0.60. Previous topic; LOCAL; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_amps_print_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_amps_print_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cphf_cutoff-1.html:621,Deployability,update,updated,621,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL_AMPS_PRINT_CUTOFF; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cphf_cutoff.html:621,Deployability,update,updated,621,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL_AMPS_PRINT_CUTOFF; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cutoff-1.html:570,Deployability,update,updated,570,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CUTOFF. Localization cutoff. Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cutoff.html:570,Deployability,update,updated,570,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CUTOFF. Localization cutoff. Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_ghost-1.html:542,Deployability,update,updated,542,". LOCAL_GHOST  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_GHOST. Type: integer; Default: -1. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_ghost-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_ghost-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_ghost.html:542,Deployability,update,updated,542,". LOCAL_GHOST  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_GHOST. Type: integer; Default: -1. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_ghost.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_ghost.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_method-1.html:769,Deployability,update,updated,769,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_METHOD. Type of local-CIS scheme to be simulated. WERNER selects the method// developed by H.-J. Werner and co-workers, and AOBASIS selects the method// developed by G.E. Scuseria and co-workers. Type: string; Possible Values: AOBASIS, WERNER; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_method-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_method.html:769,Deployability,update,updated,769,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_METHOD. Type of local-CIS scheme to be simulated. WERNER selects the method// developed by H.-J. Werner and co-workers, and AOBASIS selects the method// developed by G.E. Scuseria and co-workers. Type: string; Possible Values: AOBASIS, WERNER; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_method.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_pairdef-1.html:640,Deployability,update,updated,640,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_PAIRDEF. Definition of local pair domains, default is BP, Boughton-Pulay. Type: string; Possible Values: BP, RESPONSE; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_pairdef.html:640,Deployability,update,updated,640,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_PAIRDEF. Definition of local pair domains, default is BP, Boughton-Pulay. Type: string; Possible Values: BP, RESPONSE; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_pairdef.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp-1.html:877,Deployability,update,updated,877,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of// NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in// the same manner as strong pairs. A value of MP2 uses second-order perturbation// theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp-1.html:450,Energy Efficiency,energy,energy,450,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of// NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in// the same manner as strong pairs. A value of MP2 uses second-order perturbation// theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp.html:877,Deployability,update,updated,877,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of// NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in// the same manner as strong pairs. A value of MP2 uses second-order perturbation// theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp.html:450,Energy Efficiency,energy,energy,450,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of// NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in// the same manner as strong pairs. A value of MP2 uses second-order perturbation// theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__local_weakp.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__maxiter-1.html:557,Deployability,update,updated,557,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MAXITER. Maximum number of iterations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__maxiter-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__maxiter.html:557,Deployability,update,updated,557,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MAXITER. Maximum number of iterations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__maxiter.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory-1.html:200,Availability,avail,available,200,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 2000. Previous topic; MAXITER; Next topic; MP2_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory-1.html:571,Deployability,update,updated,571,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 2000. Previous topic; MAXITER; Next topic; MP2_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory.html:200,Availability,avail,available,200,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 2000. Previous topic; MAXITER; Next topic; MP2_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory.html:571,Deployability,update,updated,571,". MEMORY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 2000. Previous topic; MAXITER; Next topic; MP2_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__memory.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_amps_print-1.html:642,Deployability,update,updated,642,". MP2_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_AMPS_PRINT. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Previous topic; MEMORY; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_amps_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_amps_print.html:642,Deployability,update,updated,642,". MP2_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_AMPS_PRINT. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Previous topic; MEMORY; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_amps_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_os_scale-1.html:617,Deployability,update,updated,617,". MP2_OS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_OS_SCALE. The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. Previous topic; MP2_AMPS_PRINT; Next topic; MP2_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_os_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_os_scale-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_os_scale.html:617,Deployability,update,updated,617,". MP2_OS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_OS_SCALE. The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. Previous topic; MP2_AMPS_PRINT; Next topic; MP2_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_os_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_os_scale.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_ss_scale-1.html:619,Deployability,update,updated,619,". MP2_SS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_SS_SCALE. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. Previous topic; MP2_OS_SCALE; Next topic; NEGLECT_DISTANT_PAIR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_ss_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_ss_scale-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_ss_scale.html:619,Deployability,update,updated,619,". MP2_SS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_SS_SCALE. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. Previous topic; MP2_OS_SCALE; Next topic; NEGLECT_DISTANT_PAIR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_ss_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__mp2_ss_scale.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__neglect_distant_pair-1.html:588,Deployability,update,updated,588,". NEGLECT_DISTANT_PAIR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . NEGLECT_DISTANT_PAIR. Do neglect distant pairs?. Type: boolean; Default: true. Previous topic; MP2_SS_SCALE; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__neglect_distant_pair-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__neglect_distant_pair-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__neglect_distant_pair.html:588,Deployability,update,updated,588,". NEGLECT_DISTANT_PAIR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . NEGLECT_DISTANT_PAIR. Do neglect distant pairs?. Type: boolean; Default: true. Previous topic; MP2_SS_SCALE; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__neglect_distant_pair.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__neglect_distant_pair.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__new_triples-1.html:575,Deployability,update,updated,575,". NEW_TRIPLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; NEGLECT_DISTANT_PAIR; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__new_triples-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__new_triples-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__new_triples.html:575,Deployability,update,updated,575,". NEW_TRIPLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; NEGLECT_DISTANT_PAIR; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__new_triples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__new_triples.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__num_amps_print-1.html:599,Deployability,update,updated,599,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . NUM_AMPS_PRINT. Number of important and amplitudes to print. Type: integer; Default: 10. Previous topic; NEW_TRIPLES; Next topic; PAIR_ENERGIES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__num_amps_print.html:599,Deployability,update,updated,599,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . NUM_AMPS_PRINT. Number of important and amplitudes to print. Type: integer; Default: 10. Previous topic; NEW_TRIPLES; Next topic; PAIR_ENERGIES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__num_amps_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__pair_energies_print-1.html:616,Deployability,update,updated,616,". PAIR_ENERGIES_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . PAIR_ENERGIES_PRINT. Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__pair_energies_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__pair_energies_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__pair_energies_print.html:616,Deployability,update,updated,616,". PAIR_ENERGIES_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . PAIR_ENERGIES_PRINT. Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__pair_energies_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__pair_energies_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__property-1.html:827,Deployability,update,updated,827,". PROPERTY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . PROPERTY. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. Previous topic; PAIR_ENERGIES_PRINT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__property-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__property-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__property.html:827,Deployability,update,updated,827,". PROPERTY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . PROPERTY. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. Previous topic; PAIR_ENERGIES_PRINT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__property.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__reference-1.html:585,Deployability,update,updated,585,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__reference.html:585,Deployability,update,updated,585,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html:478,Deployability,update,updates,478,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html:931,Deployability,update,updated,931,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html:261,Performance,optimiz,optimizations,261,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html:478,Deployability,update,updates,478,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html:931,Deployability,update,updated,931,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html:261,Performance,optimiz,optimizations,261,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__restart.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__roots_per_irrep-1.html:629,Deployability,update,updated,629,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible// representation. Type: array; Default: No Default. Previous topic; RESTART; Next topic; SCREEN_INTS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__roots_per_irrep.html:629,Deployability,update,updated,629,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible// representation. Type: array; Default: No Default. Previous topic; RESTART; Next topic; SCREEN_INTS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__r_convergence-1.html:599,Deployability,update,updated,599,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . R_CONVERGENCE. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__r_convergence.html:599,Deployability,update,updated,599,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . R_CONVERGENCE. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__screen_ints-1.html:561,Deployability,update,updated,561,". SCREEN_INTS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCREEN_INTS. Do screen integrals?. Type: boolean; Default: false. Previous topic; ROOTS_PER_IRREP; Next topic; SCS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__screen_ints-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__screen_ints-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__screen_ints.html:561,Deployability,update,updated,561,". SCREEN_INTS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCREEN_INTS. Do screen integrals?. Type: boolean; Default: false. Previous topic; ROOTS_PER_IRREP; Next topic; SCS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__screen_ints.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__screen_ints.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs-1.html:565,Deployability,update,updated,565,". SCS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. Previous topic; SCREEN_INTS; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs.html:565,Deployability,update,updated,565,". SCS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. Previous topic; SCREEN_INTS; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2-1.html:590,Deployability,update,updated,590,". SCSN_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_N; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2-1.html:210,Performance,optimiz,optimized,210,". SCSN_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_N; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2.html:590,Deployability,update,updated,590,". SCSN_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_N; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2.html:210,Performance,optimiz,optimized,210,". SCSN_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_N; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scsn_mp2.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_ccsd-1.html:556,Deployability,update,updated,556,". SCS_CCSD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_CCSD. Do spin-component-scaled CCSD. Type: boolean; Default: false. Previous topic; SCS; Next topic; SCS_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_ccsd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_ccsd-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_ccsd.html:556,Deployability,update,updated,556,". SCS_CCSD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_CCSD. Do spin-component-scaled CCSD. Type: boolean; Default: false. Previous topic; SCS; Next topic; SCS_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_ccsd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_ccsd.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_mp2-1.html:567,Deployability,update,updated,567,". SCS_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_MP2. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. Previous topic; SCS_CCSD; Next topic; SCS_N; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_mp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_mp2-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_mp2.html:567,Deployability,update,updated,567,". SCS_MP2  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_MP2. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. Previous topic; SCS_CCSD; Next topic; SCS_N; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_mp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_mp2.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n-1.html:581,Deployability,update,updated,581,". SCS_N  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_N. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SCSN_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n-1.html:204,Performance,optimiz,optimized,204,". SCS_N  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_N. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SCSN_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n.html:581,Deployability,update,updated,581,". SCS_N  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_N. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SCSN_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n.html:204,Performance,optimiz,optimized,204,". SCS_N  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_N. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SCSN_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__scs_n.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__semicanonical-1.html:589,Deployability,update,updated,589,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCSN_MP2; Next topic; SPINADAPT_ENERGIES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__semicanonical-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__semicanonical.html:589,Deployability,update,updated,589,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCSN_MP2; Next topic; SPINADAPT_ENERGIES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__semicanonical.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html:596,Deployability,update,updated,596,". SPINADAPT_ENERGIES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html:217,Energy Efficiency,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html:217,Modifiability,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html:596,Deployability,update,updated,596,". SPINADAPT_ENERGIES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html:217,Energy Efficiency,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html:217,Modifiability,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__spinadapt_energies.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t2_coupled-1.html:549,Deployability,update,updated,549,". T2_COUPLED  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . T2_COUPLED. Type: boolean; Default: false. Previous topic; SPINADAPT_ENERGIES; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__t2_coupled-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t2_coupled-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t2_coupled.html:549,Deployability,update,updated,549,". T2_COUPLED  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . T2_COUPLED. Type: boolean; Default: false. Previous topic; SPINADAPT_ENERGIES; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__t2_coupled.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t2_coupled.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t3_ws_incore-1.html:595,Deployability,update,updated,595,". T3_WS_INCORE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . T3_WS_INCORE. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Previous topic; T2_COUPLED; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__t3_ws_incore-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t3_ws_incore-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t3_ws_incore.html:595,Deployability,update,updated,595,". T3_WS_INCORE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . T3_WS_INCORE. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Previous topic; T2_COUPLED; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__t3_ws_incore.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__t3_ws_incore.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__wfn-1.html:539,Deployability,update,updated,539,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . WFN. Wavefunction type. Type: string; Default: LMP2. Previous topic; T3_WS_INCORE; Next topic; CCEOM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__wfn.html:539,Deployability,update,updated,539,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY . WFN. Wavefunction type. Type: string; Default: LMP2. Previous topic; T3_WS_INCORE; Next topic; CCEOM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccenergy__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccenergy__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd-1.html:577,Deployability,update,updated,577,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd-1.html:299,Performance,CACHE,CACHELEVEL,299,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd.html:577,Deployability,update,updated,577,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd.html:299,Performance,CACHE,CACHELEVEL,299,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__abcd.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:983,Deployability,update,updated,983,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:171,Performance,CACHE,CACHELEVEL,171,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:184,Performance,Cache,Cacheing,184,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:335,Performance,cache,cache,335,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:397,Performance,cache,cache,397,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:638,Performance,cache,cache,638,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html:706,Performance,CACHE,CACHETYPE,706,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:983,Deployability,update,updated,983,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:171,Performance,CACHE,CACHELEVEL,171,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:184,Performance,Cache,Cacheing,184,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:335,Performance,cache,cache,335,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:397,Performance,cache,cache,397,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:638,Performance,cache,cache,638,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html:706,Performance,CACHE,CACHETYPE,706,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html:211,Deployability,release,release,211,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html:610,Deployability,update,updated,610,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html:170,Performance,CACHE,CACHETYPE,170,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html:219,Performance,cache,cached,219,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html:303,Performance,CACHE,CACHELEVEL,303,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html:211,Deployability,release,release,211,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html:610,Deployability,update,updated,610,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html:170,Performance,CACHE,CACHETYPE,170,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html:219,Performance,cache,cached,219,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html:303,Performance,CACHE,CACHELEVEL,303,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root-1.html:581,Deployability,update,updated,581,". CC3_FOLLOW_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root-1.html:276,Performance,CACHE,CACHETYPE,276,". CC3_FOLLOW_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root.html:581,Deployability,update,updated,581,". CC3_FOLLOW_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root.html:276,Performance,CACHE,CACHETYPE,276,". CC3_FOLLOW_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc3_follow_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc_num_threads-1.html:569,Deployability,update,updated,569,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CC3_FOLLOW_ROOT; Next topic; COLLAPSE_WITH_LAST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc_num_threads.html:569,Deployability,update,updated,569,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CC3_FOLLOW_ROOT; Next topic; COLLAPSE_WITH_LAST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__cc_num_threads.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__collapse_with_last-1.html:590,Deployability,update,updated,590,". COLLAPSE_WITH_LAST  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . COLLAPSE_WITH_LAST. Do collapse with last vector?. Type: boolean; Default: true. Previous topic; CC_NUM_THREADS; Next topic; COMPLEX_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__collapse_with_last-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__collapse_with_last-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__collapse_with_last.html:590,Deployability,update,updated,590,". COLLAPSE_WITH_LAST  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . COLLAPSE_WITH_LAST. Do collapse with last vector?. Type: boolean; Default: true. Previous topic; CC_NUM_THREADS; Next topic; COMPLEX_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__collapse_with_last.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__collapse_with_last.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance-1.html:206,Availability,toler,tolerance,206,". COMPLEX_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance-1.html:611,Deployability,update,updated,611,". COMPLEX_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance.html:206,Availability,toler,tolerance,206,". COMPLEX_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance.html:611,Deployability,update,updated,611,". COMPLEX_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__complex_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess-1.html:578,Availability,avail,available,578,". EOM_GUESS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__eom_guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess-1.html:984,Deployability,update,updated,984,". EOM_GUESS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__eom_guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess.html:578,Availability,avail,available,578,". EOM_GUESS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__eom_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess.html:984,Deployability,update,updated,984,". EOM_GUESS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__eom_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_guess.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_reference-1.html:624,Deployability,update,updated,624,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; EOM_GUESS; Next topic; EXCITATION_RANGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_reference.html:624,Deployability,update,updated,624,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; EOM_GUESS; Next topic; EXCITATION_RANGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__eom_reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__excitation_range-1.html:891,Deployability,update,updated,891,". EXCITATION_RANGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EXCITATION_RANGE. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. Previous topic; EOM_REFERENCE; Next topic; FULL_MATRIX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__excitation_range-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__excitation_range-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__excitation_range.html:891,Deployability,update,updated,891,". EXCITATION_RANGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . EXCITATION_RANGE. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. Previous topic; EOM_REFERENCE; Next topic; FULL_MATRIX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__excitation_range.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__excitation_range.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence-1.html:736,Deployability,update,updated,736,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence-1.html:227,Energy Efficiency,energy,energy,227,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence.html:736,Deployability,update,updated,736,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence.html:227,Energy Efficiency,energy,energy,227,". E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__e_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__full_matrix-1.html:579,Deployability,update,updated,579,". FULL_MATRIX  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . FULL_MATRIX. Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. Previous topic; EXCITATION_RANGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__full_matrix-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__full_matrix-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__full_matrix.html:579,Deployability,update,updated,579,". FULL_MATRIX  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . FULL_MATRIX. Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. Previous topic; EXCITATION_RANGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__full_matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__full_matrix.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local-1.html:584,Deployability,update,updated,584,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; FULL_MATRIX; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local.html:584,Deployability,update,updated,584,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; FULL_MATRIX; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_cutoff-1.html:810,Deployability,update,updated,810,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL; Next topic; LOCAL_DO_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_cutoff.html:810,Deployability,update,updated,810,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL; Next topic; LOCAL_DO_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_do_singles-1.html:556,Deployability,update,updated,556,". LOCAL_DO_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_DO_SINGLES. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_do_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_do_singles-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_do_singles.html:556,Deployability,update,updated,556,". LOCAL_DO_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_DO_SINGLES. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_do_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_do_singles.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_filter_singles-1.html:608,Deployability,update,updated,608,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_FILTER_SINGLES. Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_DO_SINGLES; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_filter_singles.html:608,Deployability,update,updated,608,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_FILTER_SINGLES. Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_DO_SINGLES; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_filter_singles.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_ghost-1.html:661,Deployability,update,updated,661,". LOCAL_GHOST  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_GHOST. Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_ghost-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_ghost-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_ghost.html:661,Deployability,update,updated,661,". LOCAL_GHOST  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_GHOST. Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_ghost.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_ghost.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_method-1.html:791,Deployability,update,updated,791,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_PRECONDITIONER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_method-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_method.html:791,Deployability,update,updated,791,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_PRECONDITIONER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_method.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_preconditioner-1.html:637,Deployability,update,updated,637,". LOCAL_PRECONDITIONER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_PRECONDITIONER. Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_preconditioner-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_preconditioner-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_preconditioner.html:637,Deployability,update,updated,637,". LOCAL_PRECONDITIONER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_PRECONDITIONER. Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_preconditioner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_preconditioner.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp-1.html:875,Deployability,update,updated,875,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp-1.html:443,Energy Efficiency,energy,energy,443,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp.html:875,Deployability,update,updated,875,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp.html:443,Energy Efficiency,energy,energy,443,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__local_weakp.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__maxiter-1.html:556,Deployability,update,updated,556,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . MAXITER. Maximum number of iterations. Type: integer; Default: 80. Previous topic; LOCAL_WEAKP; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__maxiter-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__maxiter.html:556,Deployability,update,updated,556,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . MAXITER. Maximum number of iterations. Type: integer; Default: 80. Previous topic; LOCAL_WEAKP; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__maxiter.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__new_triples-1.html:556,Deployability,update,updated,556,". NEW_TRIPLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; MAXITER; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__new_triples-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__new_triples-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__new_triples.html:556,Deployability,update,updated,556,". NEW_TRIPLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; MAXITER; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__new_triples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__new_triples.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__num_amps_print-1.html:581,Deployability,update,updated,581,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . NUM_AMPS_PRINT. Number of important CC amplitudes to print. Type: integer; Default: 5. Previous topic; NEW_TRIPLES; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__num_amps_print.html:581,Deployability,update,updated,581,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . NUM_AMPS_PRINT. Number of important CC amplitudes to print. Type: integer; Default: 5. Previous topic; NEW_TRIPLES; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__num_amps_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_root-1.html:622,Deployability,update,updated,622,". PROP_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . PROP_ROOT. Root number (within its irrep) for computing properties. Defaults to highest root requested. Type: integer; Default: 0. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__prop_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_root.html:622,Deployability,update,updated,622,". PROP_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . PROP_ROOT. Root number (within its irrep) for computing properties. Defaults to highest root requested. Type: integer; Default: 0. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__prop_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_sym-1.html:627,Deployability,update,updated,627,". PROP_SYM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . PROP_SYM. Symmetry of the state to compute properties. Defaults to last irrep for which states are requested. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__prop_sym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_sym-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_sym.html:627,Deployability,update,updated,627,". PROP_SYM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . PROP_SYM. Symmetry of the state to compute properties. Defaults to last irrep for which states are requested. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__prop_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__prop_sym.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__reference-1.html:598,Deployability,update,updated,598,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART_EOM_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__reference.html:598,Deployability,update,updated,598,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART_EOM_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__restart_eom_cc3-1.html:570,Deployability,update,updated,570,". RESTART_EOM_CC3  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . RESTART_EOM_CC3. Do restart from on-disk?. Type: boolean; Default: false. Previous topic; REFERENCE; Next topic; RHF_TRIPLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__restart_eom_cc3-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__restart_eom_cc3-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__restart_eom_cc3.html:570,Deployability,update,updated,570,". RESTART_EOM_CC3  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . RESTART_EOM_CC3. Do restart from on-disk?. Type: boolean; Default: false. Previous topic; REFERENCE; Next topic; RHF_TRIPLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__restart_eom_cc3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__restart_eom_cc3.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__rhf_triplets-1.html:592,Deployability,update,updated,592,". RHF_TRIPLETS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . RHF_TRIPLETS. Do form a triplet state from RHF reference?. Type: boolean; Default: false. Previous topic; RESTART_EOM_CC3; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__rhf_triplets-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__rhf_triplets-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__rhf_triplets.html:592,Deployability,update,updated,592,". RHF_TRIPLETS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . RHF_TRIPLETS. Do form a triplet state from RHF reference?. Type: boolean; Default: false. Previous topic; RESTART_EOM_CC3; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__rhf_triplets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__rhf_triplets.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__roots_per_irrep-1.html:735,Deployability,update,updated,735,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . ROOTS_PER_IRREP. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. Previous topic; RHF_TRIPLETS; Next topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__roots_per_irrep.html:735,Deployability,update,updated,735,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . ROOTS_PER_IRREP. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. Previous topic; RHF_TRIPLETS; Next topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__r_convergence-1.html:631,Deployability,update,updated,631,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. Previous topic; PROP_SYM; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__r_convergence.html:631,Deployability,update,updated,631,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. Previous topic; PROP_SYM; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__schmidt_add_residual_tolerance-1.html:714,Deployability,update,updated,714,". SCHMIDT_ADD_RESIDUAL_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SCHMIDT_ADD_RESIDUAL_TOLERANCE. Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. Previous topic; ROOTS_PER_IRREP; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__schmidt_add_residual_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__schmidt_add_residual_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__schmidt_add_residual_tolerance.html:714,Deployability,update,updated,714,". SCHMIDT_ADD_RESIDUAL_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SCHMIDT_ADD_RESIDUAL_TOLERANCE. Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. Previous topic; ROOTS_PER_IRREP; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__schmidt_add_residual_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__schmidt_add_residual_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__semicanonical-1.html:600,Deployability,update,updated,600,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; Next topic; SINGLES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__semicanonical-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__semicanonical.html:600,Deployability,update,updated,600,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; Next topic; SINGLES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__semicanonical.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__singles_print-1.html:668,Deployability,update,updated,668,". SINGLES_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SINGLES_PRINT. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; SS_E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__singles_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__singles_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__singles_print.html:668,Deployability,update,updated,668,". SINGLES_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SINGLES_PRINT. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; SS_E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__singles_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__singles_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence-1.html:665,Deployability,update,updated,665,". SS_E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence-1.html:233,Energy Efficiency,energy,energy,233,". SS_E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence.html:665,Deployability,update,updated,665,". SS_E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence.html:233,Energy Efficiency,energy,energy,233,". SS_E_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_e_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_r_convergence-1.html:665,Deployability,update,updated,665,". SS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SS_E_CONVERGENCE; Next topic; SS_SKIP_DIAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_r_convergence.html:665,Deployability,update,updated,665,". SS_R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SS_E_CONVERGENCE; Next topic; SS_SKIP_DIAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_skip_diag-1.html:592,Deployability,update,updated,592,". SS_SKIP_DIAG  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_SKIP_DIAG. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. Previous topic; SS_R_CONVERGENCE; Next topic; SS_VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_skip_diag-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_skip_diag-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_skip_diag.html:592,Deployability,update,updated,592,". SS_SKIP_DIAG  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_SKIP_DIAG. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. Previous topic; SS_R_CONVERGENCE; Next topic; SS_VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_skip_diag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_skip_diag.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_vecs_per_root-1.html:573,Deployability,update,updated,573,". SS_VECS_PER_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_VECS_PER_ROOT. SS vectors stored per root. Type: integer; Default: 5. Previous topic; SS_SKIP_DIAG; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_vecs_per_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_vecs_per_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_vecs_per_root.html:573,Deployability,update,updated,573,". SS_VECS_PER_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . SS_VECS_PER_ROOT. SS vectors stored per root. Type: integer; Default: 5. Previous topic; SS_SKIP_DIAG; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__ss_vecs_per_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__ss_vecs_per_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__t3_ws_incore-1.html:604,Deployability,update,updated,604,". T3_WS_INCORE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . T3_WS_INCORE. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. Previous topic; SS_VECS_PER_ROOT; Next topic; VECS_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__t3_ws_incore-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__t3_ws_incore-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__t3_ws_incore.html:604,Deployability,update,updated,604,". T3_WS_INCORE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . T3_WS_INCORE. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. Previous topic; SS_VECS_PER_ROOT; Next topic; VECS_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__t3_ws_incore.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__t3_ws_incore.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_cc3-1.html:567,Deployability,update,updated,567,". VECS_CC3  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . VECS_CC3. Vectors stored in CC3 computations. Type: integer; Default: 10. Previous topic; T3_WS_INCORE; Next topic; VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__vecs_cc3-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_cc3-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_cc3.html:567,Deployability,update,updated,567,". VECS_CC3  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . VECS_CC3. Vectors stored in CC3 computations. Type: integer; Default: 10. Previous topic; T3_WS_INCORE; Next topic; VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__vecs_cc3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_cc3.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_per_root-1.html:552,Deployability,update,updated,552,". VECS_PER_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . VECS_PER_ROOT. Vectors stored per root. Type: integer; Default: 12. Previous topic; VECS_CC3; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__vecs_per_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_per_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_per_root.html:552,Deployability,update,updated,552,". VECS_PER_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . VECS_PER_ROOT. Vectors stored per root. Type: integer; Default: 12. Previous topic; VECS_CC3; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__vecs_per_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__vecs_per_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__wfn-1.html:584,Deployability,update,updated,584,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . WFN. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. Previous topic; VECS_PER_ROOT; Next topic; CCHBAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__wfn.html:584,Deployability,update,updated,584,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM . WFN. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. Previous topic; VECS_PER_ROOT; Next topic; CCHBAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cceom__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cceom__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html:991,Deployability,update,updated,991,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html:991,Deployability,update,updated,991,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference-1.html:584,Deployability,update,updated,584,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference-1.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference.html:584,Deployability,update,updated,584,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__eom_reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__t_amps-1.html:586,Deployability,update,updated,586,". T_AMPS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . T_AMPS. Do compute the Tamplitude equation matrix elements?. Type: boolean; Default: false. Previous topic; EOM_REFERENCE; Next topic; WABEI_LOWDISK; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__t_amps-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__t_amps-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__t_amps.html:586,Deployability,update,updated,586,". T_AMPS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . T_AMPS. Do compute the Tamplitude equation matrix elements?. Type: boolean; Default: false. Previous topic; EOM_REFERENCE; Next topic; WABEI_LOWDISK; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__t_amps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__t_amps.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wabei_lowdisk-1.html:592,Deployability,update,updated,592,". WABEI_LOWDISK  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . WABEI_LOWDISK. Do use the minimal-disk algorithm for Wabei? Its VERY slow!. Type: boolean; Default: false. Previous topic; T_AMPS; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__wabei_lowdisk-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wabei_lowdisk-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wabei_lowdisk.html:592,Deployability,update,updated,592,". WABEI_LOWDISK  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . WABEI_LOWDISK. Do use the minimal-disk algorithm for Wabei? Its VERY slow!. Type: boolean; Default: false. Previous topic; T_AMPS; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__wabei_lowdisk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wabei_lowdisk.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wfn-1.html:538,Deployability,update,updated,538,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; WABEI_LOWDISK; Next topic; CCLAMBDA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wfn.html:538,Deployability,update,updated,538,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; WABEI_LOWDISK; Next topic; CCLAMBDA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cchbar__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cchbar__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__abcd-1.html:557,Deployability,update,updated,557,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCLAMBDA; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__abcd-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__abcd.html:557,Deployability,update,updated,557,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCLAMBDA; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__abcd.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis-1.html:600,Deployability,update,updated,600,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis-1.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis.html:600,Deployability,update,updated,600,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__ao_basis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html:999,Deployability,update,updated,999,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html:999,Deployability,update,updated,999,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; CAS_FILES_WRITE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write-1.html:633,Deployability,update,updated,633,". CAS_FILES_WRITE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CAS_FILES_WRITE. Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. Previous topic; CACHELEVEL; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write-1.html:334,Performance,CACHE,CACHELEVEL,334,". CAS_FILES_WRITE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CAS_FILES_WRITE. Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. Previous topic; CACHELEVEL; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write.html:633,Deployability,update,updated,633,". CAS_FILES_WRITE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CAS_FILES_WRITE. Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. Previous topic; CACHELEVEL; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write.html:334,Performance,CACHE,CACHELEVEL,334,". CAS_FILES_WRITE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . CAS_FILES_WRITE. Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. Previous topic; CACHELEVEL; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__cas_files_write.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__diis-1.html:586,Deployability,update,updated,586,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CAS_FILES_WRITE; Next topic; FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__diis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__diis.html:586,Deployability,update,updated,586,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CAS_FILES_WRITE; Next topic; FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__diis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__follow_root-1.html:546,Deployability,update,updated,546,". FOLLOW_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . FOLLOW_ROOT. Root to get OPDM. Type: integer; Default: 1. Previous topic; DIIS; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__follow_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__follow_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__follow_root.html:546,Deployability,update,updated,546,". FOLLOW_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . FOLLOW_ROOT. Root to get OPDM. Type: integer; Default: 1. Previous topic; DIIS; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__follow_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__follow_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype-1.html:562,Deployability,update,updated,562,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; FOLLOW_ROOT; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__jobtype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype-1.html:199,Performance,perform,performed,199,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; FOLLOW_ROOT; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__jobtype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype.html:562,Deployability,update,updated,562,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; FOLLOW_ROOT; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__jobtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype.html:199,Performance,perform,performed,199,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; FOLLOW_ROOT; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__jobtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__jobtype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local-1.html:591,Deployability,update,updated,591,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; JOBTYPE; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local.html:591,Deployability,update,updated,591,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; JOBTYPE; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cphf_cutoff-1.html:603,Deployability,update,updated,603,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cphf_cutoff.html:603,Deployability,update,updated,603,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cutoff-1.html:832,Deployability,update,updated,832,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cutoff.html:832,Deployability,update,updated,832,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_filter_singles-1.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_FILTER_SINGLES. Do apply local filtering to single de-excitation ( amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_filter_singles.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_FILTER_SINGLES. Do apply local filtering to single de-excitation ( amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_filter_singles.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_method-1.html:693,Deployability,update,updated,693,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_method-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_method.html:693,Deployability,update,updated,693,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_method.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_pairdef-1.html:586,Deployability,update,updated,586,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: No Default. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_pairdef.html:586,Deployability,update,updated,586,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: No Default. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_pairdef.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_weakp-1.html:697,Deployability,update,updated,697,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_weakp-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_weakp.html:697,Deployability,update,updated,697,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__local_weakp.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__maxiter-1.html:565,Deployability,update,updated,565,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . MAXITER. Maximum number of iterations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__maxiter-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__maxiter.html:565,Deployability,update,updated,565,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . MAXITER. Maximum number of iterations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__maxiter.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__num_amps_print-1.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. Previous topic; MAXITER; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__num_amps_print.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. Previous topic; MAXITER; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__num_amps_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_all-1.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ALL. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__prop_all-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_all-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_all.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ALL. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__prop_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_all.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_root-1.html:586,Deployability,update,updated,586,". PROP_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__prop_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_root-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_root.html:586,Deployability,update,updated,586,". PROP_ROOT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__prop_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_root.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_sym-1.html:557,Deployability,update,updated,557,". PROP_SYM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__prop_sym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_sym-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_sym.html:557,Deployability,update,updated,557,". PROP_SYM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__prop_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__prop_sym.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__restart-1.html:609,Deployability,update,updated,609,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . RESTART. Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__restart-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__restart.html:609,Deployability,update,updated,609,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . RESTART. Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__restart.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__roots_per_irrep-1.html:622,Deployability,update,updated,622,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; RESTART; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__roots_per_irrep.html:622,Deployability,update,updated,622,". ROOTS_PER_IRREP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; RESTART; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__r_convergence-1.html:625,Deployability,update,updated,625,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . R_CONVERGENCE. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. Previous topic; PROP_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__r_convergence.html:625,Deployability,update,updated,625,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . R_CONVERGENCE. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. Previous topic; PROP_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__sekino-1.html:575,Deployability,update,updated,575,". SEKINO  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; ROOTS_PER_IRREP; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__sekino-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__sekino-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__sekino.html:575,Deployability,update,updated,575,". SEKINO  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; ROOTS_PER_IRREP; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__sekino.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__sekino.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__wfn-1.html:532,Deployability,update,updated,532,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . WFN. Wavefunction type. Type: string; Default: NONE. Previous topic; SEKINO; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__wfn.html:532,Deployability,update,updated,532,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . WFN. Wavefunction type. Type: string; Default: NONE. Previous topic; SEKINO; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__zeta-1.html:534,Deployability,update,updated,534,". ZETA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; WFN; Next topic; CCRESPONSE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__zeta-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__zeta-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__zeta.html:534,Deployability,update,updated,534,". ZETA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; WFN; Next topic; CCRESPONSE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cclambda__zeta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cclambda__zeta.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__abcd-1.html:562,Deployability,update,updated,562,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCRESPONSE; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__abcd-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__abcd.html:562,Deployability,update,updated,562,". ABCD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCRESPONSE; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__abcd.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze-1.html:557,Deployability,update,updated,557,". ANALYZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__analyze-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze-1.html:274,Performance,CACHE,CACHELEVEL,274,". ANALYZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__analyze-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze.html:557,Deployability,update,updated,557,". ANALYZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__analyze.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze.html:274,Performance,CACHE,CACHELEVEL,274,". ANALYZE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__analyze.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__analyze.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html:557,Deployability,update,updated,557,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html:176,Performance,CACHE,CACHELEVEL,176,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html:189,Performance,Cache,Cacheing,189,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html:557,Deployability,update,updated,557,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html:176,Performance,CACHE,CACHELEVEL,176,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html:189,Performance,Cache,Cacheing,189,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis-1.html:579,Deployability,update,updated,579,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis-1.html:277,Performance,CACHE,CACHELEVEL,277,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis.html:579,Deployability,update,updated,579,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis.html:277,Performance,CACHE,CACHELEVEL,277,". DIIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__diis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge-1.html:997,Deployability,update,updated,997,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge-1.html:463,Integrability,depend,dependent,463,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge.html:997,Deployability,update,updated,997,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge.html:463,Integrability,depend,dependent,463,". GAUGE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__gauge.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__linear-1.html:567,Deployability,update,updated,567,". LINEAR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LINEAR. Do Bartlett size-extensive linear model?. Type: boolean; Default: false. Previous topic; GAUGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__linear-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__linear-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__linear.html:567,Deployability,update,updated,567,". LINEAR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LINEAR. Do Bartlett size-extensive linear model?. Type: boolean; Default: false. Previous topic; GAUGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__linear.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__linear.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local-1.html:568,Deployability,update,updated,568,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL. Do simulate local correlation?. Type: boolean; Default: false. Previous topic; LINEAR; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local.html:568,Deployability,update,updated,568,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL. Do simulate local correlation?. Type: boolean; Default: false. Previous topic; LINEAR; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cphf_cutoff-1.html:607,Deployability,update,updated,607,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cphf_cutoff.html:607,Deployability,update,updated,607,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cutoff-1.html:836,Deployability,update,updated,836,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.01. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cutoff.html:836,Deployability,update,updated,836,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.01. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_filter_singles-1.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_filter_singles.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_filter_singles.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_method-1.html:697,Deployability,update,updated,697,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_method-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_method.html:697,Deployability,update,updated,697,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_method.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_pairdef-1.html:584,Deployability,update,updated,584,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: NONE. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_pairdef.html:584,Deployability,update,updated,584,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: NONE. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_pairdef.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_weakp-1.html:701,Deployability,update,updated,701,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_weakp-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_weakp.html:701,Deployability,update,updated,701,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__local_weakp.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__maxiter-1.html:611,Deployability,update,updated,611,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . MAXITER. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__maxiter-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__maxiter.html:611,Deployability,update,updated,611,". MAXITER  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . MAXITER. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__maxiter.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__num_amps_print-1.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. Previous topic; MAXITER; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__num_amps_print.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. Previous topic; MAXITER; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__num_amps_print.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__omega-1.html:865,Deployability,update,updated,865,". OMEGA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . OMEGA. Array that specifies the desired frequencies of the incident// radiation field in CCLR calculations. If only one element is// given, the units will be assumed to be atomic units. If more// than one element is given, then the units must be specified as the final// element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__omega-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__omega-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__omega.html:865,Deployability,update,updated,865,". OMEGA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . OMEGA. Array that specifies the desired frequencies of the incident// radiation field in CCLR calculations. If only one element is// given, the units will be assumed to be atomic units. If more// than one element is given, then the units must be specified as the final// element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__omega.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__property-1.html:925,Deployability,update,updated,925,". PROPERTY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . PROPERTY. Array that specifies the desired frequencies of the incident// radiation field in CCLR calculations. If only one element is// given, the units will be assumed to be atomic units. If more// than one element is given, then the units must be specified as the final// element of the array. Acceptable units are HZ, NM, EV, and AU. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__property-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__property-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__property.html:925,Deployability,update,updated,925,". PROPERTY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . PROPERTY. Array that specifies the desired frequencies of the incident// radiation field in CCLR calculations. If only one element is// given, the units will be assumed to be atomic units. If more// than one element is given, then the units must be specified as the final// element of the array. Acceptable units are HZ, NM, EV, and AU. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__property.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__reference-1.html:567,Deployability,update,updated,567,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__reference.html:567,Deployability,update,updated,567,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__restart-1.html:568,Deployability,update,updated,568,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . RESTART. Do restart from on-disk amplitudes?. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__restart-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__restart.html:568,Deployability,update,updated,568,". RESTART  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . RESTART. Do restart from on-disk amplitudes?. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__restart.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__r_convergence-1.html:624,Deployability,update,updated,624,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . R_CONVERGENCE. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__r_convergence-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__r_convergence.html:624,Deployability,update,updated,624,". R_CONVERGENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . R_CONVERGENCE. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__r_convergence.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__sekino-1.html:571,Deployability,update,updated,571,". SEKINO  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; RESTART; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__sekino-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__sekino-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__sekino.html:571,Deployability,update,updated,571,". SEKINO  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; RESTART; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__sekino.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__sekino.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__wfn-1.html:537,Deployability,update,updated,537,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEKINO; Next topic; CCSORT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__wfn.html:537,Deployability,update,updated,537,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEKINO; Next topic; CCSORT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccresponse__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccresponse__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis-1.html:598,Deployability,update,updated,598,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis-1.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis.html:598,Deployability,update,updated,598,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ao_basis.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html:993,Deployability,update,updated,993,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html:993,Deployability,update,updated,993,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference-1.html:592,Deployability,update,updated,592,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference-1.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference.html:592,Deployability,update,updated,592,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__eom_reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ints_tolerance-1.html:612,Deployability,update,updated,612,". INTS_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; EOM_REFERENCE; Next topic; KEEP_OEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__ints_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ints_tolerance-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ints_tolerance.html:612,Deployability,update,updated,612,". INTS_TOLERANCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; EOM_REFERENCE; Next topic; KEEP_OEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__ints_tolerance.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_oeifile-1.html:590,Deployability,update,updated,590,". KEEP_OEIFILE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_OEIFILE. Do retain the input one-electron integrals?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; KEEP_TEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__keep_oeifile-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_oeifile-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_oeifile.html:590,Deployability,update,updated,590,". KEEP_OEIFILE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_OEIFILE. Do retain the input one-electron integrals?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; KEEP_TEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__keep_oeifile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_oeifile.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_teifile-1.html:581,Deployability,update,updated,581,". KEEP_TEIFILE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_TEIFILE. Do retain the input two-electron integrals?. Type: boolean; Default: false. Previous topic; KEEP_OEIFILE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__keep_teifile-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_teifile-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_teifile.html:581,Deployability,update,updated,581,". KEEP_TEIFILE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_TEIFILE. Do retain the input two-electron integrals?. Type: boolean; Default: false. Previous topic; KEEP_OEIFILE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__keep_teifile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__keep_teifile.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local-1.html:592,Deployability,update,updated,592,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; KEEP_TEIFILE; Next topic; LOCAL_CORE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local.html:592,Deployability,update,updated,592,". LOCAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; KEEP_TEIFILE; Next topic; LOCAL_CORE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_core_cutoff-1.html:574,Deployability,update,updated,574,". LOCAL_CORE_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CORE_CUTOFF. Local core cutoff value. Type: double; Default: 0.05. Previous topic; LOCAL; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_core_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_core_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_core_cutoff.html:574,Deployability,update,updated,574,". LOCAL_CORE_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CORE_CUTOFF. Local core cutoff value. Type: double; Default: 0.05. Previous topic; LOCAL; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_core_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_core_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cphf_cutoff-1.html:611,Deployability,update,updated,611,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL_CORE_CUTOFF; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cphf_cutoff.html:611,Deployability,update,updated,611,". LOCAL_CPHF_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL_CORE_CUTOFF; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cutoff-1.html:824,Deployability,update,updated,824,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_DOMAIN_MAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cutoff.html:824,Deployability,update,updated,824,". LOCAL_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_DOMAIN_MAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_mag-1.html:614,Deployability,update,updated,614,". LOCAL_DOMAIN_MAG  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_MAG. Do generate magnetic-field CPHF solutions for local-CC?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_DOMAIN_POLAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_mag-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_mag-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_mag.html:614,Deployability,update,updated,614,". LOCAL_DOMAIN_MAG  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_MAG. Do generate magnetic-field CPHF solutions for local-CC?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_DOMAIN_POLAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_mag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_mag.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_polar-1.html:612,Deployability,update,updated,612,". LOCAL_DOMAIN_POLAR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_POLAR. Do use augment domains with polarized orbitals?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_MAG; Next topic; LOCAL_DOMAIN_SEP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_polar-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_polar-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_polar.html:612,Deployability,update,updated,612,". LOCAL_DOMAIN_POLAR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_POLAR. Do use augment domains with polarized orbitals?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_MAG; Next topic; LOCAL_DOMAIN_SEP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_polar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_polar.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_sep-1.html:565,Deployability,update,updated,565,". LOCAL_DOMAIN_SEP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_SEP. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_POLAR; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_sep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_sep-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_sep.html:565,Deployability,update,updated,565,". LOCAL_DOMAIN_SEP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_SEP. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_POLAR; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_sep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_domain_sep.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_filter_singles-1.html:622,Deployability,update,updated,622,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_SEP; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_filter_singles.html:622,Deployability,update,updated,622,". LOCAL_FILTER_SINGLES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_SEP; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_filter_singles.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_method-1.html:689,Deployability,update,updated,689,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_method-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_method.html:689,Deployability,update,updated,689,". LOCAL_METHOD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_method.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_pairdef-1.html:621,Deployability,update,updated,621,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_PAIRDEF. Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_pairdef.html:621,Deployability,update,updated,621,". LOCAL_PAIRDEF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_PAIRDEF. Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_pairdef.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_weakp-1.html:691,Deployability,update,updated,691,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_weakp-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_weakp.html:691,Deployability,update,updated,691,". LOCAL_WEAKP  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__local_weakp.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega-1.html:580,Deployability,update,updated,580,". OMEGA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__omega-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega-1.html:175,Energy Efficiency,Energy,Energy,175,". OMEGA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__omega-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega.html:580,Deployability,update,updated,580,". OMEGA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega.html:175,Energy Efficiency,Energy,Energy,175,". OMEGA  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__omega.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__property-1.html:639,Deployability,update,updated,639,". PROPERTY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . PROPERTY. The response property desired. The unique acceptable values is POLARIZABILITY for dipole-polarizabilitie. Type: string; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__property-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__property-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__property.html:639,Deployability,update,updated,639,". PROPERTY  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . PROPERTY. The response property desired. The unique acceptable values is POLARIZABILITY for dipole-polarizabilitie. Type: string; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__property.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__reference-1.html:560,Deployability,update,updated,560,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROPERTY; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__reference.html:560,Deployability,update,updated,560,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROPERTY; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__semicanonical-1.html:571,Deployability,update,updated,571,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__semicanonical-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__semicanonical.html:571,Deployability,update,updated,571,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__semicanonical.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__wfn-1.html:546,Deployability,update,updated,546,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . WFN. Wavefunction type. Type: string; Default: No Default. Previous topic; SEMICANONICAL; Next topic; CCTRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__wfn.html:546,Deployability,update,updated,546,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT . WFN. Wavefunction type. Type: string; Default: No Default. Previous topic; SEMICANONICAL; Next topic; CCTRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/ccsort__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/ccsort__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__cc_num_threads-1.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CCTRIPLES; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__cc_num_threads.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CCTRIPLES; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__cc_num_threads.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__reference-1.html:572,Deployability,update,updated,572,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; CC_NUM_THREADS; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__reference-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__reference.html:572,Deployability,update,updated,572,". REFERENCE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; CC_NUM_THREADS; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__reference.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__semicanonical-1.html:577,Deployability,update,updated,577,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__semicanonical-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__semicanonical.html:577,Deployability,update,updated,577,". SEMICANONICAL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__semicanonical.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__wfn-1.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEMICANONICAL; Next topic; CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__wfn-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__wfn.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEMICANONICAL; Next topic; CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cctriples__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cctriples__wfn.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html:563,Deployability,update,updated,563,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html:170,Performance,CACHE,CACHELEVEL,170,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html:197,Performance,cache,cacheing,197,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html:217,Performance,perform,perform,217,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html:287,Performance,CACHE,CACHETYPE,287,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html:563,Deployability,update,updated,563,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html:170,Performance,CACHE,CACHELEVEL,170,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html:197,Performance,cache,cacheing,197,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html:217,Performance,perform,perform,217,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html:287,Performance,CACHE,CACHETYPE,287,". CACHELEVEL  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; CPHF; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachelevel.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html:210,Deployability,release,release,210,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html:606,Deployability,update,updated,606,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html:169,Performance,CACHE,CACHETYPE,169,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html:218,Performance,cache,cached,218,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html:302,Performance,CACHE,CACHELEVEL,302,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html:210,Deployability,release,release,210,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html:606,Deployability,update,updated,606,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html:169,Performance,CACHE,CACHETYPE,169,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html:218,Performance,cache,cached,218,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html:302,Performance,CACHE,CACHELEVEL,302,". CACHETYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. Previous topic; CACHELEVEL; Next topic; CIS_AD_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cachetype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states-1.html:634,Deployability,update,updated,634,". CIS_AD_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_AD_STATES. Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CACHETYPE; Next topic; CIS_AMPLITUDE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states-1.html:324,Performance,CACHE,CACHETYPE,324,". CIS_AD_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_AD_STATES. Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CACHETYPE; Next topic; CIS_AMPLITUDE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states.html:634,Deployability,update,updated,634,". CIS_AD_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_AD_STATES. Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CACHETYPE; Next topic; CIS_AMPLITUDE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states.html:324,Performance,CACHE,CACHETYPE,324,". CIS_AD_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_AD_STATES. Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CACHETYPE; Next topic; CIS_AMPLITUDE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_ad_states.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_amplitude_cutoff-1.html:610,Deployability,update,updated,610,". CIS_AMPLITUDE_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_AMPLITUDE_CUTOFF. Minimum singles amplitude to print in CIS analysis. Type: double; Default: 0.15. Previous topic; CIS_AD_STATES; Next topic; CIS_DOPDM_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_amplitude_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_amplitude_cutoff-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_amplitude_cutoff.html:610,Deployability,update,updated,610,". CIS_AMPLITUDE_CUTOFF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_AMPLITUDE_CUTOFF. Minimum singles amplitude to print in CIS analysis. Type: double; Default: 0.15. Previous topic; CIS_AD_STATES; Next topic; CIS_DOPDM_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_amplitude_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_amplitude_cutoff.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_dopdm_states-1.html:660,Deployability,update,updated,660,". CIS_DOPDM_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_DOPDM_STATES. Which states to save AO difference OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_AMPLITUDE_CUTOFF; Next topic; CIS_MEM_SAFETY_FACTOR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_dopdm_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_dopdm_states-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_dopdm_states.html:660,Deployability,update,updated,660,". CIS_DOPDM_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_DOPDM_STATES. Which states to save AO difference OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_AMPLITUDE_CUTOFF; Next topic; CIS_MEM_SAFETY_FACTOR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_dopdm_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_dopdm_states.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor-1.html:600,Deployability,update,updated,600,". CIS_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_DOPDM_STATES; Next topic; CIS_NO_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor-1.html:212,Safety,safe,safety,212,". CIS_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_DOPDM_STATES; Next topic; CIS_NO_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor.html:600,Deployability,update,updated,600,". CIS_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_DOPDM_STATES; Next topic; CIS_NO_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor.html:212,Safety,safe,safety,212,". CIS_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_DOPDM_STATES; Next topic; CIS_NO_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_mem_safety_factor.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_no_states-1.html:649,Deployability,update,updated,649,". CIS_NO_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_NO_STATES. Which states to save AO Natural Orbitals for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_MEM_SAFETY_FACTOR; Next topic; CIS_OPDM_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_no_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_no_states-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_no_states.html:649,Deployability,update,updated,649,". CIS_NO_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_NO_STATES. Which states to save AO Natural Orbitals for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_MEM_SAFETY_FACTOR; Next topic; CIS_OPDM_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_no_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_no_states.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_opdm_states-1.html:635,Deployability,update,updated,635,". CIS_OPDM_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_OPDM_STATES. Which states to save AO OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_NO_STATES; Next topic; CIS_TOPDM_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_opdm_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_opdm_states-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_opdm_states.html:635,Deployability,update,updated,635,". CIS_OPDM_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_OPDM_STATES. Which states to save AO OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_NO_STATES; Next topic; CIS_TOPDM_STATES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_opdm_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_opdm_states.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_topdm_states-1.html:656,Deployability,update,updated,656,". CIS_TOPDM_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_TOPDM_STATES. Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_OPDM_STATES; Next topic; CPHF_MEM_SAFETY_FACTOR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_topdm_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_topdm_states-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_topdm_states.html:656,Deployability,update,updated,656,". CIS_TOPDM_STATES  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CIS_TOPDM_STATES. Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CIS_OPDM_STATES; Next topic; CPHF_MEM_SAFETY_FACTOR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cis_topdm_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cis_topdm_states.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor-1.html:599,Deployability,update,updated,599,". CPHF_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CPHF_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_TOPDM_STATES; Next topic; CPHF_TASKS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor-1.html:214,Safety,safe,safety,214,". CPHF_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CPHF_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_TOPDM_STATES; Next topic; CPHF_TASKS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor.html:599,Deployability,update,updated,599,". CPHF_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CPHF_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_TOPDM_STATES; Next topic; CPHF_TASKS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor.html:214,Safety,safe,safety,214,". CPHF_MEM_SAFETY_FACTOR  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CPHF_MEM_SAFETY_FACTOR. Memory safety factor for allocating JK. Type: double; Default: 0.75. Previous topic; CIS_TOPDM_STATES; Next topic; CPHF_TASKS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_mem_safety_factor.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_tasks-1.html:607,Deployability,update,updated,607,". CPHF_TASKS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CPHF_TASKS. Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. Previous topic; CPHF_MEM_SAFETY_FACTOR; Next topic; DEBUG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cphf_tasks-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_tasks-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_tasks.html:607,Deployability,update,updated,607,". CPHF_TASKS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . CPHF_TASKS. Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. Previous topic; CPHF_MEM_SAFETY_FACTOR; Next topic; DEBUG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__cphf_tasks.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__cphf_tasks.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__debug-1.html:579,Deployability,update,updated,579,". DEBUG  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DEBUG. The amount of debug information printed to the output file. Type: integer; Default: 0. Previous topic; CPHF_TASKS; Next topic; DF_BASIS_SCF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__debug-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__debug-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__debug.html:579,Deployability,update,updated,579,". DEBUG  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DEBUG. The amount of debug information printed to the output file. Type: integer; Default: 0. Previous topic; CPHF_TASKS; Next topic; DF_BASIS_SCF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__debug.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__debug.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__df_basis_scf-1.html:591,Deployability,update,updated,591,". DF_BASIS_SCF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DF_BASIS_SCF. Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. Previous topic; DEBUG; Next topic; DO_SINGLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__df_basis_scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__df_basis_scf-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__df_basis_scf.html:591,Deployability,update,updated,591,". DF_BASIS_SCF  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DF_BASIS_SCF. Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. Previous topic; DEBUG; Next topic; DO_SINGLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__df_basis_scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__df_basis_scf.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_singlets-1.html:568,Deployability,update,updated,568,". DO_SINGLETS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DO_SINGLETS. Do singlet states? Default true. Type: boolean; Default: true. Previous topic; DF_BASIS_SCF; Next topic; DO_TRIPLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__do_singlets-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_singlets-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_singlets.html:568,Deployability,update,updated,568,". DO_SINGLETS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DO_SINGLETS. Do singlet states? Default true. Type: boolean; Default: true. Previous topic; DF_BASIS_SCF; Next topic; DO_TRIPLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__do_singlets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_singlets.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_triplets-1.html:576,Deployability,update,updated,576,". DO_TRIPLETS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DO_TRIPLETS. Do triplet states? Default true. Type: boolean; Default: true. Previous topic; DO_SINGLETS; Next topic; EXPLICIT_HAMILTONIAN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__do_triplets-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_triplets-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_triplets.html:576,Deployability,update,updated,576,". DO_TRIPLETS  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . DO_TRIPLETS. Do triplet states? Default true. Type: boolean; Default: true. Previous topic; DO_SINGLETS; Next topic; EXPLICIT_HAMILTONIAN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__do_triplets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__do_triplets.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__explicit_hamiltonian-1.html:590,Deployability,update,updated,590,". EXPLICIT_HAMILTONIAN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . EXPLICIT_HAMILTONIAN. Do explicit hamiltonian only?. Type: boolean; Default: false. Previous topic; DO_TRIPLETS; Next topic; FITTING_ALGORITHM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__explicit_hamiltonian-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__explicit_hamiltonian-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__explicit_hamiltonian.html:590,Deployability,update,updated,590,". EXPLICIT_HAMILTONIAN  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . EXPLICIT_HAMILTONIAN. Do explicit hamiltonian only?. Type: boolean; Default: false. Previous topic; DO_TRIPLETS; Next topic; FITTING_ALGORITHM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__explicit_hamiltonian.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__explicit_hamiltonian.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_algorithm-1.html:600,Deployability,update,updated,600,". FITTING_ALGORITHM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . FITTING_ALGORITHM. Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. Previous topic; EXPLICIT_HAMILTONIAN; Next topic; FITTING_CONDITION; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__fitting_algorithm-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_algorithm-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_algorithm.html:600,Deployability,update,updated,600,". FITTING_ALGORITHM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . FITTING_ALGORITHM. Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. Previous topic; EXPLICIT_HAMILTONIAN; Next topic; FITTING_CONDITION; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__fitting_algorithm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_algorithm.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_condition-1.html:614,Deployability,update,updated,614,". FITTING_CONDITION  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . FITTING_CONDITION. The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. Previous topic; FITTING_ALGORITHM; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__fitting_condition-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_condition-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_condition.html:614,Deployability,update,updated,614,". FITTING_CONDITION  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . FITTING_CONDITION. The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. Previous topic; FITTING_ALGORITHM; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__fitting_condition.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__fitting_condition.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype-1.html:553,Deployability,update,updated,553,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . JOBTYPE. Type of job being performed. Type: string; Default: SP. Previous topic; FITTING_CONDITION; Next topic; MODULE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__jobtype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype-1.html:195,Performance,perform,performed,195,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . JOBTYPE. Type of job being performed. Type: string; Default: SP. Previous topic; FITTING_CONDITION; Next topic; MODULE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__jobtype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype.html:553,Deployability,update,updated,553,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . JOBTYPE. Type of job being performed. Type: string; Default: SP. Previous topic; FITTING_CONDITION; Next topic; MODULE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__jobtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype.html:195,Performance,perform,performed,195,". JOBTYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . JOBTYPE. Type of job being performed. Type: string; Default: SP. Previous topic; FITTING_CONDITION; Next topic; MODULE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__jobtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__jobtype.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module-1.html:597,Deployability,update,updated,597,". MODULE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MODULE. What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. Previous topic; JOBTYPE; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__module-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module-1.html:187,Testability,test,test,187,". MODULE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MODULE. What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. Previous topic; JOBTYPE; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__module-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module.html:597,Deployability,update,updated,597,". MODULE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MODULE. What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. Previous topic; JOBTYPE; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module.html:187,Testability,test,test,187,". MODULE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MODULE. What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. Previous topic; JOBTYPE; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__module.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_os_scale-1.html:601,Deployability,update,updated,601,". MP2_OS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MP2_OS_SCALE. The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. Previous topic; MODULE; Next topic; MP2_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__mp2_os_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_os_scale-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_os_scale.html:601,Deployability,update,updated,601,". MP2_OS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MP2_OS_SCALE. The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. Previous topic; MODULE; Next topic; MP2_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__mp2_os_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_os_scale.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_ss_scale-1.html:599,Deployability,update,updated,599,". MP2_SS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MP2_SS_SCALE. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. Previous topic; MP2_OS_SCALE; Next topic; MP2_TYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__mp2_ss_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_ss_scale-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_ss_scale.html:599,Deployability,update,updated,599,". MP2_SS_SCALE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MP2_SS_SCALE. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. Previous topic; MP2_OS_SCALE; Next topic; MP2_TYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__mp2_ss_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_ss_scale.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_type-1.html:601,Deployability,update,updated,601,". MP2_TYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MP2_TYPE. What algorithm to use for the MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. Previous topic; MP2_SS_SCALE; Next topic; OMP_N_THREAD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__mp2_type-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_type-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_type.html:601,Deployability,update,updated,601,". MP2_TYPE  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . MP2_TYPE. What algorithm to use for the MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. Previous topic; MP2_SS_SCALE; Next topic; OMP_N_THREAD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__mp2_type.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__mp2_type.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__omp_n_thread-1.html:593,Deployability,update,updated,593,". OMP_N_THREAD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . OMP_N_THREAD. The maximum number of integral threads (0 for omp_get_max_threads()). Type: integer; Default: 0. Previous topic; MP2_TYPE; Next topic; OPDM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__omp_n_thread-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__omp_n_thread-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__omp_n_thread.html:593,Deployability,update,updated,593,". OMP_N_THREAD  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . OMP_N_THREAD. The maximum number of integral threads (0 for omp_get_max_threads()). Type: integer; Default: 0. Previous topic; MP2_TYPE; Next topic; OPDM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__omp_n_thread.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__omp_n_thread.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm-1.html:582,Deployability,update,updated,582,". OPDM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . OPDM. Do compute the one particle density matrix, for properties?. Type: boolean; Default: false. Previous topic; OMP_N_THREAD; Next topic; OPDM_RELAX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__opdm-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm.html:582,Deployability,update,updated,582,". OPDM  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . OPDM. Do compute the one particle density matrix, for properties?. Type: boolean; Default: false. Previous topic; OMP_N_THREAD; Next topic; OPDM_RELAX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__opdm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm_relax-1.html:597,Deployability,update,updated,597,". OPDM_RELAX  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . OPDM_RELAX. Do add relaxation terms to the one particle density matrix, for properties?. Type: boolean; Default: false. Previous topic; OPDM; Next topic; PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__opdm_relax-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm_relax-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm_relax.html:597,Deployability,update,updated,597,". OPDM_RELAX  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . OPDM_RELAX. Do add relaxation terms to the one particle density matrix, for properties?. Type: boolean; Default: false. Previous topic; OPDM; Next topic; PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__opdm_relax.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__opdm_relax.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__print-1.html:570,Deployability,update,updated,570,". PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . PRINT. The amount of information printed to the output file. Type: integer; Default: 1. Previous topic; OPDM_RELAX; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__print-1.html
https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__print.html:570,Deployability,update,updated,570,". PRINT  PSI4 [beta5] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF . PRINT. The amount of information printed to the output file. Type: integer; Default: 1. Previous topic; OPDM_RELAX; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta5]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/autodir_options_c/cphf__print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/cphf__print.html
