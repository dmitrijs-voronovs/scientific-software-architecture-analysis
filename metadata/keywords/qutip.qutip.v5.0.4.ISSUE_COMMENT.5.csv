id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/qutip/qutip/pull/1820#issuecomment-1137085764:82,Availability,failure,failures,82,The changes look good but there are still some `test_satisfy_eigenvalue_equation` failures -- perhaps the accuracy just needs to be loosened slightly?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1820#issuecomment-1137085764
https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500:417,Deployability,integrat,integrator,417,"The times at which the `L` are computed are not those at which the states are computed. It computes the derivative at times farther than the desired time and do an interpolation step to get the state. . Some feature (pulse) may be skipped by this method and you should set `Options(max_step=...)` with a `max_step` smaller than half the pulse width, but it should have no issue with a linear ramp. We use the `zvode` integrator of `scipy.integrate.ode`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500
https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500:438,Deployability,integrat,integrate,438,"The times at which the `L` are computed are not those at which the states are computed. It computes the derivative at times farther than the desired time and do an interpolation step to get the state. . Some feature (pulse) may be skipped by this method and you should set `Options(max_step=...)` with a `max_step` smaller than half the pulse width, but it should have no issue with a linear ramp. We use the `zvode` integrator of `scipy.integrate.ode`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500
https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500:417,Integrability,integrat,integrator,417,"The times at which the `L` are computed are not those at which the states are computed. It computes the derivative at times farther than the desired time and do an interpolation step to get the state. . Some feature (pulse) may be skipped by this method and you should set `Options(max_step=...)` with a `max_step` smaller than half the pulse width, but it should have no issue with a linear ramp. We use the `zvode` integrator of `scipy.integrate.ode`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500
https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500:438,Integrability,integrat,integrate,438,"The times at which the `L` are computed are not those at which the states are computed. It computes the derivative at times farther than the desired time and do an interpolation step to get the state. . Some feature (pulse) may be skipped by this method and you should set `Options(max_step=...)` with a `max_step` smaller than half the pulse width, but it should have no issue with a linear ramp. We use the `zvode` integrator of `scipy.integrate.ode`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1821#issuecomment-1058493500
https://github.com/qutip/qutip/pull/1825#issuecomment-1061784670:211,Deployability,update,update-superop-tests,211,[![Coverage Status](https://coveralls.io/builds/47184103/badge)](https://coveralls.io/builds/47184103). Coverage remained the same at 68.993% when pulling **175afa8685d8c131ab09587014abc7f6e863d6ad on hodgestar:update-superop-tests** into **71ad3088887e6ccde897fa5f2a632932218ae337 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1825#issuecomment-1061784670
https://github.com/qutip/qutip/pull/1825#issuecomment-1061784670:226,Testability,test,tests,226,[![Coverage Status](https://coveralls.io/builds/47184103/badge)](https://coveralls.io/builds/47184103). Coverage remained the same at 68.993% when pulling **175afa8685d8c131ab09587014abc7f6e863d6ad on hodgestar:update-superop-tests** into **71ad3088887e6ccde897fa5f2a632932218ae337 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1825#issuecomment-1061784670
https://github.com/qutip/qutip/pull/1828#issuecomment-1065880645:378,Safety,avoid,avoid,378,"Thanks! I don't think we should include ipynb files into the main repo though as they are usually pretty large binary files. . If we want to have this figure, it would be nice to include the source code stored somewhere in a file under `qutip\doc` and generate the figure automatically when building the doc. Just like other matplotlib figures. In addition, it would be good to avoid using `pandas` and `mpmath` in the code if possible. Python has its own JSON reader and for mpmath, I'm not sure if such a high float precision is necessary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1828#issuecomment-1065880645
https://github.com/qutip/qutip/pull/1828#issuecomment-1066070285:57,Testability,test,test,57,"Thanks @Leo-am !The code looks great. The HTML rendering test fails in the first test run, but it seems to be a connection problem and it passes after I reran the test. @nathanshammah do you have further comments?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1828#issuecomment-1066070285
https://github.com/qutip/qutip/pull/1828#issuecomment-1066070285:81,Testability,test,test,81,"Thanks @Leo-am !The code looks great. The HTML rendering test fails in the first test run, but it seems to be a connection problem and it passes after I reran the test. @nathanshammah do you have further comments?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1828#issuecomment-1066070285
https://github.com/qutip/qutip/pull/1828#issuecomment-1066070285:163,Testability,test,test,163,"Thanks @Leo-am !The code looks great. The HTML rendering test fails in the first test run, but it seems to be a connection problem and it passes after I reran the test. @nathanshammah do you have further comments?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1828#issuecomment-1066070285
https://github.com/qutip/qutip/issues/1831#issuecomment-1064226855:299,Deployability,release,release,299,"`mesolve` use cython code for speed and there was a strange bug when using sparse matrix with stored `0` so the `tidyup` is needed. As long as pure `0` are not kept, small values can be used. For now `..solve` will respond to `settings.auto_tidyup_atol` with #1832 for such cases. In a future major release (branch `dev.major` if you are curious), the support is for sparse matrix is improved a lot and those settings are used in the sparse matrices operations directly, so they will apply everywhere.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1831#issuecomment-1064226855
https://github.com/qutip/qutip/issues/1833#issuecomment-1065202673:277,Performance,perform,performance,277,It certainly look interesting. Fast diagonalisation of Liouvillian operators is certainly something we could make good use of. However we should wait for v5 of qutip. Some of the new features we are working on match well with this algorithm and should have a visible impact on performance.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1833#issuecomment-1065202673
https://github.com/qutip/qutip/issues/1834#issuecomment-1065163266:211,Integrability,depend,dependent-operators,211,I slightly edited the question to make the code easier to read. You should probably consider using the array-based format https://qutip.org/docs/latest/guide/dynamics/dynamics-time.html#methods-for-writing-time-dependent-operators. Precompute the `q_0` and `q_02` as NumPy arrays with respect to each `t` in the `t_list` using `np.gradient`. Then give them to the solver.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1834#issuecomment-1065163266
https://github.com/qutip/qutip/issues/1834#issuecomment-1065163266:152,Usability,guid,guide,152,I slightly edited the question to make the code easier to read. You should probably consider using the array-based format https://qutip.org/docs/latest/guide/dynamics/dynamics-time.html#methods-for-writing-time-dependent-operators. Precompute the `q_0` and `q_02` as NumPy arrays with respect to each `t` in the `t_list` using `np.gradient`. Then give them to the solver.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1834#issuecomment-1065163266
https://github.com/qutip/qutip/pull/1835#issuecomment-1065786929:202,Integrability,depend,dependabot,202,[![Coverage Status](https://coveralls.io/builds/47299519/badge)](https://coveralls.io/builds/47299519). Coverage decreased (-0.02%) to 68.991% when pulling **6b2bb1c46f8466e3b624ae7bacc844315403fe79 on dependabot/pip/doc/pillow-9.0.1** into **b65aebe0f18e401461a5dc3d7a387129709cb346 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1835#issuecomment-1065786929
https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511:346,Deployability,update,update,346,I resolved the issue with setting the alpha for multiple sets of vectors and added tests for that (and for setting the alpha of points). I'm not going to add tests for Bloch3d now since that uses mayavi which looks like it might be a whole other testing rabbit hole. I will simply run some checks in a notebook manually tomorrow. I still need to update the docstring and look at what the docstring format changes are about. @xspronken @AGaliciaMartinez Reviews of my most recent commits welcomed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511
https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511:83,Testability,test,tests,83,I resolved the issue with setting the alpha for multiple sets of vectors and added tests for that (and for setting the alpha of points). I'm not going to add tests for Bloch3d now since that uses mayavi which looks like it might be a whole other testing rabbit hole. I will simply run some checks in a notebook manually tomorrow. I still need to update the docstring and look at what the docstring format changes are about. @xspronken @AGaliciaMartinez Reviews of my most recent commits welcomed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511
https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511:158,Testability,test,tests,158,I resolved the issue with setting the alpha for multiple sets of vectors and added tests for that (and for setting the alpha of points). I'm not going to add tests for Bloch3d now since that uses mayavi which looks like it might be a whole other testing rabbit hole. I will simply run some checks in a notebook manually tomorrow. I still need to update the docstring and look at what the docstring format changes are about. @xspronken @AGaliciaMartinez Reviews of my most recent commits welcomed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511
https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511:246,Testability,test,testing,246,I resolved the issue with setting the alpha for multiple sets of vectors and added tests for that (and for setting the alpha of points). I'm not going to add tests for Bloch3d now since that uses mayavi which looks like it might be a whole other testing rabbit hole. I will simply run some checks in a notebook manually tomorrow. I still need to update the docstring and look at what the docstring format changes are about. @xspronken @AGaliciaMartinez Reviews of my most recent commits welcomed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511
https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511:274,Usability,simpl,simply,274,I resolved the issue with setting the alpha for multiple sets of vectors and added tests for that (and for setting the alpha of points). I'm not going to add tests for Bloch3d now since that uses mayavi which looks like it might be a whole other testing rabbit hole. I will simply run some checks in a notebook manually tomorrow. I still need to update the docstring and look at what the docstring format changes are about. @xspronken @AGaliciaMartinez Reviews of my most recent commits welcomed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1837#issuecomment-1093447511
https://github.com/qutip/qutip/pull/1837#issuecomment-1094727740:629,Integrability,interface,interface,629,"> The new commits look good! Was wondering whether we should add support for array-like alpha values so that something like `add_vectors([[0,0,1],[1,0,0]], alpha=[0.75,0.60])` would work. Right now it's already possible to do using multiple `add_vector` methods, each with a different alpha value but the other option might be a bit cleaner for the user. I think a single alpha is fine if we take the view that each call to `add_vectors` is one set of related vectors that share some common properties (although they already rotate colours, which is sometimes helpful and sometimes a bit weird :). We need to rethink the `Bloch` interface for version 5 though, so keep ideas like this in mind for then. P.S. Thank you for checking the new commits.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1837#issuecomment-1094727740
https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087:179,Modifiability,variab,variable,179,"Hi, @Ericgig! I would like to work on this issue. We cannot adopt the 3rd option in the master branch due to backwards compatibility, right? I'd rather avoid any single character variable wherever possible. That said, I believe the second option you gave is the best one to adopt in the master branch. Once I finish, I can work on dev.major implementing the third option.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087
https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087:152,Safety,avoid,avoid,152,"Hi, @Ericgig! I would like to work on this issue. We cannot adopt the 3rd option in the master branch due to backwards compatibility, right? I'd rather avoid any single character variable wherever possible. That said, I believe the second option you gave is the best one to adopt in the master branch. Once I finish, I can work on dev.major implementing the third option.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087
https://github.com/qutip/qutip/issues/1839#issuecomment-1079270356:129,Availability,error,errors,129,"Hello Eric,; I could have a look at it and add a test with the `scipy.special.sph_harm` .; Could you explain in more detail what errors you got?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1079270356
https://github.com/qutip/qutip/issues/1839#issuecomment-1079270356:49,Testability,test,test,49,"Hello Eric,; I could have a look at it and add a test with the `scipy.special.sph_harm` .; Could you explain in more detail what errors you got?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1079270356
https://github.com/qutip/qutip/issues/1839#issuecomment-1079304653:79,Availability,error,error,79,"Hi Anto, ; Could you please leave the issue for a GSoC candidate. There are no error raised but looking are the equations, something looks wrong. For example:; For positive `m`: `SPlm[1]`, but the equivalent term for negative values: `SPlm[abs(m)]`. So when adding the tests, I expect that some fixes will be needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1079304653
https://github.com/qutip/qutip/issues/1839#issuecomment-1079304653:269,Testability,test,tests,269,"Hi Anto, ; Could you please leave the issue for a GSoC candidate. There are no error raised but looking are the equations, something looks wrong. For example:; For positive `m`: `SPlm[1]`, but the equivalent term for negative values: `SPlm[abs(m)]`. So when adding the tests, I expect that some fixes will be needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1079304653
https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700:315,Deployability,configurat,configuration,315,"I guess it is my turn then :) ; I looked at the `orbital` function and compared it to the scipy implementation of `sph_harm` and the results don't seem to agree. There is one detail I need for clarification: The `orbital` function uses `ket`states as input. Which component of the `ket` state should refer to which configuration of `m`? . For example, if I pass `basis(3,0)` as argument is the corresponding setting `l = 1, m = -1` or `l = 1, m = 0` or `l = 1, m = 1`? ; I am not sure what the desired assignment is. For me it makes sense to start with the smallest `m` (in the example `m=-1`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700
https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700:315,Modifiability,config,configuration,315,"I guess it is my turn then :) ; I looked at the `orbital` function and compared it to the scipy implementation of `sph_harm` and the results don't seem to agree. There is one detail I need for clarification: The `orbital` function uses `ket`states as input. Which component of the `ket` state should refer to which configuration of `m`? . For example, if I pass `basis(3,0)` as argument is the corresponding setting `l = 1, m = -1` or `l = 1, m = 0` or `l = 1, m = 1`? ; I am not sure what the desired assignment is. For me it makes sense to start with the smallest `m` (in the example `m=-1`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700
https://github.com/qutip/qutip/issues/1839#issuecomment-1082462658:267,Deployability,update,update,267,"Thank you for taking this issue. The contribution to the phase is `np.exp(1.0j * 1 * phi)`, ignoring the `m` and it's not documented. So I guess all ket are `m = 1`...; Since it's wrong and not documented, you are free to choose which ever way you prefer. But please update the docstring so that is is clear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1082462658
https://github.com/qutip/qutip/issues/1839#issuecomment-1082462658:302,Usability,clear,clear,302,"Thank you for taking this issue. The contribution to the phase is `np.exp(1.0j * 1 * phi)`, ignoring the `m` and it's not documented. So I guess all ket are `m = 1`...; Since it's wrong and not documented, you are free to choose which ever way you prefer. But please update the docstring so that is is clear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1082462658
https://github.com/qutip/qutip/pull/1843#issuecomment-1086112353:20,Testability,test,tests,20,"Yes, I will add the tests and modify the loops soon. Thanks for the comments, @AGaliciaMartinez :+1:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1086112353
https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210:108,Integrability,depend,depends,108,"I am using `mesolve` in the test now. I am not sure if that is considered a good style, since the test also depends on this function. I could also just hardcode the expected output. What do you think is better, @AGaliciaMartinez ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210
https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210:28,Testability,test,test,28,"I am using `mesolve` in the test now. I am not sure if that is considered a good style, since the test also depends on this function. I could also just hardcode the expected output. What do you think is better, @AGaliciaMartinez ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210
https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210:98,Testability,test,test,98,"I am using `mesolve` in the test now. I am not sure if that is considered a good style, since the test also depends on this function. I could also just hardcode the expected output. What do you think is better, @AGaliciaMartinez ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210
https://github.com/qutip/qutip/pull/1843#issuecomment-1106279748:102,Testability,test,tests,102,"@christian512, this looks great! I am happy with this being merged as it is. We could further improve tests by testing that all arguments work correctly but I believe that to be out of the scope of this PR. Since this PR already fixes a bug I would rather have it merged. @hodgestar, are you happy with this being merged after the changes?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1106279748
https://github.com/qutip/qutip/pull/1843#issuecomment-1106279748:111,Testability,test,testing,111,"@christian512, this looks great! I am happy with this being merged as it is. We could further improve tests by testing that all arguments work correctly but I believe that to be out of the scope of this PR. Since this PR already fixes a bug I would rather have it merged. @hodgestar, are you happy with this being merged after the changes?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1106279748
https://github.com/qutip/qutip/pull/1845#issuecomment-1134828280:574,Deployability,update,updated,574,"@ksohan Apologies for the long delay in reviewing this PR. I'd prefer not to include this in QuTiP 4.7 because we're preparing for QuTiP 5 and so not adding too many more things to QuTiP 4. I'm not against the idea of supporting other iterable types in the conversion function but to do so we need:. - this PR to be made against the dev.major branch (which is where QuTiP 5 is being developed currently); - some thinking is needed on what should happen if a tuple is passed? Or a generator function? And also about what should be returned; - the docstrings would need to be updated. I'll leave this open for a bit so we can discuss more, but for QuTiP 5 a new PR would be needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1845#issuecomment-1134828280
https://github.com/qutip/qutip/pull/1846#issuecomment-1090664850:71,Testability,test,test,71,"> Thank you for the PR. It look as it should work, but could you add a test to ensure it does.; > ; > Most codeclimat issues should be solved if you make a functions to read `(N, dims)`.; > ; > For super operator you can use: `N**2 = np.prod(qutip.dimensions.flatten(dims[0]))` Ideally, we should also check `type_from_dims(dims) == 'super'`. Hi, @Ericgig! Thank you for the comments.; I will:. [ ] add a test; [ ] create a function to implement the check on `N`, `dims`.; [ ] add a check for the superoperator functions: using `N**2 = np.prod(qutip.dimensions.flatten(dims[0]))`; [ ] add a check for the superoperator functions: check `type_from_dims(dims) == 'super'`. Hi, @AGaliciaMartinez! Thanks for your comments. The plan for `dev.major` is to substitute both `N` and `dims` in favour of `dimensions`, just as you described. I'll start working on that, as soon as I finish the current PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1846#issuecomment-1090664850
https://github.com/qutip/qutip/pull/1846#issuecomment-1090664850:405,Testability,test,test,405,"> Thank you for the PR. It look as it should work, but could you add a test to ensure it does.; > ; > Most codeclimat issues should be solved if you make a functions to read `(N, dims)`.; > ; > For super operator you can use: `N**2 = np.prod(qutip.dimensions.flatten(dims[0]))` Ideally, we should also check `type_from_dims(dims) == 'super'`. Hi, @Ericgig! Thank you for the comments.; I will:. [ ] add a test; [ ] create a function to implement the check on `N`, `dims`.; [ ] add a check for the superoperator functions: using `N**2 = np.prod(qutip.dimensions.flatten(dims[0]))`; [ ] add a check for the superoperator functions: check `type_from_dims(dims) == 'super'`. Hi, @AGaliciaMartinez! Thanks for your comments. The plan for `dev.major` is to substitute both `N` and `dims` in favour of `dimensions`, just as you described. I'll start working on that, as soon as I finish the current PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1846#issuecomment-1090664850
https://github.com/qutip/qutip/pull/1846#issuecomment-1092820030:492,Integrability,interface,interface,492,"@Leo-am @Ericgig I originally marked this PR for inclusion in 4.7, but I'd like to suggest we skip this PR and clean things up for QuTiP 5. My reasoning is as follows:. - To be included in 4.7.X this PR would have to be included in 4.7.0 now and there is still quite a bit of work to do (writing tests, cleaning up _check_dims, handling some edges cases better) and I'd rather not rush those changes.; - If we make this change now, we will have to break user code *again* for 5.0 because the interface being introduced here is not the one proposed for 5.0 in #1838. Let's rather only break user code once.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1846#issuecomment-1092820030
https://github.com/qutip/qutip/pull/1846#issuecomment-1092820030:296,Testability,test,tests,296,"@Leo-am @Ericgig I originally marked this PR for inclusion in 4.7, but I'd like to suggest we skip this PR and clean things up for QuTiP 5. My reasoning is as follows:. - To be included in 4.7.X this PR would have to be included in 4.7.0 now and there is still quite a bit of work to do (writing tests, cleaning up _check_dims, handling some edges cases better) and I'd rather not rush those changes.; - If we make this change now, we will have to break user code *again* for 5.0 because the interface being introduced here is not the one proposed for 5.0 in #1838. Let's rather only break user code once.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1846#issuecomment-1092820030
https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741:405,Availability,down,down,405,"Hi @yuli139304,. I can't really make out from the code you have written what you are trying to achieve -- it simply looks like you are using numpy and Qobj incorrectly. Could you type out in terms of Sx_nv, ... and D_xx, ... what you want using simple arithmetic? E.g. maybe you want `D_xx * Sx_nv + D_yy * Sy_nv + D_zz * Sz_nv` (which just works as is)?. Then once you have the simple expression written down, you can make it fancier (e.g. use np.dot, etc) if you need to. I'm going to close this for now because this doesn't look like a QuTiP bug, but feel free to ask more questions, either here or preferably on the mailing list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741
https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741:109,Usability,simpl,simply,109,"Hi @yuli139304,. I can't really make out from the code you have written what you are trying to achieve -- it simply looks like you are using numpy and Qobj incorrectly. Could you type out in terms of Sx_nv, ... and D_xx, ... what you want using simple arithmetic? E.g. maybe you want `D_xx * Sx_nv + D_yy * Sy_nv + D_zz * Sz_nv` (which just works as is)?. Then once you have the simple expression written down, you can make it fancier (e.g. use np.dot, etc) if you need to. I'm going to close this for now because this doesn't look like a QuTiP bug, but feel free to ask more questions, either here or preferably on the mailing list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741
https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741:245,Usability,simpl,simple,245,"Hi @yuli139304,. I can't really make out from the code you have written what you are trying to achieve -- it simply looks like you are using numpy and Qobj incorrectly. Could you type out in terms of Sx_nv, ... and D_xx, ... what you want using simple arithmetic? E.g. maybe you want `D_xx * Sx_nv + D_yy * Sy_nv + D_zz * Sz_nv` (which just works as is)?. Then once you have the simple expression written down, you can make it fancier (e.g. use np.dot, etc) if you need to. I'm going to close this for now because this doesn't look like a QuTiP bug, but feel free to ask more questions, either here or preferably on the mailing list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741
https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741:379,Usability,simpl,simple,379,"Hi @yuli139304,. I can't really make out from the code you have written what you are trying to achieve -- it simply looks like you are using numpy and Qobj incorrectly. Could you type out in terms of Sx_nv, ... and D_xx, ... what you want using simple arithmetic? E.g. maybe you want `D_xx * Sx_nv + D_yy * Sy_nv + D_zz * Sz_nv` (which just works as is)?. Then once you have the simple expression written down, you can make it fancier (e.g. use np.dot, etc) if you need to. I'm going to close this for now because this doesn't look like a QuTiP bug, but feel free to ask more questions, either here or preferably on the mailing list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1848#issuecomment-1093459741
https://github.com/qutip/qutip/issues/1848#issuecomment-1093795266:340,Availability,error,error,340,"Many thanks for your kind reply. Unfortunately, I can not do that, because there is cases in my hamiltonian in which that matrix is not diagonal, I am just trying from the simplest case, actually my goal is to have a term ""S_vector * D_matrix *S_vector"" . Could you please explain how I am using Qobj incorrectly and how to used right. The error message states that since S_vector is a Qobj I can not multiply it with the D_matrix. If I put Qobj(D_matrix) then I can not multiply them because all terms are Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1848#issuecomment-1093795266
https://github.com/qutip/qutip/issues/1848#issuecomment-1093795266:346,Integrability,message,message,346,"Many thanks for your kind reply. Unfortunately, I can not do that, because there is cases in my hamiltonian in which that matrix is not diagonal, I am just trying from the simplest case, actually my goal is to have a term ""S_vector * D_matrix *S_vector"" . Could you please explain how I am using Qobj incorrectly and how to used right. The error message states that since S_vector is a Qobj I can not multiply it with the D_matrix. If I put Qobj(D_matrix) then I can not multiply them because all terms are Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1848#issuecomment-1093795266
https://github.com/qutip/qutip/issues/1848#issuecomment-1093795266:172,Usability,simpl,simplest,172,"Many thanks for your kind reply. Unfortunately, I can not do that, because there is cases in my hamiltonian in which that matrix is not diagonal, I am just trying from the simplest case, actually my goal is to have a term ""S_vector * D_matrix *S_vector"" . Could you please explain how I am using Qobj incorrectly and how to used right. The error message states that since S_vector is a Qobj I can not multiply it with the D_matrix. If I put Qobj(D_matrix) then I can not multiply them because all terms are Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1848#issuecomment-1093795266
https://github.com/qutip/qutip/pull/1850#issuecomment-1095190980:33,Usability,guid,guide,33,Floquet related examples in `doc/guide/scripts` fail. ; I am looking at it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1095190980
https://github.com/qutip/qutip/pull/1850#issuecomment-1095498766:325,Availability,error,error,325,"I started patching documentation:; - Updated import from moved files (`from qutip.states` --> `from qutip.core.states`).; - Changes `Options` to `SolverOptions`.; - Commented some calls to function and method that do not exist anymore (`QobjEvo.to_list`). There are a lots of warning when building documentattion, but actual error seems to be limited to qip and HEOM changes that where not properly merged.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1095498766
https://github.com/qutip/qutip/pull/1850#issuecomment-1095498766:10,Deployability,patch,patching,10,"I started patching documentation:; - Updated import from moved files (`from qutip.states` --> `from qutip.core.states`).; - Changes `Options` to `SolverOptions`.; - Commented some calls to function and method that do not exist anymore (`QobjEvo.to_list`). There are a lots of warning when building documentattion, but actual error seems to be limited to qip and HEOM changes that where not properly merged.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1095498766
https://github.com/qutip/qutip/pull/1850#issuecomment-1095498766:37,Deployability,Update,Updated,37,"I started patching documentation:; - Updated import from moved files (`from qutip.states` --> `from qutip.core.states`).; - Changes `Options` to `SolverOptions`.; - Commented some calls to function and method that do not exist anymore (`QobjEvo.to_list`). There are a lots of warning when building documentattion, but actual error seems to be limited to qip and HEOM changes that where not properly merged.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1095498766
https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212:335,Availability,error,error,335,"I fixed steadystate tests:; - `_permute` use numpy array, @AGaliciaMartinez is looking to fix the data layer function.; - Lowered the precision required for `test_exact_solution_for_simple_methods`. The test looked for `1e-16 +/- 1e-16` and most calls returned `0`. Most methods cannot match this precision and can fail from numerical error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212
https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212:20,Testability,test,tests,20,"I fixed steadystate tests:; - `_permute` use numpy array, @AGaliciaMartinez is looking to fix the data layer function.; - Lowered the precision required for `test_exact_solution_for_simple_methods`. The test looked for `1e-16 +/- 1e-16` and most calls returned `0`. Most methods cannot match this precision and can fail from numerical error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212
https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212:203,Testability,test,test,203,"I fixed steadystate tests:; - `_permute` use numpy array, @AGaliciaMartinez is looking to fix the data layer function.; - Lowered the precision required for `test_exact_solution_for_simple_methods`. The test looked for `1e-16 +/- 1e-16` and most calls returned `0`. Most methods cannot match this precision and can fail from numerical error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212
https://github.com/qutip/qutip/pull/1852#issuecomment-1096749552:220,Deployability,update,update-changelog-for-qutip-,220,[![Coverage Status](https://coveralls.io/builds/48246604/badge)](https://coveralls.io/builds/48246604). Coverage increased (+0.03%) to 69.593% when pulling **a5cb85fbcc0aea7fad8a570cca4a9ae29671638a on hodgestar:feature/update-changelog-for-qutip-4-7** into **5f926b45fd8a36e2f33ea7bf36f02b8cb7ffef9f on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1852#issuecomment-1096749552
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:149,Deployability,Update,Update,149,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:255,Deployability,update,update,255,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:454,Deployability,update,update,454,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:26,Testability,test,tests,26,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:56,Testability,test,tests,56,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:179,Testability,test,tests,179,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:239,Testability,test,tests,239,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:282,Testability,test,test,282,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753:288,Testability,Test,TestConstantCollapse,288,"It looks like the mcsolve tests hang if the interpolate tests are run. This is probably related to the use of multiprocessing / mcsolve inside both. Update: Actually, the mcsolve tests are hanging periodically even without the interpolate tests.; Further update: It seems to be the test `TestConstantCollapse::test_states_and_expect[string]` that hangs, so perhaps it is related to compiling Cython functions on the fly while running mcsolve?; Furtherer update: I'm trying removing the unused imports in mcsolve. This shouldn't really make a difference but with multiprocessing who knows, so it seems worth a try.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097121753
https://github.com/qutip/qutip/pull/1854#issuecomment-1097181695:82,Testability,test,tests,82,"Ah, we seem to have rediscovered #1202. We also see #1190, but that doesn't cause tests to fail.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097181695
https://github.com/qutip/qutip/pull/1854#issuecomment-1097936583:120,Deployability,release,released,120,I've opened #1855 to disable the mcsolve tests on Windows for now. I intend to leave this issue open until after 4.7 is released and to see what happens with the mcsolve in QuTiP 5.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097936583
https://github.com/qutip/qutip/pull/1854#issuecomment-1097936583:41,Testability,test,tests,41,I've opened #1855 to disable the mcsolve tests on Windows for now. I intend to leave this issue open until after 4.7 is released and to see what happens with the mcsolve in QuTiP 5.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097936583
https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175:159,Performance,concurren,concurrent,159,"In [3e530c0](https://github.com/qutip/qutip/pull/1854/commits/3e530c01d9cf686fc195c38c2cc26d0ee5bccfa8) I borrowed @nonhermitian's suggestion and switched to `concurrent.futures.ProcessPoolExecutor` in the hopes that the core Python developers have figured out how to make that works on Windows too. It also simplifies the management of the pool of workers, which is a win by itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175
https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175:308,Usability,simpl,simplifies,308,"In [3e530c0](https://github.com/qutip/qutip/pull/1854/commits/3e530c01d9cf686fc195c38c2cc26d0ee5bccfa8) I borrowed @nonhermitian's suggestion and switched to `concurrent.futures.ProcessPoolExecutor` in the hopes that the core Python developers have figured out how to make that works on Windows too. It also simplifies the management of the pool of workers, which is a win by itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175
https://github.com/qutip/qutip/pull/1854#issuecomment-1169062453:99,Availability,error,errors,99,Switching to ProcessPoolExecutor seems to have improved parallel_map quite a bit -- now all of the errors seem to be related to compiling coefficients.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1169062453
https://github.com/qutip/qutip/pull/1854#issuecomment-1170243021:62,Availability,down,down,62,"I've given up on solving this for QuTiP 4 for now -- it leads down a long rabbit hole that ends in fixing string coefficient generation, which was a big re-write and has already been done in QuTiP 5. I'm continue the work for QuTiP 5 in #1948.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1170243021
https://github.com/qutip/qutip/pull/1855#issuecomment-1097982571:109,Deployability,release,release,109,"I'm going to merge this so that tests pass repeatably on master again and so that I can proceed with the 4.7 release, but we should keep #1854 open and address it for QuTiP 5 (if tests don't just pass there already).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1855#issuecomment-1097982571
https://github.com/qutip/qutip/pull/1855#issuecomment-1097982571:32,Testability,test,tests,32,"I'm going to merge this so that tests pass repeatably on master again and so that I can proceed with the 4.7 release, but we should keep #1854 open and address it for QuTiP 5 (if tests don't just pass there already).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1855#issuecomment-1097982571
https://github.com/qutip/qutip/pull/1855#issuecomment-1097982571:179,Testability,test,tests,179,"I'm going to merge this so that tests pass repeatably on master again and so that I can proceed with the 4.7 release, but we should keep #1854 open and address it for QuTiP 5 (if tests don't just pass there already).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1855#issuecomment-1097982571
https://github.com/qutip/qutip/pull/1855#issuecomment-1097989703:235,Testability,test,tests-on-windows,235,[![Coverage Status](https://coveralls.io/builds/48244897/badge)](https://coveralls.io/builds/48244897). Coverage remained the same at 69.593% when pulling **0d539847926766c5164632a2b05d7c890d0a8ebd on hodgestar:feature/disable-mcsolve-tests-on-windows** into **ec9e8f4265a6544b1841467b9f83634f6c3727c0 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1855#issuecomment-1097989703
https://github.com/qutip/qutip/pull/1857#issuecomment-1098007336:0,Availability,Ping,Pinging,0,Pinging lots of people as reviewers just for fun and because it's a momentous occasion.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098007336
https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081:5,Availability,error,error,5,Test error is an unrelated correlation test failure (it looks like a coefficient generation race condition?).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081
https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081:44,Availability,failure,failure,44,Test error is an unrelated correlation test failure (it looks like a coefficient generation race condition?).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081
https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081:92,Performance,race condition,race condition,92,Test error is an unrelated correlation test failure (it looks like a coefficient generation race condition?).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081
https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081:0,Testability,Test,Test,0,Test error is an unrelated correlation test failure (it looks like a coefficient generation race condition?).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081
https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081:39,Testability,test,test,39,Test error is an unrelated correlation test failure (it looks like a coefficient generation race condition?).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081
https://github.com/qutip/qutip/pull/1861#issuecomment-1098463313:225,Testability,test,tests,225,[![Coverage Status](https://coveralls.io/builds/48262235/badge)](https://coveralls.io/builds/48262235). Coverage decreased (-0.04%) to 66.191% when pulling **1be01e42288f24e0fe00516e78d5e7cbc9af45fd on Ericgig:shorter.krylov.tests** into **f8c997e61accbb40664b1e9c298ac51dff212e16 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098463313
https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801:145,Safety,timeout,timeout,145,"@Ericgig Approved, because faster tests are good, but I am wondering if the krylovsolve tests are much slower on v5 because tests didn't seem to timeout on v4?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801
https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801:34,Testability,test,tests,34,"@Ericgig Approved, because faster tests are good, but I am wondering if the krylovsolve tests are much slower on v5 because tests didn't seem to timeout on v4?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801
https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801:88,Testability,test,tests,88,"@Ericgig Approved, because faster tests are good, but I am wondering if the krylovsolve tests are much slower on v5 because tests didn't seem to timeout on v4?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801
https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801:124,Testability,test,tests,124,"@Ericgig Approved, because faster tests are good, but I am wondering if the krylovsolve tests are much slower on v5 because tests didn't seem to timeout on v4?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801
https://github.com/qutip/qutip/pull/1861#issuecomment-1099170180:174,Testability,test,tests,174,"Yes they are, they seems about 3x slower.; I am not sure why, but my guess would be the eigen solving being run in sparse instead of dense for not that sparse Hamiltonian in tests. We should be careful about it when porting the solver to v5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1099170180
https://github.com/qutip/qutip/pull/1862#issuecomment-1098579474:230,Usability,guid,guide,230,[![Coverage Status](https://coveralls.io/builds/49098930/badge)](https://coveralls.io/builds/49098930). Coverage increased (+0.3%) to 69.881% when pulling **87e27c5f96c36096fe628f29e95f6e2cbf66dd0a on emilianomfortes:krylov-solve-guide** into **0b821cb547d258ba9597198ed016aad7df56593a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1098579474
https://github.com/qutip/qutip/pull/1862#issuecomment-1100042147:104,Performance,perform,perform,104,"@hodgestar I think it should work, but I never rendered retexet to html with sphinx, so maybe you could perform a quick check? (I travel to ireland tomorrow up until monday night, but im kind of excited for 4.7 so let me know, I can edit the file with my phone)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1100042147
https://github.com/qutip/qutip/pull/1862#issuecomment-1123535232:20,Usability,guid,guideline,20,"Yes, It's fine as a guideline. I've been discussing with some people a better physical example to highlight krylov strong points, but I'll do that as a follow up PR once the basic one is working.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1123535232
https://github.com/qutip/qutip/pull/1862#issuecomment-1125207449:100,Performance,perform,performance,100,"@emilianomfortes Thanks! It looks good now. Is there anything we can do to make the sparse vs dense performance plotting block run faster? It has to run every time the documentation is built (i.e. on every PR) and it takes a minute or two to run locally (so likely longer on the GitHub action VMs). It's not so much of an issue by itself, but its easy for the length of the documentation build to get out of hand if we add a minute here and a minute there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1125207449
https://github.com/qutip/qutip/pull/1862#issuecomment-1125718559:107,Usability,simpl,simple,107,"@hodgestar . Since now there's no need of anything because the output is a copy paste of mine, how about a simple `..plot::` into `..code-block:: python`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1125718559
https://github.com/qutip/qutip/pull/1862#issuecomment-1125773090:96,Usability,simpl,simple,96,"> Since now there's no need of anything because the output is a copy paste of mine, how about a simple `..plot::` into `..code-block:: python`?. I'm worried that code blocks are never run so the code in them is by definition broken.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1125773090
https://github.com/qutip/qutip/pull/1862#issuecomment-1125927027:93,Energy Efficiency,reduce,reduce,93,"I see. Okay, for sufficiently large matrices there's no requirement for averages, which will reduce the time execution a lot because of the for loop.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1125927027
https://github.com/qutip/qutip/pull/1862#issuecomment-1126038943:159,Usability,guid,guide,159,@emilianomfortes Thanks. I've merged this one and will close the related issue. Feel free to open new PRs for any improvements you want to make (either to the guide or the solver). Thanks for contributing this!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1126038943
https://github.com/qutip/qutip/issues/1864#issuecomment-1103559564:34,Usability,feedback,feedback,34,"Thank you very much for the quick feedback and sorry for the delay!. I checked also QuTiP 4.7 and yes, it still returns the same results so apparently this wasn't fixed yet. (I double-checked that I get the same result using the built-in `floquet_modes` with options rather than my `floquet_modes_mod`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1864#issuecomment-1103559564
https://github.com/qutip/qutip/issues/1864#issuecomment-1103658061:120,Testability,log,logic,120,@fpetiziol Thanks for checking. We should fix this for 4.7. It's probably not a very difficult fix (or at least we have logic for making eigenvectors orthogonal elsewhere in QuTiP that we can call or re-use).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1864#issuecomment-1103658061
https://github.com/qutip/qutip/pull/1868#issuecomment-1099651885:220,Testability,test,tests-for-,220,[![Coverage Status](https://coveralls.io/builds/48300415/badge)](https://coveralls.io/builds/48300415). Coverage decreased (-0.7%) to 68.879% when pulling **f0f18caf96230063da09805a00653c0e3d934d0f on hodgestar:fix/heom-tests-for-v5** into **4c68ce2d6ea7ca7f208a85387a004de586b97839 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1868#issuecomment-1099651885
https://github.com/qutip/qutip/pull/1869#issuecomment-1099649732:222,Testability,test,tests-for-,222,[![Coverage Status](https://coveralls.io/builds/50419378/badge)](https://coveralls.io/builds/50419378). Coverage increased (+4.001%) to 70.988% when pulling **b1dc4f34754ed7a2d8eac00326460d6747282bde on hodgestar:fix/heom-tests-for-v5** into **04d213fd4972e387352df60e949c95ea0f6bfe9d on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1099649732
https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887:291,Energy Efficiency,adapt,adapt,291,"@Ericgig I've kept the WIP label, but this is ready for a first review. I think I'm made the HEOM look as much like the base solver as I can without having to modify the base solver a bit. Perhaps we can meet up tomorrow on Discord to discuss options. I'm also happy to merge this as is and adapt the solver more in another PR (assuming tests still pass and documentation still builds with my latest commits).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887
https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887:291,Modifiability,adapt,adapt,291,"@Ericgig I've kept the WIP label, but this is ready for a first review. I think I'm made the HEOM look as much like the base solver as I can without having to modify the base solver a bit. Perhaps we can meet up tomorrow on Discord to discuss options. I'm also happy to merge this as is and adapt the solver more in another PR (assuming tests still pass and documentation still builds with my latest commits).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887
https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887:337,Testability,test,tests,337,"@Ericgig I've kept the WIP label, but this is ready for a first review. I think I'm made the HEOM look as much like the base solver as I can without having to modify the base solver a bit. Perhaps we can meet up tomorrow on Discord to discuss options. I'm also happy to merge this as is and adapt the solver more in another PR (assuming tests still pass and documentation still builds with my latest commits).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887
https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:405,Availability,down,down,405,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739
https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:889,Availability,avail,available,889,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739
https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:1003,Integrability,depend,dependent,1003,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739
https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:1244,Integrability,depend,dependent,1244,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739
https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:1677,Performance,perform,performance,1677,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739
https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:1199,Usability,simpl,simplified,1199,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739
https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:1419,Usability,simpl,simpler,1419,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739
https://github.com/qutip/qutip/pull/1869#issuecomment-1149772678:9,Testability,Test,Tests,9,"@Ericgig Tests added for the type changes. Note that `QobjEvo.__rmatmul__` is not currently callable. Calling `qobj @ qevo` will call `QobjEvo.__matmul__(qobj, qevo)` first, which will return the result. If I am not missing a case where `__rmatmul__` is called, I vote that we simply delete the implementation of `__rmatmul__` (in a separate PR).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1149772678
https://github.com/qutip/qutip/pull/1869#issuecomment-1149772678:277,Usability,simpl,simply,277,"@Ericgig Tests added for the type changes. Note that `QobjEvo.__rmatmul__` is not currently callable. Calling `qobj @ qevo` will call `QobjEvo.__matmul__(qobj, qevo)` first, which will return the result. If I am not missing a case where `__rmatmul__` is called, I vote that we simply delete the implementation of `__rmatmul__` (in a separate PR).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1149772678
https://github.com/qutip/qutip/pull/1869#issuecomment-1152371837:11,Testability,Test,Tests,11,"> @Ericgig Tests added for the type changes.; > ; > Note that `QobjEvo.__rmatmul__` is not currently callable. Calling `qobj @ qevo` will call `QobjEvo.__matmul__(qobj, qevo)` first, which will return the result. If I am not missing a case where `__rmatmul__` is called, I vote that we simply delete the implementation of `__rmatmul__` (in a separate PR). @Ericgig Explained that in Cython 3 `__rmatmul__` will be called, so we can keep it for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1152371837
https://github.com/qutip/qutip/pull/1869#issuecomment-1152371837:286,Usability,simpl,simply,286,"> @Ericgig Tests added for the type changes.; > ; > Note that `QobjEvo.__rmatmul__` is not currently callable. Calling `qobj @ qevo` will call `QobjEvo.__matmul__(qobj, qevo)` first, which will return the result. If I am not missing a case where `__rmatmul__` is called, I vote that we simply delete the implementation of `__rmatmul__` (in a separate PR). @Ericgig Explained that in Cython 3 `__rmatmul__` will be called, so we can keep it for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1152371837
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:237,Availability,error,error,237,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:424,Deployability,integrat,integrator,424,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:424,Integrability,integrat,integrator,424,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1518,Integrability,depend,dependent,1518," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1629,Integrability,depend,dependent,1629," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1718,Integrability,depend,dependent,1718," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1810,Integrability,depend,dependent,1810," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:2052,Integrability,depend,dependent,2052," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:606,Modifiability,enhance,enhancement,606,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:478,Safety,avoid,avoid,478,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:823,Safety,avoid,avoid,823,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1482,Testability,test,test,1482," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1584,Testability,test,tests,1584," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1596,Testability,test,tests,1596," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1702,Testability,test,tested,1702," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1728,Testability,log,logic,1728," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:2062,Testability,test,test,2062," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845
https://github.com/qutip/qutip/pull/1869#issuecomment-1167922200:65,Testability,test,tests,65,"Thanks @Ericgig. I'll move the HEOM into `qutip.solve` (and move tests and fix docs) in the morning and then merge if all the tests are happy, unless you want to have one final check?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1167922200
https://github.com/qutip/qutip/pull/1869#issuecomment-1167922200:126,Testability,test,tests,126,"Thanks @Ericgig. I'll move the HEOM into `qutip.solve` (and move tests and fix docs) in the morning and then merge if all the tests are happy, unless you want to have one final check?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1167922200
https://github.com/qutip/qutip/pull/1870#issuecomment-1100835521:653,Testability,test,test,653,"Thanks @claretgrace0801 for the PR. This is nice indeed that qutip_qip only needs to call `qutip.about()` and add some additional information. . As it is now, however, every new qutip family package needs to modify this to add their own info. I'm wondering if we can modify the code so that this only needs to be done once in `qutip.about` and any new family package just needs to call `qutip.about(package_name)` without having to write into qutip's source code. It could be implemented e.g.; ```; import importlib; package = importlib.import_module(package_name); print(f""package_name: {package.__version__}""); ```. Also, it would be helpful to add a test in the `qutip-qip` repo to check if the printed information indeed includes `""qutip_qip""`, e.g. see https://docs.pytest.org/en/6.2.x/capture.html.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1100835521
https://github.com/qutip/qutip/pull/1870#issuecomment-1101613152:103,Testability,test,test,103,I've made the changes. Now other libraries won't have to change anything in `qutip.about`.; I'll add a test in `qutip_qip` too.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1101613152
https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998:83,Deployability,release,released,83,"I just realize that test in qutip-qip won't work because this has to be merged and released first. The code looks fine to me. Will test it locally later. @hodgestar Just to get a second opinion, what do you think about this? As it could also be used by further family packages like control.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998
https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998:20,Testability,test,test,20,"I just realize that test in qutip-qip won't work because this has to be merged and released first. The code looks fine to me. Will test it locally later. @hodgestar Just to get a second opinion, what do you think about this? As it could also be used by further family packages like control.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998
https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998:131,Testability,test,test,131,"I just realize that test in qutip-qip won't work because this has to be merged and released first. The code looks fine to me. Will test it locally later. @hodgestar Just to get a second opinion, what do you think about this? As it could also be used by further family packages like control.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998
https://github.com/qutip/qutip/pull/1870#issuecomment-1104938167:252,Usability,simpl,simpler,252,"@BoxiLi I'm -1 on adding such complexity to `qutip.about`. It's often used for bug reporting, and complexity has cause use issue in such places in the past. Especially the importing by name and the calls to inspect look like trouble. I would suggest a simpler solution, which is to have `about_family_pkg(title, extra_lines)`. That way family packages can supply their own title and extras and `about()` in qutip and other packages can just call `about_family_pkg` with the correct arguments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1104938167
https://github.com/qutip/qutip/pull/1870#issuecomment-1106117187:62,Usability,simpl,simple,62,"I see your point that we should keep those debugging tools as simple as possible. Instead of reading the version in `qutip.about`, we do it using a hook function in the family package that returns the repo name and version etc. Something like; ```python; def about(family_pkgs=[]):; ...; for family_pkg in family_pkgs:; package_name, package_version = family_pkg._about_family_pkg(); print(....); ```; In this way we don't need to pass the string name of the package but just pass the package itself. If anything went wrong, it is just in the implementation of `_about_family_pkg` in the family packages.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1106117187
https://github.com/qutip/qutip/pull/1870#issuecomment-1110986005:157,Performance,load,load,157,"Pseudocode for entrypoint suggestion:; ```python; entrypoints = importlib.metadata.entrypoints(group=""qutip.about""); for ep in entrypoints:; about_func = ep.load(); try:; title, lines = about_func(); except Exception as exc:; title, lines = ep.name, [str(exc)]; print(title); print(""-"" * title); print(); for line in lines:; print(line); print(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1110986005
https://github.com/qutip/qutip/pull/1870#issuecomment-1123545864:25,Deployability,update,updates,25,"Hi @claretgrace0801, Any updates on this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1123545864
https://github.com/qutip/qutip/issues/1872#issuecomment-1103039679:158,Energy Efficiency,energy,energy,158,"I would like to have the BEC code be classes that have functions for BEC within QuTiP which can be used for Fluid Dynamics experiments. Specifically for high energy particle physics. ; Could we schedule a time to meet perhaps to discuss further? Maybe a zoom? ; Thank you . Hanah Rahman . > On Apr 19, 2022, at 3:20 PM, Simon Cross ***@***.***> wrote:; > ; > ; > @hrahman12 This sounds very interesting. How much of the idea do you have fleshed out so far?; > ; > If the plan is a very complete package targeting a specific physical system or family of systems, it might be best to have a separate package that used QuTiP. Such a package could however be part of the QuTiP family of packages potentially (e.g. in the same way qutip-qip is a separate package now).; > ; > On the other hand, if you want specific support for a few key classes and functions that might be more widely applicable (e.g. constructors for new quantum states or operators, a new kind of solver, new visualisation) those might well belong in the main QuTiP package (i.e. this repository).; > ; > Keen to facilitate your work if you're keen to do it -- we just need to figure out what is the best plan.; > ; > ; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1872#issuecomment-1103039679
https://github.com/qutip/qutip/issues/1872#issuecomment-1103039679:194,Energy Efficiency,schedul,schedule,194,"I would like to have the BEC code be classes that have functions for BEC within QuTiP which can be used for Fluid Dynamics experiments. Specifically for high energy particle physics. ; Could we schedule a time to meet perhaps to discuss further? Maybe a zoom? ; Thank you . Hanah Rahman . > On Apr 19, 2022, at 3:20 PM, Simon Cross ***@***.***> wrote:; > ; > ; > @hrahman12 This sounds very interesting. How much of the idea do you have fleshed out so far?; > ; > If the plan is a very complete package targeting a specific physical system or family of systems, it might be best to have a separate package that used QuTiP. Such a package could however be part of the QuTiP family of packages potentially (e.g. in the same way qutip-qip is a separate package now).; > ; > On the other hand, if you want specific support for a few key classes and functions that might be more widely applicable (e.g. constructors for new quantum states or operators, a new kind of solver, new visualisation) those might well belong in the main QuTiP package (i.e. this repository).; > ; > Keen to facilitate your work if you're keen to do it -- we just need to figure out what is the best plan.; > ; > ; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1872#issuecomment-1103039679
https://github.com/qutip/qutip/pull/1874#issuecomment-1106675195:164,Testability,test,tests,164,"@hodgestar the `.h` file imported from `base.pxd` makes is a lot simpler.; Changing the header file force recompilation, but the cythonization step is skipped.; If tests passes, it's ready for review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1874#issuecomment-1106675195
https://github.com/qutip/qutip/pull/1874#issuecomment-1106675195:65,Usability,simpl,simpler,65,"@hodgestar the `.h` file imported from `base.pxd` makes is a lot simpler.; Changing the header file force recompilation, but the cythonization step is skipped.; If tests passes, it's ready for review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1874#issuecomment-1106675195
https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223:151,Deployability,configurat,configuration,151,"`python3 -mbuild` has a `-C` option (`--config-setting`), see`https://pypa-build.readthedocs.io/en/latest/`. It sounds like it could be used for build configuration options like qutip's openmp support. It doesn't seem to work with the current handling in setup.py however. Permutations of `-C--with-openmp`, `-Copenmp`, `-Copenmp=1` enable a succcessful qutip PEP517 build, but `qutip.about()` then reports; ```; OPENMP Installed: False; ```; indicating the option is ignored.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223
https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223:420,Deployability,Install,Installed,420,"`python3 -mbuild` has a `-C` option (`--config-setting`), see`https://pypa-build.readthedocs.io/en/latest/`. It sounds like it could be used for build configuration options like qutip's openmp support. It doesn't seem to work with the current handling in setup.py however. Permutations of `-C--with-openmp`, `-Copenmp`, `-Copenmp=1` enable a succcessful qutip PEP517 build, but `qutip.about()` then reports; ```; OPENMP Installed: False; ```; indicating the option is ignored.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223
https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223:40,Modifiability,config,config-setting,40,"`python3 -mbuild` has a `-C` option (`--config-setting`), see`https://pypa-build.readthedocs.io/en/latest/`. It sounds like it could be used for build configuration options like qutip's openmp support. It doesn't seem to work with the current handling in setup.py however. Permutations of `-C--with-openmp`, `-Copenmp`, `-Copenmp=1` enable a succcessful qutip PEP517 build, but `qutip.about()` then reports; ```; OPENMP Installed: False; ```; indicating the option is ignored.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223
https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223:151,Modifiability,config,configuration,151,"`python3 -mbuild` has a `-C` option (`--config-setting`), see`https://pypa-build.readthedocs.io/en/latest/`. It sounds like it could be used for build configuration options like qutip's openmp support. It doesn't seem to work with the current handling in setup.py however. Permutations of `-C--with-openmp`, `-Copenmp`, `-Copenmp=1` enable a succcessful qutip PEP517 build, but `qutip.about()` then reports; ```; OPENMP Installed: False; ```; indicating the option is ignored.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223
https://github.com/qutip/qutip/issues/1875#issuecomment-1219669702:97,Modifiability,config,config-setting,97,"I have found out how to use this after reading the source:; ```; python -m build -n -x --wheel --config-setting=""--global-option=--with-openmp""; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219669702
https://github.com/qutip/qutip/issues/1875#issuecomment-1219672267:104,Modifiability,config,config-settings,104,"One can read a little bit of somewhat useful information in PEP517 -- https://peps.python.org/pep-0517/#config-settings. I tried `--build-option` instead of `--global-option`, but that didn't work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219672267
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:117,Availability,error,error,117,"Not sure if it's that simple.; ```; --config-setting=""--global-option=--with-openmp""; ```; actually gives me a build error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:1079,Availability,ERROR,ERROR,1079,"ld error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.8.1; Cython Version: 0.29.30; Matplotlib Version: 3.5.2; Python Version: 3.10.6; Number of CPUs:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:1297,Deployability,install,installing,1297,"ages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.8.1; Cython Version: 0.29.30; Matplotlib Version: 3.5.2; Python Version: 3.10.6; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ====================================================================",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:2147,Deployability,Install,Installed,2147,"usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.8.1; Cython Version: 0.29.30; Matplotlib Version: 3.5.2; Python Version: 3.10.6; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ``",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:2218,Deployability,Install,Installation,2218,"usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.8.1; Cython Version: 0.29.30; Matplotlib Version: 3.5.2; Python Version: 3.10.6; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ``",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:164,Integrability,depend,dependency-check,164,"Not sure if it's that simple.; ```; --config-setting=""--global-option=--with-openmp""; ```; actually gives me a build error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:38,Modifiability,config,config-setting,38,"Not sure if it's that simple.; ```; --config-setting=""--global-option=--with-openmp""; ```; actually gives me a build error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:206,Modifiability,config,config-setting,206,"Not sure if it's that simple.; ```; --config-setting=""--global-option=--with-openmp""; ```; actually gives me a build error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:1177,Modifiability,config,config-setting,1177,"ng=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.8.1; Cython Version: 0.29.30; Matplotlib Version: 3.5.2; Python Version: 3.10.6; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); I",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:22,Usability,simpl,simple,22,"Not sure if it's that simple.; ```; --config-setting=""--global-option=--with-openmp""; ```; actually gives me a build error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152
https://github.com/qutip/qutip/issues/1875#issuecomment-1220037489:3,Modifiability,config,config-setting,3,`--config-setting=--global-option=--with-openmp` is still not working with git head (with #1978 merged). This is with; * python 3.10.6-1; * python3-build 0.7.0-3; * python3-setuptools 59.6.0-1.2; * python3-wheel 0.37.1-2; * gcc 12.1.0-7,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1220037489
https://github.com/qutip/qutip/issues/1875#issuecomment-1342946354:133,Deployability,release,release,133,"@drew-parsons Is this still an issue for the Debian package? I'm not quite sure how to reproduce my side, but I am cutting the 4.7.1 release soon, so this would be a good time to address this if we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1342946354
https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:61,Deployability,update,updated,61,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726
https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:401,Deployability,Install,Installed,401,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726
https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:488,Integrability,message,message,488,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726
https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:532,Integrability,depend,dependency-check,532,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726
https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:205,Modifiability,config,config-setting,205,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726
https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:260,Modifiability,config,config-setting,260,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726
https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:639,Modifiability,config,config-setting,639,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726
https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222:237,Deployability,configurat,configuration,237,"Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", Path.home() / "".config"")` rather than depend on the `xdg` package?. How does one know if one is on a system where XDG is supported? E.g. I know Windows used to use a special APP configuration folder of its own.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222
https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222:97,Integrability,depend,depend,97,"Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", Path.home() / "".config"")` rather than depend on the `xdg` package?. How does one know if one is on a system where XDG is supported? E.g. I know Windows used to use a special APP configuration folder of its own.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222
https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222:75,Modifiability,config,config,75,"Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", Path.home() / "".config"")` rather than depend on the `xdg` package?. How does one know if one is on a system where XDG is supported? E.g. I know Windows used to use a special APP configuration folder of its own.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222
https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222:237,Modifiability,config,configuration,237,"Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", Path.home() / "".config"")` rather than depend on the `xdg` package?. How does one know if one is on a system where XDG is supported? E.g. I know Windows used to use a special APP configuration folder of its own.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222
https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744:87,Deployability,configurat,configuration,87,"I've bumped this to QuTiP 5, since that seems a more polite time to change the default configuration directory than 4.7.1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744
https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744:87,Modifiability,config,configuration,87,"I've bumped this to QuTiP 5, since that seems a more polite time to change the default configuration directory than 4.7.1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744
https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:957,Integrability,depend,dependency,957,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649
https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:67,Modifiability,config,config,67,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649
https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:163,Modifiability,variab,variable,163,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649
https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:284,Modifiability,config,config,284,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649
https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:516,Modifiability,config,config,516,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649
https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:567,Modifiability,Config,ConfigLocation,567,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649
https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:937,Safety,avoid,avoid,937,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649
https://github.com/qutip/qutip/pull/1878#issuecomment-1109771422:12,Testability,test,tests,12,The failing tests is unrelated so I will merge this.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1878#issuecomment-1109771422
https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616:252,Deployability,integrat,integrator,252,"This looks great and I think it will help a lot in cleanly implementing more complex solvers light the HEOMSolver. I have two suggestions for future improvements:. - I'd like to see `.options = ...` become a method because it now modifies the existing integrator and `.options(...)` would both make that clearer and more flexible. E.g. with a method we could allow both `.options(new_options)` to completely override the options and `.options(key=new_value)` to update just one setting. - The first call to `result.add(t, X)` uses `X = state0` but state0 could be almost anything the user passed in (and not necessarily the canonical form returned by `_restore_state`). It would be better if either there was a separate method to override to convert `state0` into the canonical form, or `result.add(t, X)` was called initially with `X = _restore_state(_data0)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616
https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616:462,Deployability,update,update,462,"This looks great and I think it will help a lot in cleanly implementing more complex solvers light the HEOMSolver. I have two suggestions for future improvements:. - I'd like to see `.options = ...` become a method because it now modifies the existing integrator and `.options(...)` would both make that clearer and more flexible. E.g. with a method we could allow both `.options(new_options)` to completely override the options and `.options(key=new_value)` to update just one setting. - The first call to `result.add(t, X)` uses `X = state0` but state0 could be almost anything the user passed in (and not necessarily the canonical form returned by `_restore_state`). It would be better if either there was a separate method to override to convert `state0` into the canonical form, or `result.add(t, X)` was called initially with `X = _restore_state(_data0)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616
https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616:252,Integrability,integrat,integrator,252,"This looks great and I think it will help a lot in cleanly implementing more complex solvers light the HEOMSolver. I have two suggestions for future improvements:. - I'd like to see `.options = ...` become a method because it now modifies the existing integrator and `.options(...)` would both make that clearer and more flexible. E.g. with a method we could allow both `.options(new_options)` to completely override the options and `.options(key=new_value)` to update just one setting. - The first call to `result.add(t, X)` uses `X = state0` but state0 could be almost anything the user passed in (and not necessarily the canonical form returned by `_restore_state`). It would be better if either there was a separate method to override to convert `state0` into the canonical form, or `result.add(t, X)` was called initially with `X = _restore_state(_data0)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616
https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616:321,Modifiability,flexible,flexible,321,"This looks great and I think it will help a lot in cleanly implementing more complex solvers light the HEOMSolver. I have two suggestions for future improvements:. - I'd like to see `.options = ...` become a method because it now modifies the existing integrator and `.options(...)` would both make that clearer and more flexible. E.g. with a method we could allow both `.options(new_options)` to completely override the options and `.options(key=new_value)` to update just one setting. - The first call to `result.add(t, X)` uses `X = state0` but state0 could be almost anything the user passed in (and not necessarily the canonical form returned by `_restore_state`). It would be better if either there was a separate method to override to convert `state0` into the canonical form, or `result.add(t, X)` was called initially with `X = _restore_state(_data0)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616
https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616:304,Usability,clear,clearer,304,"This looks great and I think it will help a lot in cleanly implementing more complex solvers light the HEOMSolver. I have two suggestions for future improvements:. - I'd like to see `.options = ...` become a method because it now modifies the existing integrator and `.options(...)` would both make that clearer and more flexible. E.g. with a method we could allow both `.options(new_options)` to completely override the options and `.options(key=new_value)` to update just one setting. - The first call to `result.add(t, X)` uses `X = state0` but state0 could be almost anything the user passed in (and not necessarily the canonical form returned by `_restore_state`). It would be better if either there was a separate method to override to convert `state0` into the canonical form, or `result.add(t, X)` was called initially with `X = _restore_state(_data0)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616
https://github.com/qutip/qutip/pull/1879#issuecomment-1108796698:20,Usability,simpl,simple,20,"The fixes are quite simple, added them here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108796698
https://github.com/qutip/qutip/pull/1880#issuecomment-1108857030:210,Deployability,integrat,integrator,210,[![Coverage Status](https://coveralls.io/builds/48544268/badge)](https://coveralls.io/builds/48544268). Coverage increased (+0.02%) to 65.506% when pulling **eaae9c110b5c9a78169db01ff213b1b4b04a0043 on Ericgig:integrator.step.fix** into **539e2e4bcd730894dffaec8cd2e0ac9b72efef77 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1880#issuecomment-1108857030
https://github.com/qutip/qutip/pull/1880#issuecomment-1108857030:210,Integrability,integrat,integrator,210,[![Coverage Status](https://coveralls.io/builds/48544268/badge)](https://coveralls.io/builds/48544268). Coverage increased (+0.02%) to 65.506% when pulling **eaae9c110b5c9a78169db01ff213b1b4b04a0043 on Ericgig:integrator.step.fix** into **539e2e4bcd730894dffaec8cd2e0ac9b72efef77 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1880#issuecomment-1108857030
https://github.com/qutip/qutip/pull/1883#issuecomment-1109695548:55,Availability,error,error,55,"Thank you @christian512, pdf seems to be build without error.; Could you add an upload step so we can access it after the job finished?; The mirror of the ""Upload built HTML files"" step.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1883#issuecomment-1109695548
https://github.com/qutip/qutip/pull/1883#issuecomment-1109695548:102,Security,access,access,102,"Thank you @christian512, pdf seems to be build without error.; Could you add an upload step so we can access it after the job finished?; The mirror of the ""Upload built HTML files"" step.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1883#issuecomment-1109695548
https://github.com/qutip/qutip/pull/1883#issuecomment-1122374547:123,Availability,down,down,123,"This doubles the time taken for the documentation build from ~9 minutes to ~18 minutes. It would be nice to do slow things down, but the documentation build is also not the slowest part of the build yet, so we can live with it for the moment.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1883#issuecomment-1122374547
https://github.com/qutip/qutip/issues/1887#issuecomment-1278553473:99,Deployability,release,release,99,"Is anyone working on this? I see no assignee, and it would be nice to get this feature on a stable release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1887#issuecomment-1278553473
https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803:56,Deployability,install,install,56,"Hi @ariels1234, here is a more detailed guide on how to install those additional packages https://qutip-qip.readthedocs.io/en/stable/installation.html#additional-software-for-plotting-circuits. (It is for the separate package qutip-qip, but the circuit plotting part is the same.). Do you have a valid version of pdflatex with packages like qcircuit and pdfcrop installed?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803
https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803:133,Deployability,install,installation,133,"Hi @ariels1234, here is a more detailed guide on how to install those additional packages https://qutip-qip.readthedocs.io/en/stable/installation.html#additional-software-for-plotting-circuits. (It is for the separate package qutip-qip, but the circuit plotting part is the same.). Do you have a valid version of pdflatex with packages like qcircuit and pdfcrop installed?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803
https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803:362,Deployability,install,installed,362,"Hi @ariels1234, here is a more detailed guide on how to install those additional packages https://qutip-qip.readthedocs.io/en/stable/installation.html#additional-software-for-plotting-circuits. (It is for the separate package qutip-qip, but the circuit plotting part is the same.). Do you have a valid version of pdflatex with packages like qcircuit and pdfcrop installed?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803
https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803:40,Usability,guid,guide,40,"Hi @ariels1234, here is a more detailed guide on how to install those additional packages https://qutip-qip.readthedocs.io/en/stable/installation.html#additional-software-for-plotting-circuits. (It is for the separate package qutip-qip, but the circuit plotting part is the same.). Do you have a valid version of pdflatex with packages like qcircuit and pdfcrop installed?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112172803
https://github.com/qutip/qutip/issues/1888#issuecomment-1112205108:36,Availability,down,downloaded,36,"Hi, thank you for replying!. I have downloaded everything necessary as written there and also tried to change the policy.xml file of ImageMagick, but it would not help, and I still get the same error:; FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'. I have a valid version of pdflatex with the packages qcircuit and pdfcrop installed. I verified it through MikTex.; After running, I obtained the latex file and the pdf file, but it is not converted to png file for some reason. Thanks,; Ariel",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112205108
https://github.com/qutip/qutip/issues/1888#issuecomment-1112205108:194,Availability,error,error,194,"Hi, thank you for replying!. I have downloaded everything necessary as written there and also tried to change the policy.xml file of ImageMagick, but it would not help, and I still get the same error:; FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'. I have a valid version of pdflatex with the packages qcircuit and pdfcrop installed. I verified it through MikTex.; After running, I obtained the latex file and the pdf file, but it is not converted to png file for some reason. Thanks,; Ariel",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112205108
https://github.com/qutip/qutip/issues/1888#issuecomment-1112205108:345,Deployability,install,installed,345,"Hi, thank you for replying!. I have downloaded everything necessary as written there and also tried to change the policy.xml file of ImageMagick, but it would not help, and I still get the same error:; FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'. I have a valid version of pdflatex with the packages qcircuit and pdfcrop installed. I verified it through MikTex.; After running, I obtained the latex file and the pdf file, but it is not converted to png file for some reason. Thanks,; Ariel",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112205108
https://github.com/qutip/qutip/issues/1888#issuecomment-1112216929:85,Deployability,install,installed,85,"Just to make sure, but I guess you already restarted the console after everything is installed?. If you got the pdf, then the LaTeX part is working. Have you tried to use the ImageMagick command to convert the pdf to png yourself?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112216929
https://github.com/qutip/qutip/issues/1888#issuecomment-1112231739:44,Deployability,install,installation,44,"Yes, I have restarted the console after the installation. I tried it now, through the command prompt and it worked fine, the qcirc.pdf file was converted to qcirc.png and I could open it. So I am not sure what is the origin of the problem when running the command q.png in python...; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1888#issuecomment-1112231739
https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173:16,Energy Efficiency,adapt,adapted,16,"@hodgestar, ; I adapted the `MultiTrajResult` to the new `Result` format, and I have some changes to the `Result` class that I want to do:; - I changed the `Result.__init__` to move setting the `e_ops` in `_post_init`: `MultiTrajResult` can't use them and needed to remove the related state processors.; - `add` was overwritten, but we could use it if we add a `_early_finish_check`: a processor that return the estimated quantity of work remaining. Parallel map will stop computing trajectories when it get under 0. I think we could have it in `Result`: it could be interesting to have with `mesolve` with the options to stop when the steady state is reached, etc. Then if times when added in a state processor, I could use `add` without overloading. Are you Ok with me going for it or do you prefer to keep `Result` as is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173
https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173:16,Modifiability,adapt,adapted,16,"@hodgestar, ; I adapted the `MultiTrajResult` to the new `Result` format, and I have some changes to the `Result` class that I want to do:; - I changed the `Result.__init__` to move setting the `e_ops` in `_post_init`: `MultiTrajResult` can't use them and needed to remove the related state processors.; - `add` was overwritten, but we could use it if we add a `_early_finish_check`: a processor that return the estimated quantity of work remaining. Parallel map will stop computing trajectories when it get under 0. I think we could have it in `Result`: it could be interesting to have with `mesolve` with the options to stop when the steady state is reached, etc. Then if times when added in a state processor, I could use `add` without overloading. Are you Ok with me going for it or do you prefer to keep `Result` as is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173
https://github.com/qutip/qutip/pull/1889#issuecomment-1191987452:9,Availability,failure,failures,9,The test failures seem to be only coveralls result upload errors. I'm happy to merge without re-running. Let's just double check that the merge commits pass everything.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1191987452
https://github.com/qutip/qutip/pull/1889#issuecomment-1191987452:58,Availability,error,errors,58,The test failures seem to be only coveralls result upload errors. I'm happy to merge without re-running. Let's just double check that the merge commits pass everything.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1191987452
https://github.com/qutip/qutip/pull/1889#issuecomment-1191987452:4,Testability,test,test,4,The test failures seem to be only coveralls result upload errors. I'm happy to merge without re-running. Let's just double check that the merge commits pass everything.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1191987452
https://github.com/qutip/qutip/pull/1889#issuecomment-1197390147:12,Testability,test,tests,12,"@hodgestar, tests are passing, can I merge?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1197390147
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:433,Availability,down,downstream,433,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:1290,Availability,down,download,1290,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:878,Deployability,install,install,878,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:653,Integrability,depend,depending,653,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:945,Integrability,depend,depending,945,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:579,Testability,test,testing,579,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:799,Testability,test,testing,799,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103:1265,Testability,test,testing,1265,"Thanks very much @Ericgig for preparing this!. I feel like it will be quite confusing if gates like `cnot` have different signatures than the ones in qutip-qip. Moreover, many of those gates/transformations are not only relevant to `qip`, but also used in other applications, so maybe we should keep more of them in the main qutip. One of the reasons that we want to include those gates into `qutip.operators` is because a few other downstream packages (e.g. `krylovsolver` that is now merged into qutip, and `qutip-tensornetwork` also uses Hadamard transform) also use them for testing (only) purposes. Having them in the main qutip may save them from depending on qutip-qip. I guess it would be better if we either; - Remove all qip and only define a few `_cnot`, `_swap` as private functions for testing inside the main qutip. And ask whoever else wants to use some gates to install `qutip-qip`. This may result in e.g. `qutip-tensornetwork` depending on `qutip-qip or having to implement a copy of some gates. or; - Include some more commonly used gates like `rx`, `ry` (they are unitaries generated by the Paulis and directly relevant to quantum control) `iswap` etc and keep them identical to the ones in qutip-qip, so that those who just want some gates for testing does not have to download the full qutip-qip. If the problem is the `qutip.qip.expand_operator`. I would argue that we can even include it into the main qutip. It is `tensor` + `permutation` and works not just for qubit systems, but also for other composite Hilbert spaces (provided a `dims`). It is quite handy not just for `qip`, but also for control and probably some other applications. What do you think?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1120403103
https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262:440,Integrability,interface,interface,440,"@BoxiLi . Yes, how to include gates in qutip is not clear to me. Many of them seems specialized so I don't think we should keep them all. Keeping only some of them could be fine but I am not well placed to choose a subset of commonly used gates and the `target` made them quite specialized. It also means that some gates will be defined in both qutip and qutip-qip. I also want all function that create `Qobj` in qutip the follow an common interface (they should all support `dtype`) and if we want these functions to also follow the qip signature, it could get somewhat complex. I think removing them and having the private functions for tests will make it easier for us on the long run. I see the use of `expand_operator` now that you explain it. I would prefer to have it in dimension.py and having users call it manually than being included in the `Qobj` creation function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262
https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262:639,Testability,test,tests,639,"@BoxiLi . Yes, how to include gates in qutip is not clear to me. Many of them seems specialized so I don't think we should keep them all. Keeping only some of them could be fine but I am not well placed to choose a subset of commonly used gates and the `target` made them quite specialized. It also means that some gates will be defined in both qutip and qutip-qip. I also want all function that create `Qobj` in qutip the follow an common interface (they should all support `dtype`) and if we want these functions to also follow the qip signature, it could get somewhat complex. I think removing them and having the private functions for tests will make it easier for us on the long run. I see the use of `expand_operator` now that you explain it. I would prefer to have it in dimension.py and having users call it manually than being included in the `Qobj` creation function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262
https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262:52,Usability,clear,clear,52,"@BoxiLi . Yes, how to include gates in qutip is not clear to me. Many of them seems specialized so I don't think we should keep them all. Keeping only some of them could be fine but I am not well placed to choose a subset of commonly used gates and the `target` made them quite specialized. It also means that some gates will be defined in both qutip and qutip-qip. I also want all function that create `Qobj` in qutip the follow an common interface (they should all support `dtype`) and if we want these functions to also follow the qip signature, it could get somewhat complex. I think removing them and having the private functions for tests will make it easier for us on the long run. I see the use of `expand_operator` now that you explain it. I would prefer to have it in dimension.py and having users call it manually than being included in the `Qobj` creation function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262
https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389:686,Deployability,release,release,686,"Yes, `target` makes them a bit specialized and calling `expand_operator` manually is probably a good option. If I may propose the following:; - Move `expand_operator` to `dimensions.py` and keep it in qutip.; - Keep two functions `hadamard_transform` and `qubit_clifford_group`, and find a proper place for them in the main qutip (`operator.py`?). They are not that trivial to implement like the rest of the gates and are also not limited to just `qip`. Keep them consistent with other functions that generate Qobj (support `dtype`).; - Remove all rest of the gates and create some private substitutions just for testing. We should probably add somewhere in the changelog for the major release that if users are using gates like `cnot` for testing and now cannot find it. They should either define the gate themselves (and use `expand_operator` if needed) or install `qutip-qip`. (BTW, is there a place where we can maintain a list of those notes for the major release?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389
https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389:859,Deployability,install,install,859,"Yes, `target` makes them a bit specialized and calling `expand_operator` manually is probably a good option. If I may propose the following:; - Move `expand_operator` to `dimensions.py` and keep it in qutip.; - Keep two functions `hadamard_transform` and `qubit_clifford_group`, and find a proper place for them in the main qutip (`operator.py`?). They are not that trivial to implement like the rest of the gates and are also not limited to just `qip`. Keep them consistent with other functions that generate Qobj (support `dtype`).; - Remove all rest of the gates and create some private substitutions just for testing. We should probably add somewhere in the changelog for the major release that if users are using gates like `cnot` for testing and now cannot find it. They should either define the gate themselves (and use `expand_operator` if needed) or install `qutip-qip`. (BTW, is there a place where we can maintain a list of those notes for the major release?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389
https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389:961,Deployability,release,release,961,"Yes, `target` makes them a bit specialized and calling `expand_operator` manually is probably a good option. If I may propose the following:; - Move `expand_operator` to `dimensions.py` and keep it in qutip.; - Keep two functions `hadamard_transform` and `qubit_clifford_group`, and find a proper place for them in the main qutip (`operator.py`?). They are not that trivial to implement like the rest of the gates and are also not limited to just `qip`. Keep them consistent with other functions that generate Qobj (support `dtype`).; - Remove all rest of the gates and create some private substitutions just for testing. We should probably add somewhere in the changelog for the major release that if users are using gates like `cnot` for testing and now cannot find it. They should either define the gate themselves (and use `expand_operator` if needed) or install `qutip-qip`. (BTW, is there a place where we can maintain a list of those notes for the major release?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389
https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389:613,Testability,test,testing,613,"Yes, `target` makes them a bit specialized and calling `expand_operator` manually is probably a good option. If I may propose the following:; - Move `expand_operator` to `dimensions.py` and keep it in qutip.; - Keep two functions `hadamard_transform` and `qubit_clifford_group`, and find a proper place for them in the main qutip (`operator.py`?). They are not that trivial to implement like the rest of the gates and are also not limited to just `qip`. Keep them consistent with other functions that generate Qobj (support `dtype`).; - Remove all rest of the gates and create some private substitutions just for testing. We should probably add somewhere in the changelog for the major release that if users are using gates like `cnot` for testing and now cannot find it. They should either define the gate themselves (and use `expand_operator` if needed) or install `qutip-qip`. (BTW, is there a place where we can maintain a list of those notes for the major release?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389
https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389:740,Testability,test,testing,740,"Yes, `target` makes them a bit specialized and calling `expand_operator` manually is probably a good option. If I may propose the following:; - Move `expand_operator` to `dimensions.py` and keep it in qutip.; - Keep two functions `hadamard_transform` and `qubit_clifford_group`, and find a proper place for them in the main qutip (`operator.py`?). They are not that trivial to implement like the rest of the gates and are also not limited to just `qip`. Keep them consistent with other functions that generate Qobj (support `dtype`).; - Remove all rest of the gates and create some private substitutions just for testing. We should probably add somewhere in the changelog for the major release that if users are using gates like `cnot` for testing and now cannot find it. They should either define the gate themselves (and use `expand_operator` if needed) or install `qutip-qip`. (BTW, is there a place where we can maintain a list of those notes for the major release?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121214389
https://github.com/qutip/qutip/pull/1890#issuecomment-1134817221:110,Availability,failure,failure,110,Is there anything preventing this merging once the documentation builds are passing?. The documentation build failure is quite odd -- maybe something to do with merging in the upstream/dev.major branch?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1134817221
https://github.com/qutip/qutip/issues/1891#issuecomment-1414283362:43,Usability,simpl,simple,43,@hodgestar; Can we close this?; We now use simple dict for options and `Options` exist for backward compatibility.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1891#issuecomment-1414283362
https://github.com/qutip/qutip/pull/1892#issuecomment-1124955633:126,Deployability,Update,Update,126,"> `qip/circuit.py` will be removed in 5.0, so a similar PR should go into qutip-qip. I'll raise one there as well, thanks!. **Update:** The corresponding PR is https://github.com/qutip/qutip-qip/pull/142.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1892#issuecomment-1124955633
https://github.com/qutip/qutip/issues/1893#issuecomment-1147241501:158,Usability,guid,guidelines,158,"Awesome, I'll do my best!. > Note that this would be a PR againt the `dev.major` branch. Does this entail any extra steps not encompassed in the contributing guidelines, or is it just a matter of branching from and PRing to `dev.major` instead of `master`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1893#issuecomment-1147241501
https://github.com/qutip/qutip/issues/1893#issuecomment-1147245506:71,Usability,guid,guidelines,71,"> Does this entail any extra steps not encompassed in the contributing guidelines, or is it just a matter of branching from and PRing to `dev.major` instead of `master`?. Just branching from and PRing to `dev.major` -- the contribution guidelines are the same.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1893#issuecomment-1147245506
https://github.com/qutip/qutip/issues/1893#issuecomment-1147245506:236,Usability,guid,guidelines,236,"> Does this entail any extra steps not encompassed in the contributing guidelines, or is it just a matter of branching from and PRing to `dev.major` instead of `master`?. Just branching from and PRing to `dev.major` -- the contribution guidelines are the same.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1893#issuecomment-1147245506
https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:689,Deployability,release,releases,689,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565
https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:1101,Deployability,configurat,configuration,1101,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565
https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:1160,Deployability,configurat,configuration,1160,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565
https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:1343,Deployability,release,release,1343,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565
https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:1101,Modifiability,config,configuration,1101,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565
https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:1160,Modifiability,config,configuration,1160,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565
https://github.com/qutip/qutip/issues/1894#issuecomment-1152285930:307,Deployability,release,release,307,"@trentfridey Thank you for opening the PR. I will review it a bit later, and attempt to answer your first question here once I have. In answer to your second question, I think the minimal approach, and the one we should take now, is to add running `towncrier build` to the steps in creating or updating the release branch (i.e. the human doing the release would run it and push the result). Later once we have some experience using it, we can consider automating the release process a bit more somehow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1152285930
https://github.com/qutip/qutip/issues/1894#issuecomment-1152285930:348,Deployability,release,release,348,"@trentfridey Thank you for opening the PR. I will review it a bit later, and attempt to answer your first question here once I have. In answer to your second question, I think the minimal approach, and the one we should take now, is to add running `towncrier build` to the steps in creating or updating the release branch (i.e. the human doing the release would run it and push the result). Later once we have some experience using it, we can consider automating the release process a bit more somehow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1152285930
https://github.com/qutip/qutip/issues/1894#issuecomment-1152285930:467,Deployability,release,release,467,"@trentfridey Thank you for opening the PR. I will review it a bit later, and attempt to answer your first question here once I have. In answer to your second question, I think the minimal approach, and the one we should take now, is to add running `towncrier build` to the steps in creating or updating the release branch (i.e. the human doing the release would run it and push the result). Later once we have some experience using it, we can consider automating the release process a bit more somehow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1152285930
https://github.com/qutip/qutip/pull/1895#issuecomment-1131688317:57,Testability,test,test,57,I've marked this for inclusion in QuTiP 4.7.1. Should we test on cython 0.29.30 or leave our testing as is for now?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1895#issuecomment-1131688317
https://github.com/qutip/qutip/pull/1895#issuecomment-1131688317:93,Testability,test,testing,93,I've marked this for inclusion in QuTiP 4.7.1. Should we test on cython 0.29.30 or leave our testing as is for now?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1895#issuecomment-1131688317
https://github.com/qutip/qutip/pull/1895#issuecomment-1131947364:103,Testability,test,tests,103,"v4 has not issue with the new version of cython, only v5.; So we should stay with the newest cython in tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1895#issuecomment-1131947364
https://github.com/qutip/qutip/issues/1896#issuecomment-1138780441:44,Availability,error,error,44,"Hey @lzawbrito, ; I tried to reproduce your error on a Linux (Ubuntu) machine. I installed your exact environment (all versions equal) and your provided code runs without a problem. Also the notebook you refer to does not give an error. So it seems to me that it is a problem with macOS. . Did you try to increase `nsteps`? You can do so by adding an option to the `mesolve()` function: . `output = mesolve(H, psi0, tlist, c_ops, e_ops, options=Options(nsteps=1000))`; Note that `1000` is the standard value for `nsteps`, so you should increase it furhter.; Let me know if increasing `nsteps` works!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1138780441
https://github.com/qutip/qutip/issues/1896#issuecomment-1138780441:230,Availability,error,error,230,"Hey @lzawbrito, ; I tried to reproduce your error on a Linux (Ubuntu) machine. I installed your exact environment (all versions equal) and your provided code runs without a problem. Also the notebook you refer to does not give an error. So it seems to me that it is a problem with macOS. . Did you try to increase `nsteps`? You can do so by adding an option to the `mesolve()` function: . `output = mesolve(H, psi0, tlist, c_ops, e_ops, options=Options(nsteps=1000))`; Note that `1000` is the standard value for `nsteps`, so you should increase it furhter.; Let me know if increasing `nsteps` works!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1138780441
https://github.com/qutip/qutip/issues/1896#issuecomment-1138780441:81,Deployability,install,installed,81,"Hey @lzawbrito, ; I tried to reproduce your error on a Linux (Ubuntu) machine. I installed your exact environment (all versions equal) and your provided code runs without a problem. Also the notebook you refer to does not give an error. So it seems to me that it is a problem with macOS. . Did you try to increase `nsteps`? You can do so by adding an option to the `mesolve()` function: . `output = mesolve(H, psi0, tlist, c_ops, e_ops, options=Options(nsteps=1000))`; Note that `1000` is the standard value for `nsteps`, so you should increase it furhter.; Let me know if increasing `nsteps` works!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1138780441
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:136,Availability,error,errors,136,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:363,Availability,error,error,363,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:102,Deployability,integrat,integration,102,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:351,Deployability,integrat,integration,351,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:376,Deployability,integrat,integrating,376,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:102,Integrability,integrat,integration,102,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:351,Integrability,integrat,integration,351,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:376,Integrability,integrat,integrating,376,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503:263,Usability,simpl,simple,263,"Hi @christian512, thanks for the help! I've increased `nsteps` for that particular simulation and the integration runs fine without any errors. One caveat is I have not checked the correctness of the result. . On the other hand, as soon as I tried `mesolve` on a simple Larmor precession problem, `mesolve` started either (1) throwing the typical ODE integration error or (2) integrating but producing a manifestly incorrect result (the final state is not on the Bloch sphere). The code I am using is ; ```; from qutip import * ; import numpy as np. sz = sigmaz(). init_ket = 2 ** (-1/2) * Qobj([[1], [1]]) # Bloch vector is unit x; init_dm = init_ket * init_ket.dag(). b_0 = 1; gam = 1; h_zeem = gam * b_0 * sz; h = [h_zeem]. larmor_freq = gam * b_0 ; period = 2 * np.pi / (larmor_freq); t = np.linspace(0, period / 2, 100). print(mesolve(h, init_dm, t, options=Options(nsteps=1e6)).states[-1]); ```. Which produces ; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.5 +0.j -263.5988765-267.24047092j]; [ -2.1425229 +0.49907152j 0.5 +0.j ]]; ```; Edit: I have also tried playing around with `atol` and `rtol` without any success.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140305503
https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420:113,Deployability,integrat,integration,113,"Hi @lzawbrito, I guess that choosing `nsteps=1e6` is a pretty big value and that it leads to problems in the ODE integration. However, again running on my system, I get a reasonable output even with these high `nsteps`: . ``` ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.5 +0.00000000e+00j 0.49999938-4.02511613e-06j]; [0.49999938+4.02511613e-06j 0.5 +0.00000000e+00j]]; ``` ; I guess that this is a problem with SciPy's integrator and your system. I don't have enough experience with QuTiP to give a more detailed analysis. Maybe someone else knows about this? @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420
https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420:474,Deployability,integrat,integrator,474,"Hi @lzawbrito, I guess that choosing `nsteps=1e6` is a pretty big value and that it leads to problems in the ODE integration. However, again running on my system, I get a reasonable output even with these high `nsteps`: . ``` ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.5 +0.00000000e+00j 0.49999938-4.02511613e-06j]; [0.49999938+4.02511613e-06j 0.5 +0.00000000e+00j]]; ``` ; I guess that this is a problem with SciPy's integrator and your system. I don't have enough experience with QuTiP to give a more detailed analysis. Maybe someone else knows about this? @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420
https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420:113,Integrability,integrat,integration,113,"Hi @lzawbrito, I guess that choosing `nsteps=1e6` is a pretty big value and that it leads to problems in the ODE integration. However, again running on my system, I get a reasonable output even with these high `nsteps`: . ``` ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.5 +0.00000000e+00j 0.49999938-4.02511613e-06j]; [0.49999938+4.02511613e-06j 0.5 +0.00000000e+00j]]; ``` ; I guess that this is a problem with SciPy's integrator and your system. I don't have enough experience with QuTiP to give a more detailed analysis. Maybe someone else knows about this? @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420
https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420:474,Integrability,integrat,integrator,474,"Hi @lzawbrito, I guess that choosing `nsteps=1e6` is a pretty big value and that it leads to problems in the ODE integration. However, again running on my system, I get a reasonable output even with these high `nsteps`: . ``` ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.5 +0.00000000e+00j 0.49999938-4.02511613e-06j]; [0.49999938+4.02511613e-06j 0.5 +0.00000000e+00j]]; ``` ; I guess that this is a problem with SciPy's integrator and your system. I don't have enough experience with QuTiP to give a more detailed analysis. Maybe someone else knows about this? @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140428420
https://github.com/qutip/qutip/issues/1896#issuecomment-1140440000:182,Deployability,integrat,integrator,182,"I cannot reproduce this on either Ubuntu or Windows... `nstep` only sets the maximally allowed number of time steps. That exception is a quite general one. It only says that the ODE integrator fails. But the Larmor example is really a trivial one and if it fails then something very important must have been contaminated. If resinstalling in a fresh environment does not work, I can only suggest to debug at the scipy level.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140440000
https://github.com/qutip/qutip/issues/1896#issuecomment-1140440000:182,Integrability,integrat,integrator,182,"I cannot reproduce this on either Ubuntu or Windows... `nstep` only sets the maximally allowed number of time steps. That exception is a quite general one. It only says that the ODE integrator fails. But the Larmor example is really a trivial one and if it fails then something very important must have been contaminated. If resinstalling in a fresh environment does not work, I can only suggest to debug at the scipy level.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1896#issuecomment-1140440000
https://github.com/qutip/qutip/issues/1898#issuecomment-1356839030:262,Availability,error,error,262,"We made good progress updating the documentation for v5, we are mostly missing pages for new features and porting from v4 to v5, which would be hard to write without being up to date with recent progress.; However if you want to take a look with fresh eyes, fix error, improve wording, fix broken links, etc. it would be greatly appreciated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1898#issuecomment-1356839030
https://github.com/qutip/qutip/issues/1901#issuecomment-1138620881:28,Availability,error,error,28,"The issue is with numerical error: the default tolerance for the computation of the propagator is `1e-8`, but the tolerance for `iscptp` is `1e-12`. You can improve the precision of the propagator by passing `options=Options(atol=1e-14, rtol=1e-14)`. These precisions are per internal step, not for the full evolution. You can also lower the requirement for `iscptp` with `qutip.settings.atol = ...`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1901#issuecomment-1138620881
https://github.com/qutip/qutip/issues/1901#issuecomment-1138620881:47,Availability,toler,tolerance,47,"The issue is with numerical error: the default tolerance for the computation of the propagator is `1e-8`, but the tolerance for `iscptp` is `1e-12`. You can improve the precision of the propagator by passing `options=Options(atol=1e-14, rtol=1e-14)`. These precisions are per internal step, not for the full evolution. You can also lower the requirement for `iscptp` with `qutip.settings.atol = ...`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1901#issuecomment-1138620881
https://github.com/qutip/qutip/issues/1901#issuecomment-1138620881:114,Availability,toler,tolerance,114,"The issue is with numerical error: the default tolerance for the computation of the propagator is `1e-8`, but the tolerance for `iscptp` is `1e-12`. You can improve the precision of the propagator by passing `options=Options(atol=1e-14, rtol=1e-14)`. These precisions are per internal step, not for the full evolution. You can also lower the requirement for `iscptp` with `qutip.settings.atol = ...`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1901#issuecomment-1138620881
https://github.com/qutip/qutip/pull/1902#issuecomment-1139096612:24,Availability,failure,failure,24,The documentation build failure is likely due to the pip bug that triggered the documentation build errors on dev.major (#1897).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1902#issuecomment-1139096612
https://github.com/qutip/qutip/pull/1902#issuecomment-1139096612:100,Availability,error,errors,100,The documentation build failure is likely due to the pip bug that triggered the documentation build errors on dev.major (#1897).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1902#issuecomment-1139096612
https://github.com/qutip/qutip/issues/1904#issuecomment-1171447682:99,Usability,learn,learn,99,Interesting discussion about the relationship between OpenMP and multiprocessing -- https://scikit-learn.org/stable/faq.html#why-do-i-sometime-get-a-crash-freeze-with-n-jobs-1-under-osx-or-linux (in case this is relevant when bringing OpenMP back). _Originally posted by @hodgestar in https://github.com/qutip/qutip/issues/1948#issuecomment-1171423571_,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1904#issuecomment-1171447682
https://github.com/qutip/qutip/issues/1905#issuecomment-1426945641:224,Integrability,rout,route,224,"@nathanshammah This seems like an important issue, unsure why this is dormant. Let me know your opinion, please. Danny (former student of mine) could turn this into a pull request, if you tell us that that's the appropriate route.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1905#issuecomment-1426945641
https://github.com/qutip/qutip/pull/1907#issuecomment-1139694450:305,Safety,avoid,avoid,305,"@Ericgig I re-factor the result class a fair bit to make it possible to re-use more of it for the HEOMSolver. Let me know if you like the general approach. I would like to remove the additional parameters to `_post_init(...)` and supply everything either directly via the result options (since that would avoid the HEOMResult class receiving parameters it doesn't use like ``rhs_is_super``). I'm happy to implement that here if you have an idea, but I'm also happy to leave it for a future PR (maybe post #1889).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1139694450
https://github.com/qutip/qutip/pull/1907#issuecomment-1139698913:2,Deployability,update,updated,2,I updated #1869 to use the new BaseResult class.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1139698913
https://github.com/qutip/qutip/pull/1907#issuecomment-1139721813:219,Modifiability,flexible,flexible-result-base-class,219,[![Coverage Status](https://coveralls.io/builds/49815148/badge)](https://coveralls.io/builds/49815148). Coverage increased (+0.2%) to 65.494% when pulling **286cce4bd3d5a778a7ad0ab817fe68db72bc30db on hodgestar:feature/flexible-result-base-class** into **e8f8b0fe6f343c585bc2d80f727a25a5f3cca1a1 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1139721813
https://github.com/qutip/qutip/pull/1907#issuecomment-1140082568:543,Integrability,depend,depend,543,"You have my approval for most of it. The approach of using `preprocessors` and `processors` fells overkill for use that I have, but I don't see any reason it wouldn't work. If you need it for HEOM, let's go for it. I don't like having expect being a dict. I was actually thinking of going with supporting the 3 cases, at least for the output. If we keep `expect` as a property, the format change can be done only there and we can keep it in another format, dict or list, inside. Simplifying `_post_init` will be tricky, normalization does not depend only on the option, but also the state... We could have `Solver.run` call `add_preprocessor` to add the normalization function, but them it would make it harder for HEOM to call.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1140082568
https://github.com/qutip/qutip/pull/1907#issuecomment-1140082568:479,Usability,Simpl,Simplifying,479,"You have my approval for most of it. The approach of using `preprocessors` and `processors` fells overkill for use that I have, but I don't see any reason it wouldn't work. If you need it for HEOM, let's go for it. I don't like having expect being a dict. I was actually thinking of going with supporting the 3 cases, at least for the output. If we keep `expect` as a property, the format change can be done only there and we can keep it in another format, dict or list, inside. Simplifying `_post_init` will be tricky, normalization does not depend only on the option, but also the state... We could have `Solver.run` call `add_preprocessor` to add the normalization function, but them it would make it harder for HEOM to call.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1140082568
https://github.com/qutip/qutip/pull/1907#issuecomment-1141239672:64,Testability,test,tested,64,"Then out about removing dict expect? Dictionary support was not tested and supported only for some solver for a long time. It would be strange to have it become the default. There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. . For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. . As for plotting function, I forgot they existed.... We could have them as methods of `Result`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141239672
https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041:741,Integrability,interface,interface,741,"> Then out about removing dict expect? Dictionary support was not tested and supported only for some solver for a long time. It ; > would be strange to have it become the default. Well, this is v5 -- we are trying to make things nicer. The issue with lists of e_ops is that often the e_ops have no sensible ordering. E.g. if the e_ops are, say, the number operator and projectors on to two different bases of interest then `[qutip.num(N), proj1, proj2]` are later accessed as `.expect[0]`, `.expect[1]` and `.expect[2]` which are then unreadable and fairly arbitrary and unmemorable numbers. Having `.expect[""num""]`, `.expect[""proj1""]` and `.expect[""proj2""]` is much more readable and will result in fewer mistakes. I *really* like the dict interface because it gives this readability to results. I'm happy to accept that others may prefer lists, but providing multiple interfaces creates a problem for any code working with results. So it is a bit of tricky question to resolve. > For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. The MC result classes already have to work around these things in awkward ways, and probably need to be a lot more careful -- e.g. e_ops functions can return strange things like Qobjs or perhaps even stranger things like strings or dicts which can't be averaged over. > There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. Agreed, although unless `result.expect` contains a uniform set of things, this are probably not sensible things to be doing. I have some other ideas but I think they make more of a mess -- e.g. keep `.expect` a list but provide `.expect_d` which is a dict. If one needs to write v4 compatible code one can always pass a list of e_ops and then work with `.expect` a bit carefully (i.e. as a dict). Thoughts?. I have added tests now, so it's just the `.expect` issu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041
https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041:870,Integrability,interface,interfaces,870,"> Then out about removing dict expect? Dictionary support was not tested and supported only for some solver for a long time. It ; > would be strange to have it become the default. Well, this is v5 -- we are trying to make things nicer. The issue with lists of e_ops is that often the e_ops have no sensible ordering. E.g. if the e_ops are, say, the number operator and projectors on to two different bases of interest then `[qutip.num(N), proj1, proj2]` are later accessed as `.expect[0]`, `.expect[1]` and `.expect[2]` which are then unreadable and fairly arbitrary and unmemorable numbers. Having `.expect[""num""]`, `.expect[""proj1""]` and `.expect[""proj2""]` is much more readable and will result in fewer mistakes. I *really* like the dict interface because it gives this readability to results. I'm happy to accept that others may prefer lists, but providing multiple interfaces creates a problem for any code working with results. So it is a bit of tricky question to resolve. > For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. The MC result classes already have to work around these things in awkward ways, and probably need to be a lot more careful -- e.g. e_ops functions can return strange things like Qobjs or perhaps even stranger things like strings or dicts which can't be averaged over. > There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. Agreed, although unless `result.expect` contains a uniform set of things, this are probably not sensible things to be doing. I have some other ideas but I think they make more of a mess -- e.g. keep `.expect` a list but provide `.expect_d` which is a dict. If one needs to write v4 compatible code one can always pass a list of e_ops and then work with `.expect` a bit carefully (i.e. as a dict). Thoughts?. I have added tests now, so it's just the `.expect` issu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041
https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041:464,Security,access,accessed,464,"> Then out about removing dict expect? Dictionary support was not tested and supported only for some solver for a long time. It ; > would be strange to have it become the default. Well, this is v5 -- we are trying to make things nicer. The issue with lists of e_ops is that often the e_ops have no sensible ordering. E.g. if the e_ops are, say, the number operator and projectors on to two different bases of interest then `[qutip.num(N), proj1, proj2]` are later accessed as `.expect[0]`, `.expect[1]` and `.expect[2]` which are then unreadable and fairly arbitrary and unmemorable numbers. Having `.expect[""num""]`, `.expect[""proj1""]` and `.expect[""proj2""]` is much more readable and will result in fewer mistakes. I *really* like the dict interface because it gives this readability to results. I'm happy to accept that others may prefer lists, but providing multiple interfaces creates a problem for any code working with results. So it is a bit of tricky question to resolve. > For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. The MC result classes already have to work around these things in awkward ways, and probably need to be a lot more careful -- e.g. e_ops functions can return strange things like Qobjs or perhaps even stranger things like strings or dicts which can't be averaged over. > There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. Agreed, although unless `result.expect` contains a uniform set of things, this are probably not sensible things to be doing. I have some other ideas but I think they make more of a mess -- e.g. keep `.expect` a list but provide `.expect_d` which is a dict. If one needs to write v4 compatible code one can always pass a list of e_ops and then work with `.expect` a bit carefully (i.e. as a dict). Thoughts?. I have added tests now, so it's just the `.expect` issu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041
https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041:66,Testability,test,tested,66,"> Then out about removing dict expect? Dictionary support was not tested and supported only for some solver for a long time. It ; > would be strange to have it become the default. Well, this is v5 -- we are trying to make things nicer. The issue with lists of e_ops is that often the e_ops have no sensible ordering. E.g. if the e_ops are, say, the number operator and projectors on to two different bases of interest then `[qutip.num(N), proj1, proj2]` are later accessed as `.expect[0]`, `.expect[1]` and `.expect[2]` which are then unreadable and fairly arbitrary and unmemorable numbers. Having `.expect[""num""]`, `.expect[""proj1""]` and `.expect[""proj2""]` is much more readable and will result in fewer mistakes. I *really* like the dict interface because it gives this readability to results. I'm happy to accept that others may prefer lists, but providing multiple interfaces creates a problem for any code working with results. So it is a bit of tricky question to resolve. > For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. The MC result classes already have to work around these things in awkward ways, and probably need to be a lot more careful -- e.g. e_ops functions can return strange things like Qobjs or perhaps even stranger things like strings or dicts which can't be averaged over. > There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. Agreed, although unless `result.expect` contains a uniform set of things, this are probably not sensible things to be doing. I have some other ideas but I think they make more of a mess -- e.g. keep `.expect` a list but provide `.expect_d` which is a dict. If one needs to write v4 compatible code one can always pass a list of e_ops and then work with `.expect` a bit carefully (i.e. as a dict). Thoughts?. I have added tests now, so it's just the `.expect` issu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041
https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041:1959,Testability,test,tests,1959,"ct? Dictionary support was not tested and supported only for some solver for a long time. It ; > would be strange to have it become the default. Well, this is v5 -- we are trying to make things nicer. The issue with lists of e_ops is that often the e_ops have no sensible ordering. E.g. if the e_ops are, say, the number operator and projectors on to two different bases of interest then `[qutip.num(N), proj1, proj2]` are later accessed as `.expect[0]`, `.expect[1]` and `.expect[2]` which are then unreadable and fairly arbitrary and unmemorable numbers. Having `.expect[""num""]`, `.expect[""proj1""]` and `.expect[""proj2""]` is much more readable and will result in fewer mistakes. I *really* like the dict interface because it gives this readability to results. I'm happy to accept that others may prefer lists, but providing multiple interfaces creates a problem for any code working with results. So it is a bit of tricky question to resolve. > For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. The MC result classes already have to work around these things in awkward ways, and probably need to be a lot more careful -- e.g. e_ops functions can return strange things like Qobjs or perhaps even stranger things like strings or dicts which can't be averaged over. > There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. Agreed, although unless `result.expect` contains a uniform set of things, this are probably not sensible things to be doing. I have some other ideas but I think they make more of a mess -- e.g. keep `.expect` a list but provide `.expect_d` which is a dict. If one needs to write v4 compatible code one can always pass a list of e_ops and then work with `.expect` a bit carefully (i.e. as a dict). Thoughts?. I have added tests now, so it's just the `.expect` issue to resolve for this PR, I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041
https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988:800,Availability,error,error,800,"Removing list and forcing dict does not feels making things nicer... Being forced to use dict is mostly a nuisance for me. Presently we support both list ans dict output without much issues, there are very few place that would have issue supporting multiple interfaces. (I can only think of `plot_expectation`.). But how about using `namedtuple`?. It act as a list for loop and numpy, but elements can be called by both the number and name, and I like having result's output somewhat immutable. The biggest issue is that we must provide field names for list inputs... For MC, if e_ops callable return weird things, they will have to choose the option to store all trajectories instead of averaging the result. If they ask for the average or standard derivation of a dict, they will and should get an error, the best we should do is making this error message useful. Custom reduce function could be doable, but probably be a mess, especially if we need one for both `mean` and `std`... So unless someone present a good use case for it, I don't plan going that way.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988
https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988:844,Availability,error,error,844,"Removing list and forcing dict does not feels making things nicer... Being forced to use dict is mostly a nuisance for me. Presently we support both list ans dict output without much issues, there are very few place that would have issue supporting multiple interfaces. (I can only think of `plot_expectation`.). But how about using `namedtuple`?. It act as a list for loop and numpy, but elements can be called by both the number and name, and I like having result's output somewhat immutable. The biggest issue is that we must provide field names for list inputs... For MC, if e_ops callable return weird things, they will have to choose the option to store all trajectories instead of averaging the result. If they ask for the average or standard derivation of a dict, they will and should get an error, the best we should do is making this error message useful. Custom reduce function could be doable, but probably be a mess, especially if we need one for both `mean` and `std`... So unless someone present a good use case for it, I don't plan going that way.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988
https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988:873,Energy Efficiency,reduce,reduce,873,"Removing list and forcing dict does not feels making things nicer... Being forced to use dict is mostly a nuisance for me. Presently we support both list ans dict output without much issues, there are very few place that would have issue supporting multiple interfaces. (I can only think of `plot_expectation`.). But how about using `namedtuple`?. It act as a list for loop and numpy, but elements can be called by both the number and name, and I like having result's output somewhat immutable. The biggest issue is that we must provide field names for list inputs... For MC, if e_ops callable return weird things, they will have to choose the option to store all trajectories instead of averaging the result. If they ask for the average or standard derivation of a dict, they will and should get an error, the best we should do is making this error message useful. Custom reduce function could be doable, but probably be a mess, especially if we need one for both `mean` and `std`... So unless someone present a good use case for it, I don't plan going that way.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988
https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988:258,Integrability,interface,interfaces,258,"Removing list and forcing dict does not feels making things nicer... Being forced to use dict is mostly a nuisance for me. Presently we support both list ans dict output without much issues, there are very few place that would have issue supporting multiple interfaces. (I can only think of `plot_expectation`.). But how about using `namedtuple`?. It act as a list for loop and numpy, but elements can be called by both the number and name, and I like having result's output somewhat immutable. The biggest issue is that we must provide field names for list inputs... For MC, if e_ops callable return weird things, they will have to choose the option to store all trajectories instead of averaging the result. If they ask for the average or standard derivation of a dict, they will and should get an error, the best we should do is making this error message useful. Custom reduce function could be doable, but probably be a mess, especially if we need one for both `mean` and `std`... So unless someone present a good use case for it, I don't plan going that way.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988
https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988:850,Integrability,message,message,850,"Removing list and forcing dict does not feels making things nicer... Being forced to use dict is mostly a nuisance for me. Presently we support both list ans dict output without much issues, there are very few place that would have issue supporting multiple interfaces. (I can only think of `plot_expectation`.). But how about using `namedtuple`?. It act as a list for loop and numpy, but elements can be called by both the number and name, and I like having result's output somewhat immutable. The biggest issue is that we must provide field names for list inputs... For MC, if e_ops callable return weird things, they will have to choose the option to store all trajectories instead of averaging the result. If they ask for the average or standard derivation of a dict, they will and should get an error, the best we should do is making this error message useful. Custom reduce function could be doable, but probably be a mess, especially if we need one for both `mean` and `std`... So unless someone present a good use case for it, I don't plan going that way.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141402988
https://github.com/qutip/qutip/pull/1907#issuecomment-1141474154:176,Deployability,integrat,integrator,176,"Half related to this, what do you think about having data-layer's data _mostly_ immutable? We could ignore the tracking of copies of the states, which are sometime done by the integrator or solver (normalization in `Solver._restore_state` ?). There are some gains to work in-place: stochastic evolution is 30% faster inplace. But I see ways around it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141474154
https://github.com/qutip/qutip/pull/1907#issuecomment-1141474154:176,Integrability,integrat,integrator,176,"Half related to this, what do you think about having data-layer's data _mostly_ immutable? We could ignore the tracking of copies of the states, which are sometime done by the integrator or solver (normalization in `Solver._restore_state` ?). There are some gains to work in-place: stochastic evolution is 30% faster inplace. But I see ways around it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141474154
https://github.com/qutip/qutip/pull/1907#issuecomment-1142321531:94,Testability,log,logic,94,"If we moved normalization into the solvers, then we wouldn't need the preprocessors. The copy logic for processors could be kept so that the state is only copied by the results if the processors require it, but we'd then need the solver to tell the result whether it had already copied the state. We'd also need to make sure that the normalization logic in the solver was re-usable and override-able. The _post_init() would still be useful for processing options (e.g. the HEOMResult already does that to process the ado_return option).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1142321531
https://github.com/qutip/qutip/pull/1907#issuecomment-1142321531:348,Testability,log,logic,348,"If we moved normalization into the solvers, then we wouldn't need the preprocessors. The copy logic for processors could be kept so that the state is only copied by the results if the processors require it, but we'd then need the solver to tell the result whether it had already copied the state. We'd also need to make sure that the normalization logic in the solver was re-usable and override-able. The _post_init() would still be useful for processing options (e.g. the HEOMResult already does that to process the ado_return option).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1142321531
https://github.com/qutip/qutip/pull/1907#issuecomment-1142321531:375,Usability,usab,usable,375,"If we moved normalization into the solvers, then we wouldn't need the preprocessors. The copy logic for processors could be kept so that the state is only copied by the results if the processors require it, but we'd then need the solver to tell the result whether it had already copied the state. We'd also need to make sure that the normalization logic in the solver was re-usable and override-able. The _post_init() would still be useful for processing options (e.g. the HEOMResult already does that to process the ado_return option).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1142321531
https://github.com/qutip/qutip/pull/1907#issuecomment-1142339185:370,Security,access,access,370,"`namedtuple` is not a bad idea, although it's a bit odd because `e_ops` is never a namedtuple and it doesn't solve the problem of what type `.e_ops` has. And `namedtuple` forbids attributes which aren't identifiers, which is also problematic. I guess we could write our own type, `Expect`, that acts enough like a list for numpy, etc but still allows item and attribute access. That feels a bit crazy, but maybe it is worth it?. I still feel that all of these options are overly complicated. `e_ops` is not a list conceptually. Lists are typically ordered, but unstructured. The `e_ops` are clearly not ordered because `e_ops[0]` doesn't ""come before"" `e_ops[1]` in any meaningful way. The order of the indexes in a list `e_ops` are meaningless -- they exist only because that is how Python lists work. *Sometimes* there may be a natural ordering to e_ops -- e.g. if they happen to be the projectors onto a complete set of basis elements -- but this a small subset of the more general situation where e_ops might be any set of operators and functions. I do see that you feel lists are the most important case though, so it would be good to support them well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1142339185
https://github.com/qutip/qutip/pull/1907#issuecomment-1142339185:591,Usability,clear,clearly,591,"`namedtuple` is not a bad idea, although it's a bit odd because `e_ops` is never a namedtuple and it doesn't solve the problem of what type `.e_ops` has. And `namedtuple` forbids attributes which aren't identifiers, which is also problematic. I guess we could write our own type, `Expect`, that acts enough like a list for numpy, etc but still allows item and attribute access. That feels a bit crazy, but maybe it is worth it?. I still feel that all of these options are overly complicated. `e_ops` is not a list conceptually. Lists are typically ordered, but unstructured. The `e_ops` are clearly not ordered because `e_ops[0]` doesn't ""come before"" `e_ops[1]` in any meaningful way. The order of the indexes in a list `e_ops` are meaningless -- they exist only because that is how Python lists work. *Sometimes* there may be a natural ordering to e_ops -- e.g. if they happen to be the projectors onto a complete set of basis elements -- but this a small subset of the more general situation where e_ops might be any set of operators and functions. I do see that you feel lists are the most important case though, so it would be good to support them well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1142339185
https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664:68,Safety,detect,detecting,68,"@Ericgig Ready for review again. I haven't implemented anything for detecting whether an .e_op returns a number that can be averaged, and I'd like to leave that for a later PR because it's really about a better implementation of the MultiTrajResult and MultiTrajResultAveraged classes and that feels quite separate (even if it tweaks the Result class a bit more). In the `HEOMResult` class in #1869 I override `_store_state`, `_store_final_state`, `_pre_copy` and `_e_op_func` which gives quite a lot of flexibility and might be sufficient to implement `MultiTrajResult` as a sub-class of `Result`. There is also a question of whether there should be a way to supply processors directly -- either in e_ops or a separate lists. Processors are almost identical to e_ops except their values are not stored in `.expect` or `.e_data` and they don't appear in `.e_ops`. I'd like to leave that for a later (maybe never) PR too -- currently I don't have an immediate use case for it, and I don't want to expose the extra feature directly until we do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664
https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664:996,Security,expose,expose,996,"@Ericgig Ready for review again. I haven't implemented anything for detecting whether an .e_op returns a number that can be averaged, and I'd like to leave that for a later PR because it's really about a better implementation of the MultiTrajResult and MultiTrajResultAveraged classes and that feels quite separate (even if it tweaks the Result class a bit more). In the `HEOMResult` class in #1869 I override `_store_state`, `_store_final_state`, `_pre_copy` and `_e_op_func` which gives quite a lot of flexibility and might be sufficient to implement `MultiTrajResult` as a sub-class of `Result`. There is also a question of whether there should be a way to supply processors directly -- either in e_ops or a separate lists. Processors are almost identical to e_ops except their values are not stored in `.expect` or `.e_data` and they don't appear in `.e_ops`. I'd like to leave that for a later (maybe never) PR too -- currently I don't have an immediate use case for it, and I don't want to expose the extra feature directly until we do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664
https://github.com/qutip/qutip/pull/1907#issuecomment-1148785670:17,Testability,test,tests,17,"@Ericgig I added tests for storing the final state without storing the state and for normalization of kets, dms and unitaries in sesolve. Worryingly, the normalization test passes regardless of whether we have `state.shape[1] == 1` or `data.shape[1] == 1` so I am not sure if both are correct, or if there is something else wrong.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148785670
https://github.com/qutip/qutip/pull/1907#issuecomment-1148785670:168,Testability,test,test,168,"@Ericgig I added tests for storing the final state without storing the state and for normalization of kets, dms and unitaries in sesolve. Worryingly, the normalization test passes regardless of whether we have `state.shape[1] == 1` or `data.shape[1] == 1` so I am not sure if both are correct, or if there is something else wrong.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148785670
https://github.com/qutip/qutip/pull/1907#issuecomment-1148793484:8,Testability,test,test,8,"Ah, the test does not fail because I forgot to make psi0 a density matrix before passing it to sesolve. Fixing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148793484
https://github.com/qutip/qutip/pull/1907#issuecomment-1148806235:229,Availability,error,error,229,"May I propose another approach for testing normalization: use a non-hermitian Hamiltonian and `qeye` as the e_ops.; Then it is clear if the normalization step does it's work or not. Otherwise the `tol` should be very strict, the error between before and after the normalization is usually quite small. `sesolve` does not differentiate between an `unitary` and a `dm`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148806235
https://github.com/qutip/qutip/pull/1907#issuecomment-1148806235:35,Testability,test,testing,35,"May I propose another approach for testing normalization: use a non-hermitian Hamiltonian and `qeye` as the e_ops.; Then it is clear if the normalization step does it's work or not. Otherwise the `tol` should be very strict, the error between before and after the normalization is usually quite small. `sesolve` does not differentiate between an `unitary` and a `dm`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148806235
https://github.com/qutip/qutip/pull/1907#issuecomment-1148806235:127,Usability,clear,clear,127,"May I propose another approach for testing normalization: use a non-hermitian Hamiltonian and `qeye` as the e_ops.; Then it is clear if the normalization step does it's work or not. Otherwise the `tol` should be very strict, the error between before and after the normalization is usually quite small. `sesolve` does not differentiate between an `unitary` and a `dm`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148806235
https://github.com/qutip/qutip/pull/1907#issuecomment-1148925787:9,Testability,Test,Tests,9,@Ericgig Tests changed to use non-hermitian H.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148925787
https://github.com/qutip/qutip/pull/1907#issuecomment-1149052416:56,Testability,test,tests,56,@Ericgig Thanks! Suggestions committed. I will merge if tests pass.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1149052416
https://github.com/qutip/qutip/pull/1909#issuecomment-1141357026:254,Modifiability,variab,variable,254,"I was surprised to see that the color argument was added long time ago for the point methods. These were not ported to master. These changes break backwards compatibility as code that used `point_colors` will not work anymore. I wonder if this change of variable name is something we want to keep as it should be possible to keep the behavior backwards compatible AND include the new colors argument (which I think is a very necessary feature that motivated me to clean the code in master in the first place, I later realized that this was already added in dev.major).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1909#issuecomment-1141357026
https://github.com/qutip/qutip/pull/1909#issuecomment-1142282073:117,Modifiability,variab,variable,117,"I agree on leaving this PR as it is. @hodgestar, I committed your suggestions and removed the `user_color` temporary variable (was not really necessary).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1909#issuecomment-1142282073
https://github.com/qutip/qutip/issues/1910#issuecomment-1142357617:26,Integrability,interface,interface,26,"I agree that unifying the interface would be ideal for QuTiP 5.0. I was aiming to do so with Bloch and also clean-up the code on my way. For tomography, visualization and distribution, we may be able to include them in the Unitary Hack if we make a more detailed issue with the requirements (provided there is still enough room for new bounties).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1910#issuecomment-1142357617
https://github.com/qutip/qutip/issues/1913#issuecomment-1142616351:103,Integrability,interface,interface,103,"If you would like another item for the todo list, I'd really like to see the matplotlib aspects of the interface cleaned up. When we added the new lines and arcs features, we allowed passing arbitrary matplotlib plotting arguments as additional parameters. Perhaps we can do the same for the other functions and remove the old means of setting colours, etc?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1913#issuecomment-1142616351
https://github.com/qutip/qutip/issues/1913#issuecomment-1145099472:79,Integrability,interface,interface,79,"Yes, definitely! I would like to tackle that when with the item list ""Make the interface consistent ...""",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1913#issuecomment-1145099472
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:40,Availability,error,error,40,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:118,Deployability,install,installed,118,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:188,Deployability,install,installation,188,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:260,Deployability,install,installation,260,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:278,Deployability,install,installation-on-windows,278,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:321,Deployability,install,installing,321,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:388,Deployability,install,install,388,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:436,Deployability,install,installed,436,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384:46,Integrability,message,message,46,"@HarshBabla99 I'm guessing based on the error message that you are running QuTiP on Windows. Do you have a C compiler installed? The compiler is needed to compile the strings. The Windows installation instructions are outlined at https://qutip.org/docs/latest/installation.html#installation-on-windows. I would recommend installing everything using conda if you can (see higher up on the install documentation page). If the compiler is installed, perhaps it is an issue with the compiler not being present in the `PATH`. Either way, this appears to be not an issue with QuTiP itself, but let's keep this issue open for a bit so that we can help you resolve things as best we can. I would also recommend upgrading your Python, QuTiP and numpy to more recent versions if possible. If you use conda, you should get the latest versions unless you explicitly request otherwise.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1914#issuecomment-1143281384
https://github.com/qutip/qutip/issues/1915#issuecomment-1144683208:172,Deployability,install,installed,172,"I'm happy to help mitigate this in QuTiP since importing less during ""import qutip"" would be a good thing, but not being able to `import scipy.fftpack` when SciPy has been installed because it vendors the wrong `GLIBCXX` seems like a fairly serious SciPy bug?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1915#issuecomment-1144683208
https://github.com/qutip/qutip/issues/1915#issuecomment-1158105114:37,Deployability,deploy,deploy,37,This did just bite me when trying to deploy QuTiP to MyBinder for my QuTiP SciPy tutorial and I can confirm this bug is incredibly annoying.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1915#issuecomment-1158105114
https://github.com/qutip/qutip/issues/1916#issuecomment-1145859124:39,Usability,undo,undocumented,39,"I'm happy for it to be removed -- it's undocumented and fails straight away, so I doubt anyone is using it successfully.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1916#issuecomment-1145859124
https://github.com/qutip/qutip/pull/1917#issuecomment-1146096672:49,Availability,outage,outage,49,The tests fail but it looks like a short network outage that caused conda to fail to download some packages. Probably just running it again will sort it out.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1917#issuecomment-1146096672
https://github.com/qutip/qutip/pull/1917#issuecomment-1146096672:85,Availability,down,download,85,The tests fail but it looks like a short network outage that caused conda to fail to download some packages. Probably just running it again will sort it out.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1917#issuecomment-1146096672
https://github.com/qutip/qutip/pull/1917#issuecomment-1146096672:4,Testability,test,tests,4,The tests fail but it looks like a short network outage that caused conda to fail to download some packages. Probably just running it again will sort it out.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1917#issuecomment-1146096672
https://github.com/qutip/qutip/pull/1918#issuecomment-1146047389:23,Testability,test,testing,23,I added ipython to the testing workflow. Let me know if it should have been included somewhere else.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146047389
https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238:135,Integrability,depend,dependencies,135,"> I added ipython to the testing workflow. Let me know if it should have been included somewhere else. Hmm. I don't like adding random dependencies into the workflow config. On the other hand, this is specific to IPython. Maybe we can add an ""ipython"" section in `setup.cfg` and add that to `full`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238
https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238:166,Modifiability,config,config,166,"> I added ipython to the testing workflow. Let me know if it should have been included somewhere else. Hmm. I don't like adding random dependencies into the workflow config. On the other hand, this is specific to IPython. Maybe we can add an ""ipython"" section in `setup.cfg` and add that to `full`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238
https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238:25,Testability,test,testing,25,"> I added ipython to the testing workflow. Let me know if it should have been included somewhere else. Hmm. I don't like adding random dependencies into the workflow config. On the other hand, this is specific to IPython. Maybe we can add an ""ipython"" section in `setup.cfg` and add that to `full`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238
https://github.com/qutip/qutip/pull/1918#issuecomment-1152346609:37,Testability,test,test,37,I think I still needed to change the test workflow. Lets see if this works but let me know if you prefer another approach to include ipython in testing.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1152346609
https://github.com/qutip/qutip/pull/1918#issuecomment-1152346609:144,Testability,test,testing,144,I think I still needed to change the test workflow. Lets see if this works but let me know if you prefer another approach to include ipython in testing.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1152346609
https://github.com/qutip/qutip/pull/1918#issuecomment-1152412952:39,Testability,test,test,39,> I think I still needed to change the test workflow. Lets see if this works but let me know if you prefer another approach to include ipython in testing. The current approach looks good to me.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1152412952
https://github.com/qutip/qutip/pull/1918#issuecomment-1152412952:146,Testability,test,testing,146,> I think I still needed to change the test workflow. Lets see if this works but let me know if you prefer another approach to include ipython in testing. The current approach looks good to me.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1152412952
https://github.com/qutip/qutip/issues/1919#issuecomment-2178970555:45,Availability,error,error,45,"The example provided no longer produces that error when I run it. However, the error still occurs whenever I run an odd value for N. I would like to look more into this issue and try to resolve it.; ### Code Output; For N=10 `0.006061302499141838 0.006061302499140235`; For N=5 `-inf 0.004046653546081098`; For N=7 `-inf 0.004630127471444943`; For N=9 `-inf 0.005564781691231526`; ### Your Environment; ```; uTiP Version: 5.0.2; Numpy Version: 1.26.4; Scipy Version: 1.12.0; Cython Version: 3.0.10; Matplotlib Version:3.5.1; Python Version: 3.10.12; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1919#issuecomment-2178970555
https://github.com/qutip/qutip/issues/1919#issuecomment-2178970555:79,Availability,error,error,79,"The example provided no longer produces that error when I run it. However, the error still occurs whenever I run an odd value for N. I would like to look more into this issue and try to resolve it.; ### Code Output; For N=10 `0.006061302499141838 0.006061302499140235`; For N=5 `-inf 0.004046653546081098`; For N=7 `-inf 0.004630127471444943`; For N=9 `-inf 0.005564781691231526`; ### Your Environment; ```; uTiP Version: 5.0.2; Numpy Version: 1.26.4; Scipy Version: 1.12.0; Cython Version: 3.0.10; Matplotlib Version:3.5.1; Python Version: 3.10.12; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1919#issuecomment-2178970555
https://github.com/qutip/qutip/issues/1919#issuecomment-2178970555:597,Deployability,Install,Installed,597,"The example provided no longer produces that error when I run it. However, the error still occurs whenever I run an odd value for N. I would like to look more into this issue and try to resolve it.; ### Code Output; For N=10 `0.006061302499141838 0.006061302499140235`; For N=5 `-inf 0.004046653546081098`; For N=7 `-inf 0.004630127471444943`; For N=9 `-inf 0.005564781691231526`; ### Your Environment; ```; uTiP Version: 5.0.2; Numpy Version: 1.26.4; Scipy Version: 1.12.0; Cython Version: 3.0.10; Matplotlib Version:3.5.1; Python Version: 3.10.12; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1919#issuecomment-2178970555
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:230,Deployability,install,installing,230,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:271,Deployability,release,released,271,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:321,Deployability,install,install,321,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:527,Deployability,install,install,527,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:649,Deployability,release,release,649,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:696,Deployability,update,update,696,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:351,Testability,test,test,351,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:491,Testability,test,test,491,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:566,Testability,test,test,566,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:714,Testability,log,log,714,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:174,Deployability,install,install,174,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:296,Deployability,release,release,296,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:343,Deployability,update,update,343,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:455,Integrability,depend,dependency,455,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:138,Testability,test,test,138,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:213,Testability,test,test,213,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:361,Testability,log,log,361,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:610,Testability,test,tests,610,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930
https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338:127,Deployability,install,install,127,"Regarding the suggestions in the TODO list:. > Have qutip-qip be an optional dependency. I'm wondering about this. Having `pip install qutip[qip]` is nice, but what should happen with `pip install qutip[full]`? Should that also install `qutip_qip`? If not should we then leave `qutip_qip` out of `full`? And should we have `qutip[full-family]`?. > Add installation of qutip-qip to the CI workflow. This we should not do -- we don't want anything in core qutip to accidentally require qutip_qip (that was sort of the point of the family packages).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338
https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338:189,Deployability,install,install,189,"Regarding the suggestions in the TODO list:. > Have qutip-qip be an optional dependency. I'm wondering about this. Having `pip install qutip[qip]` is nice, but what should happen with `pip install qutip[full]`? Should that also install `qutip_qip`? If not should we then leave `qutip_qip` out of `full`? And should we have `qutip[full-family]`?. > Add installation of qutip-qip to the CI workflow. This we should not do -- we don't want anything in core qutip to accidentally require qutip_qip (that was sort of the point of the family packages).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338
https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338:228,Deployability,install,install,228,"Regarding the suggestions in the TODO list:. > Have qutip-qip be an optional dependency. I'm wondering about this. Having `pip install qutip[qip]` is nice, but what should happen with `pip install qutip[full]`? Should that also install `qutip_qip`? If not should we then leave `qutip_qip` out of `full`? And should we have `qutip[full-family]`?. > Add installation of qutip-qip to the CI workflow. This we should not do -- we don't want anything in core qutip to accidentally require qutip_qip (that was sort of the point of the family packages).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338
https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338:352,Deployability,install,installation,352,"Regarding the suggestions in the TODO list:. > Have qutip-qip be an optional dependency. I'm wondering about this. Having `pip install qutip[qip]` is nice, but what should happen with `pip install qutip[full]`? Should that also install `qutip_qip`? If not should we then leave `qutip_qip` out of `full`? And should we have `qutip[full-family]`?. > Add installation of qutip-qip to the CI workflow. This we should not do -- we don't want anything in core qutip to accidentally require qutip_qip (that was sort of the point of the family packages).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338
https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338:77,Integrability,depend,dependency,77,"Regarding the suggestions in the TODO list:. > Have qutip-qip be an optional dependency. I'm wondering about this. Having `pip install qutip[qip]` is nice, but what should happen with `pip install qutip[full]`? Should that also install `qutip_qip`? If not should we then leave `qutip_qip` out of `full`? And should we have `qutip[full-family]`?. > Add installation of qutip-qip to the CI workflow. This we should not do -- we don't want anything in core qutip to accidentally require qutip_qip (that was sort of the point of the family packages).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147715338
https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698:39,Deployability,install,install,39,"> I'm wondering about this. Having pip install qutip[qip] is nice, but what should happen with pip install qutip[full]? Should that also install qutip_qip? If not should we then leave qutip_qip out of full? And should we have qutip[full-family]?. I understand `[full]` as ""installing everything that might be needed so that I can run everything without any ImportError"". So this means that it includes `[qip]`. However, I do get your concern that this will probably make the option `[full]` larger and larger in the future. Nonetheless, since there is not yet a released `qutip-qip` that supports qutip-5. Let's leave it to a different PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698
https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698:99,Deployability,install,install,99,"> I'm wondering about this. Having pip install qutip[qip] is nice, but what should happen with pip install qutip[full]? Should that also install qutip_qip? If not should we then leave qutip_qip out of full? And should we have qutip[full-family]?. I understand `[full]` as ""installing everything that might be needed so that I can run everything without any ImportError"". So this means that it includes `[qip]`. However, I do get your concern that this will probably make the option `[full]` larger and larger in the future. Nonetheless, since there is not yet a released `qutip-qip` that supports qutip-5. Let's leave it to a different PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698
https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698:137,Deployability,install,install,137,"> I'm wondering about this. Having pip install qutip[qip] is nice, but what should happen with pip install qutip[full]? Should that also install qutip_qip? If not should we then leave qutip_qip out of full? And should we have qutip[full-family]?. I understand `[full]` as ""installing everything that might be needed so that I can run everything without any ImportError"". So this means that it includes `[qip]`. However, I do get your concern that this will probably make the option `[full]` larger and larger in the future. Nonetheless, since there is not yet a released `qutip-qip` that supports qutip-5. Let's leave it to a different PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698
https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698:273,Deployability,install,installing,273,"> I'm wondering about this. Having pip install qutip[qip] is nice, but what should happen with pip install qutip[full]? Should that also install qutip_qip? If not should we then leave qutip_qip out of full? And should we have qutip[full-family]?. I understand `[full]` as ""installing everything that might be needed so that I can run everything without any ImportError"". So this means that it includes `[qip]`. However, I do get your concern that this will probably make the option `[full]` larger and larger in the future. Nonetheless, since there is not yet a released `qutip-qip` that supports qutip-5. Let's leave it to a different PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698
https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698:562,Deployability,release,released,562,"> I'm wondering about this. Having pip install qutip[qip] is nice, but what should happen with pip install qutip[full]? Should that also install qutip_qip? If not should we then leave qutip_qip out of full? And should we have qutip[full-family]?. I understand `[full]` as ""installing everything that might be needed so that I can run everything without any ImportError"". So this means that it includes `[qip]`. However, I do get your concern that this will probably make the option `[full]` larger and larger in the future. Nonetheless, since there is not yet a released `qutip-qip` that supports qutip-5. Let's leave it to a different PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147918698
https://github.com/qutip/qutip/pull/1920#issuecomment-1147993680:28,Deployability,install,installing,28,"> I understand `[full]` as ""installing everything that might be needed so that I can run everything without any ImportError"". So this means that it includes `[qip]`. However, I do get your concern that this will probably make the option `[full]` larger and larger in the future. Perhaps installing `qutip_qip` as part of `full` is a good first step. It means that QuTiP 5 will just ""work"" as it did before and we can always remove it from `full` in QuTiP 5.1 or later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147993680
https://github.com/qutip/qutip/pull/1920#issuecomment-1147993680:287,Deployability,install,installing,287,"> I understand `[full]` as ""installing everything that might be needed so that I can run everything without any ImportError"". So this means that it includes `[qip]`. However, I do get your concern that this will probably make the option `[full]` larger and larger in the future. Perhaps installing `qutip_qip` as part of `full` is a good first step. It means that QuTiP 5 will just ""work"" as it did before and we can always remove it from `full` in QuTiP 5.1 or later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147993680
https://github.com/qutip/qutip/pull/1920#issuecomment-1150044489:124,Testability,test,tests,124,"@BoxiLi I'd like you to approve to since this is a very important link to `qutip_qip`. Once we have Boxi's approval and the tests pass, I think we can consider this done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1150044489
https://github.com/qutip/qutip/pull/1925#issuecomment-1152508955:120,Availability,down,down,120,CodeClimate reported a bunch of places where line lengths were increased to exceed 79 characters. Could we reduce those down again if possible? Maybe do this at the end so that it's not too hard to review the reformatting.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1925#issuecomment-1152508955
https://github.com/qutip/qutip/pull/1925#issuecomment-1152508955:107,Energy Efficiency,reduce,reduce,107,CodeClimate reported a bunch of places where line lengths were increased to exceed 79 characters. Could we reduce those down again if possible? Maybe do this at the end so that it's not too hard to review the reformatting.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1925#issuecomment-1152508955
https://github.com/qutip/qutip/pull/1926#issuecomment-1151371449:210,Deployability,install,install,210,[![Coverage Status](https://coveralls.io/builds/49888682/badge)](https://coveralls.io/builds/49888682). Coverage increased (+0.01%) to 65.507% when pulling **273803aa68ccccb848933ef7536af43dc7b4abe5 on Ericgig:install.fix** into **781d58c9062fcea0b7cbacf4eaaf437adf01b274 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1926#issuecomment-1151371449
https://github.com/qutip/qutip/pull/1927#issuecomment-1154143770:147,Testability,test,test,147,"Is there a way to set towncrier to not require the PR number?; Otherwise we need to open a PR without the changelog, which will fail the towncrier test, to modify it to add the change log...; It would a lot better if we could add it when developing or have a towncrier read it from the Changelog section of PR description.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1154143770
https://github.com/qutip/qutip/pull/1927#issuecomment-1154143770:184,Testability,log,log,184,"Is there a way to set towncrier to not require the PR number?; Otherwise we need to open a PR without the changelog, which will fail the towncrier test, to modify it to add the change log...; It would a lot better if we could add it when developing or have a towncrier read it from the Changelog section of PR description.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1154143770
https://github.com/qutip/qutip/pull/1927#issuecomment-1154193144:159,Testability,test,test,159,"@Ericgig ; > Is there a way to set towncrier to not require the PR number? Otherwise we need to open a PR without the changelog, which will fail the towncrier test, to modify it to add the change log... It would a lot better if we could add it when developing or have a towncrier read it from the Changelog section of PR description. Yes, I think we could use the issue number that the change is for, if this workflow makes sense for QuTiP (I don't know, I'm a first-time contributor). This is what [pytest does](https://github.com/pytest-dev/pytest/blob/main/CONTRIBUTING.rst#preparing-pull-requests).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1154193144
https://github.com/qutip/qutip/pull/1927#issuecomment-1154193144:196,Testability,log,log,196,"@Ericgig ; > Is there a way to set towncrier to not require the PR number? Otherwise we need to open a PR without the changelog, which will fail the towncrier test, to modify it to add the change log... It would a lot better if we could add it when developing or have a towncrier read it from the Changelog section of PR description. Yes, I think we could use the issue number that the change is for, if this workflow makes sense for QuTiP (I don't know, I'm a first-time contributor). This is what [pytest does](https://github.com/pytest-dev/pytest/blob/main/CONTRIBUTING.rst#preparing-pull-requests).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1154193144
https://github.com/qutip/qutip/pull/1927#issuecomment-1155008517:124,Deployability,update,update,124,"We currently link to the PR in the changelog text, and that that seems a good thing to keep, so we already have to write or update the text after the PR is created. I'm a bit against pulling information from the PR description. My observation is that the descriptions (even my own) are not very good, because they're written when the PR is just opened, before all of the improvements that happen during review. @trentfridey Does the PR number have to appear in the filename or confer any special advantages? Or can one just use a meaningful unique name for the file? E.g. `fix-20220614-add-towncrier`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1155008517
https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155:34,Deployability,configurat,configuration,34,"Ok, so I tweaked the template and configuration for towncrier so that it doesn't render an issue/PR number next to each changelog entry. This frees you from requiring an issue / PR number when writing a news fragment. ; @hodgestar yes I think with this configuration you can just use any unique string for the filename.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155
https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155:253,Deployability,configurat,configuration,253,"Ok, so I tweaked the template and configuration for towncrier so that it doesn't render an issue/PR number next to each changelog entry. This frees you from requiring an issue / PR number when writing a news fragment. ; @hodgestar yes I think with this configuration you can just use any unique string for the filename.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155
https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155:34,Modifiability,config,configuration,34,"Ok, so I tweaked the template and configuration for towncrier so that it doesn't render an issue/PR number next to each changelog entry. This frees you from requiring an issue / PR number when writing a news fragment. ; @hodgestar yes I think with this configuration you can just use any unique string for the filename.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155
https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155:253,Modifiability,config,configuration,253,"Ok, so I tweaked the template and configuration for towncrier so that it doesn't render an issue/PR number next to each changelog entry. This frees you from requiring an issue / PR number when writing a news fragment. ; @hodgestar yes I think with this configuration you can just use any unique string for the filename.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155
https://github.com/qutip/qutip/pull/1927#issuecomment-1158111426:245,Usability,simpl,simpler,245,"@Ericgig @AGaliciaMartinez I've approved this PR and I'd like to merge it once @trentfridey has fixed the ""Verify Towncrier entry added"". I actually preferred the situation before @trentfridey removed the requirement for the PR number -- it was simpler and didn't rely on us to remember to write those numbers into the changelog. For UnitaryHack, I think we have to merge it before the end of tomorrow for it to count, and I'd like to do that since it's a big improvement and now probably we just need to try it and tweak how it is set up if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1158111426
https://github.com/qutip/qutip/pull/1927#issuecomment-1158769418:35,Availability,error,error,35,"@trentfridey, there seems to be an error in the newly added towncrier github workflow that needs to be fixed before merging. Would you mind taking a look?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1158769418
https://github.com/qutip/qutip/pull/1927#issuecomment-1159098604:132,Deployability,release,release,132,"I don't want to approve or block it.; I can't understand the template so I don't know if the generated changelog will be useful for release.; And the tests don't pass... Personally the issue number as the tag looks good to me. Yes we have many PRs without issues, but it may be a good idea to open them just to tell other what we are working on and it's easier for first time contributor who take a `good first issue`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159098604
https://github.com/qutip/qutip/pull/1927#issuecomment-1159098604:150,Testability,test,tests,150,"I don't want to approve or block it.; I can't understand the template so I don't know if the generated changelog will be useful for release.; And the tests don't pass... Personally the issue number as the tag looks good to me. Yes we have many PRs without issues, but it may be a good idea to open them just to tell other what we are working on and it's easier for first time contributor who take a `good first issue`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159098604
https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537:79,Deployability,update,updated,79,"Ok, I've reverted to using the PR number for the news fragment file names, and updated the contributing/PR instructions. I also looked into why the `towncrier-check` test is failing. It looks like towncrier is not finding the `pyproject.toml` config file because it is not running in the root directory. I added a `working-directory: /` specification to the action step to address this, hopefully this should fix it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537
https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537:243,Modifiability,config,config,243,"Ok, I've reverted to using the PR number for the news fragment file names, and updated the contributing/PR instructions. I also looked into why the `towncrier-check` test is failing. It looks like towncrier is not finding the `pyproject.toml` config file because it is not running in the root directory. I added a `working-directory: /` specification to the action step to address this, hopefully this should fix it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537
https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537:166,Testability,test,test,166,"Ok, I've reverted to using the PR number for the news fragment file names, and updated the contributing/PR instructions. I also looked into why the `towncrier-check` test is failing. It looks like towncrier is not finding the `pyproject.toml` config file because it is not running in the root directory. I added a `working-directory: /` specification to the action step to address this, hopefully this should fix it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537
https://github.com/qutip/qutip/pull/1927#issuecomment-1166314030:623,Integrability,Message,Message,623,"I just signed up. Let me know if you need anything else. On Sat, Jun 25, 2022, 6:12 AM Nathan Shammah ***@***.***>; wrote:. > @trentfridey <https://github.com/trentfridey> we cannot find your contact; > details on unitaryHACK, please sign up; > https://airtable.com/shrJeycewBFqdot2B to be able to claim your bounty!; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/1927#issuecomment-1166247981>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AC4OOFYJ47HU6VQVYITDIULVQ3LQ3ANCNFSM5YMIBCDQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1166314030
https://github.com/qutip/qutip/issues/1928#issuecomment-1153908260:45,Integrability,depend,dependent,45,"Dicke class does not support list based time-dependent Hamiltonian.; But if the Hamiltonian is a `QobjEvo`, it should work: `qutip.piqs.Dicke(N, hamiltonian=qutip.QobjEvo(H_td), emission=...)`; Otherwise you can use the Dicke class to compute the dissipation part and use `mesolve`:; ```; dicke = qutip.piqs.Dicke(N, hamiltonian=None, emission=...); qutip.mesolve(H_td, ..., c_ops =dicke.liouvillian()); ```; For more help, please use the google groupe: https://groups.google.com/g/qutip.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1928#issuecomment-1153908260
https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129:146,Availability,error,error,146,"Thanks victor! My main worry as it stands is that, as I mentioned in the previous issue, this fix, on its own, introduces an unwanted additional error for the case with a time-dependent Hamiltonian, as then that time dependence essentially gets shifted twice, once by the H_shifted change, and once again by adding tlist[idx] to tau_list. ; This case of a time-dependent H could do with a test as well I guess. . This can be easily remedied by completely omitting the old method of shifting the time-dependence (e.g., using H and c_ops instead of H_shifted and c_ops_shifted in the call to mesolve(), for example).  But I am a little concerned that the the old method of shifting the time-dependence in H_shifted and C_ops_shifted was there for a reason. @Ericgig any thoughts?. As an aside, I guess _correlation_mc_2t() also needs a fix, but maybe better to do that in a separate issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129
https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129:177,Integrability,depend,dependent,177,"Thanks victor! My main worry as it stands is that, as I mentioned in the previous issue, this fix, on its own, introduces an unwanted additional error for the case with a time-dependent Hamiltonian, as then that time dependence essentially gets shifted twice, once by the H_shifted change, and once again by adding tlist[idx] to tau_list. ; This case of a time-dependent H could do with a test as well I guess. . This can be easily remedied by completely omitting the old method of shifting the time-dependence (e.g., using H and c_ops instead of H_shifted and c_ops_shifted in the call to mesolve(), for example).  But I am a little concerned that the the old method of shifting the time-dependence in H_shifted and C_ops_shifted was there for a reason. @Ericgig any thoughts?. As an aside, I guess _correlation_mc_2t() also needs a fix, but maybe better to do that in a separate issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129
https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129:218,Integrability,depend,dependence,218,"Thanks victor! My main worry as it stands is that, as I mentioned in the previous issue, this fix, on its own, introduces an unwanted additional error for the case with a time-dependent Hamiltonian, as then that time dependence essentially gets shifted twice, once by the H_shifted change, and once again by adding tlist[idx] to tau_list. ; This case of a time-dependent H could do with a test as well I guess. . This can be easily remedied by completely omitting the old method of shifting the time-dependence (e.g., using H and c_ops instead of H_shifted and c_ops_shifted in the call to mesolve(), for example).  But I am a little concerned that the the old method of shifting the time-dependence in H_shifted and C_ops_shifted was there for a reason. @Ericgig any thoughts?. As an aside, I guess _correlation_mc_2t() also needs a fix, but maybe better to do that in a separate issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129
https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129:362,Integrability,depend,dependent,362,"Thanks victor! My main worry as it stands is that, as I mentioned in the previous issue, this fix, on its own, introduces an unwanted additional error for the case with a time-dependent Hamiltonian, as then that time dependence essentially gets shifted twice, once by the H_shifted change, and once again by adding tlist[idx] to tau_list. ; This case of a time-dependent H could do with a test as well I guess. . This can be easily remedied by completely omitting the old method of shifting the time-dependence (e.g., using H and c_ops instead of H_shifted and c_ops_shifted in the call to mesolve(), for example).  But I am a little concerned that the the old method of shifting the time-dependence in H_shifted and C_ops_shifted was there for a reason. @Ericgig any thoughts?. As an aside, I guess _correlation_mc_2t() also needs a fix, but maybe better to do that in a separate issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129
https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129:501,Integrability,depend,dependence,501,"Thanks victor! My main worry as it stands is that, as I mentioned in the previous issue, this fix, on its own, introduces an unwanted additional error for the case with a time-dependent Hamiltonian, as then that time dependence essentially gets shifted twice, once by the H_shifted change, and once again by adding tlist[idx] to tau_list. ; This case of a time-dependent H could do with a test as well I guess. . This can be easily remedied by completely omitting the old method of shifting the time-dependence (e.g., using H and c_ops instead of H_shifted and c_ops_shifted in the call to mesolve(), for example).  But I am a little concerned that the the old method of shifting the time-dependence in H_shifted and C_ops_shifted was there for a reason. @Ericgig any thoughts?. As an aside, I guess _correlation_mc_2t() also needs a fix, but maybe better to do that in a separate issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129
https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129:692,Integrability,depend,dependence,692,"Thanks victor! My main worry as it stands is that, as I mentioned in the previous issue, this fix, on its own, introduces an unwanted additional error for the case with a time-dependent Hamiltonian, as then that time dependence essentially gets shifted twice, once by the H_shifted change, and once again by adding tlist[idx] to tau_list. ; This case of a time-dependent H could do with a test as well I guess. . This can be easily remedied by completely omitting the old method of shifting the time-dependence (e.g., using H and c_ops instead of H_shifted and c_ops_shifted in the call to mesolve(), for example).  But I am a little concerned that the the old method of shifting the time-dependence in H_shifted and C_ops_shifted was there for a reason. @Ericgig any thoughts?. As an aside, I guess _correlation_mc_2t() also needs a fix, but maybe better to do that in a separate issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129
https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129:390,Testability,test,test,390,"Thanks victor! My main worry as it stands is that, as I mentioned in the previous issue, this fix, on its own, introduces an unwanted additional error for the case with a time-dependent Hamiltonian, as then that time dependence essentially gets shifted twice, once by the H_shifted change, and once again by adding tlist[idx] to tau_list. ; This case of a time-dependent H could do with a test as well I guess. . This can be easily remedied by completely omitting the old method of shifting the time-dependence (e.g., using H and c_ops instead of H_shifted and c_ops_shifted in the call to mesolve(), for example).  But I am a little concerned that the the old method of shifting the time-dependence in H_shifted and C_ops_shifted was there for a reason. @Ericgig any thoughts?. As an aside, I guess _correlation_mc_2t() also needs a fix, but maybe better to do that in a separate issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153462129
https://github.com/qutip/qutip/pull/1929#issuecomment-1153723802:250,Safety,avoid,avoid,250,"@victor-onofre Thank you for looking at this! I think it's important to address @nwlambert's concerns once @Ericgig has had a look. Note: Issue #1808 isn't part of the current Unitaryhack, so I am removing the ""[unitaryhack]"" from the issue title to avoid confusion.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153723802
https://github.com/qutip/qutip/pull/1929#issuecomment-1153946989:375,Testability,test,tested,375,"I agree with @nwlambert that we should go without shifted object and simply add the shift in the times.; This shift method predate me, but I believe at some time solve would not work properly if not started at `0`...; But this should have been fixed a while ago. @victor-onofre, would you also remove the shifted operator, this should be right.; Also the `tlist` type is not tested and it could be a list instead of an array.; Ideally the same fixes should be made to `_correlation_mc_2t`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153946989
https://github.com/qutip/qutip/pull/1929#issuecomment-1153946989:69,Usability,simpl,simply,69,"I agree with @nwlambert that we should go without shifted object and simply add the shift in the times.; This shift method predate me, but I believe at some time solve would not work properly if not started at `0`...; But this should have been fixed a while ago. @victor-onofre, would you also remove the shifted operator, this should be right.; Also the `tlist` type is not tested and it could be a list instead of an array.; Ideally the same fixes should be made to `_correlation_mc_2t`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153946989
https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964:37,Availability,error,error,37,"@haoyudoingthings It looks from your error messages that they are caused not by the import cells, but by later cells, and are the result of having modified the notebook. For example, `H = qt.qobj_list_evaluate(h_t, tau, args)` is a modified line from cell 13 of the original notebook. I would suggest starting again from the original notebook and continuing from there. Some of the notebooks are out of date. We're setting up automated tests to correct that as part of this year's Google Summer of Code, but that has only just started so it might be a few months before we have everything set up. I'm closing this for now, but please feel free to update the issue if you encounter more problems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964
https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964:647,Deployability,update,update,647,"@haoyudoingthings It looks from your error messages that they are caused not by the import cells, but by later cells, and are the result of having modified the notebook. For example, `H = qt.qobj_list_evaluate(h_t, tau, args)` is a modified line from cell 13 of the original notebook. I would suggest starting again from the original notebook and continuing from there. Some of the notebooks are out of date. We're setting up automated tests to correct that as part of this year's Google Summer of Code, but that has only just started so it might be a few months before we have everything set up. I'm closing this for now, but please feel free to update the issue if you encounter more problems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964
https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964:43,Integrability,message,messages,43,"@haoyudoingthings It looks from your error messages that they are caused not by the import cells, but by later cells, and are the result of having modified the notebook. For example, `H = qt.qobj_list_evaluate(h_t, tau, args)` is a modified line from cell 13 of the original notebook. I would suggest starting again from the original notebook and continuing from there. Some of the notebooks are out of date. We're setting up automated tests to correct that as part of this year's Google Summer of Code, but that has only just started so it might be a few months before we have everything set up. I'm closing this for now, but please feel free to update the issue if you encounter more problems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964
https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964:436,Testability,test,tests,436,"@haoyudoingthings It looks from your error messages that they are caused not by the import cells, but by later cells, and are the result of having modified the notebook. For example, `H = qt.qobj_list_evaluate(h_t, tau, args)` is a modified line from cell 13 of the original notebook. I would suggest starting again from the original notebook and continuing from there. Some of the notebooks are out of date. We're setting up automated tests to correct that as part of this year's Google Summer of Code, but that has only just started so it might be a few months before we have everything set up. I'm closing this for now, but please feel free to update the issue if you encounter more problems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964
https://github.com/qutip/qutip/issues/1935#issuecomment-1156499606:127,Usability,guid,guide,127,"For these kind of problems, you should use `smesolve`, you can see what equation it solve [here](https://qutip.org/docs/latest/guide/dynamics/dynamics-stochastic.html#stochastic-master-equation). `general_stochastic` should be used only in last resort. While it allow to use the stochastic solver mechanic with your own functions, it use the same options and mix of `Qobj`, `Qobj.data` and `array`, etc., without the layer to glue everything together... Here, the issue is that it use the same options as `ssesolve` and `smesolve`, which per default normalize the state before computing the expectation values, but do not know that it's supposed to be an density matrix, thus normalizing the state as if it was a ket... You can pass `normalize=False` to `general_stochastic` to obtain results closer to `mesolve`, but I would recommend not to use `general_stochastic` in the state it is now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1935#issuecomment-1156499606
https://github.com/qutip/qutip/pull/1940#issuecomment-1168835644:22,Testability,test,tests,22,"All the documentation tests have passed, so merging.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1940#issuecomment-1168835644
https://github.com/qutip/qutip/pull/1940#issuecomment-1168876318:201,Integrability,depend,dependabot,201,[![Coverage Status](https://coveralls.io/builds/50428231/badge)](https://coveralls.io/builds/50428231). Coverage remained the same at 69.935% when pulling **0fc3959863deb2276ba438402ce736f9526f7273 on dependabot/pip/doc/numpy-1.22.0** into **74257755d87259b94caae3dc352e3ff55930e0c1 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1940#issuecomment-1168876318
https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067:15,Deployability,update,update,15,"Should we also update the setup.cfg file with the latest version of numpy and python employed in tests? Allowing the installation of previous numpy versions that are not included in the CI may lead unanticipated bugs. Is there any reason to allow older versions of numpy in the setup.cfg (currently `numpy>=1.16"") instead of matching those with the versions used for testing?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067
https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067:117,Deployability,install,installation,117,"Should we also update the setup.cfg file with the latest version of numpy and python employed in tests? Allowing the installation of previous numpy versions that are not included in the CI may lead unanticipated bugs. Is there any reason to allow older versions of numpy in the setup.cfg (currently `numpy>=1.16"") instead of matching those with the versions used for testing?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067
https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067:97,Testability,test,tests,97,"Should we also update the setup.cfg file with the latest version of numpy and python employed in tests? Allowing the installation of previous numpy versions that are not included in the CI may lead unanticipated bugs. Is there any reason to allow older versions of numpy in the setup.cfg (currently `numpy>=1.16"") instead of matching those with the versions used for testing?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067
https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067:367,Testability,test,testing,367,"Should we also update the setup.cfg file with the latest version of numpy and python employed in tests? Allowing the installation of previous numpy versions that are not included in the CI may lead unanticipated bugs. Is there any reason to allow older versions of numpy in the setup.cfg (currently `numpy>=1.16"") instead of matching those with the versions used for testing?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163372067
https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152:140,Deployability,update,update,140,"We already don't match our requirement with tests. We require scipy 1.0 but test for >=1.4. Same for numpy, we tests for >=1.20.; We should update it before making the release. ; But we will still build with oldest-supported-numpy so it may not be inline with the tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152
https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152:168,Deployability,release,release,168,"We already don't match our requirement with tests. We require scipy 1.0 but test for >=1.4. Same for numpy, we tests for >=1.20.; We should update it before making the release. ; But we will still build with oldest-supported-numpy so it may not be inline with the tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152
https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152:44,Testability,test,tests,44,"We already don't match our requirement with tests. We require scipy 1.0 but test for >=1.4. Same for numpy, we tests for >=1.20.; We should update it before making the release. ; But we will still build with oldest-supported-numpy so it may not be inline with the tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152
https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152:76,Testability,test,test,76,"We already don't match our requirement with tests. We require scipy 1.0 but test for >=1.4. Same for numpy, we tests for >=1.20.; We should update it before making the release. ; But we will still build with oldest-supported-numpy so it may not be inline with the tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152
https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152:111,Testability,test,tests,111,"We already don't match our requirement with tests. We require scipy 1.0 but test for >=1.4. Same for numpy, we tests for >=1.20.; We should update it before making the release. ; But we will still build with oldest-supported-numpy so it may not be inline with the tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152
https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152:264,Testability,test,tests,264,"We already don't match our requirement with tests. We require scipy 1.0 but test for >=1.4. Same for numpy, we tests for >=1.20.; We should update it before making the release. ; But we will still build with oldest-supported-numpy so it may not be inline with the tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1163446152
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:1279,Availability,down,down,1279,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:411,Deployability,install,installation,411,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:487,Deployability,update,update,487,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:63,Testability,test,test,63,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:661,Testability,test,test,661,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:784,Testability,test,test,784,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:927,Testability,test,test,927,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:1026,Testability,test,test,1026,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182:1289,Testability,test,test,1289,"I've been thinking about how this interacts with our build and test infrastructure, and I'm writing some of those thoughts here partly for myself:. - We currently build with oldest-supported-numpy, and we want to keep that because which is the earliest supported numpy varies by Python version and operating system and changes over time, so it's good if someone else worries about that for us. - We require for installation currently numpy >= 1.16.6 and that is probably what we want to update to match the NEP. There is a question here of whether we should specify our minimum supported numpy in ""install_requires"" in ""setup.cfg"" or not. - The majority of our test matrix should *build* qutip with oldest-supported-numpy to match what we distribute. - We should include at least one test run for the oldest numpy we require (i.e. oldest NEP) and one for the most recent (i.e. latest numpy). . - We should include at least one test run for the oldest Python we support and one for the newest. - We should include at least one test run for the oldest SciPy we support and one for the newest. - The NEP doesn't say anything about SciPy, but I propose we select the oldest SciPy that supports our oldest NEP numpy. And as Asier suggested, I think it would be good to write this all down. The test matrix requirements could just be a big comment in the GitHub action file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1941#issuecomment-1165714182
https://github.com/qutip/qutip/pull/1943#issuecomment-1166512776:356,Deployability,install,install,356,"Thanks @eendebakpt for the fix! ; However, a similar fix was already included in dev.major in #1918. The only difference with your approach is that I did not include a try expect for import of iPython because the relevant change for the print_figure function was done 8 years ago. Besides, there is also the issue that currently our tests workflows do not install ipython so `repr` in your tests will not call `_repr_svg_`. Sorry I did not include this fix in master as well, but if you want it to be fixed I recommend cherry-picking the commits of #1918.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1166512776
https://github.com/qutip/qutip/pull/1943#issuecomment-1166512776:333,Testability,test,tests,333,"Thanks @eendebakpt for the fix! ; However, a similar fix was already included in dev.major in #1918. The only difference with your approach is that I did not include a try expect for import of iPython because the relevant change for the print_figure function was done 8 years ago. Besides, there is also the issue that currently our tests workflows do not install ipython so `repr` in your tests will not call `_repr_svg_`. Sorry I did not include this fix in master as well, but if you want it to be fixed I recommend cherry-picking the commits of #1918.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1166512776
https://github.com/qutip/qutip/pull/1943#issuecomment-1166512776:390,Testability,test,tests,390,"Thanks @eendebakpt for the fix! ; However, a similar fix was already included in dev.major in #1918. The only difference with your approach is that I did not include a try expect for import of iPython because the relevant change for the print_figure function was done 8 years ago. Besides, there is also the issue that currently our tests workflows do not install ipython so `repr` in your tests will not call `_repr_svg_`. Sorry I did not include this fix in master as well, but if you want it to be fixed I recommend cherry-picking the commits of #1918.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1166512776
https://github.com/qutip/qutip/pull/1943#issuecomment-1166623619:309,Usability,clear,clear,309,"@AGaliciaMartinez What exactly is this `dev.major` branch? . `dev.major` diverged from the qutip `master` quite a lot.; I could not find anything relevant on https://qutip.org/docs/latest/development/contributing.html. The only thing I could find is https://github.com/qutip/qutip/milestone/18, but it is not clear what the timeline is for that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1166623619
https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150:201,Deployability,release,release,201,"> What exactly is this `dev.major` branch?. Hi @eendebakpt. `dev.major` is the branch in which we are developing QuTiP version 5. We're still doing important fixes for 4.7.1, but we're not planning to release any more feature for the 4.X series (although *maybe* that could change -- we'll see how the move to 5 goes). I'll update the contributing guidelines to mention QuTiP 5. QuTiP 5 has been in the works for a long time, but we're now in the ""cleaning things up"" phase, and hope to release an alpha version in the next month or so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150
https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150:324,Deployability,update,update,324,"> What exactly is this `dev.major` branch?. Hi @eendebakpt. `dev.major` is the branch in which we are developing QuTiP version 5. We're still doing important fixes for 4.7.1, but we're not planning to release any more feature for the 4.X series (although *maybe* that could change -- we'll see how the move to 5 goes). I'll update the contributing guidelines to mention QuTiP 5. QuTiP 5 has been in the works for a long time, but we're now in the ""cleaning things up"" phase, and hope to release an alpha version in the next month or so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150
https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150:487,Deployability,release,release,487,"> What exactly is this `dev.major` branch?. Hi @eendebakpt. `dev.major` is the branch in which we are developing QuTiP version 5. We're still doing important fixes for 4.7.1, but we're not planning to release any more feature for the 4.X series (although *maybe* that could change -- we'll see how the move to 5 goes). I'll update the contributing guidelines to mention QuTiP 5. QuTiP 5 has been in the works for a long time, but we're now in the ""cleaning things up"" phase, and hope to release an alpha version in the next month or so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150
https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150:348,Usability,guid,guidelines,348,"> What exactly is this `dev.major` branch?. Hi @eendebakpt. `dev.major` is the branch in which we are developing QuTiP version 5. We're still doing important fixes for 4.7.1, but we're not planning to release any more feature for the 4.X series (although *maybe* that could change -- we'll see how the move to 5 goes). I'll update the contributing guidelines to mention QuTiP 5. QuTiP 5 has been in the works for a long time, but we're now in the ""cleaning things up"" phase, and hope to release an alpha version in the next month or so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1943#issuecomment-1168823150
https://github.com/qutip/qutip/issues/1944#issuecomment-1165721180:226,Usability,guid,guide,226,"Hi @eendebakpt ,; the link you provided refers to an old version of the docs for QuTiP Version 4.0.2.; You can find the documentation for the unitary evolution of the current QuTiP version here: [https://qutip.org/docs/latest/guide/dynamics/dynamics-master.html#unitary-evolution](https://qutip.org/docs/latest/guide/dynamics/dynamics-master.html#unitary-evolution). The code in the latest docs seems to be correct: ; `np.linspace(0.0, 10.0, 20)`. I suggest to close this issue!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1944#issuecomment-1165721180
https://github.com/qutip/qutip/issues/1944#issuecomment-1165721180:311,Usability,guid,guide,311,"Hi @eendebakpt ,; the link you provided refers to an old version of the docs for QuTiP Version 4.0.2.; You can find the documentation for the unitary evolution of the current QuTiP version here: [https://qutip.org/docs/latest/guide/dynamics/dynamics-master.html#unitary-evolution](https://qutip.org/docs/latest/guide/dynamics/dynamics-master.html#unitary-evolution). The code in the latest docs seems to be correct: ; `np.linspace(0.0, 10.0, 20)`. I suggest to close this issue!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1944#issuecomment-1165721180
https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566:122,Energy Efficiency,adapt,adaptive,122,"The reason is the same as for https://github.com/qutip/qutip/issues/1265. The pulse starts with 0 for a long time and the adaptive solver skips the real part of the pulse. You need to set `max_step` in `qutip.Options`. You can see this by setting a very small but none-zero value:; ```python; def func(t, *args):; omega_R = 2e-3; if t <100:; return 0.00001; elif t>600:; return 0.00001; else:; return 2*np.pi*omega_R; ```; The result is correct. I'll close it for now but please feel free to ask further questions if there are any.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566
https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566:122,Modifiability,adapt,adaptive,122,"The reason is the same as for https://github.com/qutip/qutip/issues/1265. The pulse starts with 0 for a long time and the adaptive solver skips the real part of the pulse. You need to set `max_step` in `qutip.Options`. You can see this by setting a very small but none-zero value:; ```python; def func(t, *args):; omega_R = 2e-3; if t <100:; return 0.00001; elif t>600:; return 0.00001; else:; return 2*np.pi*omega_R; ```; The result is correct. I'll close it for now but please feel free to ask further questions if there are any.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566
https://github.com/qutip/qutip/issues/1945#issuecomment-1168820859:319,Availability,avail,available,319,"Not in that way. `0` is the right value when the system is constant or the time dependence is always active (`sin(w*t)`, `exp(-t)`, etc.) In these case, it is best to let the solver decide the right step length. Also pulse shorter that 5% of `tlist` could still be missed. Lastly. in some cases, the `tlist` may not be available to the solver. We certainly need to be better documentation of this. Maybe a notebook showing this trap could be useful. But without being able to look into the coefficient, I don't see an easy fix.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1945#issuecomment-1168820859
https://github.com/qutip/qutip/issues/1945#issuecomment-1168820859:80,Integrability,depend,dependence,80,"Not in that way. `0` is the right value when the system is constant or the time dependence is always active (`sin(w*t)`, `exp(-t)`, etc.) In these case, it is best to let the solver decide the right step length. Also pulse shorter that 5% of `tlist` could still be missed. Lastly. in some cases, the `tlist` may not be available to the solver. We certainly need to be better documentation of this. Maybe a notebook showing this trap could be useful. But without being able to look into the coefficient, I don't see an easy fix.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1945#issuecomment-1168820859
https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480:59,Deployability,configurat,configuration,59,"I discovered that we were missing a small bit of towncrier configuration, so I added this test that does a trial run of generating the changelog. In addition to checking that the changelog can be generated, it also outputs the draft so that reviewers can look at it if they like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480
https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480:59,Modifiability,config,configuration,59,"I discovered that we were missing a small bit of towncrier configuration, so I added this test that does a trial run of generating the changelog. In addition to checking that the changelog can be generated, it also outputs the draft so that reviewers can look at it if they like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480
https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480:90,Testability,test,test,90,"I discovered that we were missing a small bit of towncrier configuration, so I added this test that does a trial run of generating the changelog. In addition to checking that the changelog can be generated, it also outputs the draft so that reviewers can look at it if they like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:176,Deployability,integrat,integrator,176,"I've had a thorough look. Simplifying the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just pr",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1027,Deployability,integrat,integrator,1027,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1515,Deployability,update,update,1515,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1526,Deployability,integrat,integrator,1526,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1540,Deployability,integrat,integrator,1540,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:176,Integrability,integrat,integrator,176,"I've had a thorough look. Simplifying the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just pr",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1027,Integrability,integrat,integrator,1027,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1526,Integrability,integrat,integrator,1526,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1540,Integrability,integrat,integrator,1540,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:26,Usability,Simpl,Simplifying,26,"I've had a thorough look. Simplifying the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just pr",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1633,Usability,clear,clear,1633,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945:1897,Usability,simpl,simpler,1897,"ng the SolverOptions class is an excellent idea, but I think the PR currently doesn't go far enough and ends up with the solver classes, the integrator classes and the solver option classes required to share too much internal state with each other. As a next step to try untangle things, I suggest the following:. - Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances).; - Having the options able to notify a listener of changes seems great -- let's keep that.; - When a solver is created, let's have the base solver create a new SolverOptions instance, either from a dictionary or another SolverOptions instance, but with the allowed options and defaults now specified.; - To deal with the integrator options, let's go back to having a single option named `ode`, but have the value of `ode` have type `SolverOptions`, and be a child of the solver options (if the child has a value modified, it should notify the parent of the change).; - For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. I think that should be enough to disentangle things from each other. The base solver would need to update the integrator if integrator options change and deal with any changes to the base options. It's not completely clear to me whether the result options should also be sub-options or just be included in the solver options. I'm happy for them to be included in the solver options, as long as the solver options are passed to the result class constructor. That keeps things a bit simpler and if solver needs new result options it can always create its own result sub-class and just process its options there. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173137945
https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276:790,Deployability,integrat,integrator,790,"> Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances). Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. ; Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. > For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276
https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276:814,Deployability,integrat,integrator,814,"> Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances). Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. ; Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. > For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276
https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276:790,Integrability,integrat,integrator,790,"> Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances). Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. ; Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. > For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276
https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276:814,Integrability,integrat,integrator,814,"> Let's remove the `known_solvers` and the solver `name` from the SolverOptions and instead have the base solver pass the allowed options with defaults in to the SolverOptions constructor directly. If the allowed options list is `None`, then we can allow all options (for the convenience of users who really want to make their own SolverOptions instances). Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. ; Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. > For convenience, when passing options as a dictionary, one should be able to use `{""ode.method"": ""vern9""}` or `{""ode"": {""method"": ""vern9""}`. Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1173856276
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:433,Deployability,integrat,integrator,433,"> Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solve",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:457,Deployability,integrat,integrator,457,"> Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solve",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:433,Integrability,integrat,integrator,433,"> Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solve",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:457,Integrability,integrat,integrator,457,"> Users who makes their own SolverOptions are the base case. Using the `??solve` function with an `Options` instance and with documentation for the options items in the `Options` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solve",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:1233,Usability,clear,clear,1233,"ptions` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solver options. I wrote quite a lot in my previous post, but mostly I was suggesting one way to simplify and disentangle things more. I am happy for use to try other ways too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:1352,Usability,guid,guide,1352,"ptions` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solver options. I wrote quite a lot in my previous post, but mostly I was suggesting one way to simplify and disentangle things more. I am happy for use to try other ways too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:1492,Usability,clear,clearer,1492,"ptions` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solver options. I wrote quite a lot in my previous post, but mostly I was suggesting one way to simplify and disentangle things more. I am happy for use to try other ways too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:1855,Usability,clear,clear,1855,"ptions` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solver options. I wrote quite a lot in my previous post, but mostly I was suggesting one way to simplify and disentangle things more. I am happy for use to try other ways too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647:2092,Usability,simpl,simplify,2092,"ptions` class, is the way in v4 and will probably stay that way for a while. Having a options not knowing about the solver let it accept bad options and typos. Also it hides the options documentation: solver's options could be in the `??solve` function, but not integrator options. The integrator was merged into the solver in v4 and is not made to be used directly by the average user. So the user should not need to know they exist to use qutip, nor refer to them directly to see which options are supported. I'm not sure I am quite following, but my thought was that options would be checked by the solver class when they are passed in. The mechanism the solver class would use for doing the check, would be to pass the description of the allowed options to the SolverOptions class, along with the options themselves. > Not sure I understand why this would be convenient, flat seems a easier to use and less confusing. Ideally the user should not need to know that there are 2 levels of options. The reason for nesting the ode options a little, is to make it clear which options might change if the ODE method changes. If one hides the structure completely, there is nothing to guide the user as to which options are related to what. E.g. If ODE method ""A"" took option ""opt1"" and method ""B"" took ""opt2"" then it's much clearer what is happening if one has to pass `""ode"": {""method"": ""A"", ""opt1"": 1}` and `""ode"": {""method"": ""B""}` than `""method"": ""A"", ""opt1"": 1"" and `""method"": ""B"", ""opt2"": 2`. In the flat case, one might accidentally have `""method"": ""B"": ""opt1"": 1` and ""opt1"" would be ignored. I am not too hung up on the exact approach for this bit though -- I just want it to be clear to the user what is going wrong, and for it to be a little be hard to options for different ODE methods clash with each other or other solver options. I wrote quite a lot in my previous post, but mostly I was suggesting one way to simplify and disentangle things more. I am happy for use to try other ways too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174214647
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:113,Deployability,integrat,integrator,113,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:182,Deployability,integrat,integration,182,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:661,Deployability,Integrat,Integrator,661,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:754,Deployability,integrat,integrate,754,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1010,Deployability,integrat,integrator,1010,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1146,Deployability,integrat,integrator,1146,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1245,Deployability,integrat,integrator,1245,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1508,Deployability,integrat,integrator,1508,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1739,Deployability,integrat,integrator,1739,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:113,Integrability,integrat,integrator,113,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:182,Integrability,integrat,integration,182,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:320,Integrability,interface,interface,320,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:661,Integrability,Integrat,Integrator,661,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:754,Integrability,integrat,integrate,754,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1010,Integrability,integrat,integrator,1010,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1046,Integrability,interface,interface,1046,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1146,Integrability,integrat,integrator,1146,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1179,Integrability,interface,interface,1179,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1245,Integrability,integrat,integrator,1245,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1508,Integrability,integrat,integrator,1508,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1612,Integrability,interface,interface,1612,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1739,Integrability,integrat,integrator,1739,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1627,Security,access,access,1627,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:355,Usability,clear,clear,355,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1907,Usability,clear,clearer,1907,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:26,Deployability,integrat,integrator,26,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:90,Deployability,integrat,integration,90,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:217,Deployability,integrat,integrators,217,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:309,Deployability,integrat,integrators,309,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:26,Integrability,integrat,integrator,26,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:90,Integrability,integrat,integration,90,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:217,Integrability,integrat,integrators,217,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894:309,Integrability,integrat,integrators,309,"I think it's okay for the integrator options to be described in the documentation for the integration -- it can't really go anywhere else. The solver documentation can then point to the documentation for the built-in integrators, and mention that it is possible for third-party packages to provide additional integrators.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174444894
https://github.com/qutip/qutip/pull/1948#issuecomment-1170357096:240,Testability,test,tests-on-windows,240,[![Coverage Status](https://coveralls.io/builds/50504519/badge)](https://coveralls.io/builds/50504519). Coverage increased (+0.07%) to 71.055% when pulling **b9047e5b5d34c1d102e0c0b651fa3dc27952d887 on hodgestar:feature/v5-activate-mcsolve-tests-on-windows** into **1da5795fe762ccbf81ff58f417100ffbd60536c0 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1170357096
https://github.com/qutip/qutip/pull/1948#issuecomment-1170374439:24,Testability,test,tests,24,"A bit surprisingly, all tests now pass on Windows on QuTiP 5. I'm not 100% sure the parallel map change fixed everything, or if everything was mostly working before. I would like to keep the parallel map change regardless, because it removes some of the management of making multiprocessing work and leaves it with the core Python developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1170374439
https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442:57,Testability,test,tests,57,"> `ProcessPoolExecutor` being enough to fix most windows tests is surprising. I have a feeling this has something to do with processes spawned not still being running after the function exits. > Now we just need to speed up correlation tests. Any idea how to speed up the correlation tests, or should I just skip those again in this PR and we can fix them in a follow up PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442
https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442:236,Testability,test,tests,236,"> `ProcessPoolExecutor` being enough to fix most windows tests is surprising. I have a feeling this has something to do with processes spawned not still being running after the function exits. > Now we just need to speed up correlation tests. Any idea how to speed up the correlation tests, or should I just skip those again in this PR and we can fix them in a follow up PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442
https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442:284,Testability,test,tests,284,"> `ProcessPoolExecutor` being enough to fix most windows tests is surprising. I have a feeling this has something to do with processes spawned not still being running after the function exits. > Now we just need to speed up correlation tests. Any idea how to speed up the correlation tests, or should I just skip those again in this PR and we can fix them in a follow up PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442
https://github.com/qutip/qutip/pull/1948#issuecomment-1171423571:99,Usability,learn,learn,99,Interesting discussion about the relationship between OpenMP and multiprocessing -- https://scikit-learn.org/stable/faq.html#why-do-i-sometime-get-a-crash-freeze-with-n-jobs-1-under-osx-or-linux (in case this is relevant when bringing OpenMP back).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171423571
https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:289,Safety,timeout,timeout,289,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877
https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:325,Safety,timeout,timeouts,325,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877
https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:83,Testability,test,test,83,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877
https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:230,Testability,test,tests,230,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877
https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:362,Testability,test,tests,362,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877
https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:398,Testability,test,test,398,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877
https://github.com/qutip/qutip/pull/1948#issuecomment-1171606033:4,Testability,test,tests,4,All tests passing again -- ready for another review!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171606033
https://github.com/qutip/qutip/issues/1949#issuecomment-1176207837:278,Testability,benchmark,benchmarks,278,"No `.compile()` in v5. ; I don't think we need a porting guide either, `compile` is called internally in evolution but users very rarely call it themselves. 99.9% of users don't know it exist. Where is it causing issues? I only remember using it in a developer notebook showing benchmarks. This notebook can be removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1176207837
https://github.com/qutip/qutip/issues/1949#issuecomment-1176207837:57,Usability,guid,guide,57,"No `.compile()` in v5. ; I don't think we need a porting guide either, `compile` is called internally in evolution but users very rarely call it themselves. 99.9% of users don't know it exist. Where is it causing issues? I only remember using it in a developer notebook showing benchmarks. This notebook can be removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1176207837
https://github.com/qutip/qutip/issues/1949#issuecomment-1176355115:269,Availability,error,error,269,"I will vote for a deprecation warning being raised for a few versions of QuTiP with a `compile()` function that does nothing. The deprecation warning can briefly explain what changed and how to tackle it (in this case simply not use `.compile()`). It can also raise an error based on QuTiP's version such that our tests warn us about needing to remove it. Even if its a rarely used function and mostly employed internal, I still think that we should deprecate it appropriately as it will help making a smother transition to QuTiP 5.0.0. A HOW TO with some of the most significant porting changes is a also useful but I would prefer if it does not substitute deprecation warnings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1176355115
https://github.com/qutip/qutip/issues/1949#issuecomment-1176355115:314,Testability,test,tests,314,"I will vote for a deprecation warning being raised for a few versions of QuTiP with a `compile()` function that does nothing. The deprecation warning can briefly explain what changed and how to tackle it (in this case simply not use `.compile()`). It can also raise an error based on QuTiP's version such that our tests warn us about needing to remove it. Even if its a rarely used function and mostly employed internal, I still think that we should deprecate it appropriately as it will help making a smother transition to QuTiP 5.0.0. A HOW TO with some of the most significant porting changes is a also useful but I would prefer if it does not substitute deprecation warnings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1176355115
https://github.com/qutip/qutip/issues/1949#issuecomment-1176355115:218,Usability,simpl,simply,218,"I will vote for a deprecation warning being raised for a few versions of QuTiP with a `compile()` function that does nothing. The deprecation warning can briefly explain what changed and how to tackle it (in this case simply not use `.compile()`). It can also raise an error based on QuTiP's version such that our tests warn us about needing to remove it. Even if its a rarely used function and mostly employed internal, I still think that we should deprecate it appropriately as it will help making a smother transition to QuTiP 5.0.0. A HOW TO with some of the most significant porting changes is a also useful but I would prefer if it does not substitute deprecation warnings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1176355115
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:106,Availability,error,error,106,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:318,Availability,error,error,318,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:360,Availability,error,error,360,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:427,Availability,error,error,427,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:180,Deployability,release,release,180,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:83,Energy Efficiency,efficient,efficiently,83,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:335,Integrability,message,message,335,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:441,Integrability,message,message,441,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:135,Usability,Simpl,Simply,135,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:159,Usability,guid,guide,159,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:369,Usability,clear,clear,369,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053:483,Usability,guid,guide,483,"Just adding my two cents. From my experience, a lot of our users don't know how to efficiently locate the error and find the solution. Simply posting a HOW-TO guide along with the release notes might not be sufficient, because the users may not be aware of its existence. It would help I think if we could; - raise an error or warning message that locates the error as clear as possible and; - if feasible, leave a link in the error/warning message directing the users to the HOW-TO guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1949#issuecomment-1179740053
https://github.com/qutip/qutip/pull/1952#issuecomment-1197371391:51,Testability,test,test,51,"The code change look good, but could we also add a test for this so it doesn't fail again in the future? Maybe there is a simple example from a notebook that can be borrowed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1952#issuecomment-1197371391
https://github.com/qutip/qutip/pull/1952#issuecomment-1197371391:122,Usability,simpl,simple,122,"The code change look good, but could we also add a test for this so it doesn't fail again in the future? Maybe there is a simple example from a notebook that can be borrowed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1952#issuecomment-1197371391
https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765:385,Deployability,release,release,385,"Wow, that a lot of work. Good to see you are still working on the lattice stuff. Right now, we don't have enough hands to maintain it and it pretty much abandoned. If you have the will to give it some love, it would be great. However could you make those PRs to qutip-lattice, in small review able chunks? v4.7 is the last of the v4 series and new feature like this can't be a bug-fix release. And in v5 we are splitting lattice, qip and control in other repo and keeping in Qutip only what me and @hodgestar can actively maintain. qutip-notebook is also taking the door in favour of qutip-tutorial, which tests notebooks and adds other maintainability features. Is this tools you created for your research that you are now contributing or do you plan to stick around contributing on qutip-lattice?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765
https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765:637,Modifiability,maintainab,maintainability,637,"Wow, that a lot of work. Good to see you are still working on the lattice stuff. Right now, we don't have enough hands to maintain it and it pretty much abandoned. If you have the will to give it some love, it would be great. However could you make those PRs to qutip-lattice, in small review able chunks? v4.7 is the last of the v4 series and new feature like this can't be a bug-fix release. And in v5 we are splitting lattice, qip and control in other repo and keeping in Qutip only what me and @hodgestar can actively maintain. qutip-notebook is also taking the door in favour of qutip-tutorial, which tests notebooks and adds other maintainability features. Is this tools you created for your research that you are now contributing or do you plan to stick around contributing on qutip-lattice?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765
https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765:606,Testability,test,tests,606,"Wow, that a lot of work. Good to see you are still working on the lattice stuff. Right now, we don't have enough hands to maintain it and it pretty much abandoned. If you have the will to give it some love, it would be great. However could you make those PRs to qutip-lattice, in small review able chunks? v4.7 is the last of the v4 series and new feature like this can't be a bug-fix release. And in v5 we are splitting lattice, qip and control in other repo and keeping in Qutip only what me and @hodgestar can actively maintain. qutip-notebook is also taking the door in favour of qutip-tutorial, which tests notebooks and adds other maintainability features. Is this tools you created for your research that you are now contributing or do you plan to stick around contributing on qutip-lattice?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765
https://github.com/qutip/qutip/pull/1957#issuecomment-1186229765:308,Availability,failure,failure,308,"@Zac-HD Any suggestions for ways we could use hypothesis better? It all looks quite clean right now. Is there a way we can change what hypothesis prints when an example is found? E.g. we don't want the data layer object repr to include the contents of the array, but it would be nice to see that in the test failure output.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1186229765
https://github.com/qutip/qutip/pull/1957#issuecomment-1186229765:303,Testability,test,test,303,"@Zac-HD Any suggestions for ways we could use hypothesis better? It all looks quite clean right now. Is there a way we can change what hypothesis prints when an example is found? E.g. we don't want the data layer object repr to include the contents of the array, but it would be nice to see that in the test failure output.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1186229765
https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602:37,Safety,sanity check,sanity check,37,@Zac-HD Would you mind doing a quick sanity check of my `MatrixShapesStrategy` class (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L15-L62)? Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. I also wouldn't mind a quick check of `qobj_shared_shapes` (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L113-L131). Is this a good thing to be doing with shared strategies?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602
https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602:169,Testability,test,tests,169,@Zac-HD Would you mind doing a quick sanity check of my `MatrixShapesStrategy` class (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L15-L62)? Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. I also wouldn't mind a quick check of `qobj_shared_shapes` (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L113-L131). Is this a good thing to be doing with shared strategies?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602
https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602:445,Testability,test,tests,445,@Zac-HD Would you mind doing a quick sanity check of my `MatrixShapesStrategy` class (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L15-L62)? Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. I also wouldn't mind a quick check of `qobj_shared_shapes` (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L113-L131). Is this a good thing to be doing with shared strategies?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602
https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240:475,Energy Efficiency,efficient,efficient,475,"> Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. > I also wouldn't mind a quick check of `qobj_shared_shapes`. Is this a good thing to be doing with shared strategies?. It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240
https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240:722,Testability,test,test,722,"> Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. > I also wouldn't mind a quick check of `qobj_shared_shapes`. Is this a good thing to be doing with shared strategies?. It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240
https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240:814,Testability,test,tests,814,"> Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. > I also wouldn't mind a quick check of `qobj_shared_shapes`. Is this a good thing to be doing with shared strategies?. It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240
https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361:372,Energy Efficiency,efficient,efficient,372,"> Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. I tried with `signature=` quite a bit but `(m, k), (k, n)` always produced thing like `(1, 1, 1), (1, 1)` despite setting `max_dims` and `min_dims` to various things.; ; > It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it. I expected there to be other use cases. I started with the output of `write numpy.matmul` but ended up playing around with my own strategy (see difficulties with mutually_broadcastable_shapes` above) and liking the idea of not have to unpack `a` and `b` inside the test, and of being able to supply the shapes for `a` and `b` to other strategies (e.g. maybe we will have a strategy for Qobj and QobjEvo objects and want to try various combinations of multiplying things together)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361
https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361:671,Testability,test,test,671,"> Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. I tried with `signature=` quite a bit but `(m, k), (k, n)` always produced thing like `(1, 1, 1), (1, 1)` despite setting `max_dims` and `min_dims` to various things.; ; > It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it. I expected there to be other use cases. I started with the output of `write numpy.matmul` but ended up playing around with my own strategy (see difficulties with mutually_broadcastable_shapes` above) and liking the idea of not have to unpack `a` and `b` inside the test, and of being able to supply the shapes for `a` and `b` to other strategies (e.g. maybe we will have a strategy for Qobj and QobjEvo objects and want to try various combinations of multiplying things together)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361
https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361:763,Testability,test,tests,763,"> Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. I tried with `signature=` quite a bit but `(m, k), (k, n)` always produced thing like `(1, 1, 1), (1, 1)` despite setting `max_dims` and `min_dims` to various things.; ; > It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it. I expected there to be other use cases. I started with the output of `write numpy.matmul` but ended up playing around with my own strategy (see difficulties with mutually_broadcastable_shapes` above) and liking the idea of not have to unpack `a` and `b` inside the test, and of being able to supply the shapes for `a` and `b` to other strategies (e.g. maybe we will have a strategy for Qobj and QobjEvo objects and want to try various combinations of multiplying things together)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361
https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361:1128,Testability,test,test,1128,"> Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. I tried with `signature=` quite a bit but `(m, k), (k, n)` always produced thing like `(1, 1, 1), (1, 1)` despite setting `max_dims` and `min_dims` to various things.; ; > It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it. I expected there to be other use cases. I started with the output of `write numpy.matmul` but ended up playing around with my own strategy (see difficulties with mutually_broadcastable_shapes` above) and liking the idea of not have to unpack `a` and `b` inside the test, and of being able to supply the shapes for `a` and `b` to other strategies (e.g. maybe we will have a strategy for Qobj and QobjEvo objects and want to try various combinations of multiplying things together)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361
https://github.com/qutip/qutip/pull/1957#issuecomment-1207510876:502,Testability,test,test,502,"> I tried with `signature=` quite a bit but `(m, k), (k, n)` always produced thing like `(1, 1, 1), (1, 1)` despite setting `max_dims` and `min_dims` to various things. Huh, that's surprising. Share some example code and I'll have a look?. > I expected there to be other use cases. I started with the output of `write numpy.matmul` but ended up playing around with my own strategy (see difficulties with mutually_broadcastable_shapes`above) and liking the idea of not have to unpack`a`and`b`inside the test, and of being able to supply the shapes for`a`and`b` to other strategies (e.g. maybe we will have a strategy for Qobj and QobjEvo objects and want to try various combinations of multiplying things together).  sounds good, carry on then!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207510876
https://github.com/qutip/qutip/pull/1957#issuecomment-1208234717:170,Availability,error,error,170,"@Ericgig and I had a brief discussion about how to handle `inf` and `nan` generally. One option is forbid them entirely from the data layer -- i.e. to check and raise an error whenever a new data layer is created. A potential downside to this is we'd have to check often to be sure, since any operation can potentially create `nan` and `inf`, even simple addition:; ```python; >>> 1e308 + 1e308; inf; >>> (1e308 + 1e308) - (1e308 + 1e308); nan; ```; an alternative is to try propagate `nan` and `inf` only as correctly as, e.g., `BLAS`. What happens with `BLAS` is that `nan` and `inf` propagate reasonably correctly, but are considered fairly interchangeable -- i.e. `nan`, `inf`, and `-inf` are all just bad values.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1208234717
https://github.com/qutip/qutip/pull/1957#issuecomment-1208234717:226,Availability,down,downside,226,"@Ericgig and I had a brief discussion about how to handle `inf` and `nan` generally. One option is forbid them entirely from the data layer -- i.e. to check and raise an error whenever a new data layer is created. A potential downside to this is we'd have to check often to be sure, since any operation can potentially create `nan` and `inf`, even simple addition:; ```python; >>> 1e308 + 1e308; inf; >>> (1e308 + 1e308) - (1e308 + 1e308); nan; ```; an alternative is to try propagate `nan` and `inf` only as correctly as, e.g., `BLAS`. What happens with `BLAS` is that `nan` and `inf` propagate reasonably correctly, but are considered fairly interchangeable -- i.e. `nan`, `inf`, and `-inf` are all just bad values.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1208234717
https://github.com/qutip/qutip/pull/1957#issuecomment-1208234717:348,Usability,simpl,simple,348,"@Ericgig and I had a brief discussion about how to handle `inf` and `nan` generally. One option is forbid them entirely from the data layer -- i.e. to check and raise an error whenever a new data layer is created. A potential downside to this is we'd have to check often to be sure, since any operation can potentially create `nan` and `inf`, even simple addition:; ```python; >>> 1e308 + 1e308; inf; >>> (1e308 + 1e308) - (1e308 + 1e308); nan; ```; an alternative is to try propagate `nan` and `inf` only as correctly as, e.g., `BLAS`. What happens with `BLAS` is that `nan` and `inf` propagate reasonably correctly, but are considered fairly interchangeable -- i.e. `nan`, `inf`, and `-inf` are all just bad values.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1208234717
https://github.com/qutip/qutip/pull/1957#issuecomment-1506031688:27,Testability,test,tests,27,"@Ericgig I've expanded the tests and reworked this so that it's less of a WIP. I've also documented the expected behaviour of the data layer in the presence of `nans`, etc in the description of the PR. I'll find somewhere in the docs to add that before merging the PR. Would you mind taking another look and letting me know what you think?. P.S. I also haven't had a clean test run on GitHub Actions yet, but they pass consistently on my machine now. I think I cleaned up most of the issues from the recent GitHub Actions runs in my recent commits, but I'll know in the morning. Obviously CI needs to pass consistently before merging could happen.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1506031688
https://github.com/qutip/qutip/pull/1957#issuecomment-1506031688:373,Testability,test,test,373,"@Ericgig I've expanded the tests and reworked this so that it's less of a WIP. I've also documented the expected behaviour of the data layer in the presence of `nans`, etc in the description of the PR. I'll find somewhere in the docs to add that before merging the PR. Would you mind taking another look and letting me know what you think?. P.S. I also haven't had a clean test run on GitHub Actions yet, but they pass consistently on my machine now. I think I cleaned up most of the issues from the recent GitHub Actions runs in my recent commits, but I'll know in the morning. Obviously CI needs to pass consistently before merging could happen.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1506031688
https://github.com/qutip/qutip/pull/1957#issuecomment-1506051484:235,Testability,test,tests-for-data-operators,235,[![Coverage Status](https://coveralls.io/builds/58978308/badge)](https://coveralls.io/builds/58978308). Coverage: 75.624% (+0.3%) from 75.317% when pulling **133677f9c94efa2b57d976618f0e15b55e2a31a6 on hodgestar:feature/add-hypothesis-tests-for-data-operators** into **fb72696119f00358b1337f88f103688d705fe9e8 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1506051484
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:1524,Availability,error,errors,1524,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:1482,Safety,avoid,avoids,1482,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:21,Testability,test,tests,21,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:57,Testability,test,tests,57,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:228,Testability,test,tested,228,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:291,Testability,test,tests,291,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:375,Testability,test,tests,375,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:469,Testability,test,tested,469,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:897,Testability,test,test,897,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:980,Testability,assert,assert,980,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695
https://github.com/qutip/qutip/issues/1960#issuecomment-1194450193:12,Deployability,install,install,12,I used `pip install git+https://github.com/qutip/qutip@dev.major ` to install it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1960#issuecomment-1194450193
https://github.com/qutip/qutip/issues/1960#issuecomment-1194450193:70,Deployability,install,install,70,I used `pip install git+https://github.com/qutip/qutip@dev.major ` to install it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1960#issuecomment-1194450193
https://github.com/qutip/qutip/issues/1960#issuecomment-1194631968:87,Deployability,install,install,87,"I tried creating a new environment, cloning the dev.major branch and running `setup.py install` which didn't work either.; Adding `recursive-include qutip *.h` to `MANIFEST.in` before running the setup solved the problem. Interestingly it solved it for the `qutip5-bench` environment as well. So I created two new environments to see if the problem would also be solved in those, installing dev.major with pip in one and by cloning and using `setup.py install` without adding `recursive-include qutip *.h` to `MANIFEST.in` in the other. The QobjEvo object was created without any problems in both environments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1960#issuecomment-1194631968
https://github.com/qutip/qutip/issues/1960#issuecomment-1194631968:380,Deployability,install,installing,380,"I tried creating a new environment, cloning the dev.major branch and running `setup.py install` which didn't work either.; Adding `recursive-include qutip *.h` to `MANIFEST.in` before running the setup solved the problem. Interestingly it solved it for the `qutip5-bench` environment as well. So I created two new environments to see if the problem would also be solved in those, installing dev.major with pip in one and by cloning and using `setup.py install` without adding `recursive-include qutip *.h` to `MANIFEST.in` in the other. The QobjEvo object was created without any problems in both environments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1960#issuecomment-1194631968
https://github.com/qutip/qutip/issues/1960#issuecomment-1194631968:452,Deployability,install,install,452,"I tried creating a new environment, cloning the dev.major branch and running `setup.py install` which didn't work either.; Adding `recursive-include qutip *.h` to `MANIFEST.in` before running the setup solved the problem. Interestingly it solved it for the `qutip5-bench` environment as well. So I created two new environments to see if the problem would also be solved in those, installing dev.major with pip in one and by cloning and using `setup.py install` without adding `recursive-include qutip *.h` to `MANIFEST.in` in the other. The QobjEvo object was created without any problems in both environments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1960#issuecomment-1194631968
https://github.com/qutip/qutip/pull/1961#issuecomment-1198052613:448,Deployability,update,update,448,"Woot for finding this buglet. I have some questions:. - What happens in v5?; - Can we also add a test for this case where a different nT is needed?; - Should we make nT a parameter which defaults to your new value? How closely do the signatures of the various Floquet solvers match currently? If they already have different options we can likely just add a new parameter. If not, perhaps we can anyway, but we should think a bit more.; - We should update the docstring to match.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198052613
https://github.com/qutip/qutip/pull/1961#issuecomment-1198052613:97,Testability,test,test,97,"Woot for finding this buglet. I have some questions:. - What happens in v5?; - Can we also add a test for this case where a different nT is needed?; - Should we make nT a parameter which defaults to your new value? How closely do the signatures of the various Floquet solvers match currently? If they already have different options we can likely just add a new parameter. If not, perhaps we can anyway, but we should think a bit more.; - We should update the docstring to match.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198052613
https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:394,Deployability,integrat,integration,394,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790
https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:706,Deployability,integrat,integration,706,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790
https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:394,Integrability,integrat,integration,394,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790
https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:706,Integrability,integrat,integration,706,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790
https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:147,Modifiability,coupling,coupling,147,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790
https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:413,Modifiability,coupling,coupling,413,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790
https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:198,Testability,test,test,198,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790
https://github.com/qutip/qutip/pull/1961#issuecomment-1200423623:39,Testability,test,test,39,@christian512 Thank you for adding the test and explaining the logic. I did a second mini-review.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1200423623
https://github.com/qutip/qutip/pull/1961#issuecomment-1200423623:63,Testability,log,logic,63,@christian512 Thank you for adding the test and explaining the logic. I did a second mini-review.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1200423623
https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734:9,Availability,failure,failure,9,The test failure was just the occasional bloch sphere test failure that happens on Windows sometimes.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734
https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734:59,Availability,failure,failure,59,The test failure was just the occasional bloch sphere test failure that happens on Windows sometimes.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734
https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734:4,Testability,test,test,4,The test failure was just the occasional bloch sphere test failure that happens on Windows sometimes.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734
https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734:54,Testability,test,test,54,The test failure was just the occasional bloch sphere test failure that happens on Windows sometimes.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1201107734
https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433:208,Availability,error,error,208,"This won't be easy to fix, if the compilation is in the task, `parfor` cannot know about it to wait for it.; The simplest would be to have only the main process able to compile. This code will still raise an error, but the solution would be in the error message.; Otherwise communication between process would be needed and this can get tricky. Also `parfor` will be removed. It says in its [documentation](https://qutip.org/docs/latest/apidoc/functions.html#qutip.parallel.parfor) to use `parallel_map` instead since v3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433
https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433:248,Availability,error,error,248,"This won't be easy to fix, if the compilation is in the task, `parfor` cannot know about it to wait for it.; The simplest would be to have only the main process able to compile. This code will still raise an error, but the solution would be in the error message.; Otherwise communication between process would be needed and this can get tricky. Also `parfor` will be removed. It says in its [documentation](https://qutip.org/docs/latest/apidoc/functions.html#qutip.parallel.parfor) to use `parallel_map` instead since v3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433
https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433:254,Integrability,message,message,254,"This won't be easy to fix, if the compilation is in the task, `parfor` cannot know about it to wait for it.; The simplest would be to have only the main process able to compile. This code will still raise an error, but the solution would be in the error message.; Otherwise communication between process would be needed and this can get tricky. Also `parfor` will be removed. It says in its [documentation](https://qutip.org/docs/latest/apidoc/functions.html#qutip.parallel.parfor) to use `parallel_map` instead since v3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433
https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433:113,Usability,simpl,simplest,113,"This won't be easy to fix, if the compilation is in the task, `parfor` cannot know about it to wait for it.; The simplest would be to have only the main process able to compile. This code will still raise an error, but the solution would be in the error message.; Otherwise communication between process would be needed and this can get tricky. Also `parfor` will be removed. It says in its [documentation](https://qutip.org/docs/latest/apidoc/functions.html#qutip.parallel.parfor) to use `parallel_map` instead since v3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1963#issuecomment-1199314433
https://github.com/qutip/qutip/issues/1963#issuecomment-1216678043:2,Deployability,update,updated,2,I updated the notebooks to use `parallel_map` instead of `parfor` in https://github.com/qutip/qutip-tutorials/pull/31.; I guess we can close this issue?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1963#issuecomment-1216678043
https://github.com/qutip/qutip/pull/1964#issuecomment-1200402896:45,Integrability,message,message,45,Thanks @PierreGuilmin!. I made the changelog message a bit more detailed and will merge now.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1964#issuecomment-1200402896
https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586:469,Availability,error,error,469,"From what I understand, on intel, brmesolve seems to work correctly, but not on M1.; This look like an issue with the eigensolver. Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Also could you look at the tensor directly:; ```; R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); ```; If the tensor is wrong on M1, this would explain the error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586
https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586:149,Testability,test,test,149,"From what I understand, on intel, brmesolve seems to work correctly, but not on M1.; This look like an issue with the eigensolver. Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Also could you look at the tensor directly:; ```; R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); ```; If the tensor is wrong on M1, this would explain the error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586
https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586:216,Testability,test,tests,216,"From what I understand, on intel, brmesolve seems to work correctly, but not on M1.; This look like an issue with the eigensolver. Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Also could you look at the tensor directly:; ```; R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); ```; If the tensor is wrong on M1, this would explain the error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586
https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586:251,Testability,test,tests,251,"From what I understand, on intel, brmesolve seems to work correctly, but not on M1.; This look like an issue with the eigensolver. Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Also could you look at the tensor directly:; ```; R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); ```; If the tensor is wrong on M1, this would explain the error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586
https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586:260,Testability,Test,Tests,260,"From what I understand, on intel, brmesolve seems to work correctly, but not on M1.; This look like an issue with the eigensolver. Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Also could you look at the tensor directly:; ```; R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); ```; If the tensor is wrong on M1, this would explain the error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586
https://github.com/qutip/qutip/issues/1965#issuecomment-1203283104:62,Availability,error,error,62,Internal note: `bloch_redfield_solve` quit without raising an error when ode integration fails.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203283104
https://github.com/qutip/qutip/issues/1965#issuecomment-1203283104:77,Deployability,integrat,integration,77,Internal note: `bloch_redfield_solve` quit without raising an error when ode integration fails.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203283104
https://github.com/qutip/qutip/issues/1965#issuecomment-1203283104:77,Integrability,integrat,integration,77,Internal note: `bloch_redfield_solve` quit without raising an error when ode integration fails.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203283104
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:432,Availability,failure,failures,432,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:502,Availability,error,error,502,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:1068,Availability,error,error,1068,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:490,Deployability,integrat,integration,490,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:735,Deployability,install,installation,735,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:777,Deployability,install,installed,777,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:490,Integrability,integrat,integration,490,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:161,Testability,test,test,161,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:228,Testability,test,tests,228,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:263,Testability,test,tests,263,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:272,Testability,Test,Tests,272,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:580,Testability,test,tests,580,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:663,Testability,test,tests,663,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063
https://github.com/qutip/qutip/issues/1965#issuecomment-1203966750:37,Testability,test,tests,37,"Could you post a list of the failing tests. If the tensor is right, then the eigensolver seems to work fine. So the ODE solver could be the issue, but in this case, `mesolve` tests should also fail.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203966750
https://github.com/qutip/qutip/issues/1965#issuecomment-1203966750:175,Testability,test,tests,175,"Could you post a list of the failing tests. If the tensor is right, then the eigensolver seems to work fine. So the ODE solver could be the issue, but in this case, `mesolve` tests should also fail.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203966750
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:157,Availability,error,error,157,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:145,Deployability,integrat,integration,145,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:299,Deployability,integrat,integrate,299,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:447,Deployability,install,installed,447,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:628,Deployability,update,updated,628,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:145,Integrability,integrat,integration,145,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:299,Integrability,integrat,integrate,299,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:38,Testability,test,tests,38,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:107,Testability,test,tests,107,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:184,Testability,test,tests,184,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:228,Testability,test,test,228,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:278,Testability,test,testing,278,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858
https://github.com/qutip/qutip/issues/1965#issuecomment-1205377439:53,Availability,error,error,53,"Good.; Still, `brmrsolve` failing without raising an error is on us, I will close this PR when we fix that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205377439
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:220,Availability,error,error,220,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:298,Availability,down,down,298,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:313,Availability,error,error,313,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:330,Availability,error,error,330,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:397,Availability,error,error,397,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:85,Deployability,install,installing,85,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:208,Deployability,integrat,integration,208,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:348,Deployability,update,update,348,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:208,Integrability,integrat,integration,208,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:246,Testability,test,tests,246,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786
https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071:25,Deployability,install,installed,25,"Hi @Ericgig ,; I just re-installed things with pip, and now the tests are passing (and my original examples work as expected)!. For what it's worth, I found that using pip to install scipy and qutip worked and resolved the issues.; The original problem seems to be related to conda installing a version of openblas which is buggy (in particular 0.3.20), see the scipy issue linked above for more info on that. Version 0.3.18 seems to work fine. Thanks for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071
https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071:175,Deployability,install,install,175,"Hi @Ericgig ,; I just re-installed things with pip, and now the tests are passing (and my original examples work as expected)!. For what it's worth, I found that using pip to install scipy and qutip worked and resolved the issues.; The original problem seems to be related to conda installing a version of openblas which is buggy (in particular 0.3.20), see the scipy issue linked above for more info on that. Version 0.3.18 seems to work fine. Thanks for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071
https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071:282,Deployability,install,installing,282,"Hi @Ericgig ,; I just re-installed things with pip, and now the tests are passing (and my original examples work as expected)!. For what it's worth, I found that using pip to install scipy and qutip worked and resolved the issues.; The original problem seems to be related to conda installing a version of openblas which is buggy (in particular 0.3.20), see the scipy issue linked above for more info on that. Version 0.3.18 seems to work fine. Thanks for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071
https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071:64,Testability,test,tests,64,"Hi @Ericgig ,; I just re-installed things with pip, and now the tests are passing (and my original examples work as expected)!. For what it's worth, I found that using pip to install scipy and qutip worked and resolved the issues.; The original problem seems to be related to conda installing a version of openblas which is buggy (in particular 0.3.20), see the scipy issue linked above for more info on that. Version 0.3.18 seems to work fine. Thanks for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071
https://github.com/qutip/qutip/pull/1967#issuecomment-1206374899:219,Deployability,update,update-roadmap-and-ideas-to-show-completed-work-,219,[![Coverage Status](https://coveralls.io/builds/51447321/badge)](https://coveralls.io/builds/51447321). Coverage remained the same at 69.927% when pulling **b179082f96cc04c039cb636c15b1b10a57794c58 on hodgestar:feature/update-roadmap-and-ideas-to-show-completed-work-2022-08** into **7a09e3ecbbeb491c70c17d8f05bb9d1dfcda5a05 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1967#issuecomment-1206374899
https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394:17,Availability,failure,failure,17,"The Windows test failure is the strange ""Tcl is not properly installed one"". Someone else reported this at https://github.com/microsoft/azure-pipelines-tasks/issues/16426 so I mentioned that we see it too. I linked to this build failure there, so please don't re-run it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394
https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394:229,Availability,failure,failure,229,"The Windows test failure is the strange ""Tcl is not properly installed one"". Someone else reported this at https://github.com/microsoft/azure-pipelines-tasks/issues/16426 so I mentioned that we see it too. I linked to this build failure there, so please don't re-run it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394
https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394:61,Deployability,install,installed,61,"The Windows test failure is the strange ""Tcl is not properly installed one"". Someone else reported this at https://github.com/microsoft/azure-pipelines-tasks/issues/16426 so I mentioned that we see it too. I linked to this build failure there, so please don't re-run it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394
https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394:142,Deployability,pipeline,pipelines-tasks,142,"The Windows test failure is the strange ""Tcl is not properly installed one"". Someone else reported this at https://github.com/microsoft/azure-pipelines-tasks/issues/16426 so I mentioned that we see it too. I linked to this build failure there, so please don't re-run it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394
https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394:12,Testability,test,test,12,"The Windows test failure is the strange ""Tcl is not properly installed one"". Someone else reported this at https://github.com/microsoft/azure-pipelines-tasks/issues/16426 so I mentioned that we see it too. I linked to this build failure there, so please don't re-run it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1207185394
https://github.com/qutip/qutip/pull/1968#issuecomment-1207185532:43,Availability,failure,failure,43,Happy for this to be merged with the build failure and we can just check that the merge commit builds correctly.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1207185532
https://github.com/qutip/qutip/pull/1968#issuecomment-1208156789:32,Testability,test,test,32,"@hodgestar ; Sorry, I reran the test before reading your comment, here is the failing attempt:; https://github.com/qutip/qutip/actions/runs/2805431012/attempts/1",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1208156789
https://github.com/qutip/qutip/pull/1969#issuecomment-1208599699:37,Integrability,depend,depend,37,"I made a custom exception class that depend on all the raised exceptions classes so we can catch it.; It feel somewhat hacky, `ExceptionGroup` would work a lot better, but we won't be able to use it for a few years.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1208599699
https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437:219,Integrability,depend,dependency,219,"I was imagining something much simpler for the exception class. There is a backport of the exceptiongroup stuff to older Pythons that we could use if we wanted to: https://pypi.org/project/exceptiongroup/. It's another dependency, but it will mean that on Python 3.11 people could start using ExceptionGroup and `except*` immediately if they wanted to. Users on Python 3.10 and below would have to catch ExceptionGroup or use the backport's ugly `with catch(...)` mechanism. . Then, many years from now when Python 3.10 is obsolete, we could drop the backport entirely. Personally I'm in favour of the simpler `ParallelMapException` that doesn't inherit from all the other exceptions. Then when 3.11 is out we can make `ParallelMapException` inherit from `ExceptionGroup` and 3.11 users will be able to use `except*`. People supporting 3.10 and below will have to use `except ParallelMapException`, but that will work just as well on 3.11.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437
https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437:646,Modifiability,inherit,inherit,646,"I was imagining something much simpler for the exception class. There is a backport of the exceptiongroup stuff to older Pythons that we could use if we wanted to: https://pypi.org/project/exceptiongroup/. It's another dependency, but it will mean that on Python 3.11 people could start using ExceptionGroup and `except*` immediately if they wanted to. Users on Python 3.10 and below would have to catch ExceptionGroup or use the backport's ugly `with catch(...)` mechanism. . Then, many years from now when Python 3.10 is obsolete, we could drop the backport entirely. Personally I'm in favour of the simpler `ParallelMapException` that doesn't inherit from all the other exceptions. Then when 3.11 is out we can make `ParallelMapException` inherit from `ExceptionGroup` and 3.11 users will be able to use `except*`. People supporting 3.10 and below will have to use `except ParallelMapException`, but that will work just as well on 3.11.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437
https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437:742,Modifiability,inherit,inherit,742,"I was imagining something much simpler for the exception class. There is a backport of the exceptiongroup stuff to older Pythons that we could use if we wanted to: https://pypi.org/project/exceptiongroup/. It's another dependency, but it will mean that on Python 3.11 people could start using ExceptionGroup and `except*` immediately if they wanted to. Users on Python 3.10 and below would have to catch ExceptionGroup or use the backport's ugly `with catch(...)` mechanism. . Then, many years from now when Python 3.10 is obsolete, we could drop the backport entirely. Personally I'm in favour of the simpler `ParallelMapException` that doesn't inherit from all the other exceptions. Then when 3.11 is out we can make `ParallelMapException` inherit from `ExceptionGroup` and 3.11 users will be able to use `except*`. People supporting 3.10 and below will have to use `except ParallelMapException`, but that will work just as well on 3.11.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437
https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437:31,Usability,simpl,simpler,31,"I was imagining something much simpler for the exception class. There is a backport of the exceptiongroup stuff to older Pythons that we could use if we wanted to: https://pypi.org/project/exceptiongroup/. It's another dependency, but it will mean that on Python 3.11 people could start using ExceptionGroup and `except*` immediately if they wanted to. Users on Python 3.10 and below would have to catch ExceptionGroup or use the backport's ugly `with catch(...)` mechanism. . Then, many years from now when Python 3.10 is obsolete, we could drop the backport entirely. Personally I'm in favour of the simpler `ParallelMapException` that doesn't inherit from all the other exceptions. Then when 3.11 is out we can make `ParallelMapException` inherit from `ExceptionGroup` and 3.11 users will be able to use `except*`. People supporting 3.10 and below will have to use `except ParallelMapException`, but that will work just as well on 3.11.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437
https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437:602,Usability,simpl,simpler,602,"I was imagining something much simpler for the exception class. There is a backport of the exceptiongroup stuff to older Pythons that we could use if we wanted to: https://pypi.org/project/exceptiongroup/. It's another dependency, but it will mean that on Python 3.11 people could start using ExceptionGroup and `except*` immediately if they wanted to. Users on Python 3.10 and below would have to catch ExceptionGroup or use the backport's ugly `with catch(...)` mechanism. . Then, many years from now when Python 3.10 is obsolete, we could drop the backport entirely. Personally I'm in favour of the simpler `ParallelMapException` that doesn't inherit from all the other exceptions. Then when 3.11 is out we can make `ParallelMapException` inherit from `ExceptionGroup` and 3.11 users will be able to use `except*`. People supporting 3.10 and below will have to use `except ParallelMapException`, but that will work just as well on 3.11.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:30,Availability,error,error,30,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:99,Availability,error,error,99,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:240,Availability,error,error,240,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:305,Availability,error,error,305,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:375,Availability,error,error,375,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:470,Availability,error,error,470,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:799,Availability,error,error,799,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:1021,Availability,error,error,1021,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:36,Integrability,depend,depend,36,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:1071,Safety,safe,safe,1071,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180
https://github.com/qutip/qutip/pull/1969#issuecomment-1209413844:161,Availability,error,errors,161,Hmm. It would be nice to get the results that succeeded. What if we made a single exception class that was used by all the functions and which contained all the errors and all the results? Then everyone can catch the same exception class and decide what to do with all the results and errors?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209413844
https://github.com/qutip/qutip/pull/1969#issuecomment-1209413844:285,Availability,error,errors,285,Hmm. It would be nice to get the results that succeeded. What if we made a single exception class that was used by all the functions and which contained all the errors and all the results? Then everyone can catch the same exception class and decide what to do with all the results and errors?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209413844
https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:313,Deployability,install,install,313,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169
https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:142,Integrability,depend,dependencies,142,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169
https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:395,Integrability,depend,dependency,395,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169
https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:78,Modifiability,Config,ConfigParser,78,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169
https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:194,Testability,test,testing,194,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169
https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:336,Testability,test,testing,336,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169
https://github.com/qutip/qutip/pull/1971#issuecomment-1207225971:212,Deployability,Update,UpdateManifest,212,[![Coverage Status](https://coveralls.io/builds/51467716/badge)](https://coveralls.io/builds/51467716). Coverage decreased (-0.05%) to 71.537% when pulling **d459df96541e5a96f5010314520a252d61750dad on xspronken:UpdateManifest** into **50be470d9d23981c7cbfed0b04a702a23d440eb8 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1971#issuecomment-1207225971
https://github.com/qutip/qutip/issues/1974#issuecomment-1905451596:303,Deployability,update,update,303,"Yeah, seems like in v5 if you give a list of colors to add_points it ignores whether you choose 's' or 'm' and just plots multicolored. I would keep that as is (since i guess the logic of choosing 's' or 'm' is more about what default values to choose if the user provides no list of colors), and maybe update the docstring to just say giving a list of colors to add_points will override the choice of 's' or 'm'? . in v4.7 on the other hand, giving point_color() seems to still obey the choice of s or m used in add_points(). i would say its not so important to preserve that (presumably if you give a list you want multiple colors). @AGaliciaMartinez @Ericgig does this sound reasonable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1974#issuecomment-1905451596
https://github.com/qutip/qutip/issues/1974#issuecomment-1905451596:179,Testability,log,logic,179,"Yeah, seems like in v5 if you give a list of colors to add_points it ignores whether you choose 's' or 'm' and just plots multicolored. I would keep that as is (since i guess the logic of choosing 's' or 'm' is more about what default values to choose if the user provides no list of colors), and maybe update the docstring to just say giving a list of colors to add_points will override the choice of 's' or 'm'? . in v4.7 on the other hand, giving point_color() seems to still obey the choice of s or m used in add_points(). i would say its not so important to preserve that (presumably if you give a list you want multiple colors). @AGaliciaMartinez @Ericgig does this sound reasonable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1974#issuecomment-1905451596
https://github.com/qutip/qutip/issues/1974#issuecomment-1910952439:75,Deployability,update,updated,75,"@nwlambert I have already made the pull request. The docstring was already updated specifing the needs of the colors you give to the add_points function depending of the style you proposed. I would like to ask two more questions:. -Is it necessary to create a changelog file if the change is small? I was reviewing the documentation and it tells you to create one but reviewing the ones that are created, they are few and all seem to be related to major code updates, so I assumed that one should only be created when the change in the project is significant. Am I right or should I add one?. -The other point I'd like to ask is if there are any open issues related to a plotting problem with the 'l' style. I believe I have found a bug related to plotting with this style due to the way the script orders the points before plotting, but I have not found any issues reporting it. . Plotting in V4:; ![Figure 2024-01-25 211444](https://github.com/qutip/qutip/assets/78165605/329291ec-195c-443f-8bf4-727fde7cdd24). Plottin in V5:; ![Figure_1](https://github.com/qutip/qutip/assets/78165605/ece1143f-d367-40db-b808-f573332b8d0a). I think I know how to solve it, but I'm not sure if someone has already reported it, if I should open a new issue or just solve it as part of this issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1974#issuecomment-1910952439
https://github.com/qutip/qutip/issues/1974#issuecomment-1910952439:459,Deployability,update,updates,459,"@nwlambert I have already made the pull request. The docstring was already updated specifing the needs of the colors you give to the add_points function depending of the style you proposed. I would like to ask two more questions:. -Is it necessary to create a changelog file if the change is small? I was reviewing the documentation and it tells you to create one but reviewing the ones that are created, they are few and all seem to be related to major code updates, so I assumed that one should only be created when the change in the project is significant. Am I right or should I add one?. -The other point I'd like to ask is if there are any open issues related to a plotting problem with the 'l' style. I believe I have found a bug related to plotting with this style due to the way the script orders the points before plotting, but I have not found any issues reporting it. . Plotting in V4:; ![Figure 2024-01-25 211444](https://github.com/qutip/qutip/assets/78165605/329291ec-195c-443f-8bf4-727fde7cdd24). Plottin in V5:; ![Figure_1](https://github.com/qutip/qutip/assets/78165605/ece1143f-d367-40db-b808-f573332b8d0a). I think I know how to solve it, but I'm not sure if someone has already reported it, if I should open a new issue or just solve it as part of this issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1974#issuecomment-1910952439
https://github.com/qutip/qutip/issues/1974#issuecomment-1910952439:153,Integrability,depend,depending,153,"@nwlambert I have already made the pull request. The docstring was already updated specifing the needs of the colors you give to the add_points function depending of the style you proposed. I would like to ask two more questions:. -Is it necessary to create a changelog file if the change is small? I was reviewing the documentation and it tells you to create one but reviewing the ones that are created, they are few and all seem to be related to major code updates, so I assumed that one should only be created when the change in the project is significant. Am I right or should I add one?. -The other point I'd like to ask is if there are any open issues related to a plotting problem with the 'l' style. I believe I have found a bug related to plotting with this style due to the way the script orders the points before plotting, but I have not found any issues reporting it. . Plotting in V4:; ![Figure 2024-01-25 211444](https://github.com/qutip/qutip/assets/78165605/329291ec-195c-443f-8bf4-727fde7cdd24). Plottin in V5:; ![Figure_1](https://github.com/qutip/qutip/assets/78165605/ece1143f-d367-40db-b808-f573332b8d0a). I think I know how to solve it, but I'm not sure if someone has already reported it, if I should open a new issue or just solve it as part of this issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1974#issuecomment-1910952439
https://github.com/qutip/qutip/pull/1975#issuecomment-1218012520:59,Testability,test,test,59,"I don't think we need a fix for master, I haven't seen the test fail yet. ; In master, we create the file in the active directory and use pyx import. So the absolute path should never be used.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1975#issuecomment-1218012520
https://github.com/qutip/qutip/pull/1975#issuecomment-1218041788:64,Testability,test,tests,64,"It looks like the Python 3.9 build managed to start running the tests, so hopefully we are good!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1975#issuecomment-1218041788
https://github.com/qutip/qutip/pull/1976#issuecomment-1218243721:218,Integrability,interface,interface,218,[![Coverage Status](https://coveralls.io/builds/51767419/badge)](https://coveralls.io/builds/51767419). Coverage decreased (-0.004%) to 71.553% when pulling **181f9f6ab878ce73257b4a7ef149a953a369a647 on Ericgig:random.interface** into **bc9b27f09086b0a066f6d9ddb2fb04739224624a on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1976#issuecomment-1218243721
https://github.com/qutip/qutip/pull/1978#issuecomment-1219804239:246,Availability,error,error-warning,246,[![Coverage Status](https://coveralls.io/builds/51772900/badge)](https://coveralls.io/builds/51772900). Coverage remained the same at 69.935% when pulling **53339827c21901c053647e9b1b6cf4f337a484de on hodgestar:feature/silence-pyximport-relative-error-warning** into **82c6704c6fea8a2801492865ad1ef7c1d73c8840 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219804239
https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355:65,Availability,error,error,65,"`--config-setting=""--global-option=--with-openmp""` gives a build error (qutip 4.7.0, debian unstable, python 3.10.6):; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355
https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355:1068,Availability,ERROR,ERROR,1068,"`--config-setting=""--global-option=--with-openmp""` gives a build error (qutip 4.7.0, debian unstable, python 3.10.6):; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355
https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355:153,Integrability,depend,dependency-check,153,"`--config-setting=""--global-option=--with-openmp""` gives a build error (qutip 4.7.0, debian unstable, python 3.10.6):; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355
https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355:3,Modifiability,config,config-setting,3,"`--config-setting=""--global-option=--with-openmp""` gives a build error (qutip 4.7.0, debian unstable, python 3.10.6):; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355
https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355:195,Modifiability,config,config-setting,195,"`--config-setting=""--global-option=--with-openmp""` gives a build error (qutip 4.7.0, debian unstable, python 3.10.6):; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355
https://github.com/qutip/qutip/pull/1978#issuecomment-1219847833:107,Deployability,release,release,107,It did work for me with QuTiP master on Python 3.10.5. Could you try with master to? We need to do a 4.7.1 release soon anyway.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219847833
https://github.com/qutip/qutip/pull/1978#issuecomment-1219947340:70,Modifiability,config,config-setting,70,@drew-parsons I'll leave #1875 open until we've sorted out why the `--config-setting=--global-option=--with-openmp` isn't working in some cases.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219947340
https://github.com/qutip/qutip/pull/1978#issuecomment-1220036080:7,Modifiability,config,config-setting,7,"No, `--config-setting=--global-option=--with-openmp` is still not working with git head. This is with ; * python 3.10.6-1; * python3-build 0.7.0-3; * python3-setuptools 59.6.0-1.2; * python3-wheel 0.37.1-2; * gcc 12.1.0-7",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1220036080
https://github.com/qutip/qutip/pull/1979#issuecomment-1219958590:12,Availability,failure,failure,12,I guess the failure on Python 3.10 will sort it self out when this gets merged.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1979#issuecomment-1219958590
https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615:303,Performance,optimiz,optimizations,303,"> Thanks @eendebakpt. This is a great improvement for a small change. I left one suggestion for adding a bit more of a description to the change log, but I think it looks good to merge. Are there any more changes you'd like to make?. I am creating a similar PR against dev.major. Perhaps there are more optimizations to be done (have not checked yet), but I think it is better to put it in a seperate PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615
https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615:145,Testability,log,log,145,"> Thanks @eendebakpt. This is a great improvement for a small change. I left one suggestion for adding a bit more of a description to the change log, but I think it looks good to merge. Are there any more changes you'd like to make?. I am creating a similar PR against dev.major. Perhaps there are more optimizations to be done (have not checked yet), but I think it is better to put it in a seperate PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615
https://github.com/qutip/qutip/pull/1983#issuecomment-1224125400:9,Availability,failure,failure,9,The test failure is the sporadic Window tk one.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1983#issuecomment-1224125400
https://github.com/qutip/qutip/pull/1983#issuecomment-1224125400:4,Testability,test,test,4,The test failure is the sporadic Window tk one.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1983#issuecomment-1224125400
https://github.com/qutip/qutip/pull/1986#issuecomment-1228914050:216,Deployability,integrat,integrator,216,[![Coverage Status](https://coveralls.io/builds/55196508/badge)](https://coveralls.io/builds/55196508). Coverage decreased (-0.2%) to 72.452% when pulling **c26257095ae5d7c9f6fd69c04bcc2206ab76c581 on Ericgig:krylov.integrator** into **a0ca511e15f2edb4d707096e74341a89d7a9d442 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1986#issuecomment-1228914050
https://github.com/qutip/qutip/pull/1986#issuecomment-1228914050:216,Integrability,integrat,integrator,216,[![Coverage Status](https://coveralls.io/builds/55196508/badge)](https://coveralls.io/builds/55196508). Coverage decreased (-0.2%) to 72.452% when pulling **c26257095ae5d7c9f6fd69c04bcc2206ab76c581 on Ericgig:krylov.integrator** into **a0ca511e15f2edb4d707096e74341a89d7a9d442 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1986#issuecomment-1228914050
https://github.com/qutip/qutip/pull/1986#issuecomment-1349624347:147,Testability,test,test,147,Thanks for addressing all the issues so quickly. I added a commit for the krylov_error comment I wanted. Happy for this to be merged if the latest test run passes.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1986#issuecomment-1349624347
https://github.com/qutip/qutip/pull/1986#issuecomment-1351836403:2,Deployability,update,updated,2,I updated the krylov page after the merger. The code was not touched since the review.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1986#issuecomment-1351836403
https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060:116,Availability,error,error,116,"@ArchieB151 The output is very strange. No new version of QuTiP was released in the last month. The ODE integration error you received would only appear if the problem being solved changed somehow. The initial state in your plot doesn't match the psi0 defined in the code (i.e. both expectation values are zero). Could you try do everything from scratch again? Start with a completely fresh download of the notebook, restart the Jupyter kernel entirely run everything from the top?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060
https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060:391,Availability,down,download,391,"@ArchieB151 The output is very strange. No new version of QuTiP was released in the last month. The ODE integration error you received would only appear if the problem being solved changed somehow. The initial state in your plot doesn't match the psi0 defined in the code (i.e. both expectation values are zero). Could you try do everything from scratch again? Start with a completely fresh download of the notebook, restart the Jupyter kernel entirely run everything from the top?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060
https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060:68,Deployability,release,released,68,"@ArchieB151 The output is very strange. No new version of QuTiP was released in the last month. The ODE integration error you received would only appear if the problem being solved changed somehow. The initial state in your plot doesn't match the psi0 defined in the code (i.e. both expectation values are zero). Could you try do everything from scratch again? Start with a completely fresh download of the notebook, restart the Jupyter kernel entirely run everything from the top?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060
https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060:104,Deployability,integrat,integration,104,"@ArchieB151 The output is very strange. No new version of QuTiP was released in the last month. The ODE integration error you received would only appear if the problem being solved changed somehow. The initial state in your plot doesn't match the psi0 defined in the code (i.e. both expectation values are zero). Could you try do everything from scratch again? Start with a completely fresh download of the notebook, restart the Jupyter kernel entirely run everything from the top?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060
https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060:104,Integrability,integrat,integration,104,"@ArchieB151 The output is very strange. No new version of QuTiP was released in the last month. The ODE integration error you received would only appear if the problem being solved changed somehow. The initial state in your plot doesn't match the psi0 defined in the code (i.e. both expectation values are zero). Could you try do everything from scratch again? Start with a completely fresh download of the notebook, restart the Jupyter kernel entirely run everything from the top?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229018060
https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791:247,Deployability,release,release,247,"@ArchieB151 I've now run the notebook myself using QuTiP 4.7.0 and it produces the expected plots. However, it has numerous small things that need to be fixed because it was originally written for an older version of QuTiP. We are almost ready to release a completely updated set of notebooks that updates all of these old notebooks. These notebooks are tested automatically regularly. You can find the updated version of the Jaynes-Cummings lecture at https://qutip.org/qutip-tutorials/tutorials-v4/lectures/Lecture-1-Jaynes-Cumming-model.ipynb and the full set of notebooks at https://qutip.org/qutip-tutorials/ (the page is very plain HTML, but it will be prettified soon). Could you try the updated notebook with 4.7.0 and see if it works for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791
https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791:268,Deployability,update,updated,268,"@ArchieB151 I've now run the notebook myself using QuTiP 4.7.0 and it produces the expected plots. However, it has numerous small things that need to be fixed because it was originally written for an older version of QuTiP. We are almost ready to release a completely updated set of notebooks that updates all of these old notebooks. These notebooks are tested automatically regularly. You can find the updated version of the Jaynes-Cummings lecture at https://qutip.org/qutip-tutorials/tutorials-v4/lectures/Lecture-1-Jaynes-Cumming-model.ipynb and the full set of notebooks at https://qutip.org/qutip-tutorials/ (the page is very plain HTML, but it will be prettified soon). Could you try the updated notebook with 4.7.0 and see if it works for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791
https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791:298,Deployability,update,updates,298,"@ArchieB151 I've now run the notebook myself using QuTiP 4.7.0 and it produces the expected plots. However, it has numerous small things that need to be fixed because it was originally written for an older version of QuTiP. We are almost ready to release a completely updated set of notebooks that updates all of these old notebooks. These notebooks are tested automatically regularly. You can find the updated version of the Jaynes-Cummings lecture at https://qutip.org/qutip-tutorials/tutorials-v4/lectures/Lecture-1-Jaynes-Cumming-model.ipynb and the full set of notebooks at https://qutip.org/qutip-tutorials/ (the page is very plain HTML, but it will be prettified soon). Could you try the updated notebook with 4.7.0 and see if it works for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791
https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791:403,Deployability,update,updated,403,"@ArchieB151 I've now run the notebook myself using QuTiP 4.7.0 and it produces the expected plots. However, it has numerous small things that need to be fixed because it was originally written for an older version of QuTiP. We are almost ready to release a completely updated set of notebooks that updates all of these old notebooks. These notebooks are tested automatically regularly. You can find the updated version of the Jaynes-Cummings lecture at https://qutip.org/qutip-tutorials/tutorials-v4/lectures/Lecture-1-Jaynes-Cumming-model.ipynb and the full set of notebooks at https://qutip.org/qutip-tutorials/ (the page is very plain HTML, but it will be prettified soon). Could you try the updated notebook with 4.7.0 and see if it works for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791
https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791:695,Deployability,update,updated,695,"@ArchieB151 I've now run the notebook myself using QuTiP 4.7.0 and it produces the expected plots. However, it has numerous small things that need to be fixed because it was originally written for an older version of QuTiP. We are almost ready to release a completely updated set of notebooks that updates all of these old notebooks. These notebooks are tested automatically regularly. You can find the updated version of the Jaynes-Cummings lecture at https://qutip.org/qutip-tutorials/tutorials-v4/lectures/Lecture-1-Jaynes-Cumming-model.ipynb and the full set of notebooks at https://qutip.org/qutip-tutorials/ (the page is very plain HTML, but it will be prettified soon). Could you try the updated notebook with 4.7.0 and see if it works for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791
https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791:354,Testability,test,tested,354,"@ArchieB151 I've now run the notebook myself using QuTiP 4.7.0 and it produces the expected plots. However, it has numerous small things that need to be fixed because it was originally written for an older version of QuTiP. We are almost ready to release a completely updated set of notebooks that updates all of these old notebooks. These notebooks are tested automatically regularly. You can find the updated version of the Jaynes-Cummings lecture at https://qutip.org/qutip-tutorials/tutorials-v4/lectures/Lecture-1-Jaynes-Cumming-model.ipynb and the full set of notebooks at https://qutip.org/qutip-tutorials/ (the page is very plain HTML, but it will be prettified soon). Could you try the updated notebook with 4.7.0 and see if it works for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791
https://github.com/qutip/qutip/issues/1987#issuecomment-1229173727:98,Deployability,update,updated,98,"@hodgestar Hi, I have made sure Qutip is running at version 4.7.0 however still after trying your updated version of the jaynes cumming model I am still experiencing the same issues. I have tried starting from scratch but this still doesn't change the output. I really appreciate your help as I'm writing my dissertation and I have to give a presentation on it in 5 weeks. ; Kind regards ; Archie",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229173727
https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846:492,Availability,Error,Error,492,"I wonder if there is something wrong with your new QuTiP install? Since I can't reproduce the issue locally it might be difficult to suggest solutions, but I can give some debugging advice:. - Try reducing the code used to produce the issue as much as possible (perhaps just a single cell that calls the solver without any c_ops and checks the initial and final expectation values, without plots).; - Check all the inputs to the solver (psi0, etc).; - If a solver prints the ""ODE Integration Error"" warning it usually means that the solver has not converged to an output it trusts, so the solution returned is likely wrong.; ; If you manage to find a smaller reproducer of the error, report it here with as much information about your setup as possible (you can start with the output of `qutip.about()`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846
https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846:677,Availability,error,error,677,"I wonder if there is something wrong with your new QuTiP install? Since I can't reproduce the issue locally it might be difficult to suggest solutions, but I can give some debugging advice:. - Try reducing the code used to produce the issue as much as possible (perhaps just a single cell that calls the solver without any c_ops and checks the initial and final expectation values, without plots).; - Check all the inputs to the solver (psi0, etc).; - If a solver prints the ""ODE Integration Error"" warning it usually means that the solver has not converged to an output it trusts, so the solution returned is likely wrong.; ; If you manage to find a smaller reproducer of the error, report it here with as much information about your setup as possible (you can start with the output of `qutip.about()`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846
https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846:57,Deployability,install,install,57,"I wonder if there is something wrong with your new QuTiP install? Since I can't reproduce the issue locally it might be difficult to suggest solutions, but I can give some debugging advice:. - Try reducing the code used to produce the issue as much as possible (perhaps just a single cell that calls the solver without any c_ops and checks the initial and final expectation values, without plots).; - Check all the inputs to the solver (psi0, etc).; - If a solver prints the ""ODE Integration Error"" warning it usually means that the solver has not converged to an output it trusts, so the solution returned is likely wrong.; ; If you manage to find a smaller reproducer of the error, report it here with as much information about your setup as possible (you can start with the output of `qutip.about()`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846
https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846:480,Deployability,Integrat,Integration,480,"I wonder if there is something wrong with your new QuTiP install? Since I can't reproduce the issue locally it might be difficult to suggest solutions, but I can give some debugging advice:. - Try reducing the code used to produce the issue as much as possible (perhaps just a single cell that calls the solver without any c_ops and checks the initial and final expectation values, without plots).; - Check all the inputs to the solver (psi0, etc).; - If a solver prints the ""ODE Integration Error"" warning it usually means that the solver has not converged to an output it trusts, so the solution returned is likely wrong.; ; If you manage to find a smaller reproducer of the error, report it here with as much information about your setup as possible (you can start with the output of `qutip.about()`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846
https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846:480,Integrability,Integrat,Integration,480,"I wonder if there is something wrong with your new QuTiP install? Since I can't reproduce the issue locally it might be difficult to suggest solutions, but I can give some debugging advice:. - Try reducing the code used to produce the issue as much as possible (perhaps just a single cell that calls the solver without any c_ops and checks the initial and final expectation values, without plots).; - Check all the inputs to the solver (psi0, etc).; - If a solver prints the ""ODE Integration Error"" warning it usually means that the solver has not converged to an output it trusts, so the solution returned is likely wrong.; ; If you manage to find a smaller reproducer of the error, report it here with as much information about your setup as possible (you can start with the output of `qutip.about()`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229174846
https://github.com/qutip/qutip/issues/1987#issuecomment-1229179569:47,Availability,error,error,47,"@hodgestar Hi, I have managed to reproduce the error with a much smaller code which i have attached at the bottom. Quitp.about() :. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.7.3; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.9.12; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /opt/anaconda3/lib/python3.9/site-packages/qutip. <img width=""1130"" alt=""Screenshot 2022-08-27 at 12 58 25"" src=""https://user-images.githubusercontent.com/75099190/187029284-1cda7133-9ed1-4b95-82a0-d1b5eb10c36e.png"">. ; <img width=""1074"" alt=""Screenshot 2022-08-27 at 12 58 46"" src=""https://user-images.githubusercontent.com/75099190/187029267-49dc711b-412f-4e12-acb4-cfb195902351.png"">. ; import numpy as np; from qutip import *. wc = 1.0 * 2 * np.pi ; wa = 1.0 * 2 * np.pi ; g = 0.05 * 2 * np.pi ; N=15 ; rate = 0.005. tlist = np.linspace(0, 25, 101); psi0 = tensor(basis(N, 0), basis(2, 1)) ; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). output = mesolve(H, psi0, tlist)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229179569
https://github.com/qutip/qutip/issues/1987#issuecomment-1229179569:322,Deployability,Install,Installed,322,"@hodgestar Hi, I have managed to reproduce the error with a much smaller code which i have attached at the bottom. Quitp.about() :. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.7.3; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.9.12; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /opt/anaconda3/lib/python3.9/site-packages/qutip. <img width=""1130"" alt=""Screenshot 2022-08-27 at 12 58 25"" src=""https://user-images.githubusercontent.com/75099190/187029284-1cda7133-9ed1-4b95-82a0-d1b5eb10c36e.png"">. ; <img width=""1074"" alt=""Screenshot 2022-08-27 at 12 58 46"" src=""https://user-images.githubusercontent.com/75099190/187029267-49dc711b-412f-4e12-acb4-cfb195902351.png"">. ; import numpy as np; from qutip import *. wc = 1.0 * 2 * np.pi ; wa = 1.0 * 2 * np.pi ; g = 0.05 * 2 * np.pi ; N=15 ; rate = 0.005. tlist = np.linspace(0, 25, 101); psi0 = tensor(basis(N, 0), basis(2, 1)) ; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). output = mesolve(H, psi0, tlist)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229179569
https://github.com/qutip/qutip/issues/1987#issuecomment-1229179569:393,Deployability,Install,Installation,393,"@hodgestar Hi, I have managed to reproduce the error with a much smaller code which i have attached at the bottom. Quitp.about() :. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.7.3; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.9.12; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /opt/anaconda3/lib/python3.9/site-packages/qutip. <img width=""1130"" alt=""Screenshot 2022-08-27 at 12 58 25"" src=""https://user-images.githubusercontent.com/75099190/187029284-1cda7133-9ed1-4b95-82a0-d1b5eb10c36e.png"">. ; <img width=""1074"" alt=""Screenshot 2022-08-27 at 12 58 46"" src=""https://user-images.githubusercontent.com/75099190/187029267-49dc711b-412f-4e12-acb4-cfb195902351.png"">. ; import numpy as np; from qutip import *. wc = 1.0 * 2 * np.pi ; wa = 1.0 * 2 * np.pi ; g = 0.05 * 2 * np.pi ; N=15 ; rate = 0.005. tlist = np.linspace(0, 25, 101); psi0 = tensor(basis(N, 0), basis(2, 1)) ; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). output = mesolve(H, psi0, tlist)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229179569
https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134:126,Availability,avail,availability,126,"Ah, are you using an Apple M1?. SciPy support for Apple M1 is still rather unreliable (this is more a function of the lack of availability of Apple M1 VMs for open source projects to run tests on than any fault of SciPy's). Perhaps you are encountering one of these two recent bugs:. - https://github.com/scipy/scipy/issues/16767; - https://github.com/scipy/scipy/issues/16875. The bugs are closed but I don't know if new versions have been released. Various work arounds have been suggested in those issue reports. Hopefully one of them will work for your case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134
https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134:205,Availability,fault,fault,205,"Ah, are you using an Apple M1?. SciPy support for Apple M1 is still rather unreliable (this is more a function of the lack of availability of Apple M1 VMs for open source projects to run tests on than any fault of SciPy's). Perhaps you are encountering one of these two recent bugs:. - https://github.com/scipy/scipy/issues/16767; - https://github.com/scipy/scipy/issues/16875. The bugs are closed but I don't know if new versions have been released. Various work arounds have been suggested in those issue reports. Hopefully one of them will work for your case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134
https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134:441,Deployability,release,released,441,"Ah, are you using an Apple M1?. SciPy support for Apple M1 is still rather unreliable (this is more a function of the lack of availability of Apple M1 VMs for open source projects to run tests on than any fault of SciPy's). Perhaps you are encountering one of these two recent bugs:. - https://github.com/scipy/scipy/issues/16767; - https://github.com/scipy/scipy/issues/16875. The bugs are closed but I don't know if new versions have been released. Various work arounds have been suggested in those issue reports. Hopefully one of them will work for your case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134
https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134:187,Testability,test,tests,187,"Ah, are you using an Apple M1?. SciPy support for Apple M1 is still rather unreliable (this is more a function of the lack of availability of Apple M1 VMs for open source projects to run tests on than any fault of SciPy's). Perhaps you are encountering one of these two recent bugs:. - https://github.com/scipy/scipy/issues/16767; - https://github.com/scipy/scipy/issues/16875. The bugs are closed but I don't know if new versions have been released. Various work arounds have been suggested in those issue reports. Hopefully one of them will work for your case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134
https://github.com/qutip/qutip/issues/1987#issuecomment-1229183720:194,Deployability,install,installed,194,"Yes, I am currently using the M1 chip. However, I previously had no issues with scipy or qutip before, only after I wiped my Mac and reinstall everything did these problems occur. . Last time I installed qutip I went into the hardware_info.py script and changed two lines of code to get the module to work on my M1. I tried to do this again in the exact same way but once I navigated to the qutip folder I found there was no such file. Could this be an issue?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229183720
https://github.com/qutip/qutip/issues/1987#issuecomment-1229185731:67,Deployability,install,install,67,"QuTiP 4.7.0 remove the hardware_info file. I suspect that your new install is just different to your old one. E.g. you seem to now be running SciPy 1.7.3, but maybe a more recent SciPy would work better (e.g. 1.8.2 or 1.9.0). In either case, this is almost certainly an issue with SciPy on M1 and not specific to QuTiP. Of course we would still like QuTiP to work for you -- it's just that the solution may lie in updating or installing SciPy differently, not QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229185731
https://github.com/qutip/qutip/issues/1987#issuecomment-1229185731:426,Deployability,install,installing,426,"QuTiP 4.7.0 remove the hardware_info file. I suspect that your new install is just different to your old one. E.g. you seem to now be running SciPy 1.7.3, but maybe a more recent SciPy would work better (e.g. 1.8.2 or 1.9.0). In either case, this is almost certainly an issue with SciPy on M1 and not specific to QuTiP. Of course we would still like QuTiP to work for you -- it's just that the solution may lie in updating or installing SciPy differently, not QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229185731
https://github.com/qutip/qutip/issues/1989#issuecomment-1232217541:496,Safety,detect,detects,496,"The `dims` in the line you commented out appear to be incorrect. They are the dims for the Liouvillian (i.e. operator over the density matrix) and not of the density matrix itself. Specify `dims=[[2, 2, 2], [2, 2, 2]]` instead. Slightly longer answer; If you don't specify the dims when creating a Qobj from an ndarray, QuTiP assumes the dims are the shape of the array. Your Hamiltonian is constructed by tensoring together operators on single qubits, so it's dims are more structured and QuTiP detects the mismatch.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1989#issuecomment-1232217541
https://github.com/qutip/qutip/issues/1990#issuecomment-1248613448:35,Deployability,release,release,35,It will be added it the next major release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1990#issuecomment-1248613448
https://github.com/qutip/qutip/issues/1990#issuecomment-1345301587:164,Testability,log,logm,164,"This won't be implemented in QuTiP 4.7, but one can implement it oneself for a given `qobj` using:. ```python; import scipy.linalg. qobj_logm = Qobj(; scipy.linalg.logm(qobj.full()),; dims=self.dims,; type=self.type; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1990#issuecomment-1345301587
https://github.com/qutip/qutip/pull/1992#issuecomment-1247954515:44,Availability,error,error,44,The Mac OS ci failed with a strange pardiso error from the HEOM tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1247954515
https://github.com/qutip/qutip/pull/1992#issuecomment-1247954515:64,Testability,test,tests,64,The Mac OS ci failed with a strange pardiso error from the HEOM tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1247954515
https://github.com/qutip/qutip/pull/1992#issuecomment-1248091570:19,Deployability,release,release,19,"I am not sure. Bug release should not add new features, but this feels too small for a minor release. Waiting for it in v5 could take some time, so I think it's fine.; But if we choose to wait for v5 for this, I am fine with it. It will be one less merge conflict when merging master to dev.major.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1248091570
https://github.com/qutip/qutip/pull/1992#issuecomment-1248091570:93,Deployability,release,release,93,"I am not sure. Bug release should not add new features, but this feels too small for a minor release. Waiting for it in v5 could take some time, so I think it's fine.; But if we choose to wait for v5 for this, I am fine with it. It will be one less merge conflict when merging master to dev.major.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1248091570
https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205:166,Deployability,release,release,166,"Hmm. I think let's leave it out. We can reply to the issue with ""it's implemented in v5 and here is how you do it in v4"". That avoids adding a new feature in a point release (and potentially confusing users) while still solving everyone's immediate problems and making the future better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205
https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205:127,Safety,avoid,avoids,127,"Hmm. I think let's leave it out. We can reply to the issue with ""it's implemented in v5 and here is how you do it in v4"". That avoids adding a new feature in a point release (and potentially confusing users) while still solving everyone's immediate problems and making the future better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205
https://github.com/qutip/qutip/pull/1993#issuecomment-1248083898:43,Testability,log,logm,43,"Since `scipy.sparse.linalg` does not have `logm`, we need to convert it to an array to do the computation.; Without the csr version, the dispatcher will do it for us.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1993#issuecomment-1248083898
https://github.com/qutip/qutip/pull/1994#issuecomment-1267575547:24,Testability,test,test,24,Merging this as failing test seems unrelated.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1994#issuecomment-1267575547
https://github.com/qutip/qutip/issues/1998#issuecomment-1416809483:65,Usability,simpl,simple,65,"I see a similar issue with just calculating the eigenstates of a simple $\sigma_x \otimes \sigma_x$ operator. ``` python; import qutip as q; import scipy. op = q.tensor(q.sigmax(), q.sigmax()); eigv_sp, eigs_sp = op.eigenstates(sparse=True); eigv_full, eigs_full = op.eigenstates(sparse=False); eigv_scipy, eigs_scipy = scipy.linalg.eigh(op.full()); print(eigv_sp, eigs_sp); print(eigv_full, eigs_full); print(eigv_scipy, eigs_scipy); ```. The sparse=True gives eigenstates . ```; [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 0.36754009-0.27845703j]; [-0.49166296+0.21364338j]; [ 0.49166296-0.21364338j]; [-0.36754009+0.27845703j]]; ````; whereas `sparse=False` and the `scipy.linalg.eigh` give the correct states. ```; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0. ]; [ 0. ]; [-0.70710678]]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1416809483
https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009:476,Availability,down,down,476,"Hi @pschindler, thanks for reporting this! Although the eigenenstates are different for both cases (`sparse=True` and `sparse=False`) I believe that they are both equally valid since the operator has degenerated eigenvalues. The approach for the computation of the eigenstates for both `sparse=True ` and `sparse=False` is different so that may explain why you see different results. For the case that @Ericgig presented though, the eigenvalues are non-degenerated. I tracked down the issue and it is related to how we compute these eigenvalues. When we ask for all the eigenvalues what we actually do is to compute the smallest half in with one method (`scipy.sparse.linalg(which='LR')`) and the largest half with a different method (`scipy.sparse.linalg(which='SR')`). Smallest half and largest half here means relative to the _real_ part of the eigenvalue. This makes complete sense for the cases where the eigenvalues are real but unfortunately not so much sense when we only care about the imaginary part. This is what the `which` is doing, is selecting the values with smallest/largest real part. If we include a small real component the bug completely disappears:; ```; In [56]: (qutip.num(4)*(1j+0.00001)).eigenenergies(sparse=True); Out[56]:; array([1.23048985e-16-2.21177095e-16j, 1.00000000e-05+1.00000000e+00j,; 2.00000000e-05+2.00000000e+00j, 3.00000000e-05+3.00000000e+00j]); ```; Because now there is a real part to use in the ordering. The behavior of `eigenstates` is definitely wrong and one way of solving it would be to not use both `LR` and `SR` options when all the eigenvalues are required and instead chose internally just one. This would still return results ordered by their real part but at least all the eigenvalues would be present (only once). We may want to extend the behavior of `eigenstates` to not only accept `sort=low` and `sort=high` and instead have a similar behavior to the one provided by scipy and allow sorting by imaginary part or absolute value.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009
https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009:1789,Modifiability,extend,extend,1789,"Hi @pschindler, thanks for reporting this! Although the eigenenstates are different for both cases (`sparse=True` and `sparse=False`) I believe that they are both equally valid since the operator has degenerated eigenvalues. The approach for the computation of the eigenstates for both `sparse=True ` and `sparse=False` is different so that may explain why you see different results. For the case that @Ericgig presented though, the eigenvalues are non-degenerated. I tracked down the issue and it is related to how we compute these eigenvalues. When we ask for all the eigenvalues what we actually do is to compute the smallest half in with one method (`scipy.sparse.linalg(which='LR')`) and the largest half with a different method (`scipy.sparse.linalg(which='SR')`). Smallest half and largest half here means relative to the _real_ part of the eigenvalue. This makes complete sense for the cases where the eigenvalues are real but unfortunately not so much sense when we only care about the imaginary part. This is what the `which` is doing, is selecting the values with smallest/largest real part. If we include a small real component the bug completely disappears:; ```; In [56]: (qutip.num(4)*(1j+0.00001)).eigenenergies(sparse=True); Out[56]:; array([1.23048985e-16-2.21177095e-16j, 1.00000000e-05+1.00000000e+00j,; 2.00000000e-05+2.00000000e+00j, 3.00000000e-05+3.00000000e+00j]); ```; Because now there is a real part to use in the ordering. The behavior of `eigenstates` is definitely wrong and one way of solving it would be to not use both `LR` and `SR` options when all the eigenvalues are required and instead chose internally just one. This would still return results ordered by their real part but at least all the eigenvalues would be present (only once). We may want to extend the behavior of `eigenstates` to not only accept `sort=low` and `sort=high` and instead have a similar behavior to the one provided by scipy and allow sorting by imaginary part or absolute value.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009
https://github.com/qutip/qutip/issues/1998#issuecomment-1419816348:1045,Availability,error,error,1045,"Hi @pschindler,. Indeed, the behavior you show is a bug in qutip 4.7.0. Thanks for reporting this! However, it is actually a bug in the `sparse=True` case. The scipy case gives a different result compared to qutip sparse because of the method used. `eigh` assumes the input is hermitian but `op` is not. You can see the correct eigenvalues using:; ```; In [7]: scipy.linalg.eigvals(op.full()); Out[7]:; array([-1. -2.22044605e-16j, -0.5+8.66025404e-01j, -0.5-8.66025404e-01j,; 0.5+8.66025404e-01j, 0.5-8.66025404e-01j, 1. +0.00000000e+00j]); ```. I am genuinely surprised that the `sparse=False` is bugged in the latest version of qutip. Fortunately, I tested this in the master branch of qutip (this contains the qutip 5.0.0 alpha version) and the bug seems to be solved there. This operator is indeed subjected to the same bug Eric shows (it is non-hermitian). However, due to the real part of the eigenvalues, it actually shows the correct answer (similar to the example I showed in my previous comment). I will try to find the source of the error but it seems very likely that we incorrectly label the operator as hermitian and hence uses the wrong method to find eigenvalues.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1419816348
https://github.com/qutip/qutip/issues/1998#issuecomment-1419816348:653,Testability,test,tested,653,"Hi @pschindler,. Indeed, the behavior you show is a bug in qutip 4.7.0. Thanks for reporting this! However, it is actually a bug in the `sparse=True` case. The scipy case gives a different result compared to qutip sparse because of the method used. `eigh` assumes the input is hermitian but `op` is not. You can see the correct eigenvalues using:; ```; In [7]: scipy.linalg.eigvals(op.full()); Out[7]:; array([-1. -2.22044605e-16j, -0.5+8.66025404e-01j, -0.5-8.66025404e-01j,; 0.5+8.66025404e-01j, 0.5-8.66025404e-01j, 1. +0.00000000e+00j]); ```. I am genuinely surprised that the `sparse=False` is bugged in the latest version of qutip. Fortunately, I tested this in the master branch of qutip (this contains the qutip 5.0.0 alpha version) and the bug seems to be solved there. This operator is indeed subjected to the same bug Eric shows (it is non-hermitian). However, due to the real part of the eigenvalues, it actually shows the correct answer (similar to the example I showed in my previous comment). I will try to find the source of the error but it seems very likely that we incorrectly label the operator as hermitian and hence uses the wrong method to find eigenvalues.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1419816348
https://github.com/qutip/qutip/issues/1998#issuecomment-1423168374:188,Availability,error,error,188,"> Hi @AGaliciaMartinez . Good to hear from you again ;). Hi! :smile: . > It seems that the hermitian check for the operator op evaluates as True. Yes, this is definitely the source of the error. Nice catch! I will try to compare the 4.7.1 version of qutip with the new pre lease of version 5.0.0 and see if we can provide a quick fix for it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1423168374
https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161:345,Deployability,install,install,345,"I do not think it's a _good first issue_...; There are multiple possible solutions and it is not clear which is the best one:. 1. Ensure all eigen values and eigen vectors are computed.; 1.1 This could be done by finding an alternative to scipy to solve for sparse matrix decomposition, but it would add extra requirement and it must be easy to install with pip.; 1.2 Use a third call to `scipy.sparse.linalg.eigs`/ `scipy.sparse.linalg.eigsh` using `sigma` to find all the pseudo degenerate values. It need to be done while being careful about special cases. This would make the sparse eigen solver even slower than it already is.; 2. Allow to sort by other orders, such as the complex value or magnitude. This would not solve the issue, but give some options to go around it. However the dense eigen solver would be expected to behave the same and the dense eigen solver does not have this options, so we need to implement it ourselves. This sorting option would also be required for any other data type we want to support. To go around that, the `Qobj` methods could be responsible for the sorting, the `sort` argument would only be passed to the dispatched function when `sparse=True`.; 3. Refuse to use the sparse solver for the full decomposition as scipy does. The sparse eigensolver is both slow and hard to use in this case. Also the eigen vectors computed by the sparse solver are stored in a dense array, so it is not that useful to save memory...; 4. Implement our own sparse eigen decomposition...; 5. Only document the issue without fixing. The default is the dense solver, which is both faster and safer in almost all cases.; 6. Something else...; ; I would personally go for either 1.2 of 3. ; Adding different sorting options in `Qobj` methods (2) and removing them from the dispatched functions, could be nice, but it's not a fix. The place to start would be to debate on the solution. If you have some opinion on the matter, please let us know.; Once we've made up our mind, you can",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161
https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161:1613,Safety,safe,safer,1613," it is not clear which is the best one:. 1. Ensure all eigen values and eigen vectors are computed.; 1.1 This could be done by finding an alternative to scipy to solve for sparse matrix decomposition, but it would add extra requirement and it must be easy to install with pip.; 1.2 Use a third call to `scipy.sparse.linalg.eigs`/ `scipy.sparse.linalg.eigsh` using `sigma` to find all the pseudo degenerate values. It need to be done while being careful about special cases. This would make the sparse eigen solver even slower than it already is.; 2. Allow to sort by other orders, such as the complex value or magnitude. This would not solve the issue, but give some options to go around it. However the dense eigen solver would be expected to behave the same and the dense eigen solver does not have this options, so we need to implement it ourselves. This sorting option would also be required for any other data type we want to support. To go around that, the `Qobj` methods could be responsible for the sorting, the `sort` argument would only be passed to the dispatched function when `sparse=True`.; 3. Refuse to use the sparse solver for the full decomposition as scipy does. The sparse eigensolver is both slow and hard to use in this case. Also the eigen vectors computed by the sparse solver are stored in a dense array, so it is not that useful to save memory...; 4. Implement our own sparse eigen decomposition...; 5. Only document the issue without fixing. The default is the dense solver, which is both faster and safer in almost all cases.; 6. Something else...; ; I would personally go for either 1.2 of 3. ; Adding different sorting options in `Qobj` methods (2) and removing them from the dispatched functions, could be nice, but it's not a fix. The place to start would be to debate on the solution. If you have some opinion on the matter, please let us know.; Once we've made up our mind, you can implement it, but only 5 would be an easy fix in line with other _good first issue_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161
https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161:97,Usability,clear,clear,97,"I do not think it's a _good first issue_...; There are multiple possible solutions and it is not clear which is the best one:. 1. Ensure all eigen values and eigen vectors are computed.; 1.1 This could be done by finding an alternative to scipy to solve for sparse matrix decomposition, but it would add extra requirement and it must be easy to install with pip.; 1.2 Use a third call to `scipy.sparse.linalg.eigs`/ `scipy.sparse.linalg.eigsh` using `sigma` to find all the pseudo degenerate values. It need to be done while being careful about special cases. This would make the sparse eigen solver even slower than it already is.; 2. Allow to sort by other orders, such as the complex value or magnitude. This would not solve the issue, but give some options to go around it. However the dense eigen solver would be expected to behave the same and the dense eigen solver does not have this options, so we need to implement it ourselves. This sorting option would also be required for any other data type we want to support. To go around that, the `Qobj` methods could be responsible for the sorting, the `sort` argument would only be passed to the dispatched function when `sparse=True`.; 3. Refuse to use the sparse solver for the full decomposition as scipy does. The sparse eigensolver is both slow and hard to use in this case. Also the eigen vectors computed by the sparse solver are stored in a dense array, so it is not that useful to save memory...; 4. Implement our own sparse eigen decomposition...; 5. Only document the issue without fixing. The default is the dense solver, which is both faster and safer in almost all cases.; 6. Something else...; ; I would personally go for either 1.2 of 3. ; Adding different sorting options in `Qobj` methods (2) and removing them from the dispatched functions, could be nice, but it's not a fix. The place to start would be to debate on the solution. If you have some opinion on the matter, please let us know.; Once we've made up our mind, you can",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161
https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858:254,Availability,Error,Error,254,"5 seems also fine for me. We default to the dense solver when all the eigenvalues are required, even if `sparse=True` and we then raise a Warning explaining why we do this and how to stop the warning. IIf I understood it correctly, 3 would be raising an Error instead of a warning, which may be a little bit more annoying for someone that just wants the code to work (?). I am fine with both though and I think they could be suitable issues for a ""medium"" level ""good_first_issue"" (if that makes sense  ). 1 and 4 seem indeed too much work right now (but perhaps they can be tackled in the future). 2 may actually be separate an enhacement, that could be useful for some specific scenarios (?). But maybe it is best to wait for when this scenario is present to actually motivate the enhancement (?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858
https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858:784,Modifiability,enhance,enhancement,784,"5 seems also fine for me. We default to the dense solver when all the eigenvalues are required, even if `sparse=True` and we then raise a Warning explaining why we do this and how to stop the warning. IIf I understood it correctly, 3 would be raising an Error instead of a warning, which may be a little bit more annoying for someone that just wants the code to work (?). I am fine with both though and I think they could be suitable issues for a ""medium"" level ""good_first_issue"" (if that makes sense  ). 1 and 4 seem indeed too much work right now (but perhaps they can be tackled in the future). 2 may actually be separate an enhacement, that could be useful for some specific scenarios (?). But maybe it is best to wait for when this scenario is present to actually motivate the enhancement (?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858
https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466:207,Availability,avail,available,207,"By (3), I meant removing the csr specialisation from the dispatched function and call the function directly when not all values are desired. When `Qobj.eigenstates` is called, the sparse operation being not available, it would defer to the dense code, no warning nor error. ; We can't fully trust `eigs_csr` as it is, so I would like to make it fully working (1) or remove it from the dispatch (3). Yes (2) can be seen as separate enhancement. For me (5) was purely documentation, a warning is fine, but when `sparse` is specified, it would use `eigh_csr` and too bad if wrong results are obtained... (3) would also mean removing the; ```; if isinstance(L.data, _data.CSR) and not sparse:; L = L.to(_data.Dense); evals, evecs = _data.eigs(L.data); ```; since they are no longer used (`spectrum.py`, `floquet.py`, `qobj.py`) and reviewing the tests cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466
https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466:267,Availability,error,error,267,"By (3), I meant removing the csr specialisation from the dispatched function and call the function directly when not all values are desired. When `Qobj.eigenstates` is called, the sparse operation being not available, it would defer to the dense code, no warning nor error. ; We can't fully trust `eigs_csr` as it is, so I would like to make it fully working (1) or remove it from the dispatch (3). Yes (2) can be seen as separate enhancement. For me (5) was purely documentation, a warning is fine, but when `sparse` is specified, it would use `eigh_csr` and too bad if wrong results are obtained... (3) would also mean removing the; ```; if isinstance(L.data, _data.CSR) and not sparse:; L = L.to(_data.Dense); evals, evecs = _data.eigs(L.data); ```; since they are no longer used (`spectrum.py`, `floquet.py`, `qobj.py`) and reviewing the tests cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466
https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466:431,Modifiability,enhance,enhancement,431,"By (3), I meant removing the csr specialisation from the dispatched function and call the function directly when not all values are desired. When `Qobj.eigenstates` is called, the sparse operation being not available, it would defer to the dense code, no warning nor error. ; We can't fully trust `eigs_csr` as it is, so I would like to make it fully working (1) or remove it from the dispatch (3). Yes (2) can be seen as separate enhancement. For me (5) was purely documentation, a warning is fine, but when `sparse` is specified, it would use `eigh_csr` and too bad if wrong results are obtained... (3) would also mean removing the; ```; if isinstance(L.data, _data.CSR) and not sparse:; L = L.to(_data.Dense); evals, evecs = _data.eigs(L.data); ```; since they are no longer used (`spectrum.py`, `floquet.py`, `qobj.py`) and reviewing the tests cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466
https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466:842,Testability,test,tests,842,"By (3), I meant removing the csr specialisation from the dispatched function and call the function directly when not all values are desired. When `Qobj.eigenstates` is called, the sparse operation being not available, it would defer to the dense code, no warning nor error. ; We can't fully trust `eigs_csr` as it is, so I would like to make it fully working (1) or remove it from the dispatch (3). Yes (2) can be seen as separate enhancement. For me (5) was purely documentation, a warning is fine, but when `sparse` is specified, it would use `eigh_csr` and too bad if wrong results are obtained... (3) would also mean removing the; ```; if isinstance(L.data, _data.CSR) and not sparse:; L = L.to(_data.Dense); evals, evecs = _data.eigs(L.data); ```; since they are no longer used (`spectrum.py`, `floquet.py`, `qobj.py`) and reviewing the tests cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466
https://github.com/qutip/qutip/pull/1999#issuecomment-1256993343:68,Modifiability,flexible,flexible,68,The feature is very interesting and makes the propagator class very flexible. I like it! I left some small comments but otherwise looks good.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1256993343
https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120:227,Deployability,configurat,configuration,227,"@hodgestar, to make it work with HEOM, I had to change `step` to return `rho` directly, (controlled by the `store_ados` options). Could you take a look and tell me if you are fine with this approach. Also, do you know a `Bath` configuration that would result in evolution similar to `mesolve` so we could use it in tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120
https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120:227,Modifiability,config,configuration,227,"@hodgestar, to make it work with HEOM, I had to change `step` to return `rho` directly, (controlled by the `store_ados` options). Could you take a look and tell me if you are fine with this approach. Also, do you know a `Bath` configuration that would result in evolution similar to `mesolve` so we could use it in tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120
https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120:315,Testability,test,tests,315,"@hodgestar, to make it work with HEOM, I had to change `step` to return `rho` directly, (controlled by the `store_ados` options). Could you take a look and tell me if you are fine with this approach. Also, do you know a `Bath` configuration that would result in evolution similar to `mesolve` so we could use it in tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335538079:405,Usability,simpl,simplify,405,"The current `.evolve_dm` and `.sys_dims` concepts both seem a bit awkward, so I'd like to suggest the following:. **For `.evolve_dm`**:. Replace `.evolve_dm` with a `.unitary` attribute on the solver itself. The attribute should be `True` if that particular instance of the solver can guarantee that the evolution it produces is unitary, and `False` otherwise. This will be more generally useful and will simplify the code inside the propagator a bit. **For `.sys_dims`**:. The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise. I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. **Specifying which solvers support propagators**:. Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335538079
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:1792,Availability,error,error,1792,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:2274,Deployability,integrat,integrator,2274,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:2306,Deployability,integrat,integrator,2306,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:1798,Integrability,message,message,1798,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:2274,Integrability,integrat,integrator,2274,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:2306,Integrability,integrat,integrator,2306,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:2324,Modifiability,evolve,evolve,2324,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:426,Usability,simpl,simplify,426,"> The current `.evolve_dm` and `.sys_dims` concepts both seem a bit awkward, so I'd like to suggest the following:; > ; > **For `.evolve_dm`**:; > ; > Replace `.evolve_dm` with a `.unitary` attribute on the solver itself. The attribute should be `True` if that particular instance of the solver can guarantee that the evolution it produces is unitary, and `False` otherwise.; > ; > This will be more generally useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120
https://github.com/qutip/qutip/pull/2000#issuecomment-1256990030:396,Security,access,accessible,396,"Hey @Ericgig.This is a great feature! I wanted to suggest a slightly different implementation that would work also for non constant cases. We could do checking that the f(t) value is real and that all elements are hermitian. However, the following does not seem to work for me (on a jupyter noteebok with latest dev.major):; ```python; qutip.QobjEvo(qt.sigmax()).elements; ```; are elements only accessible from cython?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1256990030
https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808:90,Safety,safe,safe,90,"@AGaliciaMartinez The `.elements` are intentionally only accessible from Cython (it's not safe to modify the list from Python because the QobjEvo element lists are meant to be immutable). If you have an idea for a cleaner implementation of this though, maybe just write the idea here and then we can all look at it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808
https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808:57,Security,access,accessible,57,"@AGaliciaMartinez The `.elements` are intentionally only accessible from Cython (it's not safe to modify the list from Python because the QobjEvo element lists are meant to be immutable). If you have an idea for a cleaner implementation of this though, maybe just write the idea here and then we can all look at it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808
https://github.com/qutip/qutip/pull/2000#issuecomment-1257265957:331,Energy Efficiency,efficient,efficient,331,"I was thinking something on the same lines as in `__mul__`for `Qobj`:; ```python; coeff_real = all(element.coeff(t).imag==0 for element in self.elements) ; data_herm = all(element.part(t).isherm for element in self.elements); return Qobj(..., isherm=(coeff_real and data_herm) or None); ```; Although I imagine it can be made more efficient by not looping twice in self.elements and probably using the loop in `_call`method. This way you always try to guess the hermeticity of QobjEvo even if it is not constant.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1257265957
https://github.com/qutip/qutip/pull/2002#issuecomment-1267059737:181,Availability,avail,available,181,"`svd` is used by `steadystate`. There are no method in common between `Dense` and `CSR`, the default is `solve` for `Dense`, but `spsolve` for `CSR`. All iterative methods are only available in `sparse.linalg`... So we cannot pass it anywhere thus I think it won't be hard to remember. If we want to have the default change depending on whether we have mkl or not, we could read the default method from core's settings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2002#issuecomment-1267059737
https://github.com/qutip/qutip/pull/2002#issuecomment-1267059737:324,Integrability,depend,depending,324,"`svd` is used by `steadystate`. There are no method in common between `Dense` and `CSR`, the default is `solve` for `Dense`, but `spsolve` for `CSR`. All iterative methods are only available in `sparse.linalg`... So we cannot pass it anywhere thus I think it won't be hard to remember. If we want to have the default change depending on whether we have mkl or not, we could read the default method from core's settings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2002#issuecomment-1267059737
https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:901,Deployability,update,updates,901,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054
https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:258,Energy Efficiency,adapt,adaptive,258,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054
https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:842,Energy Efficiency,adapt,adaptively,842,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054
https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:258,Modifiability,adapt,adaptive,258,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054
https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:842,Modifiability,adapt,adaptively,842,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054
https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:166,Testability,test,testing,166,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054
https://github.com/qutip/qutip/pull/2008#issuecomment-1297569831:92,Testability,benchmark,benchmarks,92,"Also fixed dense matmul to use `zgemv` for `oper@ket`.; In the `oper @ ket` [matmul scaling benchmarks](https://qutip.org/qutip-benchmark/s_matmul.html), `Dense` is slower than `numpy`. Our dense data layer used `zgemm` for both matrix @ matrix and matrix @ vector operations. By switching to `zgemv` we get closer to numpy's times: faster in `C` format but slower in `Fortran`.; `bra@oper` still use `zgemm`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2008#issuecomment-1297569831
https://github.com/qutip/qutip/pull/2008#issuecomment-1297569831:128,Testability,benchmark,benchmark,128,"Also fixed dense matmul to use `zgemv` for `oper@ket`.; In the `oper @ ket` [matmul scaling benchmarks](https://qutip.org/qutip-benchmark/s_matmul.html), `Dense` is slower than `numpy`. Our dense data layer used `zgemm` for both matrix @ matrix and matrix @ vector operations. By switching to `zgemv` we get closer to numpy's times: faster in `C` format but slower in `Fortran`.; `bra@oper` still use `zgemm`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2008#issuecomment-1297569831
https://github.com/qutip/qutip/pull/2012#issuecomment-1291128875:24,Performance,perform,perform,24,I'm not too sure how to perform cascading PRs on a forked repository ... ?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2012#issuecomment-1291128875
https://github.com/qutip/qutip/pull/2013#issuecomment-1317836479:27,Testability,test,test,27,"@hodgestar Let's rerun the test a few times to see if it works.; If after ~5 tries, the windows tests always passes. I will approve.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1317836479
https://github.com/qutip/qutip/pull/2013#issuecomment-1317836479:96,Testability,test,tests,96,"@hodgestar Let's rerun the test a few times to see if it works.; If after ~5 tries, the windows tests always passes. I will approve.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1317836479
https://github.com/qutip/qutip/pull/2013#issuecomment-1318339342:234,Testability,test,test-flakiness-on-windows,234,[![Coverage Status](https://coveralls.io/builds/54311514/badge)](https://coveralls.io/builds/54311514). Coverage remained the same at 69.919% when pulling **cb585f21fdaa441d98aa5004e179a9e4c83cf485 on hodgestar:feature/fix-matplotlib-test-flakiness-on-windows** into **b79c7cca9f67dcdaca141b4c1a32be9c7279cb4d on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1318339342
https://github.com/qutip/qutip/pull/2013#issuecomment-1318447588:2,Testability,test,test,2,3 test runs successful and 4th started.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1318447588
https://github.com/qutip/qutip/pull/2013#issuecomment-1318533244:4,Testability,test,test,4,All test runs passed. @Ericgig I'm going to merge so that other PRs can merge this in. Should I also create a PR for dev.major?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1318533244
https://github.com/qutip/qutip/pull/2014#issuecomment-1297498455:170,Testability,test,tests,170,"We already have a separate repo for lattice: https://github.com/qutip/qutip-lattice.; Make a PR for that repo, there is nothing to do here. From v5, all lattice code and tests will be removed from this repo and only https://github.com/qutip/qutip-lattice will remain.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2014#issuecomment-1297498455
https://github.com/qutip/qutip/pull/2015#issuecomment-1438679479:119,Availability,error,error,119,"> My biggest concern is with the addition of `**_` to some of the functions, I would argue that it is best to raise an error if the function does not have arguments. this may lead to code that works on jax being incompatible with code that works on just qutip though, so it is something to think about. We pass unused arguments when we mix different types of coefficients in solver and `QobjEvo`. So we cannot raise an error. > I could be an interesting idea for the future to consider adding a similar context manager that removes other dtypes (`CSR` and `Dense`) so that it is clear what the code is doing?. I don't understand what you mean by this... A context manager that remove dtype from those known to the dispatcher?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2015#issuecomment-1438679479
https://github.com/qutip/qutip/pull/2015#issuecomment-1438679479:419,Availability,error,error,419,"> My biggest concern is with the addition of `**_` to some of the functions, I would argue that it is best to raise an error if the function does not have arguments. this may lead to code that works on jax being incompatible with code that works on just qutip though, so it is something to think about. We pass unused arguments when we mix different types of coefficients in solver and `QobjEvo`. So we cannot raise an error. > I could be an interesting idea for the future to consider adding a similar context manager that removes other dtypes (`CSR` and `Dense`) so that it is clear what the code is doing?. I don't understand what you mean by this... A context manager that remove dtype from those known to the dispatcher?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2015#issuecomment-1438679479
https://github.com/qutip/qutip/pull/2015#issuecomment-1438679479:579,Usability,clear,clear,579,"> My biggest concern is with the addition of `**_` to some of the functions, I would argue that it is best to raise an error if the function does not have arguments. this may lead to code that works on jax being incompatible with code that works on just qutip though, so it is something to think about. We pass unused arguments when we mix different types of coefficients in solver and `QobjEvo`. So we cannot raise an error. > I could be an interesting idea for the future to consider adding a similar context manager that removes other dtypes (`CSR` and `Dense`) so that it is clear what the code is doing?. I don't understand what you mean by this... A context manager that remove dtype from those known to the dispatcher?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2015#issuecomment-1438679479
https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575:190,Deployability,release,release,190,"It will be useful for solver feedback.; In v4 we can define Hamiltonian to depend on the state: `H(t, args, psi/rho)`.; We don't have it working in v5, but we will need to restore it before release.; This `_prepare` catch the time and state at the start of `matmul` and `expect` and update the arguments according to feedback.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575
https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575:283,Deployability,update,update,283,"It will be useful for solver feedback.; In v4 we can define Hamiltonian to depend on the state: `H(t, args, psi/rho)`.; We don't have it working in v5, but we will need to restore it before release.; This `_prepare` catch the time and state at the start of `matmul` and `expect` and update the arguments according to feedback.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575
https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575:75,Integrability,depend,depend,75,"It will be useful for solver feedback.; In v4 we can define Hamiltonian to depend on the state: `H(t, args, psi/rho)`.; We don't have it working in v5, but we will need to restore it before release.; This `_prepare` catch the time and state at the start of `matmul` and `expect` and update the arguments according to feedback.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575
https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575:29,Usability,feedback,feedback,29,"It will be useful for solver feedback.; In v4 we can define Hamiltonian to depend on the state: `H(t, args, psi/rho)`.; We don't have it working in v5, but we will need to restore it before release.; This `_prepare` catch the time and state at the start of `matmul` and `expect` and update the arguments according to feedback.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575
https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575:317,Usability,feedback,feedback,317,"It will be useful for solver feedback.; In v4 we can define Hamiltonian to depend on the state: `H(t, args, psi/rho)`.; We don't have it working in v5, but we will need to restore it before release.; This `_prepare` catch the time and state at the start of `matmul` and `expect` and update the arguments according to feedback.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2016#issuecomment-1302681575
https://github.com/qutip/qutip/pull/2017#issuecomment-1302788072:521,Testability,test,testing,521,"Before:; <img width=""863"" alt=""Screen Shot 2022-11-03 at 4 19 25 PM"" src=""https://user-images.githubusercontent.com/113714002/199853312-2f6880df-09dc-43cc-9c0b-8e1daa15a49f.png"">. After:; <img width=""704"" alt=""Screen Shot 2022-11-03 at 4 17 55 PM"" src=""https://user-images.githubusercontent.com/113714002/199853348-0eb3e5b2-8f20-496f-96fe-d97d27860f93.png"">. Been playing around with the `$` placement but can't seem to get it right, it returns the output like the first picture. Help here is appreciated, it's very slow testing this having to recompile after small changes (noob here). Edit: <s>Also note I'm not quite getting the newline correct. Doesn't quite behave the way I would expect latex to behave.</s>. Edit 2: Was using a wrong version for the second picture, the correct one does respect the; <img width=""512"" alt=""Screen Shot 2022-11-03 at 4 49 01 PM"" src=""https://user-images.githubusercontent.com/113714002/199856352-825db071-fb7e-4567-b4db-c6d71b8a16df.png"">; newline; Also just read I should be using develop mode, so hopefully testing different things will be faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2017#issuecomment-1302788072
https://github.com/qutip/qutip/pull/2017#issuecomment-1302788072:1047,Testability,test,testing,1047,"Before:; <img width=""863"" alt=""Screen Shot 2022-11-03 at 4 19 25 PM"" src=""https://user-images.githubusercontent.com/113714002/199853312-2f6880df-09dc-43cc-9c0b-8e1daa15a49f.png"">. After:; <img width=""704"" alt=""Screen Shot 2022-11-03 at 4 17 55 PM"" src=""https://user-images.githubusercontent.com/113714002/199853348-0eb3e5b2-8f20-496f-96fe-d97d27860f93.png"">. Been playing around with the `$` placement but can't seem to get it right, it returns the output like the first picture. Help here is appreciated, it's very slow testing this having to recompile after small changes (noob here). Edit: <s>Also note I'm not quite getting the newline correct. Doesn't quite behave the way I would expect latex to behave.</s>. Edit 2: Was using a wrong version for the second picture, the correct one does respect the; <img width=""512"" alt=""Screen Shot 2022-11-03 at 4 49 01 PM"" src=""https://user-images.githubusercontent.com/113714002/199856352-825db071-fb7e-4567-b4db-c6d71b8a16df.png"">; newline; Also just read I should be using develop mode, so hopefully testing different things will be faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2017#issuecomment-1302788072
https://github.com/qutip/qutip/pull/2017#issuecomment-1351838277:37,Usability,learn,learning,37,@hiliuzheng no problem! It was a fun learning experience. Thanks for pointing me in the right direction!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2017#issuecomment-1351838277
https://github.com/qutip/qutip/issues/2018#issuecomment-1317635091:301,Usability,clear,clear,301,"Just changing the docstring to something like ""_If tlist is None, `tlist=[0]` is assumed and the corresponding correlation matrix returned._"" should be enough, I think. ; The implementation in QuTiP 4 returned this 1D array, which confused me. Changing the behavior broke one tutorial notebook, but a clear docstring should help users to see what the problem is.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2018#issuecomment-1317635091
https://github.com/qutip/qutip/issues/2018#issuecomment-1319812997:14,Deployability,update,updated,14,Documentation updated in #2021.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2018#issuecomment-1319812997
https://github.com/qutip/qutip/pull/2022#issuecomment-1319739195:237,Testability,test,test-flakiness-on-windows,237,[![Coverage Status](https://coveralls.io/builds/54352960/badge)](https://coveralls.io/builds/54352960). Coverage remained the same at 72.139% when pulling **edad48ec43fabd8ccd32c45853563b0c2055de79 on hodgestar:feature/v5/fix-matplotlib-test-flakiness-on-windows** into **88fea8427be9a26ac99b58bdba39c55b79a9cfc9 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2022#issuecomment-1319739195
https://github.com/qutip/qutip/pull/2023#issuecomment-1323508204:201,Integrability,depend,dependabot,201,[![Coverage Status](https://coveralls.io/builds/54454836/badge)](https://coveralls.io/builds/54454836). Coverage increased (+0.02%) to 69.94% when pulling **c00b13fd99d4f847e0d768c06cfc2f0c52bedf92 on dependabot/pip/doc/pillow-9.3.0** into **b29ca42b9931f029a8d1aa278c4ac75366c81a1a on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2023#issuecomment-1323508204
https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564:113,Deployability,install,installing,113,"There isn't a QuTiP build for Apple ARM CPUs on PyPI because we don't have the hardware to build it. I recommend installing from conda-forge by following the instructions at https://qutip.org/docs/latest/installation.html#installing-with-conda. You can also compile from source yourself by installing all the necessary dependencies, but I think try conda-forge first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564
https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564:204,Deployability,install,installation,204,"There isn't a QuTiP build for Apple ARM CPUs on PyPI because we don't have the hardware to build it. I recommend installing from conda-forge by following the instructions at https://qutip.org/docs/latest/installation.html#installing-with-conda. You can also compile from source yourself by installing all the necessary dependencies, but I think try conda-forge first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564
https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564:222,Deployability,install,installing-with-conda,222,"There isn't a QuTiP build for Apple ARM CPUs on PyPI because we don't have the hardware to build it. I recommend installing from conda-forge by following the instructions at https://qutip.org/docs/latest/installation.html#installing-with-conda. You can also compile from source yourself by installing all the necessary dependencies, but I think try conda-forge first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564
https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564:290,Deployability,install,installing,290,"There isn't a QuTiP build for Apple ARM CPUs on PyPI because we don't have the hardware to build it. I recommend installing from conda-forge by following the instructions at https://qutip.org/docs/latest/installation.html#installing-with-conda. You can also compile from source yourself by installing all the necessary dependencies, but I think try conda-forge first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564
https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564:319,Integrability,depend,dependencies,319,"There isn't a QuTiP build for Apple ARM CPUs on PyPI because we don't have the hardware to build it. I recommend installing from conda-forge by following the instructions at https://qutip.org/docs/latest/installation.html#installing-with-conda. You can also compile from source yourself by installing all the necessary dependencies, but I think try conda-forge first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2027#issuecomment-1335129564
https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866:104,Availability,toler,tolerance,104,"I see it as `v4` being wrong instead of `dev.major`. It should not truncate small values with an hidden tolerance.; Here it's the sparse matrix operations which drop small values to stay sparse that cause the change. In v5, these operations are done using dense matrices. However this should have been the case for a long time... The test `p != 0` is always risky with floating number, we should use `p >= tol` with a documented tolerance instead. The `atol` from core options would work here, but we could also have the tolerance as an optional input to measurement functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866
https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866:429,Availability,toler,tolerance,429,"I see it as `v4` being wrong instead of `dev.major`. It should not truncate small values with an hidden tolerance.; Here it's the sparse matrix operations which drop small values to stay sparse that cause the change. In v5, these operations are done using dense matrices. However this should have been the case for a long time... The test `p != 0` is always risky with floating number, we should use `p >= tol` with a documented tolerance instead. The `atol` from core options would work here, but we could also have the tolerance as an optional input to measurement functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866
https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866:521,Availability,toler,tolerance,521,"I see it as `v4` being wrong instead of `dev.major`. It should not truncate small values with an hidden tolerance.; Here it's the sparse matrix operations which drop small values to stay sparse that cause the change. In v5, these operations are done using dense matrices. However this should have been the case for a long time... The test `p != 0` is always risky with floating number, we should use `p >= tol` with a documented tolerance instead. The `atol` from core options would work here, but we could also have the tolerance as an optional input to measurement functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866
https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866:358,Safety,risk,risky,358,"I see it as `v4` being wrong instead of `dev.major`. It should not truncate small values with an hidden tolerance.; Here it's the sparse matrix operations which drop small values to stay sparse that cause the change. In v5, these operations are done using dense matrices. However this should have been the case for a long time... The test `p != 0` is always risky with floating number, we should use `p >= tol` with a documented tolerance instead. The `atol` from core options would work here, but we could also have the tolerance as an optional input to measurement functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866
https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866:334,Testability,test,test,334,"I see it as `v4` being wrong instead of `dev.major`. It should not truncate small values with an hidden tolerance.; Here it's the sparse matrix operations which drop small values to stay sparse that cause the change. In v5, these operations are done using dense matrices. However this should have been the case for a long time... The test `p != 0` is always risky with floating number, we should use `p >= tol` with a documented tolerance instead. The `atol` from core options would work here, but we could also have the tolerance as an optional input to measurement functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866
https://github.com/qutip/qutip/issues/2029#issuecomment-1336427119:648,Availability,toler,tolerance,648,"It would be good to understand why the qutip-qip test started failing now. Perhaps it is related to the new specializations for dense that were merged on Friday? Previously some operations that went via the sparse data layer may have been tidied up and now they are not. The use of `p != 0` existed in version 4 and is, I think, correct in this particular case. If a POVM is supplied as a list of operators, and some of those operators have zero probability, then one cannot provide a normalized final density matrix, but one still needs to return a value to the user, since they specifically asked about that POVM. Perhaps qutip-qip could apply a tolerance itself on the returned probabilities?. We could also add an atol parameter to some measurement functions for v5, but I think that ship has sailed for 4.7.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336427119
https://github.com/qutip/qutip/issues/2029#issuecomment-1336427119:49,Testability,test,test,49,"It would be good to understand why the qutip-qip test started failing now. Perhaps it is related to the new specializations for dense that were merged on Friday? Previously some operations that went via the sparse data layer may have been tidied up and now they are not. The use of `p != 0` existed in version 4 and is, I think, correct in this particular case. If a POVM is supplied as a list of operators, and some of those operators have zero probability, then one cannot provide a normalized final density matrix, but one still needs to return a value to the user, since they specifically asked about that POVM. Perhaps qutip-qip could apply a tolerance itself on the returned probabilities?. We could also add an atol parameter to some measurement functions for v5, but I think that ship has sailed for 4.7.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336427119
https://github.com/qutip/qutip/issues/2029#issuecomment-1336432722:507,Availability,toler,tolerance,507,> Perhaps it is related to the new specializations for dense that were merged on Friday? Previously some operations that went via the sparse data layer may have been tidied up and now they are not. That could be the reason. I posted this just in case there are some undesired changes that got merged accidentally. It is not difficult to fix it on the side of `qutip-qip`. Just add a filter to the probabilities and states. I agree that we could use the `atol` from core options by default and perhaps add a tolerance parameter to some measurement functions.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336432722
https://github.com/qutip/qutip/pull/2035#issuecomment-1342951991:49,Deployability,release,release,49,"The tests failed because of the recent packaging release (see #2037). The documentation builds passed though, so I'm merging this change to the documentation requirements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2035#issuecomment-1342951991
https://github.com/qutip/qutip/pull/2035#issuecomment-1342951991:4,Testability,test,tests,4,"The tests failed because of the recent packaging release (see #2037). The documentation builds passed though, so I'm merging this change to the documentation requirements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2035#issuecomment-1342951991
https://github.com/qutip/qutip/issues/2036#issuecomment-1342764859:184,Availability,error,error,184,"Thanks for reporting this. The new version of packaging removed LegacyVersion. They deprecated *constructing* LegacyVersion for two years, but not doing the right thing and raising an error on LegacyVersion ourselves (which we do). So we'll have to remove our check and release 4.7.1 to fix this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1342764859
https://github.com/qutip/qutip/issues/2036#issuecomment-1342764859:270,Deployability,release,release,270,"Thanks for reporting this. The new version of packaging removed LegacyVersion. They deprecated *constructing* LegacyVersion for two years, but not doing the right thing and raising an error on LegacyVersion ourselves (which we do). So we'll have to remove our check and release 4.7.1 to fix this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1342764859
https://github.com/qutip/qutip/issues/2036#issuecomment-1342844102:115,Deployability,release,released,115,"It doesn't fail on Python 3.10 and below, because there are pre-built wheels for those Pythons. Python 3.11 wasn't released when 4.7.0 came out, so there aren't prebuilt wheels for that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1342844102
https://github.com/qutip/qutip/issues/2036#issuecomment-1342861183:59,Modifiability,inherit,inherited,59,This also affects qutip-qip and other family packages that inherited the qutip `setup.py` file.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1342861183
https://github.com/qutip/qutip/issues/2036#issuecomment-1344152741:98,Deployability,release,release,98,"Thanks for your work on this, @hodgestar . I hope you don't mind me asking: do you have a planned release date for `v4.7.1`? I just need to know so that I can decide whether I wait for it to be released or if I look for a temporary workaround.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1344152741
https://github.com/qutip/qutip/issues/2036#issuecomment-1344152741:194,Deployability,release,released,194,"Thanks for your work on this, @hodgestar . I hope you don't mind me asking: do you have a planned release date for `v4.7.1`? I just need to know so that I can decide whether I wait for it to be released or if I look for a temporary workaround.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1344152741
https://github.com/qutip/qutip/issues/2036#issuecomment-1344178773:17,Deployability,release,release,17,"We'll have a new release before Monday, and maybe today.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1344178773
https://github.com/qutip/qutip/issues/2036#issuecomment-1346425908:93,Deployability,release,release,93,"I'm busy checking builds in #2046, and hopefully once those are running successfully, we can release. It's the usual dance of figuring out which versions of SciPy and numpy to build for.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1346425908
https://github.com/qutip/qutip/issues/2036#issuecomment-1347417696:21,Deployability,release,released,21,QuTiP 4.7.1 has been released to PyPI -- https://pypi.org/project/qutip/4.7.1/ -- and `pip install qutip` now works for me on Python 3.11.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1347417696
https://github.com/qutip/qutip/issues/2036#issuecomment-1347417696:91,Deployability,install,install,91,QuTiP 4.7.1 has been released to PyPI -- https://pypi.org/project/qutip/4.7.1/ -- and `pip install qutip` now works for me on Python 3.11.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1347417696
https://github.com/qutip/qutip/pull/2040#issuecomment-1344175267:442,Availability,down,downside,442,"@Ericgig I am wondering whether in v5.1 we should add a way for users to specify the timescale of a QobjEvo. At the moment if one knows the timescale when calling the solver one can just set max step, but in code like Boxi's where one is handling QobjEvos or pulses that were created somewhere else, it can be a lot of extra work to determine what the max_step should be, and it would be good if the QobjEvo already had that information. The downside is that one might have to specify the time step when creating the QobjEvo, and that might be too annoying or too easy to forget to do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2040#issuecomment-1344175267
https://github.com/qutip/qutip/pull/2041#issuecomment-1344657806:9,Deployability,install,install,9,We could install without `semidefinite` for 3.11 to remove `cvxopt` from the requirement.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2041#issuecomment-1344657806
https://github.com/qutip/qutip/pull/2041#issuecomment-1345397044:63,Deployability,release,release,63,I'm keen to merge this and make this the last PR for the 4.7.1 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2041#issuecomment-1345397044
https://github.com/qutip/qutip/pull/2041#issuecomment-1345571497:64,Testability,test,tests,64,"@hodgestar Are you sure this was ready to be merged?; While the tests part look fine, have you checked that the wheels will build properly? Is there no need to tell the tools building the wheels were to find python 3.11? With 3.10 we skipped some build, (win32, etc.), don't we need to do the same for 3.11?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2041#issuecomment-1345571497
https://github.com/qutip/qutip/pull/2043#issuecomment-1345273111:219,Usability,simpl,simplify-version-parsing,219,[![Coverage Status](https://coveralls.io/builds/55037385/badge)](https://coveralls.io/builds/55037385). Coverage remained the same at 69.926% when pulling **ab7bfb5fe516bab2c3bbe4785a779e02d085266a on hodgestar:feature/simplify-version-parsing** into **52b222e9d4fbe143ef27522b2faa2db33d1043d1 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2043#issuecomment-1345273111
https://github.com/qutip/qutip/pull/2043#issuecomment-1345288271:88,Deployability,release,release,88,"Merging since this looks straight forward and it would be good to have it for the 4.7.1 release, but would appreciate post-merge review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2043#issuecomment-1345288271
https://github.com/qutip/qutip/pull/2044#issuecomment-1345270392:221,Usability,simpl,simplify-version-parsing,221,[![Coverage Status](https://coveralls.io/builds/55037246/badge)](https://coveralls.io/builds/55037246). Coverage remained the same at 72.23% when pulling **2fc35ba8c6017a8c71e9ee40fe72be2b994c5f09 on hodgestar:feature/v5-simplify-version-parsing** into **169b000bfdffc3555984a1f4df0f36d0b40f5527 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2044#issuecomment-1345270392
https://github.com/qutip/qutip/pull/2047#issuecomment-1346770727:96,Testability,test,tests,96,"I'm going to merge these changes into master, so that I can merge master into #2046 and let the tests run one final time there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2047#issuecomment-1346770727
https://github.com/qutip/qutip/pull/2048#issuecomment-1351593301:87,Deployability,release,release,87,I also deactivated towncrier in this that we need to remember to add back for the full release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2048#issuecomment-1351593301
https://github.com/qutip/qutip/pull/2049#issuecomment-1354531823:211,Deployability,patch,patch-,211,[![Coverage Status](https://coveralls.io/builds/55225653/badge)](https://coveralls.io/builds/55225653). Coverage remained the same at 69.926% when pulling **e0747ab227153f16854be1a5e54a070dc8d0bded on eltociear:patch-1** into **ff9ada8cbab96b98e3163e9f5c9337c29ca59ac1 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2049#issuecomment-1354531823
https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677:77,Integrability,depend,dependent,77,"It appears that the coefficients in your Hamiltonian are large, and the time-dependent part of the Hamiltonian oscillates very rapidly, The result is that the solver does not by default take small enough time steps when evolving the state. You can fix this by specifying a `max_step` to the `Options`:; ```python; max_step = 1. / (100 * gamma); options = Options(max_step=max_step, nsteps=10000); ```; With this max_step the solver correctly evolves the system for me. Closing this for now, but please feel free to continue the discussion here as needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677
https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677:442,Modifiability,evolve,evolves,442,"It appears that the coefficients in your Hamiltonian are large, and the time-dependent part of the Hamiltonian oscillates very rapidly, The result is that the solver does not by default take small enough time steps when evolving the state. You can fix this by specifying a `max_step` to the `Options`:; ```python; max_step = 1. / (100 * gamma); options = Options(max_step=max_step, nsteps=10000); ```; With this max_step the solver correctly evolves the system for me. Closing this for now, but please feel free to continue the discussion here as needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677
https://github.com/qutip/qutip/issues/2058#issuecomment-1384473486:315,Integrability,depend,depending,315,"Hi @epelofske-LANL. This behaviour in QuTiP is intentional for the following reason: If the dims of the system are `[2, 2]` then it's unambiguous how the system should be partitioned into two parts because the dims specify what the two parts. If the dims are `[4]` then one could divide the system in multiple ways depending on how one considers the four basis vectors. If one knows that the four basis states are `00`, `01`, `10`, `11`, one can override the dims by writing `dm.dims = [[2, 2], [2, 2]]` or `qutip.Qobj(dm, dims=[[2, 2], [2, 2]])`. Hope this helps. I agree this could be made more intuitive. Perhaps `maximally_mixed_dm` should allow specifying `dims` too instead of just `N`. I'm closing this issue for now, but please feel free to continue the discussion in the comments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2058#issuecomment-1384473486
https://github.com/qutip/qutip/issues/2058#issuecomment-1384473486:597,Usability,intuit,intuitive,597,"Hi @epelofske-LANL. This behaviour in QuTiP is intentional for the following reason: If the dims of the system are `[2, 2]` then it's unambiguous how the system should be partitioned into two parts because the dims specify what the two parts. If the dims are `[4]` then one could divide the system in multiple ways depending on how one considers the four basis vectors. If one knows that the four basis states are `00`, `01`, `10`, `11`, one can override the dims by writing `dm.dims = [[2, 2], [2, 2]]` or `qutip.Qobj(dm, dims=[[2, 2], [2, 2]])`. Hope this helps. I agree this could be made more intuitive. Perhaps `maximally_mixed_dm` should allow specifying `dims` too instead of just `N`. I'm closing this issue for now, but please feel free to continue the discussion in the comments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2058#issuecomment-1384473486
https://github.com/qutip/qutip/issues/2060#issuecomment-1385475587:154,Availability,error,error,154,"No, not yet, it will be supported in v5.; You could try to use `photocurrent_mesolve` which is very similar, but with a slower algorithm. ps. There is an error in the formula in the [documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-photocurrent.html#open-system):; L_eff(rho) = L(rho) - C_dag*C*rho - rho*C_dag*C + tr(C_dag*C*rho - rho*C_dag*C)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2060#issuecomment-1385475587
https://github.com/qutip/qutip/issues/2060#issuecomment-1385475587:228,Usability,guid,guide,228,"No, not yet, it will be supported in v5.; You could try to use `photocurrent_mesolve` which is very similar, but with a slower algorithm. ps. There is an error in the formula in the [documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-photocurrent.html#open-system):; L_eff(rho) = L(rho) - C_dag*C*rho - rho*C_dag*C + tr(C_dag*C*rho - rho*C_dag*C)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2060#issuecomment-1385475587
https://github.com/qutip/qutip/pull/2064#issuecomment-1408690839:38,Deployability,integrat,integrator,38,"@AGaliciaMartinez,; I already made an integrator for jax in qutip/qutip-jax#14 and made and an example for auto-differentiation in `sesolve` using it.; There is still some polishing to do, but half of the deliverable are there. We should ask the student to use it to makes new tools with it and improve the interface.; Using it for quantum control is impractical since `jax.grad` only support real scalar output and our inputs are also complex.; We need to find an user friendly a way to tell which part of the result are subject to the derivation and how to expand to jacobians, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2064#issuecomment-1408690839
https://github.com/qutip/qutip/pull/2064#issuecomment-1408690839:38,Integrability,integrat,integrator,38,"@AGaliciaMartinez,; I already made an integrator for jax in qutip/qutip-jax#14 and made and an example for auto-differentiation in `sesolve` using it.; There is still some polishing to do, but half of the deliverable are there. We should ask the student to use it to makes new tools with it and improve the interface.; Using it for quantum control is impractical since `jax.grad` only support real scalar output and our inputs are also complex.; We need to find an user friendly a way to tell which part of the result are subject to the derivation and how to expand to jacobians, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2064#issuecomment-1408690839
https://github.com/qutip/qutip/pull/2064#issuecomment-1408690839:307,Integrability,interface,interface,307,"@AGaliciaMartinez,; I already made an integrator for jax in qutip/qutip-jax#14 and made and an example for auto-differentiation in `sesolve` using it.; There is still some polishing to do, but half of the deliverable are there. We should ask the student to use it to makes new tools with it and improve the interface.; Using it for quantum control is impractical since `jax.grad` only support real scalar output and our inputs are also complex.; We need to find an user friendly a way to tell which part of the result are subject to the derivation and how to expand to jacobians, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2064#issuecomment-1408690839
https://github.com/qutip/qutip/pull/2064#issuecomment-1412749534:28,Deployability,update,update,28,"Hi @Ericgig, thanks for the update! when I was checking the status of the project I did not take a look at the PR. Indeed, with halve the deliverables already finished in the PR this proposal does not make much sense. I am closing this for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2064#issuecomment-1412749534
https://github.com/qutip/qutip/issues/2065#issuecomment-1408604158:241,Availability,error,error,241,"- 1, 2: Solvers expect list, not tuple. In a few places, we do not explicitly test for list but only extract the elements, so tuple should behave the same, but it's untested. In my tries with `mesolve` they seems to behave the same or raise error. - 3: `c_ops=[C_0, C_1, [(\hat{a}, f(t)), (\hat{b}, c(t))]]` should work in `mesolve` with `[(\hat{a}, f(t)), (\hat{b}, c(t))]` as the third collapse operator.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1408604158
https://github.com/qutip/qutip/issues/2065#issuecomment-1408604158:78,Testability,test,test,78,"- 1, 2: Solvers expect list, not tuple. In a few places, we do not explicitly test for list but only extract the elements, so tuple should behave the same, but it's untested. In my tries with `mesolve` they seems to behave the same or raise error. - 3: `c_ops=[C_0, C_1, [(\hat{a}, f(t)), (\hat{b}, c(t))]]` should work in `mesolve` with `[(\hat{a}, f(t)), (\hat{b}, c(t))]` as the third collapse operator.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1408604158
https://github.com/qutip/qutip/issues/2065#issuecomment-1410024050:266,Usability,simpl,simple,266,"Thanks for the fast response! It helps a lot! . As an additional question, with the list of tuples in #3, what happens if it is a list of lists instead?. Regarding 1/2: ; In my code, using tuples does result in different behaviour. I cannot (so far) think of a good simple example to reproduce this though, and am hesitant to upload the full code in which I see the difference as it is work in progress. What I can say is that when looking at expectation values after running mesolve, the list-vs-tuple question seems to not matter, at least for the things I tend to look at. However, when using qt.correlations_2op_2t, the results are very drastically different, and it seems to me that using tuples actually gets results closer to what I would expect to see. But I'm very suspicious of trusting numerical results that arise from using definitions in ways contrary to the documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410024050
https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:56,Integrability,depend,dependent,56,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360
https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:260,Integrability,depend,dependent,260,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360
https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:85,Modifiability,layers,layers,85,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360
https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:127,Testability,test,test,127,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360
https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:237,Testability,test,tested,237,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360
https://github.com/qutip/qutip/pull/2070#issuecomment-1414634007:1897,Deployability,integrat,integrator,1897," this solver? It seems to be able to produce states which trace is not one, which seems strange. Thank you for your detailed comments! We are here at RIKEN working together with the authors of the paper linked above to try and add this functionality to qutip. So far, this PR is just a starting point for the collaboration, but proper documentation and examples are high on our priority list. To add some very quick explanation here: the master equation describing a general completely positive (but not necessarily CP-divisible) map can involve rate functions that become negative at some times. The usual Monte-Carlo algorithm cannot be applied in this case, but Donvil et al. describe [here](https://www.nature.com/articles/s41467-022-31533-8) and [here](https://arxiv.org/abs/2209.08958) a workaround where states are weighted with an ""influence martingale"". Including this weight, the involved states are indeed not normalized; however, the state that results from an average over sufficiently many trajectories is normalized. (Checking *how well* the average is normalized could maybe be used as an indicator of how good the convergence is, as noted at the top.). > I am not too sure about adding the time parameter to `_restore_state`. In floquet, the state produced need a basis change depending on time, but it was put in the `Result` so the state before and after the transformation can be stored. Maybe something like this would be useful, it would allow the `mu` to be saved in results. Putting this calculation into the `Result` instead does sound reasonable to me. I am unsure how to achieve that in practice though, since the result class used for a single trajectory is hard-coded in mcsolve:; ```; result = Result(e_ops, {**self.options, ""normalize_output"": False}); ```; Note that in principle, we could also get the time from the integrator in _restore_state without adding it as a function parameter. Tagging @hodgestar who suggested adding the time parameter to `_restore_state`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1414634007
https://github.com/qutip/qutip/pull/2070#issuecomment-1414634007:1342,Integrability,depend,depending,1342," this solver? It seems to be able to produce states which trace is not one, which seems strange. Thank you for your detailed comments! We are here at RIKEN working together with the authors of the paper linked above to try and add this functionality to qutip. So far, this PR is just a starting point for the collaboration, but proper documentation and examples are high on our priority list. To add some very quick explanation here: the master equation describing a general completely positive (but not necessarily CP-divisible) map can involve rate functions that become negative at some times. The usual Monte-Carlo algorithm cannot be applied in this case, but Donvil et al. describe [here](https://www.nature.com/articles/s41467-022-31533-8) and [here](https://arxiv.org/abs/2209.08958) a workaround where states are weighted with an ""influence martingale"". Including this weight, the involved states are indeed not normalized; however, the state that results from an average over sufficiently many trajectories is normalized. (Checking *how well* the average is normalized could maybe be used as an indicator of how good the convergence is, as noted at the top.). > I am not too sure about adding the time parameter to `_restore_state`. In floquet, the state produced need a basis change depending on time, but it was put in the `Result` so the state before and after the transformation can be stored. Maybe something like this would be useful, it would allow the `mu` to be saved in results. Putting this calculation into the `Result` instead does sound reasonable to me. I am unsure how to achieve that in practice though, since the result class used for a single trajectory is hard-coded in mcsolve:; ```; result = Result(e_ops, {**self.options, ""normalize_output"": False}); ```; Note that in principle, we could also get the time from the integrator in _restore_state without adding it as a function parameter. Tagging @hodgestar who suggested adding the time parameter to `_restore_state`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1414634007
https://github.com/qutip/qutip/pull/2070#issuecomment-1414634007:1897,Integrability,integrat,integrator,1897," this solver? It seems to be able to produce states which trace is not one, which seems strange. Thank you for your detailed comments! We are here at RIKEN working together with the authors of the paper linked above to try and add this functionality to qutip. So far, this PR is just a starting point for the collaboration, but proper documentation and examples are high on our priority list. To add some very quick explanation here: the master equation describing a general completely positive (but not necessarily CP-divisible) map can involve rate functions that become negative at some times. The usual Monte-Carlo algorithm cannot be applied in this case, but Donvil et al. describe [here](https://www.nature.com/articles/s41467-022-31533-8) and [here](https://arxiv.org/abs/2209.08958) a workaround where states are weighted with an ""influence martingale"". Including this weight, the involved states are indeed not normalized; however, the state that results from an average over sufficiently many trajectories is normalized. (Checking *how well* the average is normalized could maybe be used as an indicator of how good the convergence is, as noted at the top.). > I am not too sure about adding the time parameter to `_restore_state`. In floquet, the state produced need a basis change depending on time, but it was put in the `Result` so the state before and after the transformation can be stored. Maybe something like this would be useful, it would allow the `mu` to be saved in results. Putting this calculation into the `Result` instead does sound reasonable to me. I am unsure how to achieve that in practice though, since the result class used for a single trajectory is hard-coded in mcsolve:; ```; result = Result(e_ops, {**self.options, ""normalize_output"": False}); ```; Note that in principle, we could also get the time from the integrator in _restore_state without adding it as a function parameter. Tagging @hodgestar who suggested adding the time parameter to `_restore_state`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1414634007
https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901:369,Availability,error,error,369,"We have made some progress! But I also have some questions for the experts here.; * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?; * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; * The _run_one_traj function now exists 3 times, with practically identical code:; https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. Side note: due to a WSL bug, some of my commit timestamps are messed up. Because of that, some commits seem to be shown out of order here...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901
https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901:1062,Deployability,integrat,integrate,1062,"We have made some progress! But I also have some questions for the experts here.; * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?; * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; * The _run_one_traj function now exists 3 times, with practically identical code:; https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. Side note: due to a WSL bug, some of my commit timestamps are messed up. Because of that, some commits seem to be shown out of order here...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901
https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901:375,Integrability,message,message,375,"We have made some progress! But I also have some questions for the experts here.; * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?; * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; * The _run_one_traj function now exists 3 times, with practically identical code:; https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. Side note: due to a WSL bug, some of my commit timestamps are messed up. Because of that, some commits seem to be shown out of order here...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901
https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901:1062,Integrability,integrat,integrate,1062,"We have made some progress! But I also have some questions for the experts here.; * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?; * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; * The _run_one_traj function now exists 3 times, with practically identical code:; https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. Side note: due to a WSL bug, some of my commit timestamps are messed up. Because of that, some commits seem to be shown out of order here...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901
https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901:106,Usability,Guid,Guide,106,"We have made some progress! But I also have some questions for the experts here.; * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?; * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; * The _run_one_traj function now exists 3 times, with practically identical code:; https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. Side note: due to a WSL bug, some of my commit timestamps are messed up. Because of that, some commits seem to be shown out of order here...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901
https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901:180,Usability,guid,guide,180,"We have made some progress! But I also have some questions for the experts here.; * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?; * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; * The _run_one_traj function now exists 3 times, with practically identical code:; https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. Side note: due to a WSL bug, some of my commit timestamps are messed up. Because of that, some commits seem to be shown out of order here...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446149901
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:289,Availability,error,error,289,"> * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:353,Availability,error,error,353,"> * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:386,Availability,Error,Error,386,"> * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:2086,Deployability,integrat,integrate,2086,"s (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. ; `step` was renamed to `integrate` a while ago. Good catch!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:2132,Deployability,integrat,integrate,2132,"s (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. ; `step` was renamed to `integrate` a while ago. Good catch!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:295,Integrability,message,message,295,"> * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:2086,Integrability,integrat,integrate,2086,"s (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. ; `step` was renamed to `integrate` a while ago. Good catch!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:2132,Integrability,integrat,integrate,2132,"s (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. ; `step` was renamed to `integrate` a while ago. Good catch!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:26,Usability,Guid,Guide,26,"> * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:100,Usability,guid,guide,100,"> * We have added a Users Guide for the new solver, as a new subsection of the ""Monte Carlo Solver"" guide. On my machine, I can build the documentation without problems (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:235,Deployability,integrat,integrator,235,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:938,Deployability,continuous,continuous,938,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1624,Deployability,integrat,integrator,1624,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1796,Deployability,integrat,integration,1796,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:235,Integrability,integrat,integrator,235,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1624,Integrability,integrat,integrator,1624,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1796,Integrability,integrat,integration,1796,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:298,Safety,avoid,avoid,298,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1024,Security,expose,expose,1024,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1228,Security,expose,exposed,1228,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1713,Security,expose,expose,1713,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1743,Security,expose,exposed,1743,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:78,Testability,test,tests,78,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:774,Testability,test,test,774,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:881,Testability,test,tests,881,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:897,Testability,assert,assertions,897,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1334,Testability,test,test,1334,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1488,Testability,test,tests,1488,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1820,Testability,test,testing,1820,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1836,Testability,test,tests,1836,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354
https://github.com/qutip/qutip/pull/2070#issuecomment-1498867381:12,Deployability,update,updated,12,@pmenczel I updated the PR again to simplify the new Cython code a lot and shift parts to Python. I'm much happier with this version and hopefully it makes it easier for you to understand too.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1498867381
https://github.com/qutip/qutip/pull/2070#issuecomment-1498867381:36,Usability,simpl,simplify,36,@pmenczel I updated the PR again to simplify the new Cython code a lot and shift parts to Python. I'm much happier with this version and hopefully it makes it easier for you to understand too.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1498867381
https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633:353,Availability,Error,Error,353,"> If this is supposed to be displayed in the Sphinx-rendered HTML instead of markdown. I think you need double backticks for the monospace font? E.g. `` ``Qobj`` ``. Yes, I do. Fixed.; ; > Does this also serve as a `guide on migrating from v4 to v5` or do we plan to have it separately somewhere else? It would be nice if we could summarize some common Error messages that one may see along with the solution/possible reasons. The error messages are what people usually type into Google search. This does serve as an initial guideline of what to expect, but I think we do also need a proper porting document like the one you mention.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633
https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633:431,Availability,error,error,431,"> If this is supposed to be displayed in the Sphinx-rendered HTML instead of markdown. I think you need double backticks for the monospace font? E.g. `` ``Qobj`` ``. Yes, I do. Fixed.; ; > Does this also serve as a `guide on migrating from v4 to v5` or do we plan to have it separately somewhere else? It would be nice if we could summarize some common Error messages that one may see along with the solution/possible reasons. The error messages are what people usually type into Google search. This does serve as an initial guideline of what to expect, but I think we do also need a proper porting document like the one you mention.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633
https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633:359,Integrability,message,messages,359,"> If this is supposed to be displayed in the Sphinx-rendered HTML instead of markdown. I think you need double backticks for the monospace font? E.g. `` ``Qobj`` ``. Yes, I do. Fixed.; ; > Does this also serve as a `guide on migrating from v4 to v5` or do we plan to have it separately somewhere else? It would be nice if we could summarize some common Error messages that one may see along with the solution/possible reasons. The error messages are what people usually type into Google search. This does serve as an initial guideline of what to expect, but I think we do also need a proper porting document like the one you mention.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633
https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633:437,Integrability,message,messages,437,"> If this is supposed to be displayed in the Sphinx-rendered HTML instead of markdown. I think you need double backticks for the monospace font? E.g. `` ``Qobj`` ``. Yes, I do. Fixed.; ; > Does this also serve as a `guide on migrating from v4 to v5` or do we plan to have it separately somewhere else? It would be nice if we could summarize some common Error messages that one may see along with the solution/possible reasons. The error messages are what people usually type into Google search. This does serve as an initial guideline of what to expect, but I think we do also need a proper porting document like the one you mention.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633
https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633:216,Usability,guid,guide,216,"> If this is supposed to be displayed in the Sphinx-rendered HTML instead of markdown. I think you need double backticks for the monospace font? E.g. `` ``Qobj`` ``. Yes, I do. Fixed.; ; > Does this also serve as a `guide on migrating from v4 to v5` or do we plan to have it separately somewhere else? It would be nice if we could summarize some common Error messages that one may see along with the solution/possible reasons. The error messages are what people usually type into Google search. This does serve as an initial guideline of what to expect, but I think we do also need a proper porting document like the one you mention.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633
https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633:525,Usability,guid,guideline,525,"> If this is supposed to be displayed in the Sphinx-rendered HTML instead of markdown. I think you need double backticks for the monospace font? E.g. `` ``Qobj`` ``. Yes, I do. Fixed.; ; > Does this also serve as a `guide on migrating from v4 to v5` or do we plan to have it separately somewhere else? It would be nice if we could summarize some common Error messages that one may see along with the solution/possible reasons. The error messages are what people usually type into Google search. This does serve as an initial guideline of what to expect, but I think we do also need a proper porting document like the one you mention.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2076#issuecomment-1419933633
https://github.com/qutip/qutip/pull/2076#issuecomment-1419934178:57,Deployability,update,update,57,"@Ericgig I'm off to sleep now. I'm happy for you to fix, update or merge this as needed before I wake up. Otherwise I'll make any changes after I wake up.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2076#issuecomment-1419934178
https://github.com/qutip/qutip/pull/2081#issuecomment-1424035216:104,Testability,test,test,104,"@theodotk Thank you for the bug report. I cherry-picked your fix into this PR. Any thoughts on a simple test case we could add? Ideally we could just pass in custom m_ops in something like `test_smesolve_heterodyne` but I don't know what the custom m_ops should be, how to calculate the expected result or how to be sure the right m_ops were used.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424035216
https://github.com/qutip/qutip/pull/2081#issuecomment-1424035216:97,Usability,simpl,simple,97,"@theodotk Thank you for the bug report. I cherry-picked your fix into this PR. Any thoughts on a simple test case we could add? Ideally we could just pass in custom m_ops in something like `test_smesolve_heterodyne` but I don't know what the custom m_ops should be, how to calculate the expected result or how to be sure the right m_ops were used.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424035216
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:336,Modifiability,coupling,coupling,336,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:713,Modifiability,coupling,coupling,713,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:234,Safety,detect,detected,234,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:312,Safety,detect,detection,312,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:346,Safety,detect,detection,346,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:556,Testability,test,tests,556,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:1062,Testability,test,tests,1062,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:1200,Testability,assert,assert,1200,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:1271,Testability,assert,assert,1271,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:330,Usability,guid,guide,330,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:1068,Usability,simpl,simpler,1068,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548
https://github.com/qutip/qutip/pull/2081#issuecomment-1446044347:56,Testability,test,tests,56,@theodotk Apologies for the delay and thank you for the tests. I've incorporate them now and they look good. It would be nice to make the expected results match a little better. Supplying only `atol` is problematic when the values themselves are small and currently the relative differences are larger than `1`. Any suggestion for making these better without having the test take too long?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1446044347
https://github.com/qutip/qutip/pull/2081#issuecomment-1446044347:370,Testability,test,test,370,@theodotk Apologies for the delay and thank you for the tests. I've incorporate them now and they look good. It would be nice to make the expected results match a little better. Supplying only `atol` is problematic when the values themselves are small and currently the relative differences are larger than `1`. Any suggestion for making these better without having the test take too long?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1446044347
https://github.com/qutip/qutip/pull/2085#issuecomment-1426556497:200,Integrability,depend,dependabot,200,[![Coverage Status](https://coveralls.io/builds/56839207/badge)](https://coveralls.io/builds/56839207). Coverage: 72.029%. Remained the same when pulling **b11d87127b60feaded72a1ac8261837ab5a954ff on dependabot/pip/doc/ipython-8.10.0** into **6da3fc2b87406053389e11ff68e8308e87b352e4 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426556497
https://github.com/qutip/qutip/pull/2085#issuecomment-1426687909:0,Availability,Failure,Failure,0,Failure in doc builds was `ipython 8.10.0 depends on prompt-toolkit<3.1.0 and >=3.0.30` so we likely just need to bump the version of prompt-toolkit.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426687909
https://github.com/qutip/qutip/pull/2085#issuecomment-1426687909:42,Integrability,depend,depends,42,Failure in doc builds was `ipython 8.10.0 depends on prompt-toolkit<3.1.0 and >=3.0.30` so we likely just need to bump the version of prompt-toolkit.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426687909
https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519:93,Availability,avail,available,93,"OK, I won't notify you again about this release, but will get in touch when a new version is available. If you'd rather skip all updates until the next major or minor version, let me know by commenting `@dependabot ignore this major version` or `@dependabot ignore this minor version`. If you change your mind, just re-open this PR and I'll resolve any conflicts on it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519
https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519:40,Deployability,release,release,40,"OK, I won't notify you again about this release, but will get in touch when a new version is available. If you'd rather skip all updates until the next major or minor version, let me know by commenting `@dependabot ignore this major version` or `@dependabot ignore this minor version`. If you change your mind, just re-open this PR and I'll resolve any conflicts on it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519
https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519:129,Deployability,update,updates,129,"OK, I won't notify you again about this release, but will get in touch when a new version is available. If you'd rather skip all updates until the next major or minor version, let me know by commenting `@dependabot ignore this major version` or `@dependabot ignore this minor version`. If you change your mind, just re-open this PR and I'll resolve any conflicts on it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519
https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519:204,Integrability,depend,dependabot,204,"OK, I won't notify you again about this release, but will get in touch when a new version is available. If you'd rather skip all updates until the next major or minor version, let me know by commenting `@dependabot ignore this major version` or `@dependabot ignore this minor version`. If you change your mind, just re-open this PR and I'll resolve any conflicts on it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519
https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519:247,Integrability,depend,dependabot,247,"OK, I won't notify you again about this release, but will get in touch when a new version is available. If you'd rather skip all updates until the next major or minor version, let me know by commenting `@dependabot ignore this major version` or `@dependabot ignore this minor version`. If you change your mind, just re-open this PR and I'll resolve any conflicts on it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2085#issuecomment-1426693519
https://github.com/qutip/qutip/pull/2086#issuecomment-1426703028:218,Deployability,update,update-ipython-version-for-docs-to-,218,[![Coverage Status](https://coveralls.io/builds/56843722/badge)](https://coveralls.io/builds/56843722). Coverage: 72.029%. Remained the same when pulling **778cbba6833f6472ac1cb4c1c5eea7164cd3d70c on hodgestar:feature/update-ipython-version-for-docs-to-8.10.0** into **6da3fc2b87406053389e11ff68e8308e87b352e4 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2086#issuecomment-1426703028
https://github.com/qutip/qutip/pull/2087#issuecomment-1428131345:220,Deployability,release,release,220,"I would like CI to check that the documentation builds work, but maybe we can reduce what is built somewhat once we're happy with how ReadTheDocs is set up. I suggest that on ReadTheDocs we build docs for all the active release branches (so currently qutip-4.7.X and qutip-5.0.X) and then yes, we'll have to update which is stable when that changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2087#issuecomment-1428131345
https://github.com/qutip/qutip/pull/2087#issuecomment-1428131345:308,Deployability,update,update,308,"I would like CI to check that the documentation builds work, but maybe we can reduce what is built somewhat once we're happy with how ReadTheDocs is set up. I suggest that on ReadTheDocs we build docs for all the active release branches (so currently qutip-4.7.X and qutip-5.0.X) and then yes, we'll have to update which is stable when that changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2087#issuecomment-1428131345
https://github.com/qutip/qutip/pull/2087#issuecomment-1428131345:78,Energy Efficiency,reduce,reduce,78,"I would like CI to check that the documentation builds work, but maybe we can reduce what is built somewhat once we're happy with how ReadTheDocs is set up. I suggest that on ReadTheDocs we build docs for all the active release branches (so currently qutip-4.7.X and qutip-5.0.X) and then yes, we'll have to update which is stable when that changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2087#issuecomment-1428131345
https://github.com/qutip/qutip/pull/2089#issuecomment-1429059370:26,Testability,log,logic,26,"thanks simon, i think the logic of the changes looks good to me. I can do some quick checks against some examples from the literature. For tests, I think if we set up the correlation functions for the bosonic bath to basically mimic an undamped oscillator we can probably use the existing discrete boson example as a benchmark. ; https://github.com/qutip/qutip-notebooks/blob/master/examples/heom/heom-5b-fermions-discrete-boson-model.ipynb; I will try and set it up and see.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1429059370
https://github.com/qutip/qutip/pull/2089#issuecomment-1429059370:139,Testability,test,tests,139,"thanks simon, i think the logic of the changes looks good to me. I can do some quick checks against some examples from the literature. For tests, I think if we set up the correlation functions for the bosonic bath to basically mimic an undamped oscillator we can probably use the existing discrete boson example as a benchmark. ; https://github.com/qutip/qutip-notebooks/blob/master/examples/heom/heom-5b-fermions-discrete-boson-model.ipynb; I will try and set it up and see.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1429059370
https://github.com/qutip/qutip/pull/2089#issuecomment-1429059370:317,Testability,benchmark,benchmark,317,"thanks simon, i think the logic of the changes looks good to me. I can do some quick checks against some examples from the literature. For tests, I think if we set up the correlation functions for the bosonic bath to basically mimic an undamped oscillator we can probably use the existing discrete boson example as a benchmark. ; https://github.com/qutip/qutip-notebooks/blob/master/examples/heom/heom-5b-fermions-discrete-boson-model.ipynb; I will try and set it up and see.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1429059370
https://github.com/qutip/qutip/pull/2089#issuecomment-1431828061:4,Testability,test,test,4,New test added that includes both non-trivial fermionic and bosonic baths coupled to a spin. Thanks @nwlambert for figuring out how to model the bosonic mode as a bath.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1431828061
https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731:335,Availability,toler,tolerance,335,The failing test was unrelated:; ```; FAILED qutip/tests/solver/test_floquet.py::TestFloquet::testFloquetUnitary - assert (0.9999980885...77441045e-05j) == 1.0  5.0e-05; comparison failed; Obtained: (0.9999980885612143+5.1789504077441045e-05j); Expected: 1.0  5.0e-05; ```; Recording it here so that we can fix it (looks like just a tolerance issue in the Floquet tests).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731
https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731:12,Testability,test,test,12,The failing test was unrelated:; ```; FAILED qutip/tests/solver/test_floquet.py::TestFloquet::testFloquetUnitary - assert (0.9999980885...77441045e-05j) == 1.0  5.0e-05; comparison failed; Obtained: (0.9999980885612143+5.1789504077441045e-05j); Expected: 1.0  5.0e-05; ```; Recording it here so that we can fix it (looks like just a tolerance issue in the Floquet tests).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731
https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731:51,Testability,test,tests,51,The failing test was unrelated:; ```; FAILED qutip/tests/solver/test_floquet.py::TestFloquet::testFloquetUnitary - assert (0.9999980885...77441045e-05j) == 1.0  5.0e-05; comparison failed; Obtained: (0.9999980885612143+5.1789504077441045e-05j); Expected: 1.0  5.0e-05; ```; Recording it here so that we can fix it (looks like just a tolerance issue in the Floquet tests).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731
https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731:81,Testability,Test,TestFloquet,81,The failing test was unrelated:; ```; FAILED qutip/tests/solver/test_floquet.py::TestFloquet::testFloquetUnitary - assert (0.9999980885...77441045e-05j) == 1.0  5.0e-05; comparison failed; Obtained: (0.9999980885612143+5.1789504077441045e-05j); Expected: 1.0  5.0e-05; ```; Recording it here so that we can fix it (looks like just a tolerance issue in the Floquet tests).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731
https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731:94,Testability,test,testFloquetUnitary,94,The failing test was unrelated:; ```; FAILED qutip/tests/solver/test_floquet.py::TestFloquet::testFloquetUnitary - assert (0.9999980885...77441045e-05j) == 1.0  5.0e-05; comparison failed; Obtained: (0.9999980885612143+5.1789504077441045e-05j); Expected: 1.0  5.0e-05; ```; Recording it here so that we can fix it (looks like just a tolerance issue in the Floquet tests).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731
https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731:115,Testability,assert,assert,115,The failing test was unrelated:; ```; FAILED qutip/tests/solver/test_floquet.py::TestFloquet::testFloquetUnitary - assert (0.9999980885...77441045e-05j) == 1.0  5.0e-05; comparison failed; Obtained: (0.9999980885612143+5.1789504077441045e-05j); Expected: 1.0  5.0e-05; ```; Recording it here so that we can fix it (looks like just a tolerance issue in the Floquet tests).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731
https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731:366,Testability,test,tests,366,The failing test was unrelated:; ```; FAILED qutip/tests/solver/test_floquet.py::TestFloquet::testFloquetUnitary - assert (0.9999980885...77441045e-05j) == 1.0  5.0e-05; comparison failed; Obtained: (0.9999980885612143+5.1789504077441045e-05j); Expected: 1.0  5.0e-05; ```; Recording it here so that we can fix it (looks like just a tolerance issue in the Floquet tests).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2089#issuecomment-1432205731
https://github.com/qutip/qutip/pull/2091#issuecomment-1428714078:4,Availability,error,errors,4,"The errors in this PR are caused by SciPy 1.11 raising:; ```; FAILED qutip/tests/test_sp_eigs.py::test_DenseHermValsVecs - DeprecationWarning: Keyword argument 'eigvals' is deprecated in favour of 'subset_by_index' keyword instead and will be removed in SciPy 1.12.0.; FAILED qutip/tests/test_sp_eigs.py::test_DenseValsOnly - DeprecationWarning: Keyword argument 'eigvals' is deprecated in favour of 'subset_by_index' keyword instead and will be removed in SciPy 1.12.0.; =========== 2 failed, 3250 passed, 12 skipped in 1792.40s (0:29:52) ============; ```; These should be fixed but in another PR. Issue #2093 created to ensure this isn't forgotten.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2091#issuecomment-1428714078
https://github.com/qutip/qutip/pull/2091#issuecomment-1428714078:75,Testability,test,tests,75,"The errors in this PR are caused by SciPy 1.11 raising:; ```; FAILED qutip/tests/test_sp_eigs.py::test_DenseHermValsVecs - DeprecationWarning: Keyword argument 'eigvals' is deprecated in favour of 'subset_by_index' keyword instead and will be removed in SciPy 1.12.0.; FAILED qutip/tests/test_sp_eigs.py::test_DenseValsOnly - DeprecationWarning: Keyword argument 'eigvals' is deprecated in favour of 'subset_by_index' keyword instead and will be removed in SciPy 1.12.0.; =========== 2 failed, 3250 passed, 12 skipped in 1792.40s (0:29:52) ============; ```; These should be fixed but in another PR. Issue #2093 created to ensure this isn't forgotten.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2091#issuecomment-1428714078
https://github.com/qutip/qutip/pull/2091#issuecomment-1428714078:282,Testability,test,tests,282,"The errors in this PR are caused by SciPy 1.11 raising:; ```; FAILED qutip/tests/test_sp_eigs.py::test_DenseHermValsVecs - DeprecationWarning: Keyword argument 'eigvals' is deprecated in favour of 'subset_by_index' keyword instead and will be removed in SciPy 1.12.0.; FAILED qutip/tests/test_sp_eigs.py::test_DenseValsOnly - DeprecationWarning: Keyword argument 'eigvals' is deprecated in favour of 'subset_by_index' keyword instead and will be removed in SciPy 1.12.0.; =========== 2 failed, 3250 passed, 12 skipped in 1792.40s (0:29:52) ============; ```; These should be fixed but in another PR. Issue #2093 created to ensure this isn't forgotten.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2091#issuecomment-1428714078
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:172,Availability,error,error,172,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:288,Availability,error,error,288,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:320,Availability,error,error,320,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:274,Deployability,Configurat,Configuration,274,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:334,Deployability,configurat,configuration,334,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:274,Modifiability,Config,Configuration,274,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:334,Modifiability,config,configuration,334,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:937,Modifiability,config,config,937,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488
https://github.com/qutip/qutip/issues/2098#issuecomment-1463557721:27,Availability,error,error,27,@awkwardPotato812 Hi. Your error is similar to the problem on this [website ](https://iq.opengenus.org/module-compiled-against-api-version-0x10-but-this-version-of-numpy-is-0xe/). You may have to upgrade your numpy.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1463557721
https://github.com/qutip/qutip/issues/2098#issuecomment-1463557721:196,Deployability,upgrade,upgrade,196,@awkwardPotato812 Hi. Your error is similar to the problem on this [website ](https://iq.opengenus.org/module-compiled-against-api-version-0x10-but-this-version-of-numpy-is-0xe/). You may have to upgrade your numpy.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1463557721
https://github.com/qutip/qutip/issues/2098#issuecomment-1465279129:50,Availability,error,error,50,@tamakoshi2001 Thanks for the info! That fixed my error.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1465279129
https://github.com/qutip/qutip/issues/2099#issuecomment-1450984573:239,Deployability,update,update,239,"Hi @lklivingstone `superop` is indeed not an attribute, but you should be able to get the information necessary from the attribute `superrep`. The other two, `isconstant` and `num_elements` are attributes in the latest branch. We recently update the master branch with the new pre alpha version of qutip. I hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2099#issuecomment-1450984573
https://github.com/qutip/qutip/issues/2099#issuecomment-1454113177:227,Usability,feedback,feedback,227,"I would suggest to change the `|` for `,` and also add a space after `type` and others, for example: `type = oper`. This is so that the fomating resembles that of Qobj. Nevertherless, feel free to open a Pull Request as giving feedback there is usually more conveninent. . Thanks for your effort! I am looking forward to your contribution  .",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2099#issuecomment-1454113177
https://github.com/qutip/qutip/issues/2100#issuecomment-1443775819:421,Deployability,update,updated,421,"Hi,; The print should show all the important information without being overwhelming...; I am not sure what would be the best way to do it and am hopping that someone with a good idea comes along.; But the `compile` entry is too long and not important enough to be placed first... `qutip.settings` is defined in `qutip/settings.py`.; If you think it would be useful to change the `compile` entry representation, it can be updated by changing `qutip/core/options.py:QutipOptions`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2100#issuecomment-1443775819
https://github.com/qutip/qutip/issues/2102#issuecomment-1450305103:73,Deployability,release,release,73,"The `fidelity` function use the Nielsen & Chuang definition. In a future release, [process_fidelity](https://github.com/qutip/qutip/blob/eeae142630e23818cd08a6b3ea5f6145e3e60225/qutip/core/metrics.py#L148), will be the fidelity version you expect.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2102#issuecomment-1450305103
https://github.com/qutip/qutip/issues/2102#issuecomment-1450321937:95,Usability,clear,clear,95,Thank you for the clarification. A suggestion would be to also relabel `fidelity` to make this clear.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2102#issuecomment-1450321937
https://github.com/qutip/qutip/pull/2103#issuecomment-1451965023:173,Deployability,release,release,173,"Looking good, could you add the file `doc/change/2103.misc` containing a short description of the changes.; We use it to make sure we don't forget contributions when making release documentation.; See https://qutip.org/docs/latest/development/contributing.html#changelog-generation",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2103#issuecomment-1451965023
https://github.com/qutip/qutip/pull/2103#issuecomment-1453007487:17,Testability,log,log,17,"added the change log, sorry for missing it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2103#issuecomment-1453007487
https://github.com/qutip/qutip/issues/2104#issuecomment-1451692026:91,Usability,guid,guide,91,Perhaps we can close this issue though? The docs at https://qutip.readthedocs.io/en/latest/guide/heom/bosonic.html seem good?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1451692026
https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987:47,Deployability,release,release,47,"I got it from here: https://qutip.org/docs/pre-release/guide/guide-heom.html. This is the link that ""online html documentation"" links to in the qutip webpage. Is this not keept up to date, as https://qutip.readthedocs.io/en/master/guide/guide-heom.html is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987
https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987:55,Usability,guid,guide,55,"I got it from here: https://qutip.org/docs/pre-release/guide/guide-heom.html. This is the link that ""online html documentation"" links to in the qutip webpage. Is this not keept up to date, as https://qutip.readthedocs.io/en/master/guide/guide-heom.html is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987
https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987:61,Usability,guid,guide-heom,61,"I got it from here: https://qutip.org/docs/pre-release/guide/guide-heom.html. This is the link that ""online html documentation"" links to in the qutip webpage. Is this not keept up to date, as https://qutip.readthedocs.io/en/master/guide/guide-heom.html is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987
https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987:231,Usability,guid,guide,231,"I got it from here: https://qutip.org/docs/pre-release/guide/guide-heom.html. This is the link that ""online html documentation"" links to in the qutip webpage. Is this not keept up to date, as https://qutip.readthedocs.io/en/master/guide/guide-heom.html is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987
https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987:237,Usability,guid,guide-heom,237,"I got it from here: https://qutip.org/docs/pre-release/guide/guide-heom.html. This is the link that ""online html documentation"" links to in the qutip webpage. Is this not keept up to date, as https://qutip.readthedocs.io/en/master/guide/guide-heom.html is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1454064987
https://github.com/qutip/qutip/issues/2104#issuecomment-1454074321:87,Availability,down,downloading,87,"The Read The Docs version is compiled on each commit, but the website version requires downloading the update version and manually updating the website repo.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1454074321
https://github.com/qutip/qutip/issues/2104#issuecomment-1454074321:103,Deployability,update,update,103,"The Read The Docs version is compiled on each commit, but the website version requires downloading the update version and manually updating the website repo.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2104#issuecomment-1454074321
https://github.com/qutip/qutip/issues/2109#issuecomment-1458453064:64,Availability,error,error,64,"Hi. I replaced scipy wrapper with _data.solve. I ran pytest and error occurred. Does anybody know how to solve this? Thank you. File ""qutip/core/data/dispatch.pyx"", line 582, in qutip.core.data.dispatch.Dispatcher.__call__; raise TypeError(""unknown types to dispatch on: "" + str(dispatch)) from None; TypeError: unknown types to dispatch on: [<class 'scipy.sparse._csr.csr_matrix'>, <class 'numpy.ndarray'>]; Traceback (most recent call last):; File ""/root/opt/qutip/qutip/solver/countstat.py"", line 83, in _solve; return _data.solve(A, V, ""splu"")",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2109#issuecomment-1458453064
https://github.com/qutip/qutip/issues/2109#issuecomment-1458453064:21,Integrability,wrap,wrapper,21,"Hi. I replaced scipy wrapper with _data.solve. I ran pytest and error occurred. Does anybody know how to solve this? Thank you. File ""qutip/core/data/dispatch.pyx"", line 582, in qutip.core.data.dispatch.Dispatcher.__call__; raise TypeError(""unknown types to dispatch on: "" + str(dispatch)) from None; TypeError: unknown types to dispatch on: [<class 'scipy.sparse._csr.csr_matrix'>, <class 'numpy.ndarray'>]; Traceback (most recent call last):; File ""/root/opt/qutip/qutip/solver/countstat.py"", line 83, in _solve; return _data.solve(A, V, ""splu"")",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2109#issuecomment-1458453064
https://github.com/qutip/qutip/issues/2109#issuecomment-1458460315:116,Integrability,wrap,wrap,116,@tamakoshi2001 I suspect the issue is that the argument `V` is a numpy array. It should be a data instance. You can wrap the numpy array with `_data.Dense(V)` to convert it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2109#issuecomment-1458460315
https://github.com/qutip/qutip/issues/2109#issuecomment-1458484606:128,Testability,test,test,128,"@hodgestar Thank you for your reply. I added `_data.Dense(V)`, but failed. The first code failed and the second code passed the test.; ```; def _solve(A, V):; try:; if settings.has_mkl:; return _data.solve(A, V, ""mkl_spsolve"", {""csc"": True}); else:; return _data.solve(A, V, ""splu""); except TypeError:; out = _data.solve(A,_data.Dense(V)); return out; ```; ```; def _solve(A, V):; try:; if settings.has_mkl:; return _data.solve(A, V, ""mkl_spsolve"", {""csc"": True}); else:; return _data.solve(A, V, ""splu""); except TypeError:; out = sp.linalg.lsqr(A, V)[0]; return out; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2109#issuecomment-1458484606
https://github.com/qutip/qutip/issues/2109#issuecomment-1459917369:108,Availability,error,error,108,"Hi. By clarifying the data types `_data.solve(_data.CSR(A),_data.Dense(V))`, Typeerror stops, but Attribute error occurred instead.; ```; qutip/solver/countstat.py:221: in countstat_current_noise; current, noise = _noise_direct(L, wlist, rhoss, J_ops); qutip/solver/countstat.py:118: in _noise_direct; X_rho = [_data.dense.fast_from_numpy(_solve(A, op)); qutip/solver/countstat.py:118: in <listcomp>; X_rho = [_data.dense.fast_from_numpy(_solve(A, op)); qutip/core/data/dense.pyx:215: in qutip.core.data.dense.fast_from_numpy; cpdef Dense fast_from_numpy(object array):; _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ . > if array.ndim == 1:; E AttributeError: 'qutip.core.data.dense.Dense' object has no attribute 'ndim'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2109#issuecomment-1459917369
https://github.com/qutip/qutip/pull/2110#issuecomment-1458493695:73,Deployability,update,update,73,"Hello @AGaliciaMartinez,; Thanks for the review. I will look into it and update.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2110#issuecomment-1458493695
https://github.com/qutip/qutip/pull/2110#issuecomment-1461774279:16,Availability,Ping,Ping,16,@gadhvirushiraj Ping me when you'd like a re-review.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2110#issuecomment-1461774279
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:59,Availability,error,errors,59,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:143,Availability,error,errors,143,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:1251,Deployability,update,update,1251,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:461,Testability,test,test,461,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:526,Testability,test,test,526,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:836,Testability,test,test,836,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:861,Testability,test,tests,861,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:942,Testability,test,tests,942,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:996,Testability,test,tests,996,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:1122,Testability,test,testing,1122,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838
https://github.com/qutip/qutip/pull/2111#issuecomment-1458446395:445,Testability,test,test,445,"@AGaliciaMartinez Hello, I have made the required changes in the __repr__() of QobjEvo. . Output of the new code:; ```; >>> import qutip; >>> qutip.QobjEvo([qutip.qeye(2), lambda t: t]); <QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=False, num_elements=1>; ```; _In your suggestion, there wasnt a ""<"" before QobjEvo, so I added that._. I have also edited the page according to the `pycodestyle`. Kindly check the test too. This is my first test, so do suggest changes, if required. I could not think of different cases, so I write 4 cases, and checked them according to the expected result.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1458446395
https://github.com/qutip/qutip/pull/2111#issuecomment-1458446395:472,Testability,test,test,472,"@AGaliciaMartinez Hello, I have made the required changes in the __repr__() of QobjEvo. . Output of the new code:; ```; >>> import qutip; >>> qutip.QobjEvo([qutip.qeye(2), lambda t: t]); <QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=False, num_elements=1>; ```; _In your suggestion, there wasnt a ""<"" before QobjEvo, so I added that._. I have also edited the page according to the `pycodestyle`. Kindly check the test too. This is my first test, so do suggest changes, if required. I could not think of different cases, so I write 4 cases, and checked them according to the expected result.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1458446395
https://github.com/qutip/qutip/pull/2111#issuecomment-1464940552:301,Testability,test,tests,301,"@AGaliciaMartinez Thank you!; I have removed both `<` and `>` from the `repr()`. Now it looks like this:; ```; >>> import qutip; >>> qutip.QobjEvo([qutip.qeye(2), lambda t: t]); QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=False, num_elements=1; ```. I have added many tests according to your suggestions. Now there are 7 cases to check.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1464940552
https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:15,Testability,test,test,15,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308
https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:193,Testability,assert,assert,193,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308
https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:377,Testability,assert,assert,377,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308
https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:566,Testability,assert,assert,566,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308
https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:812,Testability,assert,assert,812,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308
https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:1054,Testability,assert,assert,1054,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308
https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:1137,Usability,undo,undone,1137,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308
https://github.com/qutip/qutip/pull/2111#issuecomment-1472303983:159,Testability,test,tests,159,It's not the conversation but the conflict in the `qobjevo.pyx` file that need to be resolved.; The PR cannot be merged while there is a conflict. Most of the tests can't be ran.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472303983
https://github.com/qutip/qutip/pull/2112#issuecomment-1462010251:55,Testability,test,tests,55,@HarshKhilawala Would you be interested in adding some tests for the progress bars in another PR?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1462010251
https://github.com/qutip/qutip/pull/2112#issuecomment-1462010251:69,Usability,progress bar,progress bars,69,@HarshKhilawala Would you be interested in adding some tests for the progress bars in another PR?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1462010251
https://github.com/qutip/qutip/pull/2112#issuecomment-1462049113:92,Testability,test,tests,92,"@hodgestar Sure, do I need to be assigned another issue? Can I create new issue for writing tests for progress bar and get assigned to work on it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1462049113
https://github.com/qutip/qutip/pull/2112#issuecomment-1462049113:102,Usability,progress bar,progress bar,102,"@hodgestar Sure, do I need to be assigned another issue? Can I create new issue for writing tests for progress bar and get assigned to work on it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1462049113
https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:44,Testability,test,tests,44,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603
https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:73,Testability,test,test,73,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603
https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:115,Testability,test,test,115,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603
https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:241,Testability,test,test,241,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603
https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:281,Testability,test,testing,281,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603
https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:320,Testability,test,tests,320,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603
https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:264,Usability,learn,learn,264,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603
https://github.com/qutip/qutip/pull/2112#issuecomment-1465168803:87,Testability,test,tests,87,@hodgestar Anything for reference? Any pre-existing test_code which I can use to write tests for progressbar? PTAL!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1465168803
https://github.com/qutip/qutip/pull/2112#issuecomment-1471891250:64,Testability,test,tests,64,@Ericgig Can you help me with this one? I am considering adding tests for progressbar.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471891250
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:176,Deployability,update,update,176,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:468,Deployability,update,update,468,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:375,Security,access,accessing-captured-output-from-a-test-function,375,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:13,Testability,test,test,13,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:77,Testability,test,test,77,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:95,Testability,test,tests,95,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:127,Testability,test,test,127,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:408,Testability,test,test-function,408,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:27,Usability,progress bar,progress bars,27,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:142,Usability,simpl,simple,142,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520
https://github.com/qutip/qutip/pull/2114#issuecomment-1462413586:88,Testability,test,test,88,@awkwardPotato812 Thanks for starting this PR. I did a partial review and activated the test run. I will leave a full review for Eric to do though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2114#issuecomment-1462413586
https://github.com/qutip/qutip/pull/2114#issuecomment-1463345791:116,Availability,error,error,116,I'm changing this draft to the complete PR. I'll update it with any changes related to documentation once the build error is resolved.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2114#issuecomment-1463345791
https://github.com/qutip/qutip/pull/2114#issuecomment-1463345791:49,Deployability,update,update,49,I'm changing this draft to the complete PR. I'll update it with any changes related to documentation once the build error is resolved.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2114#issuecomment-1463345791
https://github.com/qutip/qutip/pull/2114#issuecomment-1468855861:8,Testability,test,test,8,The new test is failing.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2114#issuecomment-1468855861
https://github.com/qutip/qutip/issues/2115#issuecomment-1463686048:345,Energy Efficiency,reduce,reduce,345,"@Chengie6 Thank you for the bug report. Could you post a small snippet of code that demonstrates the issue? Then I can attempt to reproduce the issue. The likely cause is that since operators may now be either sparse or dense, it is possible to accidentally use the kind that is much slower for a particular operation. However, we would like to reduce how often this happens so whatever the cause, we are keen to fix things so that they just work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2115#issuecomment-1463686048
https://github.com/qutip/qutip/issues/2115#issuecomment-1463773076:39,Testability,benchmark,benchmarking,39,"I had a quick look at this since i was benchmarking expm() anyway. Essentially I think the issue is your A operator is diagonal, and in 4.7 there is a check that notices it is diagonal, and quickly returns the result. In v5, there is a similar check for sparse matrices, but the default behavior is to convert to dense, so the check is not done. if you use expm(dtype=""CSR"") the v5 example should be quick (with the caveat that the result is nan in both 5 and 4.7). I guess we need to add a check for diagonality for dense cases too. edit:; @hodgestar pointed out that A.to(""dense"") helps too, so I guess it is just; https://github.com/qutip/qutip/blob/fccec5d60e396c964627664bff85a22901adb85a/qutip/core/data/expm.py#L40; which needs a diagonality check?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2115#issuecomment-1463773076
https://github.com/qutip/qutip/issues/2115#issuecomment-1463804614:227,Availability,error,error,227,"@nwlambert Thanks for the help, it somehow solves the problem a bit. However, it doesn't really help much when I increase the Hilbert space cut-off to N=20 or 25. In fact, 4.7 still calculates instantly, but 5.0 will report an error that the space required is too large, or the kernel just shuts down itself... I don't know so much about algorithms, but from your answer it seems that 4.7 and 5.0 are using completely different ways to handle matrices? It seems the 5.0 method is in general a bit slower to handle heavier calculations?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2115#issuecomment-1463804614
https://github.com/qutip/qutip/issues/2115#issuecomment-1463804614:296,Availability,down,down,296,"@nwlambert Thanks for the help, it somehow solves the problem a bit. However, it doesn't really help much when I increase the Hilbert space cut-off to N=20 or 25. In fact, 4.7 still calculates instantly, but 5.0 will report an error that the space required is too large, or the kernel just shuts down itself... I don't know so much about algorithms, but from your answer it seems that 4.7 and 5.0 are using completely different ways to handle matrices? It seems the 5.0 method is in general a bit slower to handle heavier calculations?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2115#issuecomment-1463804614
https://github.com/qutip/qutip/pull/2116#issuecomment-1466322463:77,Deployability,update,update,77,"The tutorials only use it indirectly, so it's just qutip-qip that we need to update. Update: This might be a little tricky, since `qutip-qtrl` only supports QuTiP v5 and `qutip-qip` supports both v4 and v5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2116#issuecomment-1466322463
https://github.com/qutip/qutip/pull/2116#issuecomment-1466322463:85,Deployability,Update,Update,85,"The tutorials only use it indirectly, so it's just qutip-qip that we need to update. Update: This might be a little tricky, since `qutip-qtrl` only supports QuTiP v5 and `qutip-qip` supports both v4 and v5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2116#issuecomment-1466322463
https://github.com/qutip/qutip/issues/2117#issuecomment-1466976688:74,Deployability,install,install,74,"@Prashik123, sure you can work on it. If you are not sure where to start, install qutip from source using the version 3 of cython in pre-release. You will get a lot of warnings related to the point 1 above. Fix those warnings and make a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2117#issuecomment-1466976688
https://github.com/qutip/qutip/issues/2117#issuecomment-1466976688:137,Deployability,release,release,137,"@Prashik123, sure you can work on it. If you are not sure where to start, install qutip from source using the version 3 of cython in pre-release. You will get a lot of warnings related to the point 1 above. Fix those warnings and make a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2117#issuecomment-1466976688
https://github.com/qutip/qutip/issues/2118#issuecomment-1468144893:217,Availability,error,error,217,"Thank you for reporting. `e_ops=callable` should work and allow you to obtain the result you need for now.; `e_ops=[callable]` support should have been added, but it seems it was only properly done for `sesolve`. The error is in the qutip-4.7.X branch at: https://github.com/qutip/qutip/blob/15880398a222ebfd62fd52361cc3852a685b1ac7/qutip/mesolve.py#L458; where is should be set to `True` if at least one of the `e_ops` is a callable but not a `Qobj`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2118#issuecomment-1468144893
https://github.com/qutip/qutip/pull/2120#issuecomment-1470193242:36,Testability,test,tests,36,@Ericgig Hi. I added `lsqr` and all tests succeeded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2120#issuecomment-1470193242
https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817:136,Availability,error,error,136,"I am using spyder. When I run the code once by pressing F5 button, then I get expected behaviour. But when I press F5 again, then I get error. If I modify the code and press F5, same error. If I restart spyder, then again I do not get any error on the first run, but the error repeats on subsequent runs. Yes, just running `import qutip` also gives the same error. I guess you are asking for the full error message and not just the last two lines. Here it is for `import qutip` for two subsequent runs.-. IN [1]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). IN [2]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 11, in <module>; import qutip. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/__init__.py"", line 106, in <module>; from qutip.qobj import *. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 2526, in <module>; import qutip.superop_reps as sr. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/superop_reps.py"", line 74, in <module>; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 278, in sigmax; return 2 * jmat(1 / 2, 'x'). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 80, in jmat; A ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817
https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817:183,Availability,error,error,183,"I am using spyder. When I run the code once by pressing F5 button, then I get expected behaviour. But when I press F5 again, then I get error. If I modify the code and press F5, same error. If I restart spyder, then again I do not get any error on the first run, but the error repeats on subsequent runs. Yes, just running `import qutip` also gives the same error. I guess you are asking for the full error message and not just the last two lines. Here it is for `import qutip` for two subsequent runs.-. IN [1]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). IN [2]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 11, in <module>; import qutip. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/__init__.py"", line 106, in <module>; from qutip.qobj import *. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 2526, in <module>; import qutip.superop_reps as sr. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/superop_reps.py"", line 74, in <module>; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 278, in sigmax; return 2 * jmat(1 / 2, 'x'). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 80, in jmat; A ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817
https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817:239,Availability,error,error,239,"I am using spyder. When I run the code once by pressing F5 button, then I get expected behaviour. But when I press F5 again, then I get error. If I modify the code and press F5, same error. If I restart spyder, then again I do not get any error on the first run, but the error repeats on subsequent runs. Yes, just running `import qutip` also gives the same error. I guess you are asking for the full error message and not just the last two lines. Here it is for `import qutip` for two subsequent runs.-. IN [1]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). IN [2]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 11, in <module>; import qutip. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/__init__.py"", line 106, in <module>; from qutip.qobj import *. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 2526, in <module>; import qutip.superop_reps as sr. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/superop_reps.py"", line 74, in <module>; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 278, in sigmax; return 2 * jmat(1 / 2, 'x'). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 80, in jmat; A ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817
https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817:271,Availability,error,error,271,"I am using spyder. When I run the code once by pressing F5 button, then I get expected behaviour. But when I press F5 again, then I get error. If I modify the code and press F5, same error. If I restart spyder, then again I do not get any error on the first run, but the error repeats on subsequent runs. Yes, just running `import qutip` also gives the same error. I guess you are asking for the full error message and not just the last two lines. Here it is for `import qutip` for two subsequent runs.-. IN [1]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). IN [2]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 11, in <module>; import qutip. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/__init__.py"", line 106, in <module>; from qutip.qobj import *. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 2526, in <module>; import qutip.superop_reps as sr. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/superop_reps.py"", line 74, in <module>; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 278, in sigmax; return 2 * jmat(1 / 2, 'x'). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 80, in jmat; A ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817
https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817:358,Availability,error,error,358,"I am using spyder. When I run the code once by pressing F5 button, then I get expected behaviour. But when I press F5 again, then I get error. If I modify the code and press F5, same error. If I restart spyder, then again I do not get any error on the first run, but the error repeats on subsequent runs. Yes, just running `import qutip` also gives the same error. I guess you are asking for the full error message and not just the last two lines. Here it is for `import qutip` for two subsequent runs.-. IN [1]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). IN [2]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 11, in <module>; import qutip. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/__init__.py"", line 106, in <module>; from qutip.qobj import *. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 2526, in <module>; import qutip.superop_reps as sr. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/superop_reps.py"", line 74, in <module>; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 278, in sigmax; return 2 * jmat(1 / 2, 'x'). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 80, in jmat; A ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817
https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817:401,Availability,error,error,401,"I am using spyder. When I run the code once by pressing F5 button, then I get expected behaviour. But when I press F5 again, then I get error. If I modify the code and press F5, same error. If I restart spyder, then again I do not get any error on the first run, but the error repeats on subsequent runs. Yes, just running `import qutip` also gives the same error. I guess you are asking for the full error message and not just the last two lines. Here it is for `import qutip` for two subsequent runs.-. IN [1]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). IN [2]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 11, in <module>; import qutip. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/__init__.py"", line 106, in <module>; from qutip.qobj import *. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 2526, in <module>; import qutip.superop_reps as sr. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/superop_reps.py"", line 74, in <module>; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 278, in sigmax; return 2 * jmat(1 / 2, 'x'). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 80, in jmat; A ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817
https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817:407,Integrability,message,message,407,"I am using spyder. When I run the code once by pressing F5 button, then I get expected behaviour. But when I press F5 again, then I get error. If I modify the code and press F5, same error. If I restart spyder, then again I do not get any error on the first run, but the error repeats on subsequent runs. Yes, just running `import qutip` also gives the same error. I guess you are asking for the full error message and not just the last two lines. Here it is for `import qutip` for two subsequent runs.-. IN [1]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). IN [2]: runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 11, in <module>; import qutip. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/__init__.py"", line 106, in <module>; from qutip.qobj import *. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 2526, in <module>; import qutip.superop_reps as sr. File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/superop_reps.py"", line 74, in <module>; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 278, in sigmax; return 2 * jmat(1 / 2, 'x'). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/operators.py"", line 80, in jmat; A ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469319817
https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223:39,Availability,error,error,39,"Hi. Thanks, but I am now getting a new error. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj())`. Then there is no error whatsoever. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj()). print(Qobj([[1],[2],[3],[4],[5]]))`. Then it gives expected result if I run it first thing after launching spyder. But if I have already run any qutip code and then try to run this code, then I get the following error-. File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/base.py"", line 283, in __bool__; raise ValueError(""The truth value of an array with more than one "". ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). The full error message is-. runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 19, in <module>; print(Qobj([[1],[2],[3],[4],[5]])). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 256, in __init__; _tmp = sp.csr_matrix(data, dtype=complex). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(coo_matrix(arg1, dtype=dtype))). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223
https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223:171,Availability,error,error,171,"Hi. Thanks, but I am now getting a new error. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj())`. Then there is no error whatsoever. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj()). print(Qobj([[1],[2],[3],[4],[5]]))`. Then it gives expected result if I run it first thing after launching spyder. But if I have already run any qutip code and then try to run this code, then I get the following error-. File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/base.py"", line 283, in __bool__; raise ValueError(""The truth value of an array with more than one "". ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). The full error message is-. runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 19, in <module>; print(Qobj([[1],[2],[3],[4],[5]])). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 256, in __init__; _tmp = sp.csr_matrix(data, dtype=complex). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(coo_matrix(arg1, dtype=dtype))). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223
https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223:508,Availability,error,error,508,"Hi. Thanks, but I am now getting a new error. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj())`. Then there is no error whatsoever. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj()). print(Qobj([[1],[2],[3],[4],[5]]))`. Then it gives expected result if I run it first thing after launching spyder. But if I have already run any qutip code and then try to run this code, then I get the following error-. File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/base.py"", line 283, in __bool__; raise ValueError(""The truth value of an array with more than one "". ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). The full error message is-. runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 19, in <module>; print(Qobj([[1],[2],[3],[4],[5]])). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 256, in __init__; _tmp = sp.csr_matrix(data, dtype=complex). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(coo_matrix(arg1, dtype=dtype))). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223
https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223:798,Availability,error,error,798,"Hi. Thanks, but I am now getting a new error. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj())`. Then there is no error whatsoever. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj()). print(Qobj([[1],[2],[3],[4],[5]]))`. Then it gives expected result if I run it first thing after launching spyder. But if I have already run any qutip code and then try to run this code, then I get the following error-. File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/base.py"", line 283, in __bool__; raise ValueError(""The truth value of an array with more than one "". ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). The full error message is-. runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 19, in <module>; print(Qobj([[1],[2],[3],[4],[5]])). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 256, in __init__; _tmp = sp.csr_matrix(data, dtype=complex). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(coo_matrix(arg1, dtype=dtype))). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223
https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223:804,Integrability,message,message,804,"Hi. Thanks, but I am now getting a new error. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj())`. Then there is no error whatsoever. If the code is-. `from qutip import *. import numpy as np. import matplotlib.pyplot as plt. print(Qobj()). print(Qobj([[1],[2],[3],[4],[5]]))`. Then it gives expected result if I run it first thing after launching spyder. But if I have already run any qutip code and then try to run this code, then I get the following error-. File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/base.py"", line 283, in __bool__; raise ValueError(""The truth value of an array with more than one "". ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). The full error message is-. runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'); Traceback (most recent call last):. File ""<ipython-input-2-af424448e75a>"", line 1, in <module>; runfile('/home/premkr/Dropbox/work/python/qutip/gksl_learning.py', wdir='/home/premkr/Dropbox/work/python/qutip'). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 678, in runfile; execfile(filename, namespace). File ""/usr/lib/python3/dist-packages/spyder_kernels/customize/spydercustomize.py"", line 106, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""/home/premkr/Dropbox/work/python/qutip/gksl_learning.py"", line 19, in <module>; print(Qobj([[1],[2],[3],[4],[5]])). File ""/home/premkr/.local/lib/python3.7/site-packages/qutip/qobj.py"", line 256, in __init__; _tmp = sp.csr_matrix(data, dtype=complex). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(coo_matrix(arg1, dtype=dtype))). File ""/home/premkr/.local/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 86, in __init__; self._set_self(self.__class__(c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469601223
https://github.com/qutip/qutip/issues/2121#issuecomment-1469782342:321,Deployability,update,update,321,"Thanks. I added numpy, scipy and matplotlib to the modules not to be reloaded, and the issue seems to have resolved. By the way, I am using an old version of spyder on my device. Could that be the cause of this issue? I do not have the admin control over the device, so if that is likely a cause, I will ask the admin to update spyder.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2121#issuecomment-1469782342
https://github.com/qutip/qutip/issues/2122#issuecomment-1470003116:444,Usability,clear,clearer,444,"Somewhat related -- I'd like to have `qeye_like(op)` that takes an operator and produces the appropriate identity. One might naively think that `qeye(dims[0])` does the right thing, but this issue shows that the situation is more complex than that. . We can already solve this without #1996 by just constructing a data object identity with the right shape and passing that to Qobj with the correct dims (but #1996 will make the situation a lot clearer).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2122#issuecomment-1470003116
https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220:66,Testability,test,test,66,@Ericgig Can you please guide me through (step-by-step developing test function or test classes) writing tests for progressbar? I don't have much experience with writing python tests? But I am a quick learner and can easily grasp the fundamentals.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220
https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220:83,Testability,test,test,83,@Ericgig Can you please guide me through (step-by-step developing test function or test classes) writing tests for progressbar? I don't have much experience with writing python tests? But I am a quick learner and can easily grasp the fundamentals.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220
https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220:105,Testability,test,tests,105,@Ericgig Can you please guide me through (step-by-step developing test function or test classes) writing tests for progressbar? I don't have much experience with writing python tests? But I am a quick learner and can easily grasp the fundamentals.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220
https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220:177,Testability,test,tests,177,@Ericgig Can you please guide me through (step-by-step developing test function or test classes) writing tests for progressbar? I don't have much experience with writing python tests? But I am a quick learner and can easily grasp the fundamentals.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220
https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220:24,Usability,guid,guide,24,@Ericgig Can you please guide me through (step-by-step developing test function or test classes) writing tests for progressbar? I don't have much experience with writing python tests? But I am a quick learner and can easily grasp the fundamentals.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220
https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220:201,Usability,learn,learner,201,@Ericgig Can you please guide me through (step-by-step developing test function or test classes) writing tests for progressbar? I don't have much experience with writing python tests? But I am a quick learner and can easily grasp the fundamentals.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220
https://github.com/qutip/qutip/pull/2127#issuecomment-1474764914:215,Testability,test,test-progressbar,215,[![Coverage Status](https://coveralls.io/builds/57993720/badge)](https://coveralls.io/builds/57993720). Coverage: 75.391%. Remained the same when pulling **a25e4d4192323ea695fc611e144d8368973c8b07 on HarshKhilawala:test-progressbar** into **41129bc2924fa6fa7726c051f5560e17be2c8039 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474764914
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:194,Availability,error,error,194,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:234,Availability,error,error,234,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:248,Testability,test,test,248,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:358,Testability,test,tests,358,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:393,Testability,test,tests,393,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:4,Usability,simpl,simple,4,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:72,Usability,progress bar,progress bar,72,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084:342,Usability,guid,guide,342,"You simple need to create a function starting with `test_` that use the progress bar. Ideally you would use it in a way that ensure all lines of code are used at least once. Then if there is an error in the code, python will raise an error and the test will fail. There should be some tutorials for pytest on the web, writing a step per step guide on making tests is more work than making the tests themselves so please have mercy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478014084
https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804:57,Energy Efficiency,efficient,efficient,57,"Hello Harsh,. Thank for your interest in qutip. The most efficient way for us to interact with code is through Github.; Please attempt a draft PR for this. There are many test functions in our; project that you can use as a template. Assuming that you are interested in GSoC, when assessing candidates, an; ability to work independently is a key criteria. All the best with it, we look forward to reviewing your PR. Alex. On Tue, 21 Mar 2023, 18:06 Harsh Khilawala, ***@***.***>; wrote:. > @Ericgig <https://github.com/Ericgig> Thanks for getting back to me. I; > will refer to pytest tutorials on web but I found some code lines like; > following:; >; > @pytest.mark.parametrize; > @check_pngs_equal; > @pytest.fixture; > @pytest.mark.repeat(10)...; >; > Can you please let me know when and why were these used? Is there a; > resource also for this one?; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2127#issuecomment-1478364599>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ACGFP3MUPPBWDTOQGGBNOTLW5HU2ZANCNFSM6AAAAAAV7J6OKU>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804
https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804:1182,Integrability,Message,Message,1182,"Hello Harsh,. Thank for your interest in qutip. The most efficient way for us to interact with code is through Github.; Please attempt a draft PR for this. There are many test functions in our; project that you can use as a template. Assuming that you are interested in GSoC, when assessing candidates, an; ability to work independently is a key criteria. All the best with it, we look forward to reviewing your PR. Alex. On Tue, 21 Mar 2023, 18:06 Harsh Khilawala, ***@***.***>; wrote:. > @Ericgig <https://github.com/Ericgig> Thanks for getting back to me. I; > will refer to pytest tutorials on web but I found some code lines like; > following:; >; > @pytest.mark.parametrize; > @check_pngs_equal; > @pytest.fixture; > @pytest.mark.repeat(10)...; >; > Can you please let me know when and why were these used? Is there a; > resource also for this one?; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2127#issuecomment-1478364599>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ACGFP3MUPPBWDTOQGGBNOTLW5HU2ZANCNFSM6AAAAAAV7J6OKU>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804
https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804:171,Testability,test,test,171,"Hello Harsh,. Thank for your interest in qutip. The most efficient way for us to interact with code is through Github.; Please attempt a draft PR for this. There are many test functions in our; project that you can use as a template. Assuming that you are interested in GSoC, when assessing candidates, an; ability to work independently is a key criteria. All the best with it, we look forward to reviewing your PR. Alex. On Tue, 21 Mar 2023, 18:06 Harsh Khilawala, ***@***.***>; wrote:. > @Ericgig <https://github.com/Ericgig> Thanks for getting back to me. I; > will refer to pytest tutorials on web but I found some code lines like; > following:; >; > @pytest.mark.parametrize; > @check_pngs_equal; > @pytest.fixture; > @pytest.mark.repeat(10)...; >; > Can you please let me know when and why were these used? Is there a; > resource also for this one?; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2127#issuecomment-1478364599>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ACGFP3MUPPBWDTOQGGBNOTLW5HU2ZANCNFSM6AAAAAAV7J6OKU>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804
https://github.com/qutip/qutip/pull/2128#issuecomment-1476648533:351,Integrability,interface,interface,351,"@nwlambert Would you mind giving this a try with some bigger realistic HEOM examples you have lying around? Eric's recent improvements to CSR `mul` and `imul` also help HEOM RHS construction since there is a lot of `c * op` happening. The 3.5x improvement from this branch is on top of that. @Ericgig Would you mind giving your thoughts on the Cython interface both from a ""is this good from a technical point of view"" and from a ""do we want this point of view"". I guess we could also name it `_from_csr_blocks` if we don't want to expose it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1476648533
https://github.com/qutip/qutip/pull/2128#issuecomment-1476648533:532,Security,expose,expose,532,"@nwlambert Would you mind giving this a try with some bigger realistic HEOM examples you have lying around? Eric's recent improvements to CSR `mul` and `imul` also help HEOM RHS construction since there is a lot of `c * op` happening. The 3.5x improvement from this branch is on top of that. @Ericgig Would you mind giving your thoughts on the Cython interface both from a ""is this good from a technical point of view"" and from a ""do we want this point of view"". I guess we could also name it `_from_csr_blocks` if we don't want to expose it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1476648533
https://github.com/qutip/qutip/pull/2128#issuecomment-1476692791:16,Availability,robust,robust,16,"It doesn't look robust enough to be user facing as it is, but as a private function, if you get a 3.5x, I'd say we want it. Technically, just give a type to `i` and it's all running in c code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1476692791
https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388:18,Availability,robust,robust,18,"> It doesn't look robust enough to be user facing as it is, but as a private function, if you get a 3.5x, I'd say we want it. I'll rename it to `_from_csr_blocks` and add some more checks on the ordering and shape of the ops if those aren't too expensive and add some tests. We can expose it publicly if that's ever useful. > Technically, just give a type to `i` and it's all running in c code. Thanks! Adding the type to `i` did make it a little faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388
https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388:282,Security,expose,expose,282,"> It doesn't look robust enough to be user facing as it is, but as a private function, if you get a 3.5x, I'd say we want it. I'll rename it to `_from_csr_blocks` and add some more checks on the ordering and shape of the ops if those aren't too expensive and add some tests. We can expose it publicly if that's ever useful. > Technically, just give a type to `i` and it's all running in c code. Thanks! Adding the type to `i` did make it a little faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388
https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388:268,Testability,test,tests,268,"> It doesn't look robust enough to be user facing as it is, but as a private function, if you get a 3.5x, I'd say we want it. I'll rename it to `_from_csr_blocks` and add some more checks on the ordering and shape of the ops if those aren't too expensive and add some tests. We can expose it publicly if that's ever useful. > Technically, just give a type to `i` and it's all running in c code. Thanks! Adding the type to `i` did make it a little faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388
https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457:286,Performance,perform,perform,286,"The problem seems pretty simple, I think I could take care of it. However, I don't have much experience in collaborative programming, in particular I don't know what the local customs are. (I know how to use git, but I'm not familiar with the layout of the library, what tests should I perform [or even add my own, since this issue wasn't noticed before 5.0.0] etc.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457
https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457:271,Testability,test,tests,271,"The problem seems pretty simple, I think I could take care of it. However, I don't have much experience in collaborative programming, in particular I don't know what the local customs are. (I know how to use git, but I'm not familiar with the layout of the library, what tests should I perform [or even add my own, since this issue wasn't noticed before 5.0.0] etc.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457
https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457:25,Usability,simpl,simple,25,"The problem seems pretty simple, I think I could take care of it. However, I don't have much experience in collaborative programming, in particular I don't know what the local customs are. (I know how to use git, but I'm not familiar with the layout of the library, what tests should I perform [or even add my own, since this issue wasn't noticed before 5.0.0] etc.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457
https://github.com/qutip/qutip/pull/2131#issuecomment-1481913534:27,Deployability,integrat,integration,27,"I changed back the default integration method to `taylor1.5` for `smesolve` and `platen` for `ssesolve`.; The property that the state stay physical of `rouchon` is actually problematic since even when the `dt` is too large, the state still look fine but is totally wrong. Whereas other methods will get negative eigenvalues or Nan.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2131#issuecomment-1481913534
https://github.com/qutip/qutip/pull/2131#issuecomment-1481913534:27,Integrability,integrat,integration,27,"I changed back the default integration method to `taylor1.5` for `smesolve` and `platen` for `ssesolve`.; The property that the state stay physical of `rouchon` is actually problematic since even when the `dt` is too large, the state still look fine but is totally wrong. Whereas other methods will get negative eigenvalues or Nan.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2131#issuecomment-1481913534
https://github.com/qutip/qutip/pull/2132#issuecomment-1481288399:146,Testability,test,test,146,"I just cleaned up a tool I used when making the jax data layer, but I don't want to add something that will ask for our time to maintain, thus no test or coverage. In this meaning, it doesn't seems belong here. I am closing this and making a new one with just the missing specializations + will check if they were also skipped in test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2132#issuecomment-1481288399
https://github.com/qutip/qutip/pull/2132#issuecomment-1481288399:330,Testability,test,test,330,"I just cleaned up a tool I used when making the jax data layer, but I don't want to add something that will ask for our time to maintain, thus no test or coverage. In this meaning, it doesn't seems belong here. I am closing this and making a new one with just the missing specializations + will check if they were also skipped in test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2132#issuecomment-1481288399
https://github.com/qutip/qutip/pull/2136#issuecomment-1485494643:31,Usability,simpl,simply,31,"Hi Eric, I would love to but I simply don't know what the git diff issue is, might it be that only the file that I modified should show in the diff?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2136#issuecomment-1485494643
https://github.com/qutip/qutip/pull/2136#issuecomment-1485558289:11,Usability,clear,clearing,11,"Thanks for clearing that, I'm also not sure how that happened, but it should be fixed now",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2136#issuecomment-1485558289
https://github.com/qutip/qutip/pull/2136#issuecomment-1490968491:16,Usability,feedback,feedback,16,"Thanks for your feedback, I think it should be better now",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2136#issuecomment-1490968491
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:978,Deployability,update,updated,978,"Edit: I thought that the original pull request would have been killed such that I would need to submit a new one. I don't think this is the case, as of viewing still open request on Git, so I wont be submitting another pull request unless otherwise informed. I'm going to submit another pull request, and it should be much better this; time. I made these changes:. - Fixed whitespace, blank line, and linting issues as far as I can tell; - I'm not sure that I broke lines up entirely the best way in all ; cases, but I think it looks okay enough as of now.; - Took all of my new functions out of floquet.py and placed them; properly into flimesolve.py; - The version of floquet.py that I'll be submitting was one I; directly copy-pasted from the main repository, such that there; shouldn't be any changes whatsoever to it; - replaced all scipy functions with numpy equivalents; - Fixed the issues in correlation.py, as far as I know; - Turns out the issue here was that I never updated correlation.py to; my most current version, which should only add in flimesolve as an option; for solvers (with an if statement or two to get the Hamiltonian into a; FloquetBasis object if flimesolve is the selected solver). Thanks again for your feedback!. On Mon, Jun 26, 2023 at 6:32PM Fenton Clawson ***@***.***> wrote:. > Hey Eric,; >; > Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:3257,Integrability,Message,Message,3257,"> Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there should not be 3 empty lines; >> in a function.; >>; >> ; >> Reply to this email directly, view it on GitHub; >> <https://github.com/qutip/qutip/pull/2140#pullrequestreview-1499406717>,; >> or unsubscribe; >> <https://github.com/notifications/unsubscribe-auth/AV5WL5EA3UU23BHDUONIEN3XNHYVNANCNFSM6AAAAAAWLGP4AU>; >> .; >> You are receiving this because you authored the thread.Message ID:; >> ***@***.***>; >>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:2410,Testability,Test,Tests,2410,"> Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there should not be 3 empty lines; >> in a function.; >>; >> ; >> Reply to this email directly, view it on GitHub; >> <https://github.com/qutip/qutip/pull/2140#pullrequestreview-1499406717>,; >> or unsubscribe; >> <https://github.com/notifications/unsubscribe-auth/AV5WL5EA3UU23BHDUONIEN3XNHYVNANCNFSM6AAAAAAWLGP4AU>; >> .; >> You are receiving this because you authored the thread.Message ID:; >> ***@***.***>; >>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:2506,Testability,test,tests,2506,"> Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there should not be 3 empty lines; >> in a function.; >>; >> ; >> Reply to this email directly, view it on GitHub; >> <https://github.com/qutip/qutip/pull/2140#pullrequestreview-1499406717>,; >> or unsubscribe; >> <https://github.com/notifications/unsubscribe-auth/AV5WL5EA3UU23BHDUONIEN3XNHYVNANCNFSM6AAAAAAWLGP4AU>; >> .; >> You are receiving this because you authored the thread.Message ID:; >> ***@***.***>; >>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:2571,Testability,test,tests,2571,"> Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there should not be 3 empty lines; >> in a function.; >>; >> ; >> Reply to this email directly, view it on GitHub; >> <https://github.com/qutip/qutip/pull/2140#pullrequestreview-1499406717>,; >> or unsubscribe; >> <https://github.com/notifications/unsubscribe-auth/AV5WL5EA3UU23BHDUONIEN3XNHYVNANCNFSM6AAAAAAWLGP4AU>; >> .; >> You are receiving this because you authored the thread.Message ID:; >> ***@***.***>; >>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:2595,Testability,test,tests,2595,"> Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there should not be 3 empty lines; >> in a function.; >>; >> ; >> Reply to this email directly, view it on GitHub; >> <https://github.com/qutip/qutip/pull/2140#pullrequestreview-1499406717>,; >> or unsubscribe; >> <https://github.com/notifications/unsubscribe-auth/AV5WL5EA3UU23BHDUONIEN3XNHYVNANCNFSM6AAAAAAWLGP4AU>; >> .; >> You are receiving this because you authored the thread.Message ID:; >> ***@***.***>; >>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:1233,Usability,feedback,feedback,1233,"quest unless otherwise informed. I'm going to submit another pull request, and it should be much better this; time. I made these changes:. - Fixed whitespace, blank line, and linting issues as far as I can tell; - I'm not sure that I broke lines up entirely the best way in all ; cases, but I think it looks okay enough as of now.; - Took all of my new functions out of floquet.py and placed them; properly into flimesolve.py; - The version of floquet.py that I'll be submitting was one I; directly copy-pasted from the main repository, such that there; shouldn't be any changes whatsoever to it; - replaced all scipy functions with numpy equivalents; - Fixed the issues in correlation.py, as far as I know; - Turns out the issue here was that I never updated correlation.py to; my most current version, which should only add in flimesolve as an option; for solvers (with an if statement or two to get the Hamiltonian into a; FloquetBasis object if flimesolve is the selected solver). Thanks again for your feedback!. On Mon, Jun 26, 2023 at 6:32PM Fenton Clawson ***@***.***> wrote:. > Hey Eric,; >; > Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Somet",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:1809,Usability,simpl,simply,1809," Fixed the issues in correlation.py, as far as I know; - Turns out the issue here was that I never updated correlation.py to; my most current version, which should only add in flimesolve as an option; for solvers (with an if statement or two to get the Hamiltonian into a; FloquetBasis object if flimesolve is the selected solver). Thanks again for your feedback!. On Mon, Jun 26, 2023 at 6:32PM Fenton Clawson ***@***.***> wrote:. > Hey Eric,; >; > Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:2010,Usability,feedback,feedback,2010,"ich should only add in flimesolve as an option; for solvers (with an if statement or two to get the Hamiltonian into a; FloquetBasis object if flimesolve is the selected solver). Thanks again for your feedback!. On Mon, Jun 26, 2023 at 6:32PM Fenton Clawson ***@***.***> wrote:. > Hey Eric,; >; > Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Gigure ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there should not be 3 empty lines; >> in a function.; >>; >> ; >> Reply to this email directly, view it on GitHub; >> <https://github.com/qutip/qutip/pull/214",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805
https://github.com/qutip/qutip/pull/2140#issuecomment-1610223257:92,Deployability,release,released,92,"I changed the merge target from `qutip-5.0.X` to `master`. The `qutip-...` branches are for released version.; Could you merge the current master branch, we added fixes for the new numpy, scipy version and it should help tests to passes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610223257
https://github.com/qutip/qutip/pull/2140#issuecomment-1610223257:221,Testability,test,tests,221,"I changed the merge target from `qutip-5.0.X` to `master`. The `qutip-...` branches are for released version.; Could you merge the current master branch, we added fixes for the new numpy, scipy version and it should help tests to passes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610223257
https://github.com/qutip/qutip/pull/2140#issuecomment-1610357858:102,Deployability,release,released,102,"Merged. > I changed the merge target from `qutip-5.0.X` to `master`. The `qutip-...` branches are for released version. Could you merge the current master branch, we added fixes for the new numpy, scipy version and it should help tests to passes. Merged my qutip-5.0.X to master",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610357858
https://github.com/qutip/qutip/pull/2140#issuecomment-1610357858:230,Testability,test,tests,230,"Merged. > I changed the merge target from `qutip-5.0.X` to `master`. The `qutip-...` branches are for released version. Could you merge the current master branch, we added fixes for the new numpy, scipy version and it should help tests to passes. Merged my qutip-5.0.X to master",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610357858
https://github.com/qutip/qutip/pull/2146#issuecomment-1492643493:9,Availability,failure,failure,9,The test failure was just the random superoperator `iscptp` and `isherm` test that is being fixed in #2147.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2146#issuecomment-1492643493
https://github.com/qutip/qutip/pull/2146#issuecomment-1492643493:4,Testability,test,test,4,The test failure was just the random superoperator `iscptp` and `isherm` test that is being fixed in #2147.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2146#issuecomment-1492643493
https://github.com/qutip/qutip/pull/2146#issuecomment-1492643493:73,Testability,test,test,73,The test failure was just the random superoperator `iscptp` and `isherm` test that is being fixed in #2147.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2146#issuecomment-1492643493
https://github.com/qutip/qutip/pull/2149#issuecomment-1494599342:20,Availability,ping,pinged,20,@jakelishman I just pinged you for fun and because I though you might like to see the QuTiP documentation builds being dragged into the century of the fruit bat. :),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1494599342
https://github.com/qutip/qutip/pull/2149#issuecomment-1494605382:186,Deployability,patch,patched,186,"Hahaha, thanks! One of the earlier things I did on Qiskit was to get the docs building with current Sphinx (4, at the time) too - we had found a couple of bugs in extensions that I then patched, and we needed to be on latest Sphinx to use them. You'll be ahead of us if you're up to Sphinx 6 - we still have a UI toolkit dependency that limits us (unnecessarily) to Sphinx 5 right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1494605382
https://github.com/qutip/qutip/pull/2149#issuecomment-1494605382:321,Integrability,depend,dependency,321,"Hahaha, thanks! One of the earlier things I did on Qiskit was to get the docs building with current Sphinx (4, at the time) too - we had found a couple of bugs in extensions that I then patched, and we needed to be on latest Sphinx to use them. You'll be ahead of us if you're up to Sphinx 6 - we still have a UI toolkit dependency that limits us (unnecessarily) to Sphinx 5 right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1494605382
https://github.com/qutip/qutip/pull/2149#issuecomment-1494663755:218,Deployability,update,update-doc-build-requirements,218,[![Coverage Status](https://coveralls.io/builds/58517887/badge)](https://coveralls.io/builds/58517887). Coverage: 75.271%. Remained the same when pulling **97596dbf927b20ded1d70ad4d890e377f736dba4 on hodgestar:feature/update-doc-build-requirements** into **32bbdf958ec2fe8ef37e8143f945929ed881ae6a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1494663755
https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797:35,Availability,down,downloading,35,"> Not sure why, but I have trouble downloading opening HTML documentation from the artifact... I will re-run the doc build to see if it change anything. The download worked for me and the HTML and PDF docs look okay.; ; > Is it needed to fix all version up the the micro release?. This PR doesn't change that. We fix the version to micro releases to ensure that the documentation builds don't fail or do odd things without us noticing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797
https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797:157,Availability,down,download,157,"> Not sure why, but I have trouble downloading opening HTML documentation from the artifact... I will re-run the doc build to see if it change anything. The download worked for me and the HTML and PDF docs look okay.; ; > Is it needed to fix all version up the the micro release?. This PR doesn't change that. We fix the version to micro releases to ensure that the documentation builds don't fail or do odd things without us noticing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797
https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797:271,Deployability,release,release,271,"> Not sure why, but I have trouble downloading opening HTML documentation from the artifact... I will re-run the doc build to see if it change anything. The download worked for me and the HTML and PDF docs look okay.; ; > Is it needed to fix all version up the the micro release?. This PR doesn't change that. We fix the version to micro releases to ensure that the documentation builds don't fail or do odd things without us noticing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797
https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797:338,Deployability,release,releases,338,"> Not sure why, but I have trouble downloading opening HTML documentation from the artifact... I will re-run the doc build to see if it change anything. The download worked for me and the HTML and PDF docs look okay.; ; > Is it needed to fix all version up the the micro release?. This PR doesn't change that. We fix the version to micro releases to ensure that the documentation builds don't fail or do odd things without us noticing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2149#issuecomment-1495028797
https://github.com/qutip/qutip/pull/2151#issuecomment-1681332508:50,Deployability,release,released,50,"@hodgestar ; Instead of waiting for the fix to be released in cython, I commented the missing feature: data specializations' `__module__`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2151#issuecomment-1681332508
https://github.com/qutip/qutip/pull/2152#issuecomment-1506604844:136,Testability,test,test,136,I asked @nwlambert to have a look at the memorycascade and tell us whether he thinks it is useful to keep and to help us come up with a test if it is.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2152#issuecomment-1506604844
https://github.com/qutip/qutip/pull/2152#issuecomment-1515698162:233,Testability,test,test,233,"yep just a note that i will take a look at this. I was using a very similar method for the problem in the example notebook, will take a closer look at this and get back with some thoughts on whether to keep it or not and a potential test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2152#issuecomment-1515698162
https://github.com/qutip/qutip/pull/2152#issuecomment-1591401079:57,Testability,test,test,57,Perhaps we could ask Arne himself if he wants to write a test for it? I am a bit surprised that he did not submit it with a notebook at least. @nwlambert are you still in touch with Arne?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2152#issuecomment-1591401079
https://github.com/qutip/qutip/pull/2152#issuecomment-1591408995:207,Testability,test,tests,207,I think this is a valuable piece of qutip and we should try to keep it in if possible. Comparing with other non-Markov solvers seems like an interesting idea. But I agree with @Ericgig that if we don't have tests and a note book then it should be moved to legacy.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2152#issuecomment-1591408995
https://github.com/qutip/qutip/issues/2161#issuecomment-1542433352:311,Availability,error,error,311,"The issue is when the `O[N-1-j][n]` is evaluated. In the second case, it is evaluated when the object is created, but the first case, it is evaluated when the function is used, using the latest `n` and `j`.; If you did `n=None` between creating `H_globallight` and calling mesolve, the first case will raise an error, but the second will work. Since this is an issue with python, not qutip, I will close the issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2161#issuecomment-1542433352
https://github.com/qutip/qutip/pull/2164#issuecomment-1558641653:200,Integrability,depend,dependabot,200,[![Coverage Status](https://coveralls.io/builds/60213413/badge)](https://coveralls.io/builds/60213413). Coverage: 78.092%. Remained the same when pulling **e3d45a55eb8e28845301c9d507742a6dcd87c20f on dependabot/pip/doc/requests-2.31.0** into **7892453dd3ae03ce8ac17caffc0457df200a69ec on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2164#issuecomment-1558641653
https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:156,Availability,error,error,156,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898
https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:924,Availability,error,error,924,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898
https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:643,Safety,avoid,avoid,643,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898
https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:120,Testability,test,tests,120,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898
https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:523,Testability,test,tests,523,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898
https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451:110,Availability,error,error,110,"> I addressed all your comments in my new commit, but when I try to run the tests with pytest I get a strange error:. This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. > Also, to avoid the circular import problem with tensor, would it be better if I created a new py file (qutip.core.fermionic_operators.py) for these new operators? . A new file for this seems too much for me... I think `operators.py` is the best choice but it includes indeed mostly basic operators not using `tensor`. Maybe there is a better place for this @Ericgig ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451
https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451:164,Deployability,install,installed,164,"> I addressed all your comments in my new commit, but when I try to run the tests with pytest I get a strange error:. This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. > Also, to avoid the circular import problem with tensor, would it be better if I created a new py file (qutip.core.fermionic_operators.py) for these new operators? . A new file for this seems too much for me... I think `operators.py` is the best choice but it includes indeed mostly basic operators not using `tensor`. Maybe there is a better place for this @Ericgig ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451
https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451:244,Safety,avoid,avoid,244,"> I addressed all your comments in my new commit, but when I try to run the tests with pytest I get a strange error:. This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. > Also, to avoid the circular import problem with tensor, would it be better if I created a new py file (qutip.core.fermionic_operators.py) for these new operators? . A new file for this seems too much for me... I think `operators.py` is the best choice but it includes indeed mostly basic operators not using `tensor`. Maybe there is a better place for this @Ericgig ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451
https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451:76,Testability,test,tests,76,"> I addressed all your comments in my new commit, but when I try to run the tests with pytest I get a strange error:. This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. > Also, to avoid the circular import problem with tensor, would it be better if I created a new py file (qutip.core.fermionic_operators.py) for these new operators? . A new file for this seems too much for me... I think `operators.py` is the best choice but it includes indeed mostly basic operators not using `tensor`. Maybe there is a better place for this @Ericgig ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451
https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:48,Deployability,install,installed,48,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987
https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:198,Deployability,install,installed,198,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987
https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:312,Testability,test,tests,312,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987
https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:331,Testability,test,tests,331,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987
https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:347,Testability,test,tests,347,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987
https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:416,Testability,test,tests,416,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987
https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:486,Testability,test,tests,486,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987
https://github.com/qutip/qutip/pull/2167#issuecomment-1566246459:71,Modifiability,inherit,inherit,71,"I had also the idea that showing from which base classes these solvers inherit would be enough, but since the issue asks to show `property` and `run` explicitly on each of the solver docs, then I opted do to it this way. Also, from my implementation, also other methods are now documented (e.g. add_integrator). Which I believe since these are public methods, they should be documented as well (?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1566246459
https://github.com/qutip/qutip/pull/2167#issuecomment-1566883813:18,Availability,error,error,18,"I see there is an error when building the pdf but don't understand why. Running the `make pdflatex` command works for me locally. Also the html page is rendered as expected:. <img width=""422"" alt=""Screenshot 2023-05-29 at 11 56 07"" src=""https://github.com/qutip/qutip/assets/57567043/ebbd88a8-df2e-4567-a254-53031d6d7e13"">",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1566883813
https://github.com/qutip/qutip/pull/2167#issuecomment-1566998431:39,Availability,error,errors,39,"In the CI test, we convert warnings to errors. Have you tried `make latexpdf -W`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1566998431
https://github.com/qutip/qutip/pull/2167#issuecomment-1566998431:10,Testability,test,test,10,"In the CI test, we convert warnings to errors. Have you tried `make latexpdf -W`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1566998431
https://github.com/qutip/qutip/pull/2167#issuecomment-1567334034:110,Availability,error,error,110,"I just ran locally:; `make latexpdf SPHINXOPTS=""-W --keep-going -T""`; And got `build succeeded` message.; The error on the project pipeline shows:; `Unknown interpreted text role ""cls"".` for the `me_solver`. Do you have an idea of why could this be happening?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1567334034
https://github.com/qutip/qutip/pull/2167#issuecomment-1567334034:131,Deployability,pipeline,pipeline,131,"I just ran locally:; `make latexpdf SPHINXOPTS=""-W --keep-going -T""`; And got `build succeeded` message.; The error on the project pipeline shows:; `Unknown interpreted text role ""cls"".` for the `me_solver`. Do you have an idea of why could this be happening?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1567334034
https://github.com/qutip/qutip/pull/2167#issuecomment-1567334034:96,Integrability,message,message,96,"I just ran locally:; `make latexpdf SPHINXOPTS=""-W --keep-going -T""`; And got `build succeeded` message.; The error on the project pipeline shows:; `Unknown interpreted text role ""cls"".` for the `me_solver`. Do you have an idea of why could this be happening?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1567334034
https://github.com/qutip/qutip/pull/2167#issuecomment-1571077559:830,Deployability,release,released,830,"Thank you for the comments! . Also, as someone who uses QuTip on a daily basis as part of my work, I was really happy with the changes and restructuring of the solver module. Thank you for the work  . If I may take this opportunity to ask two things:; * I have been looking on Qutip 4.7 for ways to speed up the mc solver simulations, and one of them was to not compute the average density matrix for all times, but only for the last time. Since the behaviour at 4.7 of `mcsolve` was to average the state anyways (despite what I passed on the options object), I found a workaround by having an independent list to create my time dependant Hamiltonian and the `tlist` argument of the solver. Is this something achievable more straightforwardly/differently in Qutip 5.0?; * (shorter): Is there a roadmap for when will Qutip 5.0 be released?. Thank you for your time, and I hope its fine me asking here ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1571077559
https://github.com/qutip/qutip/pull/2167#issuecomment-1571077559:630,Integrability,depend,dependant,630,"Thank you for the comments! . Also, as someone who uses QuTip on a daily basis as part of my work, I was really happy with the changes and restructuring of the solver module. Thank you for the work  . If I may take this opportunity to ask two things:; * I have been looking on Qutip 4.7 for ways to speed up the mc solver simulations, and one of them was to not compute the average density matrix for all times, but only for the last time. Since the behaviour at 4.7 of `mcsolve` was to average the state anyways (despite what I passed on the options object), I found a workaround by having an independent list to create my time dependant Hamiltonian and the `tlist` argument of the solver. Is this something achievable more straightforwardly/differently in Qutip 5.0?; * (shorter): Is there a roadmap for when will Qutip 5.0 be released?. Thank you for your time, and I hope its fine me asking here ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1571077559
https://github.com/qutip/qutip/pull/2167#issuecomment-1575060855:105,Availability,down,down,105,I have added the issue. I have spotted already some suggestions of what can be going wrong and note them down on the issue details!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1575060855
https://github.com/qutip/qutip/pull/2167#issuecomment-1578707335:456,Deployability,release,release,456,"@EmilianoG-byte; Not too sure... When using spline interpolation for time dependent systems, I would recommend to create them before using the solver as to not link the spline times with the solver output times. Which is probably what you are doing with v4 and what you should keep doing for v5. In the next version, the `QobjEvo` is somewhat more user facing and we will probably just document better that this is the way to do it. As for when we plan to release v5, we had to push back the planned release time a few time already so it's hard to say...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1578707335
https://github.com/qutip/qutip/pull/2167#issuecomment-1578707335:500,Deployability,release,release,500,"@EmilianoG-byte; Not too sure... When using spline interpolation for time dependent systems, I would recommend to create them before using the solver as to not link the spline times with the solver output times. Which is probably what you are doing with v4 and what you should keep doing for v5. In the next version, the `QobjEvo` is somewhat more user facing and we will probably just document better that this is the way to do it. As for when we plan to release v5, we had to push back the planned release time a few time already so it's hard to say...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1578707335
https://github.com/qutip/qutip/pull/2167#issuecomment-1578707335:74,Integrability,depend,dependent,74,"@EmilianoG-byte; Not too sure... When using spline interpolation for time dependent systems, I would recommend to create them before using the solver as to not link the spline times with the solver output times. Which is probably what you are doing with v4 and what you should keep doing for v5. In the next version, the `QobjEvo` is somewhat more user facing and we will probably just document better that this is the way to do it. As for when we plan to release v5, we had to push back the planned release time a few time already so it's hard to say...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1578707335
https://github.com/qutip/qutip/pull/2167#issuecomment-1584158549:146,Modifiability,flexible,flexible,146,"@Ericgig, I see. Thank you so much! I had the impression that v5 would change something related to the calculation of density matrices being more flexible. But all in order now. Thank you!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1584158549
https://github.com/qutip/qutip/pull/2170#issuecomment-1596919269:103,Energy Efficiency,energy,energy,103,"I will work on ; plot_wigner_sphere, ; matrix_histogram,; inner functions,; deprecated functions (e.g. energy level diagram),; cmap on qubism and schmidt,; documents",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2170#issuecomment-1596919269
https://github.com/qutip/qutip/pull/2170#issuecomment-1620368190:46,Deployability,update,updated,46,"Other than doing the changes you suggested, I updated [the description](https://github.com/qutip/qutip/pull/2170#issue-1737987577) and deleted all deprecated functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2170#issuecomment-1620368190
https://github.com/qutip/qutip/issues/2172#issuecomment-1828518028:579,Availability,error,error,579,"Seeing this on `5.0.0.dev` with VSCode Insiders. Calling ; ```python; import qutip as qt; qt.fock(2, 0)._repr_latex_(); ``` ; yields `""Quantum object: dims=[[2], [1]], shape=(2, 1), type='ket'\\begin{equation*}\\left(\\begin{array}{*{11}c}1\\\\0\\end{array}\\right)\\end{equation*}""`. So the missing ""equation"" asterisk is being interpreted as markdown when displayed I think, and matching an asterisk in the column alignment argument `*{11}c`.; ```python; from IPython.display import display, Math; Math(qt.fock(2, 0)._repr_latex_()); ```; results in ```ParseError: KaTeX parse error: {equation*} can be used only in display mode.```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2172#issuecomment-1828518028
https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203:648,Deployability,update,updated,648,"> We allow the user to supply the `QobjEvo` class to use as an option, and allow them to specify either the class itself or a name for the class. E.g. `qobjevo_cls=QobjEvoHerm` or `qobjevo_cls=herm`. I would prefer the user not needing to know how we do it, just that there an option that speed up the simulation by 40 % in normal cases. Knowing that we forced it in an alternative qobjevo class is not useful and I hope we won't be forced to add many kinds of qobjevo. > Perhaps we should also not allow users to switch the class later by changing options? That might simplify the logic because we wouldn't need to modify the RHS when options are updated. Since changing options does not change the physic, I would like them to be changeable. But the `rhs`, and `_rhs` is certainly not great. I will rethink the way to do it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203
https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203:582,Testability,log,logic,582,"> We allow the user to supply the `QobjEvo` class to use as an option, and allow them to specify either the class itself or a name for the class. E.g. `qobjevo_cls=QobjEvoHerm` or `qobjevo_cls=herm`. I would prefer the user not needing to know how we do it, just that there an option that speed up the simulation by 40 % in normal cases. Knowing that we forced it in an alternative qobjevo class is not useful and I hope we won't be forced to add many kinds of qobjevo. > Perhaps we should also not allow users to switch the class later by changing options? That might simplify the logic because we wouldn't need to modify the RHS when options are updated. Since changing options does not change the physic, I would like them to be changeable. But the `rhs`, and `_rhs` is certainly not great. I will rethink the way to do it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203
https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203:569,Usability,simpl,simplify,569,"> We allow the user to supply the `QobjEvo` class to use as an option, and allow them to specify either the class itself or a name for the class. E.g. `qobjevo_cls=QobjEvoHerm` or `qobjevo_cls=herm`. I would prefer the user not needing to know how we do it, just that there an option that speed up the simulation by 40 % in normal cases. Knowing that we forced it in an alternative qobjevo class is not useful and I hope we won't be forced to add many kinds of qobjevo. > Perhaps we should also not allow users to switch the class later by changing options? That might simplify the logic because we wouldn't need to modify the RHS when options are updated. Since changing options does not change the physic, I would like them to be changeable. But the `rhs`, and `_rhs` is certainly not great. I will rethink the way to do it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203
https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940:85,Deployability,integrat,integrator,85,@hodgestar . I removed the `_rhs` by changing it so the rhs is built when making the integrator instead of in `__init__`. I also simplified the way options are updated so brmesolve no longer need to overwrite `_apply_options`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940
https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940:160,Deployability,update,updated,160,@hodgestar . I removed the `_rhs` by changing it so the rhs is built when making the integrator instead of in `__init__`. I also simplified the way options are updated so brmesolve no longer need to overwrite `_apply_options`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940
https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940:85,Integrability,integrat,integrator,85,@hodgestar . I removed the `_rhs` by changing it so the rhs is built when making the integrator instead of in `__init__`. I also simplified the way options are updated so brmesolve no longer need to overwrite `_apply_options`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940
https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940:129,Usability,simpl,simplified,129,@hodgestar . I removed the `_rhs` by changing it so the rhs is built when making the integrator instead of in `__init__`. I also simplified the way options are updated so brmesolve no longer need to overwrite `_apply_options`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1681331940
https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812:104,Integrability,Depend,Depending,104,"Yeah in my experience this is something one has to be careful of with the steady-state solver as it is. Depending on the method chosen it can either fail, return one of the possibilities, or some linear combination of them. The default one (direct) tends to fail, which at least sometimes lets you know you have this issue. . We could consider adding null_space solver which returns all possibilities, or modify the existing svd solver to do so if possible? ; Still, if the default ""direct"" method is silently failing it may trip people up still, so adding some examples to the documentation might help, as a minimum. I don't know of a way to extend that direct method to return all possible solutions, and connect those to possible initial conditions. It would be very interesting if its possible!. One minor thing; looking at the the example in the linked paper you provided seems to badly constructed. The dephasing operator they define there is actually just an identity, so does nothing, so technically the second example has no well-defined steady-state at all. A more useful example would be a proper dephasing through a collapse operator = sigma_z, and no driving on the qubit, so the degenerate steady-states are <sigmaz>=\pm 1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812
https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812:643,Modifiability,extend,extend,643,"Yeah in my experience this is something one has to be careful of with the steady-state solver as it is. Depending on the method chosen it can either fail, return one of the possibilities, or some linear combination of them. The default one (direct) tends to fail, which at least sometimes lets you know you have this issue. . We could consider adding null_space solver which returns all possibilities, or modify the existing svd solver to do so if possible? ; Still, if the default ""direct"" method is silently failing it may trip people up still, so adding some examples to the documentation might help, as a minimum. I don't know of a way to extend that direct method to return all possible solutions, and connect those to possible initial conditions. It would be very interesting if its possible!. One minor thing; looking at the the example in the linked paper you provided seems to badly constructed. The dephasing operator they define there is actually just an identity, so does nothing, so technically the second example has no well-defined steady-state at all. A more useful example would be a proper dephasing through a collapse operator = sigma_z, and no driving on the qubit, so the degenerate steady-states are <sigmaz>=\pm 1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812
https://github.com/qutip/qutip/issues/2176#issuecomment-1593531707:28,Usability,simpl,simply,28,NumPy uses dense array. You simply need such a big memory to store those NumPy matrices. There is no way around it. It is important to understand what you want to do with those matrices afterwards. Keeping them as dense matrices is just infeasible. Maybe you can try to get the sparse data by `Qobj.data` and work with that.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2176#issuecomment-1593531707
https://github.com/qutip/qutip/issues/2176#issuecomment-1594313976:50,Performance,perform,performance,50,"`Qobj` also supports `tr()`. It would be nice for performance reasons to stay in QuTiP if possible. But if you do want to get the raw data, `Qobj.data` returns you a custom version of scipy's sparse matrix (at least for qutip 4.7). `qobj.data.trace()` already works for me. You need to use `scipy.sparse.csr_matrix(qobj.data)` to make it compatible with the default scipy csr matrix before using anything in `scipy.sparse.linalg` I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2176#issuecomment-1594313976
https://github.com/qutip/qutip/issues/2179#issuecomment-1601564240:83,Deployability,patch,patch,83,"The fix is already merged in the qutip-4.7.X branch (#2178).; I can't say when the patch will be officially released, but I am expecting it to come sooner than later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2179#issuecomment-1601564240
https://github.com/qutip/qutip/issues/2179#issuecomment-1601564240:108,Deployability,release,released,108,"The fix is already merged in the qutip-4.7.X branch (#2178).; I can't say when the patch will be officially released, but I am expecting it to come sooner than later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2179#issuecomment-1601564240
https://github.com/qutip/qutip/issues/2180#issuecomment-1601563608:181,Deployability,patch,patch,181,"The tests don't work with numpy 1.25, the actual code work but raise warnings from time to time.; The fix is already merged in the qutip-4.7.X branch (#2178).; I can't say when the patch will be officially released, but I am expecting it to come sooner than later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2180#issuecomment-1601563608
https://github.com/qutip/qutip/issues/2180#issuecomment-1601563608:206,Deployability,release,released,206,"The tests don't work with numpy 1.25, the actual code work but raise warnings from time to time.; The fix is already merged in the qutip-4.7.X branch (#2178).; I can't say when the patch will be officially released, but I am expecting it to come sooner than later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2180#issuecomment-1601563608
https://github.com/qutip/qutip/issues/2180#issuecomment-1601563608:4,Testability,test,tests,4,"The tests don't work with numpy 1.25, the actual code work but raise warnings from time to time.; The fix is already merged in the qutip-4.7.X branch (#2178).; I can't say when the patch will be officially released, but I am expecting it to come sooner than later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2180#issuecomment-1601563608
https://github.com/qutip/qutip/issues/2180#issuecomment-1601854467:49,Deployability,install,install,49,"Ok great! Thanks, I was worried I screwed up the install somehow",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2180#issuecomment-1601854467
https://github.com/qutip/qutip/issues/2180#issuecomment-1613443341:21,Deployability,release,released,21,QuTiP 4.7.2 was just released on pypi.; coda-forge release coming next.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2180#issuecomment-1613443341
https://github.com/qutip/qutip/issues/2180#issuecomment-1613443341:51,Deployability,release,release,51,QuTiP 4.7.2 was just released on pypi.; coda-forge release coming next.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2180#issuecomment-1613443341
https://github.com/qutip/qutip/pull/2181#issuecomment-1609825456:208,Deployability,patch,patch-,208,[![Coverage Status](https://coveralls.io/builds/61043380/badge)](https://coveralls.io/builds/61043380). coverage: 78.106% (-0.02%) from 78.129% when pulling **e07d26cc2443f5ade4d9db7a5a929410a9102cad on SJUW:patch-1** into **ec0fcc60142fb5bfb3adc7f9b720fc7b2af9d8a2 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2181#issuecomment-1609825456
https://github.com/qutip/qutip/pull/2181#issuecomment-1610360194:147,Availability,robust,robust,147,"Thanks all, I am new to this and I apologise for the extra help required. Here is the plot. Just FYI, the function ""matrix_histogram"" is much more robust than; ""matrix_histogram_complex"", and has cbar_pad as an option. It may be better; in the long run to base the complex version on the ""matrix_histogram""; function.; [image: image.png]. On Wed, 28 Jun 2023 at 09:00, Yuji TAMAKOSHI ***@***.***>; wrote:. > @SJUW <https://github.com/SJUW> Hi. Can you show me a plot? I want to see; > that your change is better.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2181#issuecomment-1610330125>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/A3KQ4AJKUOCE7MJK42H7APDXNNQYLANCNFSM6AAAAAAZTS45QQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2181#issuecomment-1610360194
https://github.com/qutip/qutip/pull/2181#issuecomment-1610360194:825,Integrability,Message,Message,825,"Thanks all, I am new to this and I apologise for the extra help required. Here is the plot. Just FYI, the function ""matrix_histogram"" is much more robust than; ""matrix_histogram_complex"", and has cbar_pad as an option. It may be better; in the long run to base the complex version on the ""matrix_histogram""; function.; [image: image.png]. On Wed, 28 Jun 2023 at 09:00, Yuji TAMAKOSHI ***@***.***>; wrote:. > @SJUW <https://github.com/SJUW> Hi. Can you show me a plot? I want to see; > that your change is better.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2181#issuecomment-1610330125>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/A3KQ4AJKUOCE7MJK42H7APDXNNQYLANCNFSM6AAAAAAZTS45QQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2181#issuecomment-1610360194
https://github.com/qutip/qutip/issues/2182#issuecomment-1607754914:48,Availability,error,error,48,"Reducing to `scipy==1.10.1` gave me a different error, `AttributeError: partially initialized module 'qutip' has no attribute 'settings' (most likely due to a circular import)`. using:; ```; qutip 4.7.1; scipy 1.10.1; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2182#issuecomment-1607754914
https://github.com/qutip/qutip/issues/2182#issuecomment-1608172869:36,Availability,avail,available,36,"Thank you for reporting, the fix is available in the qutip-4.7.X branch.; We will try to make a release with the fix soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2182#issuecomment-1608172869
https://github.com/qutip/qutip/issues/2182#issuecomment-1608172869:96,Deployability,release,release,96,"Thank you for reporting, the fix is available in the qutip-4.7.X branch.; We will try to make a release with the fix soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2182#issuecomment-1608172869
https://github.com/qutip/qutip/issues/2182#issuecomment-1613333083:21,Deployability,release,released,21,QuTiP 4.7.2 was just released on pypi.; coda-forge release coming next.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2182#issuecomment-1613333083
https://github.com/qutip/qutip/issues/2182#issuecomment-1613333083:51,Deployability,release,release,51,QuTiP 4.7.2 was just released on pypi.; coda-forge release coming next.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2182#issuecomment-1613333083
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:706,Deployability,integrat,integration,706,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:806,Deployability,integrat,integrator,806,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:1545,Deployability,release,release,1545,"mported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + o",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:2879,Deployability,integrat,integrator,2879,"[0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTer",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:2933,Deployability,update,update,2933,"tion_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + re",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:10765,Deployability,update,update,10765,"change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops, c_op_rates = zip(*c_ops_and_rates); >; > or do the check here while you are looping over all elements.; >  Suggested change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops = []; > + c_op_rates = []; > + for c_op, rate in c_ops_and_rates:; > + if not isinstance(c_op, Qobj):; > + raise TypeError(""c_ops must be type Qobj""); > + c_ops.append(c_op); > + c_op_rates.append(rate); >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245642075>:; >; > > + The state must be initialized first by calling ``start`` or; > + ``run``. If ``run`` is called,``step`` will continue from the last; > + time and state obtained.; > + """"""; > + if args:; > + raise ValueError(; > + ""FMESolver cannot update arguments""); > + state = super().step(t); > + if not floquet:; > + state = self.floquet_basis.from_floquet_basis(; > + state, t); > + elif copy:; > + state = state.copy(); > + return state; > +; > + def run(self, state00, taulist, *, floquet=False, args=None, e_ops=None,):; >; > state00?; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245643705>:; >; > > + elif copy:; > + state = state.copy(); > + return state; > +; > + def run(self, state00, taulist, *, floquet=False, args=None, e_ops=None,):; > + """"""; > + Calculate the evolution of the quantum system.; > +; > + For a ``state0`` at time ``tlist[0]`` do the evolution as directed by; > + ``rhs`` and for each time in ``tlist`` store the state and/or; > + expectation values in a :class:`Result`. The evolution method and; > + stored results are determined by ``options``.; > +; > + Parameters; > + ----------; > + state0 : :class:`Qobj`; >; ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:13227,Deployability,update,update,13227,"245663589>:; >; > > + self.floquet_basis.T,; > + c_ops,; > + c_op_rates,; > + Hargs,; > + time_sense=time_sense); > +; > + Rate_Qobj_list = [Qobj(; > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; >; > These self.Rt_timedep_pairs are never used?; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245667295>:; >; > > + floquet : bool,optional {False}; > + Whether to return the state in the floquet basis or laboratory; > + basis.; > +; > + args : dict,optional {None}; > + Not supported; > +; > + .. note::; > + The state must be initialized first by calling ``start`` or; > + ``run``. If ``run`` is called,``step`` will continue from the last; > + time and state obtained.; > + """"""; > + if args:; > + raise ValueError(; > + ""FMESolver cannot update arguments""); > + state = super().step(t); >; > Did you test this?; > I am pretty sure it would not work when time_sense=0.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245668542>:; >; > > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; > + for idx, key in enumerate(RateDic.keys()):; > + if key != 0.0:; > + self.Rt_timedep_pairs.append(list([Rate_Qobj_list[idx],; > + 'exp(1j*' + str(; > + key * list(Hargs.values())[0]); > + + '*t)'])); > + self.Rt_timedep_pairs = [list([Rate_Qobj_list[idx],; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quickso",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:706,Integrability,integrat,integration,706,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:806,Integrability,integrat,integrator,806,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:2879,Integrability,integrat,integrator,2879,"[0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTer",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:5425,Integrability,depend,dependence,5425," + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; >  Suggested change; >; > - Taulist:*list* / *array*; > + tlist: *list* / *array*; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610938>:; >; > > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; > + List of times for :math:`t`.; > +; > + T : float; > + The period of the time-dependence of the hamiltonian.; > +; > + c_ops_and_rates : list of :class:`qutip.Qobj`.; > + List of lists of [collapse operator,collapse operator rate] pairs; >; >  Suggested change; >; > - List of lists of [collapse operator,collapse operator rate] pairs; > + List of lists of [collapse operator, collapse operator rate] pairs; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245611168>:; >; > > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:6170,Integrability,depend,dependent,6170,"] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; > + List of times for :math:`t`.; > +; > + T : float; > + The period of the time-dependence of the hamiltonian.; > +; > + c_ops_and_rates : list of :class:`qutip.Qobj`.; > + List of lists of [collapse operator,collapse operator rate] pairs; >; >  Suggested change; >; > - List of lists of [collapse operator,collapse operator rate] pairs; > + List of lists of [collapse operator, collapse operator rate] pairs; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245611168>:; >; > > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; > + True to use the quicksolve method,which utilizes the most strict; >; >  Suggested change; >; > - True to use the quicksolve method,which utilizes the most strict; > + True to use the quicksolve method, which utilizes the most strict; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245613247>:; >; > > + IVP solvers. Can be overridden if desired (e.g. for; > + debuggin/troubleshooting).; >; > With overwrite you mean using quicksolve with non-zero time_sense?; > If so, how to overwrite it?; >  Suggested change; >; > - IVP solvers. Can be overridd",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:7767,Integrability,depend,dependent,7767,"ict; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245613247>:; >; > > + IVP solvers. Can be overridden if desired (e.g. for; > + debuggin/troubleshooting).; >; > With overwrite you mean using quicksolve with non-zero time_sense?; > If so, how to overwrite it?; >  Suggested change; >; > - IVP solvers. Can be overridden if desired (e.g. for; > - debuggin/troubleshooting).; > + IVP solvers. Can be overridden if desired (e.g. for; > + debuggin/troubleshooting).; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245614869>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > Input that change how the computation is done should be in options.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245616491>:; >; > > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + return total_R_tensor; > +; > +; > +def flimesolve(; > + H,; > + rho0,; > + taulist,; > + T,; > + Nt=None,; >; > There is no docstring entry for Nt.; > ------------------------------; >; > In qutip/solver/fl",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:14691,Integrability,depend,dependent,14691,"+ self.Rt_timedep_pairs = []; > + for idx, key in enumerate(RateDic.keys()):; > + if key != 0.0:; > + self.Rt_timedep_pairs.append(list([Rate_Qobj_list[idx],; > + 'exp(1j*' + str(; > + key * list(Hargs.values())[0]); > + + '*t)'])); > + self.Rt_timedep_pairs = [list([Rate_Qobj_list[idx],; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; > Since time dependent c_ops not being supported is the exception, it would; > be nice to have a note in this regard.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245633903>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > The function does not seems to use it...; >; > ; > Reply to this email directly, view it on GitHub; > <ht",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:15278,Integrability,depend,dependent,15278,"; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; > Since time dependent c_ops not being supported is the exception, it would; > be nice to have a note in this regard.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245633903>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > The function does not seems to use it...; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#pullrequestreview-1502921416>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AGKQRG75CR5YOQUD3XNSCP7ANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:15974,Integrability,Message,Message,15974,"; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; > Since time dependent c_ops not being supported is the exception, it would; > be nice to have a note in this regard.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245633903>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > The function does not seems to use it...; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#pullrequestreview-1502921416>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AGKQRG75CR5YOQUD3XNSCP7ANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:451,Modifiability,variab,variable,451,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:86,Testability,test,tests,86,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:570,Testability,test,tests,570,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:9403,Testability,test,test,9403,"np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + return total_R_tensor; > +; > +; > +def flimesolve(; > + H,; > + rho0,; > + taulist,; > + T,; > + Nt=None,; >; > There is no docstring entry for Nt.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245620508>:; >; > > + if isinstance(floquet_basis, FloquetBasis):; > + self.floquet_basis = floquet_basis; > + else:; > + raise TypeError(; > + ""The ``floquet_basis`` must be a FloquetBasis""); >; > Check done twice; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245632475>:; >; > > + Rate_Qobj_list = [Qobj(; > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; >; > You go the Hdim from the shape, not the dimension. dims has the; > information about subsystem, shape does not. This should make test fail if; > there where some.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245632794>:; >; > > + c_ops = []; > + c_op_rates = []; > + for entry in c_ops_and_rates:; > + c_ops.append(entry[0]); > + c_op_rates.append(entry[1]); >; > Small trick:; >  Suggested change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops, c_op_rates = zip(*c_ops_and_rates); >; > or do the check here while you are looping over all elements.; >  Suggested change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops = []; > + c_op_rates = []; > + for c_op, rate in c_ops_and_rates:; > + if not isinstance(c_op, Qobj):; > + raise TypeError(""c_ops must be type Qobj""); > + c_ops.append(c_op); > + c_op_rates.append(rate); >; > ------------------------",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:13289,Testability,test,test,13289,"e=time_sense); > +; > + Rate_Qobj_list = [Qobj(; > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; >; > These self.Rt_timedep_pairs are never used?; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245667295>:; >; > > + floquet : bool,optional {False}; > + Whether to return the state in the floquet basis or laboratory; > + basis.; > +; > + args : dict,optional {None}; > + Not supported; > +; > + .. note::; > + The state must be initialized first by calling ``start`` or; > + ``run``. If ``run`` is called,``step`` will continue from the last; > + time and state obtained.; > + """"""; > + if args:; > + raise ValueError(; > + ""FMESolver cannot update arguments""); > + state = super().step(t); >; > Did you test this?; > I am pretty sure it would not work when time_sense=0.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245668542>:; >; > > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; > + for idx, key in enumerate(RateDic.keys()):; > + if key != 0.0:; > + self.Rt_timedep_pairs.append(list([Rate_Qobj_list[idx],; > + 'exp(1j*' + str(; > + key * list(Hargs.values())[0]); > + + '*t)'])); > + self.Rt_timedep_pairs = [list([Rate_Qobj_list[idx],; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:1050,Usability,guid,guide,1050," like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > -------------",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:3305,Usability,learn,learned,3305,"r(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + return total_R_tensor; > +; > +; > +def flimesolve(; > + H,; > + rho0,; > + taulist,; >; >  Suggested change; >; > - taulist,; > + tlist,; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610703>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H :",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:698,Deployability,integrat,integration,698,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:798,Deployability,integrat,integrator,798,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:1537,Deployability,release,release,1537,"mported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + o",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:2871,Deployability,integrat,integrator,2871,"[0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTer",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:2925,Deployability,update,update,2925,"tion_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + re",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:10757,Deployability,update,update,10757,"change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops, c_op_rates = zip(*c_ops_and_rates); >; > or do the check here while you are looping over all elements.; >  Suggested change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops = []; > + c_op_rates = []; > + for c_op, rate in c_ops_and_rates:; > + if not isinstance(c_op, Qobj):; > + raise TypeError(""c_ops must be type Qobj""); > + c_ops.append(c_op); > + c_op_rates.append(rate); >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245642075>:; >; > > + The state must be initialized first by calling ``start`` or; > + ``run``. If ``run`` is called,``step`` will continue from the last; > + time and state obtained.; > + """"""; > + if args:; > + raise ValueError(; > + ""FMESolver cannot update arguments""); > + state = super().step(t); > + if not floquet:; > + state = self.floquet_basis.from_floquet_basis(; > + state, t); > + elif copy:; > + state = state.copy(); > + return state; > +; > + def run(self, state00, taulist, *, floquet=False, args=None, e_ops=None,):; >; > state00?; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245643705>:; >; > > + elif copy:; > + state = state.copy(); > + return state; > +; > + def run(self, state00, taulist, *, floquet=False, args=None, e_ops=None,):; > + """"""; > + Calculate the evolution of the quantum system.; > +; > + For a ``state0`` at time ``tlist[0]`` do the evolution as directed by; > + ``rhs`` and for each time in ``tlist`` store the state and/or; > + expectation values in a :class:`Result`. The evolution method and; > + stored results are determined by ``options``.; > +; > + Parameters; > + ----------; > + state0 : :class:`Qobj`; >; ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:13219,Deployability,update,update,13219,"245663589>:; >; > > + self.floquet_basis.T,; > + c_ops,; > + c_op_rates,; > + Hargs,; > + time_sense=time_sense); > +; > + Rate_Qobj_list = [Qobj(; > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; >; > These self.Rt_timedep_pairs are never used?; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245667295>:; >; > > + floquet : bool,optional {False}; > + Whether to return the state in the floquet basis or laboratory; > + basis.; > +; > + args : dict,optional {None}; > + Not supported; > +; > + .. note::; > + The state must be initialized first by calling ``start`` or; > + ``run``. If ``run`` is called,``step`` will continue from the last; > + time and state obtained.; > + """"""; > + if args:; > + raise ValueError(; > + ""FMESolver cannot update arguments""); > + state = super().step(t); >; > Did you test this?; > I am pretty sure it would not work when time_sense=0.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245668542>:; >; > > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; > + for idx, key in enumerate(RateDic.keys()):; > + if key != 0.0:; > + self.Rt_timedep_pairs.append(list([Rate_Qobj_list[idx],; > + 'exp(1j*' + str(; > + key * list(Hargs.values())[0]); > + + '*t)'])); > + self.Rt_timedep_pairs = [list([Rate_Qobj_list[idx],; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quickso",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:698,Integrability,integrat,integration,698,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:798,Integrability,integrat,integrator,798,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:2871,Integrability,integrat,integrator,2871,"[0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245592358>:; >; > > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense; > + ); >; >  Suggested change; >; > - solver_instance = FLiMESolver(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTer",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:5417,Integrability,depend,dependence,5417," + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; >  Suggested change; >; > - Taulist:*list* / *array*; > + tlist: *list* / *array*; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610938>:; >; > > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; > + List of times for :math:`t`.; > +; > + T : float; > + The period of the time-dependence of the hamiltonian.; > +; > + c_ops_and_rates : list of :class:`qutip.Qobj`.; > + List of lists of [collapse operator,collapse operator rate] pairs; >; >  Suggested change; >; > - List of lists of [collapse operator,collapse operator rate] pairs; > + List of lists of [collapse operator, collapse operator rate] pairs; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245611168>:; >; > > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:6162,Integrability,depend,dependent,6162,"] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; > + List of times for :math:`t`.; > +; > + T : float; > + The period of the time-dependence of the hamiltonian.; > +; > + c_ops_and_rates : list of :class:`qutip.Qobj`.; > + List of lists of [collapse operator,collapse operator rate] pairs; >; >  Suggested change; >; > - List of lists of [collapse operator,collapse operator rate] pairs; > + List of lists of [collapse operator, collapse operator rate] pairs; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245611168>:; >; > > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; > + True to use the quicksolve method,which utilizes the most strict; >; >  Suggested change; >; > - True to use the quicksolve method,which utilizes the most strict; > + True to use the quicksolve method, which utilizes the most strict; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245613247>:; >; > > + IVP solvers. Can be overridden if desired (e.g. for; > + debuggin/troubleshooting).; >; > With overwrite you mean using quicksolve with non-zero time_sense?; > If so, how to overwrite it?; >  Suggested change; >; > - IVP solvers. Can be overridd",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:7759,Integrability,depend,dependent,7759,"ict; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245613247>:; >; > > + IVP solvers. Can be overridden if desired (e.g. for; > + debuggin/troubleshooting).; >; > With overwrite you mean using quicksolve with non-zero time_sense?; > If so, how to overwrite it?; >  Suggested change; >; > - IVP solvers. Can be overridden if desired (e.g. for; > - debuggin/troubleshooting).; > + IVP solvers. Can be overridden if desired (e.g. for; > + debuggin/troubleshooting).; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245614869>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > Input that change how the computation is done should be in options.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245616491>:; >; > > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + return total_R_tensor; > +; > +; > +def flimesolve(; > + H,; > + rho0,; > + taulist,; > + T,; > + Nt=None,; >; > There is no docstring entry for Nt.; > ------------------------------; >; > In qutip/solver/fl",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:14683,Integrability,depend,dependent,14683,"+ self.Rt_timedep_pairs = []; > + for idx, key in enumerate(RateDic.keys()):; > + if key != 0.0:; > + self.Rt_timedep_pairs.append(list([Rate_Qobj_list[idx],; > + 'exp(1j*' + str(; > + key * list(Hargs.values())[0]); > + + '*t)'])); > + self.Rt_timedep_pairs = [list([Rate_Qobj_list[idx],; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; > Since time dependent c_ops not being supported is the exception, it would; > be nice to have a note in this regard.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245633903>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > The function does not seems to use it...; >; > ; > Reply to this email directly, view it on GitHub; > <ht",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:15270,Integrability,depend,dependent,15270,"; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; > Since time dependent c_ops not being supported is the exception, it would; > be nice to have a note in this regard.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245633903>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > The function does not seems to use it...; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#pullrequestreview-1502921416>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AGKQRG75CR5YOQUD3XNSCP7ANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:15966,Integrability,Message,Message,15966,"; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,:class:`QobjEvo`,:class:`QobjEvo` compatible format.; > + Periodic system Hamiltonian as :class:`QobjEvo`. List of; > + [:class:`Qobj`,:class:`Coefficient`] or callable that; > + can be made into :class:`QobjEvo` are also accepted.; > +; > + rho0 / psi0 : :class:`qutip.Qobj`; > + Initial density matrix or state vector (ket).; > +; > + Taulist:*list* / *array*; >; > Since time dependent c_ops not being supported is the exception, it would; > be nice to have a note in this regard.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245633903>:; >; > > + List of lists of [collapse operator,collapse operator rate] pairs; > +; > + e_ops : list of :class:`qutip.Qobj` / callback function; > + List of operators for which to evaluate expectation values.; > + The states are reverted to the lab basis before applying the; > +; > + args : *dictionary*; > + Dictionary of parameters for time-dependent Hamiltonian; > +; > + time_sense : float; > + Experimental. Value of the secular approximation (in terms of system; > + frequency 2*np.pi/T) to use when constructing the rate matrix R(t).; > + Default value of zero uses the fully time-independent/most strict; > + secular approximation.; > +; > + quicksolve: Boolean; >; > The function does not seems to use it...; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#pullrequestreview-1502921416>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AGKQRG75CR5YOQUD3XNSCP7ANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:443,Modifiability,variab,variable,443,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:562,Testability,test,tests,562,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:9395,Testability,test,test,9395,"np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + return total_R_tensor; > +; > +; > +def flimesolve(; > + H,; > + rho0,; > + taulist,; > + T,; > + Nt=None,; >; > There is no docstring entry for Nt.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245620508>:; >; > > + if isinstance(floquet_basis, FloquetBasis):; > + self.floquet_basis = floquet_basis; > + else:; > + raise TypeError(; > + ""The ``floquet_basis`` must be a FloquetBasis""); >; > Check done twice; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245632475>:; >; > > + Rate_Qobj_list = [Qobj(; > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; >; > You go the Hdim from the shape, not the dimension. dims has the; > information about subsystem, shape does not. This should make test fail if; > there where some.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245632794>:; >; > > + c_ops = []; > + c_op_rates = []; > + for entry in c_ops_and_rates:; > + c_ops.append(entry[0]); > + c_op_rates.append(entry[1]); >; > Small trick:; >  Suggested change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops, c_op_rates = zip(*c_ops_and_rates); >; > or do the check here while you are looping over all elements.; >  Suggested change; >; > - c_ops = []; > - c_op_rates = []; > - for entry in c_ops_and_rates:; > - c_ops.append(entry[0]); > - c_op_rates.append(entry[1]); > + c_ops = []; > + c_op_rates = []; > + for c_op, rate in c_ops_and_rates:; > + if not isinstance(c_op, Qobj):; > + raise TypeError(""c_ops must be type Qobj""); > + c_ops.append(c_op); > + c_op_rates.append(rate); >; > ------------------------",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:13281,Testability,test,test,13281,"e=time_sense); > +; > + Rate_Qobj_list = [Qobj(; > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; >; > These self.Rt_timedep_pairs are never used?; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245667295>:; >; > > + floquet : bool,optional {False}; > + Whether to return the state in the floquet basis or laboratory; > + basis.; > +; > + args : dict,optional {None}; > + Not supported; > +; > + .. note::; > + The state must be initialized first by calling ``start`` or; > + ``run``. If ``run`` is called,``step`` will continue from the last; > + time and state obtained.; > + """"""; > + if args:; > + raise ValueError(; > + ""FMESolver cannot update arguments""); > + state = super().step(t); >; > Did you test this?; > I am pretty sure it would not work when time_sense=0.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245668542>:; >; > > + RateMat, dims=[[self.Hdim, self.Hdim], [; > + self.Hdim, self.Hdim]],; > + type=""super"",; > + superrep=""super"",; > + copy=False; > + ) for RateMat in RateDic.values()]; > + self.R0 = Rate_Qobj_list[0]; > +; > + self.Rt_timedep_pairs = []; > + for idx, key in enumerate(RateDic.keys()):; > + if key != 0.0:; > + self.Rt_timedep_pairs.append(list([Rate_Qobj_list[idx],; > + 'exp(1j*' + str(; > + key * list(Hargs.values())[0]); > + + '*t)'])); > + self.Rt_timedep_pairs = [list([Rate_Qobj_list[idx],; >; > This is defined twice...; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245675791>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H : :class:`Qobj`,",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:1042,Usability,guid,guide,1042,"ugh your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Gigure ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; >  Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op; > + )[0]; >; > -------------",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:3297,Usability,learn,learned,3297,"r(; > - floquet_basis,; > - c_ops,; > - args,; > - time_sense=time_sense; > - ); > + solver_instance = FLiMESolver(; > + floquet_basis,; > + c_ops,; > + args,; > + time_sense=time_sense,; > + options=options,; > + ); >; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245594985>:; >; > > @@ -929,4 +930,5 @@ def run(self, state0, tlist, *, floquet=False, args=None, e_ops=None):; > stats[""run time""] = progress_bar.total_time(); > # TODO: It would be nice if integrator could give evolution statistics; > # stats.update(_integrator.stats); > +; >; > Why a new empty line here?; > ------------------------------; >; > In qutip/solver/floquet.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245604228>:; >; > > + self.evecs = _data.permute.indices(; > + evecs, col_perm=np.argsort(perm)); >; > This file already has black ran on it and the style is ok as is.; > (But I just learned that black exclude the newline in it's character count; > while pycodestyle include it.); > Since it's not the main part of your PR, please revert it to it's original; > state.; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610200>:; >; > > + total_R_tensor[key] += np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + except KeyError:; > + total_R_tensor[key] = np.reshape(flime_FirstTerm - (1 / 2); > + * (flime_SecondTerm +; > + flime_ThirdTerm),; > + (Hdim**2, Hdim**2)); > + return total_R_tensor; > +; > +; > +def flimesolve(; > + H,; > + rho0,; > + taulist,; >; >  Suggested change; >; > - taulist,; > + tlist,; >; > ------------------------------; >; > In qutip/solver/flimesolve.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245610703>:; >; > > + time_sense=0,; > + quicksolve=False,; > + options=None):; > + """"""; > + Parameters; > + ----------; > +; > + H :",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839
https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050:438,Testability,test,tests,438,"@magnamancer I think part of the issue was that you merged `qutip-5.0.X` into `master` but that shouldn't have been done because `master` now contains the latest 5.X qutip code. Sorry to be a pain, but could you open a new new PR with just your changes? No need to be fancy -- just create a new branch from master, copy across the files you want to change, create PR. The `VERSION` file should not be changed. How hard would it be to add tests? I remember you have tests in a notebook somewhere. If you can point me at the latest versions, I can think about how to convert them into unit tests and add them to the new PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050
https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050:465,Testability,test,tests,465,"@magnamancer I think part of the issue was that you merged `qutip-5.0.X` into `master` but that shouldn't have been done because `master` now contains the latest 5.X qutip code. Sorry to be a pain, but could you open a new new PR with just your changes? No need to be fancy -- just create a new branch from master, copy across the files you want to change, create PR. The `VERSION` file should not be changed. How hard would it be to add tests? I remember you have tests in a notebook somewhere. If you can point me at the latest versions, I can think about how to convert them into unit tests and add them to the new PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050
https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050:588,Testability,test,tests,588,"@magnamancer I think part of the issue was that you merged `qutip-5.0.X` into `master` but that shouldn't have been done because `master` now contains the latest 5.X qutip code. Sorry to be a pain, but could you open a new new PR with just your changes? No need to be fancy -- just create a new branch from master, copy across the files you want to change, create PR. The `VERSION` file should not be changed. How hard would it be to add tests? I remember you have tests in a notebook somewhere. If you can point me at the latest versions, I can think about how to convert them into unit tests and add them to the new PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050
https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:2516,Integrability,Message,Message,2516,"t I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you can point me at the latest versions, I can think about; > how to convert them into unit tests and add them to the new PR.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AU2Z2WLCVH7BFC2QLXOW6QNANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036
https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:428,Testability,test,tests,428,"Hey Simon,. I've been working on a few issues this last week that Eric pointed out. I actually did end up going back and just copying the master branch to my; local and copying in my changes, so hopefully that won't be an issue going; forward. I'll likely do it a second time before submitting another request; just to be sure there wasn't anything I changed that I've forgotten about. I've also been working on adding in a few tests. I'm mostly working on; mirroring the floquet_test test file as best I can, although it looks like; there are some slight changes I need to make that I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036
https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:485,Testability,test,test,485,"Hey Simon,. I've been working on a few issues this last week that Eric pointed out. I actually did end up going back and just copying the master branch to my; local and copying in my changes, so hopefully that won't be an issue going; forward. I'll likely do it a second time before submitting another request; just to be sure there wasn't anything I changed that I've forgotten about. I've also been working on adding in a few tests. I'm mostly working on; mirroring the floquet_test test file as best I can, although it looks like; there are some slight changes I need to make that I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036
https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:1138,Testability,test,testing,1138,"I actually did end up going back and just copying the master branch to my; local and copying in my changes, so hopefully that won't be an issue going; forward. I'll likely do it a second time before submitting another request; just to be sure there wasn't anything I changed that I've forgotten about. I've also been working on adding in a few tests. I'm mostly working on; mirroring the floquet_test test file as best I can, although it looks like; there are some slight changes I need to make that I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you ca",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036
https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:2014,Testability,test,tests,2014,"t I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you can point me at the latest versions, I can think about; > how to convert them into unit tests and add them to the new PR.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AU2Z2WLCVH7BFC2QLXOW6QNANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036
https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:2041,Testability,test,tests,2041,"t I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you can point me at the latest versions, I can think about; > how to convert them into unit tests and add them to the new PR.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AU2Z2WLCVH7BFC2QLXOW6QNANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036
https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:2170,Testability,test,tests,2170,"t I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you can point me at the latest versions, I can think about; > how to convert them into unit tests and add them to the new PR.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AU2Z2WLCVH7BFC2QLXOW6QNANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036
https://github.com/qutip/qutip/pull/2186#issuecomment-1624220778:170,Testability,test,test,170,"Hey Simon and Eric,. - I've gone through and fixed (I hope!) the formatting and code issues due to the bad merge I did last week; - I've added in flimesolve_test.py as a test script for flimesolve; - I've tried to format everything according to PEP8, although there are likely some issues here. I've not had any formal training on PEP8 formatting (and python in general, to be honest), such that even with the help of the PEP8 style guide and Spyder's auto-formatting tool for PEP8, I'm sure there are some small fixes that need to be made; - I'm not entirely sure what Eric meant about separating out the physics from the data container, etc. I moved anything having to do with the precalculation of the Floquet states into its own function, but to kill this precalculation off entirely would severely hinder the speed of flimesolve, as an large advantage of Floquet theory comes from being able to accurately create the basis states at any time once you have the initial basis states. If this is still an issue (or if I've misinterpreted Eric's comment entirely and need to change something else in this regard), please let me know. Maybe we could have a live discussion over the issue, if that would work better. Thanks for your help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1624220778
https://github.com/qutip/qutip/pull/2186#issuecomment-1624220778:433,Usability,guid,guide,433,"Hey Simon and Eric,. - I've gone through and fixed (I hope!) the formatting and code issues due to the bad merge I did last week; - I've added in flimesolve_test.py as a test script for flimesolve; - I've tried to format everything according to PEP8, although there are likely some issues here. I've not had any formal training on PEP8 formatting (and python in general, to be honest), such that even with the help of the PEP8 style guide and Spyder's auto-formatting tool for PEP8, I'm sure there are some small fixes that need to be made; - I'm not entirely sure what Eric meant about separating out the physics from the data container, etc. I moved anything having to do with the precalculation of the Floquet states into its own function, but to kill this precalculation off entirely would severely hinder the speed of flimesolve, as an large advantage of Floquet theory comes from being able to accurately create the basis states at any time once you have the initial basis states. If this is still an issue (or if I've misinterpreted Eric's comment entirely and need to change something else in this regard), please let me know. Maybe we could have a live discussion over the issue, if that would work better. Thanks for your help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1624220778
https://github.com/qutip/qutip/pull/2186#issuecomment-1631197945:706,Testability,test,test,706,"Could you send the equation for the case where `time_sense` is not `0`. When I try it with a period of `1.0` it give extra term with very low frequencies:; ```; dict_keys([0.0, 4.304872064735899e-09, 1.0157988986038049e-08, 1.1379302858450767e-08, -2.9820390185456766e-09, -4.304872064735899e-09, 5.8531169213021495e-09, 7.074430793714867e-09, -7.286911083281576e-09, -1.0157988986038049e-08, -5.8531169213021495e-09, 1.2213138724127176e-09, -1.3140028004583725e-08, -1.1379302858450767e-08, -7.074430793714867e-09, -1.2213138724127176e-09, -1.4361341876996443e-08, 2.9820390185456766e-09, 7.286911083281576e-09, 1.3140028004583725e-08, 1.4361341876996443e-08]); ```. Is it normal? You did not include any test using `time_sense`. ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631197945
https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788:2610,Deployability,update,update,2610,"61341876996443e-08]); > ```; > ; > Is it normal? You did not include any test using `time_sense`.; > ; > . The relaxation of the secular approximation isn't by direct time-dependence. It was originally, but this was later changed to relax the secular approximation according to the ""importance"" of each term, which is dictated by a quotient. The numerator of the quotient is the product of the FFT coefficients that make up a certain element of the rate matrix super operator, and the denominator is the difference of frequencies between the two elements multiplied by the system frequency omega. When `time_sense` is `0`, the rate matrix is constructed using only the product of FFT coefficients for which the frequency arguments completely cancel. When `timesense` isn't `0`, however, is when that quotient comes into play. In a nutshell, this ends up dividing the rate at which a certain element changes the system by the frequency at which that rate rotates in the Floquet Basis. If the result of the quotient is small, the frequency is much higher than the collapse operator elements actually affect the system, such that it averages out on longer timescales. If the result of the quotient is large, then the collapse operator elements appreciably change the system on a shorter timescale than they rotate, such that their contribution to the overall matrix can't be ignored. If I've explained this poorly, which I suspect is the case since I'm not sure how to add equations here or if that's possible, I can email you with a more thorough explanation. . I haven't included tests for the latter case yet mostly due to my only dealing with systems heavily dictated by their primary frequency, so far. I'm working on a system now that should show different behavior for different secular approximations, but my results look slightly different from the published results such that I'm not sure I'm very confident in what I've done, yet. I'll try to update with a test for this when I can, however.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788
https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788:831,Integrability,depend,dependence,831,"> Could you send the equation for the case where `time_sense` is not `0`.; > ; > When I try it with a period of `1.0` it give extra term with very low frequencies:; > ; > ```; > dict_keys([0.0, 4.304872064735899e-09, 1.0157988986038049e-08, 1.1379302858450767e-08, -2.9820390185456766e-09, -4.304872064735899e-09, 5.8531169213021495e-09, 7.074430793714867e-09, -7.286911083281576e-09, -1.0157988986038049e-08, -5.8531169213021495e-09, 1.2213138724127176e-09, -1.3140028004583725e-08, -1.1379302858450767e-08, -7.074430793714867e-09, -1.2213138724127176e-09, -1.4361341876996443e-08, 2.9820390185456766e-09, 7.286911083281576e-09, 1.3140028004583725e-08, 1.4361341876996443e-08]); > ```; > ; > Is it normal? You did not include any test using `time_sense`.; > ; > . The relaxation of the secular approximation isn't by direct time-dependence. It was originally, but this was later changed to relax the secular approximation according to the ""importance"" of each term, which is dictated by a quotient. The numerator of the quotient is the product of the FFT coefficients that make up a certain element of the rate matrix super operator, and the denominator is the difference of frequencies between the two elements multiplied by the system frequency omega. When `time_sense` is `0`, the rate matrix is constructed using only the product of FFT coefficients for which the frequency arguments completely cancel. When `timesense` isn't `0`, however, is when that quotient comes into play. In a nutshell, this ends up dividing the rate at which a certain element changes the system by the frequency at which that rate rotates in the Floquet Basis. If the result of the quotient is small, the frequency is much higher than the collapse operator elements actually affect the system, such that it averages out on longer timescales. If the result of the quotient is large, then the collapse operator elements appreciably change the system on a shorter timescale than they rotate, such that their contribution t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788
https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788:731,Testability,test,test,731,"> Could you send the equation for the case where `time_sense` is not `0`.; > ; > When I try it with a period of `1.0` it give extra term with very low frequencies:; > ; > ```; > dict_keys([0.0, 4.304872064735899e-09, 1.0157988986038049e-08, 1.1379302858450767e-08, -2.9820390185456766e-09, -4.304872064735899e-09, 5.8531169213021495e-09, 7.074430793714867e-09, -7.286911083281576e-09, -1.0157988986038049e-08, -5.8531169213021495e-09, 1.2213138724127176e-09, -1.3140028004583725e-08, -1.1379302858450767e-08, -7.074430793714867e-09, -1.2213138724127176e-09, -1.4361341876996443e-08, 2.9820390185456766e-09, 7.286911083281576e-09, 1.3140028004583725e-08, 1.4361341876996443e-08]); > ```; > ; > Is it normal? You did not include any test using `time_sense`.; > ; > . The relaxation of the secular approximation isn't by direct time-dependence. It was originally, but this was later changed to relax the secular approximation according to the ""importance"" of each term, which is dictated by a quotient. The numerator of the quotient is the product of the FFT coefficients that make up a certain element of the rate matrix super operator, and the denominator is the difference of frequencies between the two elements multiplied by the system frequency omega. When `time_sense` is `0`, the rate matrix is constructed using only the product of FFT coefficients for which the frequency arguments completely cancel. When `timesense` isn't `0`, however, is when that quotient comes into play. In a nutshell, this ends up dividing the rate at which a certain element changes the system by the frequency at which that rate rotates in the Floquet Basis. If the result of the quotient is small, the frequency is much higher than the collapse operator elements actually affect the system, such that it averages out on longer timescales. If the result of the quotient is large, then the collapse operator elements appreciably change the system on a shorter timescale than they rotate, such that their contribution t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788
https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788:2238,Testability,test,tests,2238,"61341876996443e-08]); > ```; > ; > Is it normal? You did not include any test using `time_sense`.; > ; > . The relaxation of the secular approximation isn't by direct time-dependence. It was originally, but this was later changed to relax the secular approximation according to the ""importance"" of each term, which is dictated by a quotient. The numerator of the quotient is the product of the FFT coefficients that make up a certain element of the rate matrix super operator, and the denominator is the difference of frequencies between the two elements multiplied by the system frequency omega. When `time_sense` is `0`, the rate matrix is constructed using only the product of FFT coefficients for which the frequency arguments completely cancel. When `timesense` isn't `0`, however, is when that quotient comes into play. In a nutshell, this ends up dividing the rate at which a certain element changes the system by the frequency at which that rate rotates in the Floquet Basis. If the result of the quotient is small, the frequency is much higher than the collapse operator elements actually affect the system, such that it averages out on longer timescales. If the result of the quotient is large, then the collapse operator elements appreciably change the system on a shorter timescale than they rotate, such that their contribution to the overall matrix can't be ignored. If I've explained this poorly, which I suspect is the case since I'm not sure how to add equations here or if that's possible, I can email you with a more thorough explanation. . I haven't included tests for the latter case yet mostly due to my only dealing with systems heavily dictated by their primary frequency, so far. I'm working on a system now that should show different behavior for different secular approximations, but my results look slightly different from the published results such that I'm not sure I'm very confident in what I've done, yet. I'll try to update with a test for this when I can, however.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788
https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788:2624,Testability,test,test,2624,"61341876996443e-08]); > ```; > ; > Is it normal? You did not include any test using `time_sense`.; > ; > . The relaxation of the secular approximation isn't by direct time-dependence. It was originally, but this was later changed to relax the secular approximation according to the ""importance"" of each term, which is dictated by a quotient. The numerator of the quotient is the product of the FFT coefficients that make up a certain element of the rate matrix super operator, and the denominator is the difference of frequencies between the two elements multiplied by the system frequency omega. When `time_sense` is `0`, the rate matrix is constructed using only the product of FFT coefficients for which the frequency arguments completely cancel. When `timesense` isn't `0`, however, is when that quotient comes into play. In a nutshell, this ends up dividing the rate at which a certain element changes the system by the frequency at which that rate rotates in the Floquet Basis. If the result of the quotient is small, the frequency is much higher than the collapse operator elements actually affect the system, such that it averages out on longer timescales. If the result of the quotient is large, then the collapse operator elements appreciably change the system on a shorter timescale than they rotate, such that their contribution to the overall matrix can't be ignored. If I've explained this poorly, which I suspect is the case since I'm not sure how to add equations here or if that's possible, I can email you with a more thorough explanation. . I haven't included tests for the latter case yet mostly due to my only dealing with systems heavily dictated by their primary frequency, so far. I'm working on a system now that should show different behavior for different secular approximations, but my results look slightly different from the published results such that I'm not sure I'm very confident in what I've done, yet. I'll try to update with a test for this when I can, however.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788
https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935:101,Energy Efficiency,efficient,efficient,101,"Hey Eric,. I've been working on improving the underlying structure of FLiMESolve and; making it more efficient. I haven't done another review request yet because; I want to try to address as many things as I can at once. I've been delayed; heavily by a system I'm trying to solve for my paper about this solver, on; which Simon has offered to help such that I'll hopefully be moving forward; again soon. Additionally, there are some changes I want to make that I'm; not sure how to do which I'm going to try to address with Simon when we are; able to meet next. Most of those are in regards to structural things, e.g.; how to filter input ""args"" arguments to pull out the frequency of the; Hamiltonian in the same manner as other solvers in QuTiP are able to filter; arguments. I've been trying to avoid submitting review requests/questions; in the PR comments too much so as not to be a bother. I have definitely not; abandoned this PR, and plan on seeing it through fully, although I; apologize for my relative lack of communication the last few weeks. Thanks!. On Mon, Aug 21, 2023, 11:29 AM Eric Gigure ***@***.***>; wrote:. > @magnamancer <https://github.com/magnamancer> are you waiting for review,; > still working on the PR or abandoned it?; >; > There are still issues I raised here and in magnamancer#4; > <https://github.com/magnamancer/qutip/pull/4>, that you have not been; > addressed and I am waiting for them before the next round of review.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1686550860>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5GN3R6GPKYKYNOWSGDXWN5GDANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935
https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935:1771,Integrability,Message,Message,1771,"Hey Eric,. I've been working on improving the underlying structure of FLiMESolve and; making it more efficient. I haven't done another review request yet because; I want to try to address as many things as I can at once. I've been delayed; heavily by a system I'm trying to solve for my paper about this solver, on; which Simon has offered to help such that I'll hopefully be moving forward; again soon. Additionally, there are some changes I want to make that I'm; not sure how to do which I'm going to try to address with Simon when we are; able to meet next. Most of those are in regards to structural things, e.g.; how to filter input ""args"" arguments to pull out the frequency of the; Hamiltonian in the same manner as other solvers in QuTiP are able to filter; arguments. I've been trying to avoid submitting review requests/questions; in the PR comments too much so as not to be a bother. I have definitely not; abandoned this PR, and plan on seeing it through fully, although I; apologize for my relative lack of communication the last few weeks. Thanks!. On Mon, Aug 21, 2023, 11:29 AM Eric Gigure ***@***.***>; wrote:. > @magnamancer <https://github.com/magnamancer> are you waiting for review,; > still working on the PR or abandoned it?; >; > There are still issues I raised here and in magnamancer#4; > <https://github.com/magnamancer/qutip/pull/4>, that you have not been; > addressed and I am waiting for them before the next round of review.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1686550860>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5GN3R6GPKYKYNOWSGDXWN5GDANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935
https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935:798,Safety,avoid,avoid,798,"Hey Eric,. I've been working on improving the underlying structure of FLiMESolve and; making it more efficient. I haven't done another review request yet because; I want to try to address as many things as I can at once. I've been delayed; heavily by a system I'm trying to solve for my paper about this solver, on; which Simon has offered to help such that I'll hopefully be moving forward; again soon. Additionally, there are some changes I want to make that I'm; not sure how to do which I'm going to try to address with Simon when we are; able to meet next. Most of those are in regards to structural things, e.g.; how to filter input ""args"" arguments to pull out the frequency of the; Hamiltonian in the same manner as other solvers in QuTiP are able to filter; arguments. I've been trying to avoid submitting review requests/questions; in the PR comments too much so as not to be a bother. I have definitely not; abandoned this PR, and plan on seeing it through fully, although I; apologize for my relative lack of communication the last few weeks. Thanks!. On Mon, Aug 21, 2023, 11:29 AM Eric Gigure ***@***.***>; wrote:. > @magnamancer <https://github.com/magnamancer> are you waiting for review,; > still working on the PR or abandoned it?; >; > There are still issues I raised here and in magnamancer#4; > <https://github.com/magnamancer/qutip/pull/4>, that you have not been; > addressed and I am waiting for them before the next round of review.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1686550860>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5GN3R6GPKYKYNOWSGDXWN5GDANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935
https://github.com/qutip/qutip/pull/2186#issuecomment-1695947385:21,Testability,test,test,21,Let's also try add a test in the region where FLiMESolve and the older FloquetSolver agree.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1695947385
https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693:97,Availability,ping,ping,97,"@Ericgig Hey Eric, I fixed the test script issues last week, but wasn't sure if you wanted me to ping you again. I'm pinging you again now, but if this isn't what you would like, please let me know!. That is, I'm _pretty sure_ everything should be working now. The test_flimesolve.py script, flimesolve (with your changes made - without the fixing of the step method yet), and correlation.py (where I added options for FLiMESolve to be used) should all be working now. Let me know if there's anything else that needs fixed. Thank you!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693
https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693:117,Availability,ping,pinging,117,"@Ericgig Hey Eric, I fixed the test script issues last week, but wasn't sure if you wanted me to ping you again. I'm pinging you again now, but if this isn't what you would like, please let me know!. That is, I'm _pretty sure_ everything should be working now. The test_flimesolve.py script, flimesolve (with your changes made - without the fixing of the step method yet), and correlation.py (where I added options for FLiMESolve to be used) should all be working now. Let me know if there's anything else that needs fixed. Thank you!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693
https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693:31,Testability,test,test,31,"@Ericgig Hey Eric, I fixed the test script issues last week, but wasn't sure if you wanted me to ping you again. I'm pinging you again now, but if this isn't what you would like, please let me know!. That is, I'm _pretty sure_ everything should be working now. The test_flimesolve.py script, flimesolve (with your changes made - without the fixing of the step method yet), and correlation.py (where I added options for FLiMESolve to be used) should all be working now. Let me know if there's anything else that needs fixed. Thank you!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693
https://github.com/qutip/qutip/pull/2186#issuecomment-2083263942:46,Availability,ping,ping,46,"@Ericgig Hey again Eric, sorry for the double ping. Small issue where I forgot to turn the returned Floquet states (when desired) as quantum objects instead of just numpy arrays. This caused one of the example scripts to mess up again. I fixed this and it looks like the script runs on my end.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2083263942
https://github.com/qutip/qutip/pull/2186#issuecomment-2090845530:53,Testability,test,test,53,"@Ericgig I fixed the typos you mentioned and added a test in for nonzero timesense values and for the correlation functions. I also fixed the typo you mentioned and added a short descriptor for FLiMESolve above the ""parameters"" in documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2090845530
https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518:75,Availability,error,error,75,"@Ericgig Hey Eric, added your changes to the test, fixed the documentation error as well. I also added a steady state solver, would you want me to make a test for that?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518
https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518:45,Testability,test,test,45,"@Ericgig Hey Eric, added your changes to the test, fixed the documentation error as well. I also added a steady state solver, would you want me to make a test for that?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518
https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518:154,Testability,test,test,154,"@Ericgig Hey Eric, added your changes to the test, fixed the documentation error as well. I also added a steady state solver, would you want me to make a test for that?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518
https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938:75,Deployability,update,update,75,"@SJUW the towncrier entry should be in the previous pull request.; You can update a pull request by pushing new commit on the branch on github.; To fix this, you can do something like:; ```; git checkout patch-1; git merge patch-2; git push origin patch-1; ```; Then the towncrier entry should appear in #2181.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938
https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938:204,Deployability,patch,patch-,204,"@SJUW the towncrier entry should be in the previous pull request.; You can update a pull request by pushing new commit on the branch on github.; To fix this, you can do something like:; ```; git checkout patch-1; git merge patch-2; git push origin patch-1; ```; Then the towncrier entry should appear in #2181.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938
https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938:223,Deployability,patch,patch-,223,"@SJUW the towncrier entry should be in the previous pull request.; You can update a pull request by pushing new commit on the branch on github.; To fix this, you can do something like:; ```; git checkout patch-1; git merge patch-2; git push origin patch-1; ```; Then the towncrier entry should appear in #2181.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938
https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938:248,Deployability,patch,patch-,248,"@SJUW the towncrier entry should be in the previous pull request.; You can update a pull request by pushing new commit on the branch on github.; To fix this, you can do something like:; ```; git checkout patch-1; git merge patch-2; git push origin patch-1; ```; Then the towncrier entry should appear in #2181.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2187#issuecomment-1611267938
https://github.com/qutip/qutip/issues/2189#issuecomment-1615929767:53,Deployability,release,released,53,This looks like a duplicate of #2118. A fix was just released in QuTiP 4.7.2 -- would you mind trying with that and letting us know if the fix works for you?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2189#issuecomment-1615929767
https://github.com/qutip/qutip/issues/2189#issuecomment-1615936547:55,Deployability,release,released,55,"> This looks like a duplicate of #2118. A fix was just released in QuTiP 4.7.2 -- would you mind trying with that and letting us know if the fix works for you?. Yup, this sure fixes it. Sorry for missing the duplicate!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2189#issuecomment-1615936547
https://github.com/qutip/qutip/issues/2190#issuecomment-1622081465:79,Availability,error,error,79,Hi @yurivict. Could you give more detail?; I can't reproduce the issue and the error messages are not enough to understand what is happening.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2190#issuecomment-1622081465
https://github.com/qutip/qutip/issues/2190#issuecomment-1622081465:85,Integrability,message,messages,85,Hi @yurivict. Could you give more detail?; I can't reproduce the issue and the error messages are not enough to understand what is happening.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2190#issuecomment-1622081465
https://github.com/qutip/qutip/issues/2190#issuecomment-1622099822:76,Availability,error,errors,76,"Hi @Ericgig . I've ran the tests from the FreeBSD port's directory, and the errors above are what was printed. Yuri",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2190#issuecomment-1622099822
https://github.com/qutip/qutip/issues/2190#issuecomment-1622099822:27,Testability,test,tests,27,"Hi @Ericgig . I've ran the tests from the FreeBSD port's directory, and the errors above are what was printed. Yuri",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2190#issuecomment-1622099822
https://github.com/qutip/qutip/issues/2190#issuecomment-1856842578:114,Testability,Test,Tests,114,Without more detail we can't help resolve this so closing it for now. Feel free to re-open if you can help debug. Tests pass in quite a few CI combinations.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2190#issuecomment-1856842578
https://github.com/qutip/qutip/issues/2191#issuecomment-1629652084:4,Usability,progress bar,progress bar,4,"The progress bar control in now in the options: `mesolve(..., options={'progress_bar': False})`.; Any of `["""", None, False]` will not display the time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2191#issuecomment-1629652084
https://github.com/qutip/qutip/pull/2192#issuecomment-1634286008:24,Testability,test,test,24,"@Ericgig Hi. The Github test fails because of plot_spin_distribution. ```plot_spin_distribution``` plots color at (x, y), but the correct way to use ```pcolor``` is plotting color in rectangles made by four matrix elements ([the link](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.pcolor.html)). It may be difficult to fix this warning and hence we can not add pytests for it.; https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.pcolor.html",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2192#issuecomment-1634286008
https://github.com/qutip/qutip/pull/2192#issuecomment-1634395932:182,Integrability,message,message,182,"You can ignore warnings with:; `@pytest.mark.filterwarnings(""ignore:The input coordinates to pcolor:UserWarning"")`; The `The input coordinates to pcolor` is the start of the warning message. ; `UserWarning` is the kind of warnings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2192#issuecomment-1634395932
https://github.com/qutip/qutip/pull/2192#issuecomment-1635892287:76,Testability,test,tests,76,"There are a few options:; - Wait for #2193 to be merged and add the missing tests after.; - Merge this and add the tests for `matrix_histogram`, etc. in #2193. Any is good, just tell me when you are ready for a review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2192#issuecomment-1635892287
https://github.com/qutip/qutip/pull/2192#issuecomment-1635892287:115,Testability,test,tests,115,"There are a few options:; - Wait for #2193 to be merged and add the missing tests after.; - Merge this and add the tests for `matrix_histogram`, etc. in #2193. Any is good, just tell me when you are ready for a review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2192#issuecomment-1635892287
https://github.com/qutip/qutip/pull/2192#issuecomment-1637065595:46,Testability,test,tests,46,@Ericgig Hi. I prefer the latter. I am adding tests in #2193 now.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2192#issuecomment-1637065595
https://github.com/qutip/qutip/pull/2193#issuecomment-1628641527:11,Safety,detect,detects,11,"Codeclimte detects the same code in matrix_histogram and matrix_histogram_complex, but matrix_histogram_complex will be deleted after matrix_histogram takes over it and the problem will be solved",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2193#issuecomment-1628641527
https://github.com/qutip/qutip/pull/2193#issuecomment-1630117889:152,Availability,error,error,152,"I moved ```limits bar_style color_limits color_style```. The number of arguments is 13 > 10, but they should not be in ```options```. Also, I raised an error when users pass unexpected arguments to ```bar_style color_style```.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2193#issuecomment-1630117889
https://github.com/qutip/qutip/pull/2193#issuecomment-1632461619:109,Availability,error,error,109,@Ericgig Hi. Do you have any advice on plot_wigner_sphere and matrix_histogram? I will fix the documentation error tomorrow.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2193#issuecomment-1632461619
https://github.com/qutip/qutip/pull/2193#issuecomment-1634245514:46,Availability,error,error,46,"@Ericgig Hi. I tried to fix the documentation error, but I do not know how to fix the following errors. Could you help me?; ```; /home/runner/work/qutip/qutip/qutip/visualization.py:docstring of qutip.visualization.hinton:10: WARNING: Bullet list ends without a blank line; unexpected unindent.; looking for now-outdated files... none found; /home/runner/work/qutip/qutip/qutip/visualization.py:docstring of qutip.visualization.hinton:7: WARNING: Bullet list ends without a blank line; unexpected unindent.; /home/runner/work/qutip/qutip/qutip/visualization.py:docstring of qutip.visualization.hinton:23: WARNING: Bullet list ends without a blank line; unexpected unindent.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2193#issuecomment-1634245514
https://github.com/qutip/qutip/pull/2193#issuecomment-1634245514:96,Availability,error,errors,96,"@Ericgig Hi. I tried to fix the documentation error, but I do not know how to fix the following errors. Could you help me?; ```; /home/runner/work/qutip/qutip/qutip/visualization.py:docstring of qutip.visualization.hinton:10: WARNING: Bullet list ends without a blank line; unexpected unindent.; looking for now-outdated files... none found; /home/runner/work/qutip/qutip/qutip/visualization.py:docstring of qutip.visualization.hinton:7: WARNING: Bullet list ends without a blank line; unexpected unindent.; /home/runner/work/qutip/qutip/qutip/visualization.py:docstring of qutip.visualization.hinton:23: WARNING: Bullet list ends without a blank line; unexpected unindent.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2193#issuecomment-1634245514
https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926:698,Availability,error,error,698,"`result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually. `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible. The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926
https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926:811,Deployability,integrat,integration,811,"`result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually. `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible. The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926
https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926:508,Integrability,depend,depending,508,"`result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually. `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible. The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926
https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926:811,Integrability,integrat,integration,811,"`result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually. `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible. The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1634520926
https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:707,Availability,error,error,707,"> `result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually.; > ; > `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible.; > ; > The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories. In my understanding, solving for 'smesolve' gives the corresponding '(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ '(t)' (`expect`). If I want to show all _ntraj_ s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where (t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **(t)** and solve the relevant expected value **Tr[(t)A]**. On the one hand, I want to see the expectations of a",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206
https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:827,Deployability,integrat,integration,827,"> `result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually.; > ; > `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible.; > ; > The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories. In my understanding, solving for 'smesolve' gives the corresponding '(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ '(t)' (`expect`). If I want to show all _ntraj_ s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where (t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **(t)** and solve the relevant expected value **Tr[(t)A]**. On the one hand, I want to see the expectations of a",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206
https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:1771,Deployability,continuous,continuous,1771,"match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible.; > ; > The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories. In my understanding, solving for 'smesolve' gives the corresponding '(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ '(t)' (`expect`). If I want to show all _ntraj_ s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where (t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **(t)** and solve the relevant expected value **Tr[(t)A]**. On the one hand, I want to see the expectations of all N quantum trajectories (t)'s expect (**Tr[(t)A] maybe with different dW**), and on the other hand I want to compare the expected average of N quantum trajectories with the result of the master equation(`mesolve.expect`). This is similar to this code in Note (but the result in [Note](https://nbviewer.org/urls/qutip.org/qutip-tutorials/tutorials-v4/time-evolution/016_smesolve-inefficient-detection.ipynb) is `result.measurement`). `fig, ax = plt.subplots(figsize=(8, 4)). for m in result.measurement:; ax.plot(times, m[:, 0].real, ""b"", alpha=0.025). ax.plot(times, result_ref.expect[1], ""k"", lw=2). ax.set_ylim(-25, 25); ax.set_xlim(0",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206
https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:517,Integrability,depend,depending,517,"> `result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually.; > ; > `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible.; > ; > The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories. In my understanding, solving for 'smesolve' gives the corresponding '(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ '(t)' (`expect`). If I want to show all _ntraj_ s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where (t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **(t)** and solve the relevant expected value **Tr[(t)A]**. On the one hand, I want to see the expectations of a",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206
https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:827,Integrability,integrat,integration,827,"> `result.measurement` is not the same as `result.expect`, the measurement is an expectation value, but not of the `e_ops` but `m_ops` which are usually automatically generated from the `c_ops` and noise is added to the computed expectation value of the state of the trajectory. The noise is usually larger than the signal and makes it hard to see, but it should converge to mesolve's solution eventually.; > ; > `smesolve`'s `expect` are just the expectation value of the state of each trajectories (averaged or not depending on options) and should average to the master equation solutions with enough trajectories. Plot in cell 8 show the match is quite good. Even with enough trajectories, the numerical error from `smesolve` will be visible.; > ; > The equation solved are those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories. In my understanding, solving for 'smesolve' gives the corresponding '(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ '(t)' (`expect`). If I want to show all _ntraj_ s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where (t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **(t)** and solve the relevant expected value **Tr[(t)A]**. On the one hand, I want to see the expectations of a",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206
https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:2395,Safety,detect,detection,2395,"re those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories. In my understanding, solving for 'smesolve' gives the corresponding '(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ '(t)' (`expect`). If I want to show all _ntraj_ s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where (t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **(t)** and solve the relevant expected value **Tr[(t)A]**. On the one hand, I want to see the expectations of all N quantum trajectories (t)'s expect (**Tr[(t)A] maybe with different dW**), and on the other hand I want to compare the expected average of N quantum trajectories with the result of the master equation(`mesolve.expect`). This is similar to this code in Note (but the result in [Note](https://nbviewer.org/urls/qutip.org/qutip-tutorials/tutorials-v4/time-evolution/016_smesolve-inefficient-detection.ipynb) is `result.measurement`). `fig, ax = plt.subplots(figsize=(8, 4)). for m in result.measurement:; ax.plot(times, m[:, 0].real, ""b"", alpha=0.025). ax.plot(times, result_ref.expect[1], ""k"", lw=2). ax.set_ylim(-25, 25); ax.set_xlim(0, times.max()); ax.set_xlabel(""time"", fontsize=12); ax.plot(times, np.array(result.measurement).mean(axis=0)[:, 0].real, ""b"", lw=2);`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206
https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:1816,Usability,simpl,simply,1816,"re those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories. In my understanding, solving for 'smesolve' gives the corresponding '(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ '(t)' (`expect`). If I want to show all _ntraj_ s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where (t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **(t)** and solve the relevant expected value **Tr[(t)A]**. On the one hand, I want to see the expectations of all N quantum trajectories (t)'s expect (**Tr[(t)A] maybe with different dW**), and on the other hand I want to compare the expected average of N quantum trajectories with the result of the master equation(`mesolve.expect`). This is similar to this code in Note (but the result in [Note](https://nbviewer.org/urls/qutip.org/qutip-tutorials/tutorials-v4/time-evolution/016_smesolve-inefficient-detection.ipynb) is `result.measurement`). `fig, ax = plt.subplots(figsize=(8, 4)). for m in result.measurement:; ax.plot(times, m[:, 0].real, ""b"", alpha=0.025). ax.plot(times, result_ref.expect[1], ""k"", lw=2). ax.set_ylim(-25, 25); ax.set_xlim(0, times.max()); ax.set_xlabel(""time"", fontsize=12); ax.plot(times, np.array(result.measurement).mean(axis=0)[:, 0].real, ""b"", lw=2);`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206
https://github.com/qutip/qutip/issues/2194#issuecomment-1635773906:307,Deployability,release,release,307,"You can use: `smesolve(..., store_all_expect=True)` then use `result.runs_expect[traj_n, e_op, t]`.; (Please check the order of the index.). You can also use `options=SolverOptions(average_states=False, store_states=True)` to have `results.states` keep the states of all trajectories. If you use the v5 pre-release, the with `options = {'keep_run_results': True}` you have both `result.average_expect` and `result.runs_expect`. Same for the states, adding `'store_states':True` to the options, you can get the trajectories states with `result.runs_states` and the averaged states with `result.average_state`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635773906
https://github.com/qutip/qutip/pull/2196#issuecomment-1663036896:25,Testability,benchmark,benchmarks,25,"Yes, let's add it to the benchmarks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2196#issuecomment-1663036896
https://github.com/qutip/qutip/issues/2198#issuecomment-1642186485:119,Deployability,patch,patch,119,"Thank you for reporting.; Yes, Qutip does not work with cython 3.0.0.; I found a bug in cython trying to fix it so the patch could take some time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2198#issuecomment-1642186485
https://github.com/qutip/qutip/issues/2198#issuecomment-1642259420:161,Deployability,release,release,161,"Ah, I see now that you do have a pin:; https://github.com/qutip/qutip/blob/efd39be22db0536ef0680547a6631a4f9156b922/requirements.txt#L1. but there hasn't been a release since that change.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2198#issuecomment-1642259420
https://github.com/qutip/qutip/pull/2201#issuecomment-1643899196:200,Integrability,depend,dependabot,200,[![Coverage Status](https://coveralls.io/builds/61470251/badge)](https://coveralls.io/builds/61470251). coverage: 84.621%. remained the same when pulling **2e9d45226f7ecd367475624f5fe0e049973f7b35 on dependabot/pip/doc/pygments-2.15.0** into **efd39be22db0536ef0680547a6631a4f9156b922 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2201#issuecomment-1643899196
https://github.com/qutip/qutip/pull/2203#issuecomment-1667219957:109,Usability,simpl,simply,109,"@Ericgig Hi. I merged animation functions with functions in visualization.py. Now, users can have animations simply by passing a list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2203#issuecomment-1667219957
https://github.com/qutip/qutip/pull/2203#issuecomment-1678682976:62,Usability,clear,clear,62,"@Ericgig Hi. I made ```anim_wigner_sphere``` again to make it clear that users use an animation function. If it is ok, I will do the same for other functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2203#issuecomment-1678682976
https://github.com/qutip/qutip/pull/2203#issuecomment-1680562161:54,Testability,test,test,54,@Ericgig I chose ```anim_wigner_sphere```. I will add test tomorrow.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2203#issuecomment-1680562161
https://github.com/qutip/qutip/pull/2203#issuecomment-1682090307:21,Testability,test,tests,21,@Ericgig Hi. I added tests. Could you review the code?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2203#issuecomment-1682090307
https://github.com/qutip/qutip/pull/2203#issuecomment-1685150552:85,Deployability,update,updated,85,@Ericgig I saw it works for other functions and thought it is ok. I deleted them and updated the docs.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2203#issuecomment-1685150552
https://github.com/qutip/qutip/issues/2206#issuecomment-1651655375:69,Deployability,patch,patch,69,"Cython 3.0.0 is not supported and probably won't for some time.; The patch is not as easy as we hoped.; Duplicate of #2198, so closing this issue. Feel free to continue the discussion there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2206#issuecomment-1651655375
https://github.com/qutip/qutip/issues/2208#issuecomment-1658492275:70,Availability,error,error,70,Thank you for reporting. I will fix by having ket + scalar raising an error.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2208#issuecomment-1658492275
https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538:707,Availability,avail,available,707,"Early thought:. The `solver.add_feedback` approach doesn't look too bad, but it does seem a bit odd because on does to specify the state parameters when constructing the operators that the define the system -- i.e. H, c_ops, etc. Could we not expose the feedback on the QobjEvo itself so that users can then do:. ```python; H = QobjEvo([op, lambda t, ket: bra @ ket], feedback={""ket"": ""qobj""}); ...; ```. or; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); H.add_feedback(ket=""qobj""); ...; ```. or even; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); solver = Solver(...); solver.rhs.add_feedback(ket=""qobj""); ```. Thoughts?. It will get a bit trickier for the feedback that is less easily available from the state, but perhaps solvers can just check whether the ops they're using need the special feedback?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538
https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538:243,Security,expose,expose,243,"Early thought:. The `solver.add_feedback` approach doesn't look too bad, but it does seem a bit odd because on does to specify the state parameters when constructing the operators that the define the system -- i.e. H, c_ops, etc. Could we not expose the feedback on the QobjEvo itself so that users can then do:. ```python; H = QobjEvo([op, lambda t, ket: bra @ ket], feedback={""ket"": ""qobj""}); ...; ```. or; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); H.add_feedback(ket=""qobj""); ...; ```. or even; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); solver = Solver(...); solver.rhs.add_feedback(ket=""qobj""); ```. Thoughts?. It will get a bit trickier for the feedback that is less easily available from the state, but perhaps solvers can just check whether the ops they're using need the special feedback?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538
https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538:254,Usability,feedback,feedback,254,"Early thought:. The `solver.add_feedback` approach doesn't look too bad, but it does seem a bit odd because on does to specify the state parameters when constructing the operators that the define the system -- i.e. H, c_ops, etc. Could we not expose the feedback on the QobjEvo itself so that users can then do:. ```python; H = QobjEvo([op, lambda t, ket: bra @ ket], feedback={""ket"": ""qobj""}); ...; ```. or; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); H.add_feedback(ket=""qobj""); ...; ```. or even; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); solver = Solver(...); solver.rhs.add_feedback(ket=""qobj""); ```. Thoughts?. It will get a bit trickier for the feedback that is less easily available from the state, but perhaps solvers can just check whether the ops they're using need the special feedback?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538
https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538:368,Usability,feedback,feedback,368,"Early thought:. The `solver.add_feedback` approach doesn't look too bad, but it does seem a bit odd because on does to specify the state parameters when constructing the operators that the define the system -- i.e. H, c_ops, etc. Could we not expose the feedback on the QobjEvo itself so that users can then do:. ```python; H = QobjEvo([op, lambda t, ket: bra @ ket], feedback={""ket"": ""qobj""}); ...; ```. or; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); H.add_feedback(ket=""qobj""); ...; ```. or even; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); solver = Solver(...); solver.rhs.add_feedback(ket=""qobj""); ```. Thoughts?. It will get a bit trickier for the feedback that is less easily available from the state, but perhaps solvers can just check whether the ops they're using need the special feedback?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538
https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538:678,Usability,feedback,feedback,678,"Early thought:. The `solver.add_feedback` approach doesn't look too bad, but it does seem a bit odd because on does to specify the state parameters when constructing the operators that the define the system -- i.e. H, c_ops, etc. Could we not expose the feedback on the QobjEvo itself so that users can then do:. ```python; H = QobjEvo([op, lambda t, ket: bra @ ket], feedback={""ket"": ""qobj""}); ...; ```. or; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); H.add_feedback(ket=""qobj""); ...; ```. or even; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); solver = Solver(...); solver.rhs.add_feedback(ket=""qobj""); ```. Thoughts?. It will get a bit trickier for the feedback that is less easily available from the state, but perhaps solvers can just check whether the ops they're using need the special feedback?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538
https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538:815,Usability,feedback,feedback,815,"Early thought:. The `solver.add_feedback` approach doesn't look too bad, but it does seem a bit odd because on does to specify the state parameters when constructing the operators that the define the system -- i.e. H, c_ops, etc. Could we not expose the feedback on the QobjEvo itself so that users can then do:. ```python; H = QobjEvo([op, lambda t, ket: bra @ ket], feedback={""ket"": ""qobj""}); ...; ```. or; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); H.add_feedback(ket=""qobj""); ...; ```. or even; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); solver = Solver(...); solver.rhs.add_feedback(ket=""qobj""); ```. Thoughts?. It will get a bit trickier for the feedback that is less easily available from the state, but perhaps solvers can just check whether the ops they're using need the special feedback?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538
https://github.com/qutip/qutip/pull/2210#issuecomment-1663071540:219,Usability,feedback,feedback,219,[![Coverage Status](https://coveralls.io/builds/64568924/badge)](https://coveralls.io/builds/64568924). coverage: 84.198% (-0.2%) from 84.382%; when pulling **6707a4b024b6c570988e27948190425b5651e137 on Ericgig:feature.feedback**; into **f0c507eda7241332911965a59e7f0b0a9ec28185 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663071540
https://github.com/qutip/qutip/pull/2210#issuecomment-1663071666:324,Usability,feedback,feedback,324,"My example was incomplete, they need to set an initial value when creating the `QobjEvo`:; ```; H = QobjEvo([op, lambda t, ket: bra @ ket], args={""ket"": basis(...)}); ```; Otherwise there is an issue with creating the coefficient and if the operator is call without a state first `H(t)`. For a stand alone QobjEvo, having a feedback does not mean much, I prefer to attach it to the solver where it get's it's meaning. It is also the solver that knows about the collapse and wiener_process. add_feedback exist on QobjEvo, it just private:; ```; H = QobjEvo([op, lambda t, ket: bra @ ket], {""ket"":basis(...)}); H._add_feedback(""ket"", ""qobj""); ```; Using dict instead of a pair of input does look good.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663071666
https://github.com/qutip/qutip/pull/2210#issuecomment-1789395152:18,Availability,ping,ping,18,@Ericgig Will you ping me when you'd like another round of review? Thanks for making the changes so far.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1789395152
https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286:365,Availability,error,error,365,"@hodgestar ; It's ready for another look.; I made it so the feedback can be set at `QobjEvo` creation, with `QobjEvo.add_feedback` method and with a method of the solver. `QobjEvo` with feedback can be used outside solver with a default value for the argument passed at creation. This default value is needed when creating the coefficient. When used in a solver an error will be raised if the solver cannot provide the feedback. The `QobjEvo` print will show it has feedback. . The solver method is mostly there for documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286
https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286:60,Usability,feedback,feedback,60,"@hodgestar ; It's ready for another look.; I made it so the feedback can be set at `QobjEvo` creation, with `QobjEvo.add_feedback` method and with a method of the solver. `QobjEvo` with feedback can be used outside solver with a default value for the argument passed at creation. This default value is needed when creating the coefficient. When used in a solver an error will be raised if the solver cannot provide the feedback. The `QobjEvo` print will show it has feedback. . The solver method is mostly there for documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286
https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286:186,Usability,feedback,feedback,186,"@hodgestar ; It's ready for another look.; I made it so the feedback can be set at `QobjEvo` creation, with `QobjEvo.add_feedback` method and with a method of the solver. `QobjEvo` with feedback can be used outside solver with a default value for the argument passed at creation. This default value is needed when creating the coefficient. When used in a solver an error will be raised if the solver cannot provide the feedback. The `QobjEvo` print will show it has feedback. . The solver method is mostly there for documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286
https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286:419,Usability,feedback,feedback,419,"@hodgestar ; It's ready for another look.; I made it so the feedback can be set at `QobjEvo` creation, with `QobjEvo.add_feedback` method and with a method of the solver. `QobjEvo` with feedback can be used outside solver with a default value for the argument passed at creation. This default value is needed when creating the coefficient. When used in a solver an error will be raised if the solver cannot provide the feedback. The `QobjEvo` print will show it has feedback. . The solver method is mostly there for documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286
https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286:466,Usability,feedback,feedback,466,"@hodgestar ; It's ready for another look.; I made it so the feedback can be set at `QobjEvo` creation, with `QobjEvo.add_feedback` method and with a method of the solver. `QobjEvo` with feedback can be used outside solver with a default value for the argument passed at creation. This default value is needed when creating the coefficient. When used in a solver an error will be raised if the solver cannot provide the feedback. The `QobjEvo` print will show it has feedback. . The solver method is mostly there for documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1789631286
https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911:653,Deployability,update,updated,653,"I've done another round of reviewing. I'm still unhappy with `register_feedback` and `add_feedback` on Solvers, but I'd like to propose that we try merge this PR with those in place and then argue about them separately outside of this PR and change things if I manage to convince you. :). I'll try summarize my point of view here (just so that I don't forget my own thinking):. - Solvers provide feedback.; - QobjEvos use feedback.; - Each solver class should define what feedback it can provide.; - Each QobjEvo should define what feedback it uses. The sensible place to do this is when the `QobjEvo` is constructed.; - When a solver is constructed or updated, it should check that it can provide the feedback used by all of the relevant `QobjEvo`s and raise an exception if it can not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911
https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911:396,Usability,feedback,feedback,396,"I've done another round of reviewing. I'm still unhappy with `register_feedback` and `add_feedback` on Solvers, but I'd like to propose that we try merge this PR with those in place and then argue about them separately outside of this PR and change things if I manage to convince you. :). I'll try summarize my point of view here (just so that I don't forget my own thinking):. - Solvers provide feedback.; - QobjEvos use feedback.; - Each solver class should define what feedback it can provide.; - Each QobjEvo should define what feedback it uses. The sensible place to do this is when the `QobjEvo` is constructed.; - When a solver is constructed or updated, it should check that it can provide the feedback used by all of the relevant `QobjEvo`s and raise an exception if it can not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911
https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911:422,Usability,feedback,feedback,422,"I've done another round of reviewing. I'm still unhappy with `register_feedback` and `add_feedback` on Solvers, but I'd like to propose that we try merge this PR with those in place and then argue about them separately outside of this PR and change things if I manage to convince you. :). I'll try summarize my point of view here (just so that I don't forget my own thinking):. - Solvers provide feedback.; - QobjEvos use feedback.; - Each solver class should define what feedback it can provide.; - Each QobjEvo should define what feedback it uses. The sensible place to do this is when the `QobjEvo` is constructed.; - When a solver is constructed or updated, it should check that it can provide the feedback used by all of the relevant `QobjEvo`s and raise an exception if it can not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911
https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911:472,Usability,feedback,feedback,472,"I've done another round of reviewing. I'm still unhappy with `register_feedback` and `add_feedback` on Solvers, but I'd like to propose that we try merge this PR with those in place and then argue about them separately outside of this PR and change things if I manage to convince you. :). I'll try summarize my point of view here (just so that I don't forget my own thinking):. - Solvers provide feedback.; - QobjEvos use feedback.; - Each solver class should define what feedback it can provide.; - Each QobjEvo should define what feedback it uses. The sensible place to do this is when the `QobjEvo` is constructed.; - When a solver is constructed or updated, it should check that it can provide the feedback used by all of the relevant `QobjEvo`s and raise an exception if it can not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911
https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911:532,Usability,feedback,feedback,532,"I've done another round of reviewing. I'm still unhappy with `register_feedback` and `add_feedback` on Solvers, but I'd like to propose that we try merge this PR with those in place and then argue about them separately outside of this PR and change things if I manage to convince you. :). I'll try summarize my point of view here (just so that I don't forget my own thinking):. - Solvers provide feedback.; - QobjEvos use feedback.; - Each solver class should define what feedback it can provide.; - Each QobjEvo should define what feedback it uses. The sensible place to do this is when the `QobjEvo` is constructed.; - When a solver is constructed or updated, it should check that it can provide the feedback used by all of the relevant `QobjEvo`s and raise an exception if it can not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911
https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911:702,Usability,feedback,feedback,702,"I've done another round of reviewing. I'm still unhappy with `register_feedback` and `add_feedback` on Solvers, but I'd like to propose that we try merge this PR with those in place and then argue about them separately outside of this PR and change things if I manage to convince you. :). I'll try summarize my point of view here (just so that I don't forget my own thinking):. - Solvers provide feedback.; - QobjEvos use feedback.; - Each solver class should define what feedback it can provide.; - Each QobjEvo should define what feedback it uses. The sensible place to do this is when the `QobjEvo` is constructed.; - When a solver is constructed or updated, it should check that it can provide the feedback used by all of the relevant `QobjEvo`s and raise an exception if it can not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1837260911
https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709:459,Usability,clear,clear,459,"What if we rethink the approach from the beginning:. ```; QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); ```; And we remove the `add_feedback` method. This makes clear that the feedback comes from the solver and used by the QobjEvo.; What is supported by which solver and what has the role to document it is clear. This has the bonus of removing the need for default in many case.; Also, since the feedback creation is a function call, we can add options such as the state basis for floquet or bloch-redfield.; Lastly, updating args can switch feedback on/off, could be useful to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709
https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709:474,Usability,feedback,feedback,474,"What if we rethink the approach from the beginning:. ```; QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); ```; And we remove the `add_feedback` method. This makes clear that the feedback comes from the solver and used by the QobjEvo.; What is supported by which solver and what has the role to document it is clear. This has the bonus of removing the need for default in many case.; Also, since the feedback creation is a function call, we can add options such as the state basis for floquet or bloch-redfield.; Lastly, updating args can switch feedback on/off, could be useful to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709
https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709:605,Usability,clear,clear,605,"What if we rethink the approach from the beginning:. ```; QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); ```; And we remove the `add_feedback` method. This makes clear that the feedback comes from the solver and used by the QobjEvo.; What is supported by which solver and what has the role to document it is clear. This has the bonus of removing the need for default in many case.; Also, since the feedback creation is a function call, we can add options such as the state basis for floquet or bloch-redfield.; Lastly, updating args can switch feedback on/off, could be useful to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709
https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709:695,Usability,feedback,feedback,695,"What if we rethink the approach from the beginning:. ```; QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); ```; And we remove the `add_feedback` method. This makes clear that the feedback comes from the solver and used by the QobjEvo.; What is supported by which solver and what has the role to document it is clear. This has the bonus of removing the need for default in many case.; Also, since the feedback creation is a function call, we can add options such as the state basis for floquet or bloch-redfield.; Lastly, updating args can switch feedback on/off, could be useful to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709
https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709:841,Usability,feedback,feedback,841,"What if we rethink the approach from the beginning:. ```; QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); ```; And we remove the `add_feedback` method. This makes clear that the feedback comes from the solver and used by the QobjEvo.; What is supported by which solver and what has the role to document it is clear. This has the bonus of removing the need for default in many case.; Also, since the feedback creation is a function call, we can add options such as the state basis for floquet or bloch-redfield.; Lastly, updating args can switch feedback on/off, could be useful to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839382709
https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984:765,Deployability,update,update,765,"> What if we rethink the approach from the beginning:; > ; > ```; > QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); > QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); > QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); > QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); > QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); > ```; > ; > And we remove the `add_feedback` method. This looks great. I really like that it makes it clearer where the feedback comes from and that it is solver dependent. Removing the need to specify the feedback in two places when constructing a `QobjEvo` is really nice too. Let's do it in a separate PR though (unless you strongly want to update this one). I have a slight concern that it might be a bit complicated for users to find the feedback classes (e.g. they have to know to import the right solver) but I'm sure we can make that nice the PR itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984
https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984:583,Integrability,depend,dependent,583,"> What if we rethink the approach from the beginning:; > ; > ```; > QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); > QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); > QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); > QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); > QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); > ```; > ; > And we remove the `add_feedback` method. This looks great. I really like that it makes it clearer where the feedback comes from and that it is solver dependent. Removing the need to specify the feedback in two places when constructing a `QobjEvo` is really nice too. Let's do it in a separate PR though (unless you strongly want to update this one). I have a slight concern that it might be a bit complicated for users to find the feedback classes (e.g. they have to know to import the right solver) but I'm sure we can make that nice the PR itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984
https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984:523,Usability,clear,clearer,523,"> What if we rethink the approach from the beginning:; > ; > ```; > QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); > QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); > QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); > QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); > QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); > ```; > ; > And we remove the `add_feedback` method. This looks great. I really like that it makes it clearer where the feedback comes from and that it is solver dependent. Removing the need to specify the feedback in two places when constructing a `QobjEvo` is really nice too. Let's do it in a separate PR though (unless you strongly want to update this one). I have a slight concern that it might be a bit complicated for users to find the feedback classes (e.g. they have to know to import the right solver) but I'm sure we can make that nice the PR itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984
https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984:541,Usability,feedback,feedback,541,"> What if we rethink the approach from the beginning:; > ; > ```; > QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); > QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); > QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); > QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); > QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); > ```; > ; > And we remove the `add_feedback` method. This looks great. I really like that it makes it clearer where the feedback comes from and that it is solver dependent. Removing the need to specify the feedback in two places when constructing a `QobjEvo` is really nice too. Let's do it in a separate PR though (unless you strongly want to update this one). I have a slight concern that it might be a bit complicated for users to find the feedback classes (e.g. they have to know to import the right solver) but I'm sure we can make that nice the PR itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984
https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984:627,Usability,feedback,feedback,627,"> What if we rethink the approach from the beginning:; > ; > ```; > QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); > QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); > QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); > QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); > QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); > ```; > ; > And we remove the `add_feedback` method. This looks great. I really like that it makes it clearer where the feedback comes from and that it is solver dependent. Removing the need to specify the feedback in two places when constructing a `QobjEvo` is really nice too. Let's do it in a separate PR though (unless you strongly want to update this one). I have a slight concern that it might be a bit complicated for users to find the feedback classes (e.g. they have to know to import the right solver) but I'm sure we can make that nice the PR itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984
https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984:864,Usability,feedback,feedback,864,"> What if we rethink the approach from the beginning:; > ; > ```; > QobjEvo([op, func], args={""state"": Solver.StateFeedback(default=psi0)}); > QobjEvo([op, func], args={""e1"": SESolver.ExpectFeedback(e_op)}); > QobjEvo([op, func], args={""state"": MESolver.StateFeedback(raw_data=True)}); > QobjEvo([op, func], args={""collapse"": MCSolver.CollapseFeedback()}); > QobjEvo([op, func], args={""W"": SMESolver.WeinerFeedback()}); > ```; > ; > And we remove the `add_feedback` method. This looks great. I really like that it makes it clearer where the feedback comes from and that it is solver dependent. Removing the need to specify the feedback in two places when constructing a `QobjEvo` is really nice too. Let's do it in a separate PR though (unless you strongly want to update this one). I have a slight concern that it might be a bit complicated for users to find the feedback classes (e.g. they have to know to import the right solver) but I'm sure we can make that nice the PR itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1839582984
https://github.com/qutip/qutip/pull/2210#issuecomment-1843594542:26,Integrability,interface,interface,26,@hodgestar; I changed the interface.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1843594542
https://github.com/qutip/qutip/pull/2210#issuecomment-1845422093:261,Testability,test,test,261,"Questions / doubt I still have is about making the `default` mandatory for states.; At first I wanted to pass `qzeros` with the dims fetched from those of the `QobjEvo`, but sometime we need to use the args first to get the QobjEvo's dimensions... I also added test for `QobjEvo.dag().dims`, previously the test passed even without the fix because we only tested for the returned qobj's dims.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1845422093
https://github.com/qutip/qutip/pull/2210#issuecomment-1845422093:307,Testability,test,test,307,"Questions / doubt I still have is about making the `default` mandatory for states.; At first I wanted to pass `qzeros` with the dims fetched from those of the `QobjEvo`, but sometime we need to use the args first to get the QobjEvo's dimensions... I also added test for `QobjEvo.dag().dims`, previously the test passed even without the fix because we only tested for the returned qobj's dims.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1845422093
https://github.com/qutip/qutip/pull/2210#issuecomment-1845422093:356,Testability,test,tested,356,"Questions / doubt I still have is about making the `default` mandatory for states.; At first I wanted to pass `qzeros` with the dims fetched from those of the `QobjEvo`, but sometime we need to use the args first to get the QobjEvo's dimensions... I also added test for `QobjEvo.dag().dims`, previously the test passed even without the fix because we only tested for the returned qobj's dims.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1845422093
https://github.com/qutip/qutip/pull/2210#issuecomment-1846240598:1005,Safety,avoid,avoid,1005,"The question about the mandatory default for states is a good one. So currently we call the `QobjEvo` with `t=0` to get its dims. This is slightly hacky, but very convenient, and usually `t=0` is a valid time. Feedback breaks this assumption though because now `t=0` is insufficient information. We also need the current state, but we can't create a dummy state because we don't know what its dims should be yet. So there is a cycle we have to break somehow. Currently we break this by having the user supply an initial state, but perhaps we could do other things. The worst case is when the Qobj part of an EvoElement is supplied by a function. Then we can't get the dims without calling it. When the Qobj part is just a Qobj, getting the dims is fairly straight forward. So one option would be to ask the user to supply the dims if there are no EvoElements that provide a Qobj to look at, or to guarantee that their function is callable with just `t=0`. I'm not sure this is entirely nicer, but it does avoid having to supply a dummy initial state. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1846240598
https://github.com/qutip/qutip/pull/2210#issuecomment-1846240598:210,Usability,Feedback,Feedback,210,"The question about the mandatory default for states is a good one. So currently we call the `QobjEvo` with `t=0` to get its dims. This is slightly hacky, but very convenient, and usually `t=0` is a valid time. Feedback breaks this assumption though because now `t=0` is insufficient information. We also need the current state, but we can't create a dummy state because we don't know what its dims should be yet. So there is a cycle we have to break somehow. Currently we break this by having the user supply an initial state, but perhaps we could do other things. The worst case is when the Qobj part of an EvoElement is supplied by a function. Then we can't get the dims without calling it. When the Qobj part is just a Qobj, getting the dims is fairly straight forward. So one option would be to ask the user to supply the dims if there are no EvoElements that provide a Qobj to look at, or to guarantee that their function is callable with just `t=0`. I'm not sure this is entirely nicer, but it does avoid having to supply a dummy initial state. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1846240598
https://github.com/qutip/qutip/issues/2211#issuecomment-1674730690:26,Deployability,release,release,26,It is fixed in the latest release (4.7.2) with #2082.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2211#issuecomment-1674730690
https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:648,Integrability,interface,interface,648,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681
https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:888,Modifiability,inherit,inherited,888,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681
https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:1040,Modifiability,inherit,inheritance,1040,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681
https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:82,Security,access,access,82,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681
https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:621,Security,access,accessing,621,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681
https://github.com/qutip/qutip/pull/2218#issuecomment-1692317449:795,Deployability,update,updated,795,"> I believe that `MultiTrajSolverImprovedSampling` and `MultiTrajResultImprovedSampling`. We only need one new class for the solver and result, not 2 each. It would even be nice if it could be inserted into `MCSolver` without making the code to messy...; >; Agreed ; > I believe that a scaling should be applied in to the `McResult.photocurrent` method. Could you check. It's an histogram of the jumps times.; > ; Yes you're right, sorry I missed that. Should be fixed now.; > The last issue is whether to make a new function or not. I feel it belong as an options in the existing mscolve, but it would be easy to overlook by users. As a new function it will get more attention. I also don't have a strong opinion on the matter.; >; I think you are right. I added it as an option to options and updated tests, docs accordingly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1692317449
https://github.com/qutip/qutip/pull/2218#issuecomment-1692317449:803,Testability,test,tests,803,"> I believe that `MultiTrajSolverImprovedSampling` and `MultiTrajResultImprovedSampling`. We only need one new class for the solver and result, not 2 each. It would even be nice if it could be inserted into `MCSolver` without making the code to messy...; >; Agreed ; > I believe that a scaling should be applied in to the `McResult.photocurrent` method. Could you check. It's an histogram of the jumps times.; > ; Yes you're right, sorry I missed that. Should be fixed now.; > The last issue is whether to make a new function or not. I feel it belong as an options in the existing mscolve, but it would be easy to overlook by users. As a new function it will get more attention. I also don't have a strong opinion on the matter.; >; I think you are right. I added it as an option to options and updated tests, docs accordingly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1692317449
https://github.com/qutip/qutip/pull/2224#issuecomment-1706571816:8,Testability,test,test,8,"Yes, in test mathematics we test kron for both dense and sparse non-square.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2224#issuecomment-1706571816
https://github.com/qutip/qutip/pull/2224#issuecomment-1706571816:28,Testability,test,test,28,"Yes, in test mathematics we test kron for both dense and sparse non-square.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2224#issuecomment-1706571816
https://github.com/qutip/qutip/issues/2229#issuecomment-1713056542:174,Availability,toler,tolerances,174,"It looks like your parameters are a bit challenging for the ODE solver (the Rabi frequency Omega is much much smaller than the energy splitting omega). If you change the ODE tolerances using options you will find it gives the expected result, e.g., something like: . ```; options = qt.Options(rtol=1e-8, atol=1e-8); result = qt.mesolve(H, rho0, t, options=options,progress_bar=True); ```. If you use a ket instead of a density operator mesolve() will pass the problem to sesolve(), which I guess for some reason is more robust in this case. It is a little annoying it is just failing silently. I am curious if you tried in v5?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2229#issuecomment-1713056542
https://github.com/qutip/qutip/issues/2229#issuecomment-1713056542:520,Availability,robust,robust,520,"It looks like your parameters are a bit challenging for the ODE solver (the Rabi frequency Omega is much much smaller than the energy splitting omega). If you change the ODE tolerances using options you will find it gives the expected result, e.g., something like: . ```; options = qt.Options(rtol=1e-8, atol=1e-8); result = qt.mesolve(H, rho0, t, options=options,progress_bar=True); ```. If you use a ket instead of a density operator mesolve() will pass the problem to sesolve(), which I guess for some reason is more robust in this case. It is a little annoying it is just failing silently. I am curious if you tried in v5?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2229#issuecomment-1713056542
https://github.com/qutip/qutip/issues/2229#issuecomment-1713056542:127,Energy Efficiency,energy,energy,127,"It looks like your parameters are a bit challenging for the ODE solver (the Rabi frequency Omega is much much smaller than the energy splitting omega). If you change the ODE tolerances using options you will find it gives the expected result, e.g., something like: . ```; options = qt.Options(rtol=1e-8, atol=1e-8); result = qt.mesolve(H, rho0, t, options=options,progress_bar=True); ```. If you use a ket instead of a density operator mesolve() will pass the problem to sesolve(), which I guess for some reason is more robust in this case. It is a little annoying it is just failing silently. I am curious if you tried in v5?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2229#issuecomment-1713056542
https://github.com/qutip/qutip/issues/2229#issuecomment-1713148770:49,Availability,toler,tolerances,49,"It gives me correct result when I change the ODE tolerances as you mentioned, in mesolve(). Thank you so much. I tried in v4.7.3, now, after I upgrade it to v5, still same result as v4.7.3.; Now I can try my original calculation, your suggestion should work then.; Thanks. > It is a little annoying it is just failing silently. yes, I agree....",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2229#issuecomment-1713148770
https://github.com/qutip/qutip/issues/2229#issuecomment-1713148770:143,Deployability,upgrade,upgrade,143,"It gives me correct result when I change the ODE tolerances as you mentioned, in mesolve(). Thank you so much. I tried in v4.7.3, now, after I upgrade it to v5, still same result as v4.7.3.; Now I can try my original calculation, your suggestion should work then.; Thanks. > It is a little annoying it is just failing silently. yes, I agree....",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2229#issuecomment-1713148770
https://github.com/qutip/qutip/pull/2234#issuecomment-1740361085:23,Testability,test,tests,23,"I now noticed that the tests failed because of the added warnings. Unsure how to handle this, could add `@pytest.mark.filterwarnings('ignore::UserWarning')` to the tests?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1740361085
https://github.com/qutip/qutip/pull/2234#issuecomment-1740361085:164,Testability,test,tests,164,"I now noticed that the tests failed because of the added warnings. Unsure how to handle this, could add `@pytest.mark.filterwarnings('ignore::UserWarning')` to the tests?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1740361085
https://github.com/qutip/qutip/pull/2234#issuecomment-1750005892:190,Availability,error,error,190,"Hi Eric, thanks for your comment. > You should remove the options from `solver_options` instead. It contain every valid options keys, just removing the key from it would makes setting it an error. Unfortunately it is not so easy, since `MCSolver` relies on the option being present in `self.options`: https://github.com/qutip/qutip/blob/48df19ceeb1f07dd60659ccdc2fe61d8df159e78/qutip/solver/mcsolve.py#L474; We could try overriding every method of MCSolver that accesses this option, but that seems easy to break accidentally again with future changes in MCSolver. > Also I would suggest to overwrite the `options` property to add the `completeness_rtol`, etc. to it's docsting. Done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1750005892
https://github.com/qutip/qutip/pull/2234#issuecomment-1750005892:462,Security,access,accesses,462,"Hi Eric, thanks for your comment. > You should remove the options from `solver_options` instead. It contain every valid options keys, just removing the key from it would makes setting it an error. Unfortunately it is not so easy, since `MCSolver` relies on the option being present in `self.options`: https://github.com/qutip/qutip/blob/48df19ceeb1f07dd60659ccdc2fe61d8df159e78/qutip/solver/mcsolve.py#L474; We could try overriding every method of MCSolver that accesses this option, but that seems easy to break accidentally again with future changes in MCSolver. > Also I would suggest to overwrite the `options` property to add the `completeness_rtol`, etc. to it's docsting. Done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1750005892
https://github.com/qutip/qutip/pull/2234#issuecomment-1750008231:8,Testability,test,tested,8,"Note: I tested the ; `del solver_options[""improved_sampling""]`; in this branch in my fork: https://github.com/pmenczel/qutip/tree/nmmcsolve-delete-sampling-option",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1750008231
https://github.com/qutip/qutip/pull/2234#issuecomment-1751297442:30,Availability,avail,available,30,"`solver_options` contains all available options. I don't think we want to breaks this pattern for this.; Maybe fixing MCSolver to use `options.get(""improved_sampling"", False)` instead of `options[""improved_sampling""]` would be enough for now. But it shows that our solver class structure is to be reworked or we need an equivalent to `improved_sampling` for `nm_mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1751297442
https://github.com/qutip/qutip/pull/2234#issuecomment-1754376221:32,Availability,avail,available,32,"> `solver_options` contains all available options. I don't think we want to breaks this pattern for this. Maybe fixing MCSolver to use `options.get(""improved_sampling"", False)` instead of `options[""improved_sampling""]` would be enough for now. Okay, I have fixed it like this for now. > But it shows that our solver class structure is to be reworked or we need an equivalent to `improved_sampling` for `nm_mcsolve`. I could try implementing `improved_sampling` for `nm_mcsolve`, but that would need a bit more time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1754376221
https://github.com/qutip/qutip/pull/2244#issuecomment-1756117748:211,Testability,test,test,211,[![Coverage Status](https://coveralls.io/builds/63232951/badge)](https://coveralls.io/builds/63232951). coverage: 43.961% (-40.9%) from 84.833% when pulling **c193e9c98bf391c45d791368c3ba1ded91682ccd on Ericgig:test.email** into **7f28e55e0fa03017b308f2f1582d77e3dbbb1c99 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2244#issuecomment-1756117748
https://github.com/qutip/qutip/issues/2245#issuecomment-1773217627:66,Deployability,release,released,66,We don't support cython 3.X and the fix for matplotlib 3.8 is not released yet.; My guess is if you roll back cython to 0.29.36 it will work. Fix for cython 3.X will be in the next major release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2245#issuecomment-1773217627
https://github.com/qutip/qutip/issues/2245#issuecomment-1773217627:187,Deployability,release,release,187,We don't support cython 3.X and the fix for matplotlib 3.8 is not released yet.; My guess is if you roll back cython to 0.29.36 it will work. Fix for cython 3.X will be in the next major release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2245#issuecomment-1773217627
https://github.com/qutip/qutip/issues/2245#issuecomment-1780372022:68,Deployability,install,installing,68,"> Thank you for your reply. However, the problem didn't solve after installing cython 0.29.36. ![image](https://github.com/qutip/qutip/assets/125566140/ed96af0d-3dc7-497c-91f9-196154d7a13f)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2245#issuecomment-1780372022
https://github.com/qutip/qutip/issues/2245#issuecomment-1856882465:88,Availability,avail,available,88,"Closing this because the original issue is resolved. Some support for Cython 3.0 is now available, but the situation is still a bit fluid and complex as Cython 3.0 stabilizes. We'll likely need a few more specific issues to deal with Cython 3.0 support. Anyone reading feel free to open such an issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2245#issuecomment-1856882465
https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168:152,Performance,bottleneck,bottleneck,152,"@hodgestar I will merge this as is since it block the tests from passing everywhere. The situation with `except * nogil` is not perfect, but it's not a bottleneck in our computations. If you look at the generated code, the issue is only when calling an `except * nogil` function returning complex or void within another `nogil` function. Therefore I removed the nogil from function that called other nogil functions, not those who did the work. If you see optimisation I missed, please open another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168
https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168:54,Testability,test,tests,54,"@hodgestar I will merge this as is since it block the tests from passing everywhere. The situation with `except * nogil` is not perfect, but it's not a bottleneck in our computations. If you look at the generated code, the issue is only when calling an `except * nogil` function returning complex or void within another `nogil` function. Therefore I removed the nogil from function that called other nogil functions, not those who did the work. If you see optimisation I missed, please open another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168
https://github.com/qutip/qutip/pull/2251#issuecomment-1781162157:82,Availability,reliab,reliable,82,Not sure how to make a test for this. The file name is random and it's not always reliable when the `__del__` is called which is where the file is erased.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1781162157
https://github.com/qutip/qutip/pull/2251#issuecomment-1781162157:23,Testability,test,test,23,Not sure how to make a test for this. The file name is random and it's not always reliable when the `__del__` is called which is where the file is erased.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1781162157
https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773:84,Availability,reliab,reliable,84,"> Not sure how to make a test for this. The file name is random and it's not always reliable when the `__del__` is called which is where the file is erased. You could create a coefficient and check that the last entry of `coeff_files.file_list` looks correct and exists. The wouldn't check the deletion but would check that the filename is correct. You can do `del qutip.qobjevo.coeff_files` to trigger the clean-up of the object, but that is a bit GC dependent and implementing it properly would require calling `gc.collect()`. Not sure if that is worth the hassle.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773
https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773:452,Integrability,depend,dependent,452,"> Not sure how to make a test for this. The file name is random and it's not always reliable when the `__del__` is called which is where the file is erased. You could create a coefficient and check that the last entry of `coeff_files.file_list` looks correct and exists. The wouldn't check the deletion but would check that the filename is correct. You can do `del qutip.qobjevo.coeff_files` to trigger the clean-up of the object, but that is a bit GC dependent and implementing it properly would require calling `gc.collect()`. Not sure if that is worth the hassle.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773
https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773:25,Testability,test,test,25,"> Not sure how to make a test for this. The file name is random and it's not always reliable when the `__del__` is called which is where the file is erased. You could create a coefficient and check that the last entry of `coeff_files.file_list` looks correct and exists. The wouldn't check the deletion but would check that the filename is correct. You can do `del qutip.qobjevo.coeff_files` to trigger the clean-up of the object, but that is a bit GC dependent and implementing it properly would require calling `gc.collect()`. Not sure if that is worth the hassle.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773
https://github.com/qutip/qutip/pull/2251#issuecomment-1955525255:49,Deployability,release,release,49,"Hi, thanks for fixing this issue. ; However, its release seems to be stalled because of other incomplete features in v4.7.3.; Is there something I can to fix this issue for myself locally, while we wait for v4.7.3 to be released publicly?. Thanks,; Harsh.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1955525255
https://github.com/qutip/qutip/pull/2251#issuecomment-1955525255:220,Deployability,release,released,220,"Hi, thanks for fixing this issue. ; However, its release seems to be stalled because of other incomplete features in v4.7.3.; Is there something I can to fix this issue for myself locally, while we wait for v4.7.3 to be released publicly?. Thanks,; Harsh.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1955525255
https://github.com/qutip/qutip/pull/2251#issuecomment-1956630959:43,Availability,avail,available,43,v4.7.5 was released a few weeks ago.; It's available on both conda and pypi.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1956630959
https://github.com/qutip/qutip/pull/2251#issuecomment-1956630959:11,Deployability,release,released,11,v4.7.5 was released a few weeks ago.; It's available on both conda and pypi.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1956630959
https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479:68,Availability,recover,recovered,68,"Oh, yes, I increase the sampling rate. Indeed the correct result is recovered. Great thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479
https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479:68,Safety,recover,recovered,68,"Oh, yes, I increase the sampling rate. Indeed the correct result is recovered. Great thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479
https://github.com/qutip/qutip/pull/2254#issuecomment-1796518340:0,Testability,Test,Tests,0,"Tests were only with `Dia`, added tests with other types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2254#issuecomment-1796518340
https://github.com/qutip/qutip/pull/2254#issuecomment-1796518340:34,Testability,test,tests,34,"Tests were only with `Dia`, added tests with other types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2254#issuecomment-1796518340
https://github.com/qutip/qutip/issues/2258#issuecomment-1793050302:25,Availability,error,error,25,"This is due to numerical error in the integration, you can change the precision in options:; `Options(max_step=1/(wr * 100), atol=1e-9, rtol=1e-9)`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2258#issuecomment-1793050302
https://github.com/qutip/qutip/issues/2258#issuecomment-1793050302:38,Deployability,integrat,integration,38,"This is due to numerical error in the integration, you can change the precision in options:; `Options(max_step=1/(wr * 100), atol=1e-9, rtol=1e-9)`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2258#issuecomment-1793050302
https://github.com/qutip/qutip/issues/2258#issuecomment-1793050302:38,Integrability,integrat,integration,38,"This is due to numerical error in the integration, you can change the precision in options:; `Options(max_step=1/(wr * 100), atol=1e-9, rtol=1e-9)`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2258#issuecomment-1793050302
https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764:1151,Availability,down,downside,1151,"Sorry for the delay on the docstrings and so on, I think all suggestions should be incorporated now. However, thanks to Paul's suggestion of adapting the tutorial 1e. I realized that I made a ""mistake from the very beggining"", namely the function used to fit the correlation function is only good if the imaginary part of the spectral density is 0 at t=0, because I'm using. $C(t)=\sum_{k}a_{k}e^{-b_{k} t}e^{i c_{k} t}$. so . $C_{R}(t)=\sum_{k}a_{k}e^{-b_{k} t}cos(c_{k} t)$. $C_{I}(t)=\sum_{k}a_{k}e^{-b_{k} t}sin(c_{k} t)$. No matter how many terms I take $C_{I}(0)=0$. I should have realized before but this can be bypassed by excluding $t=0$ from the fit, and starting at a small t, you get a decent fit, as long as you don't look at C(0), and I never check for these situations before. The results of doing this are pretty decent, but updating tutorial 1e I realized it required higher calculation times for the HEOMSolver when compared to using another ansatz for the correlation function, since solving is the expensive bit then I changed the code use another function for fitting. $C(t)=\sum_{k}(a_{k}+i d_{k})e^{-b_{k} t}e^{i c_{k} t}$. The downside is that since this function has 4 parameters, it required changing other functions as well, luckily only functions starting with _, hopefully this won't delay the PR too much. I updated the tutorials with this as well, and added a bit so that passing the parameters for the fitting is easier (after this comment), if the change is not desirable we can just go back to the commit before this comment",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764
https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764:1338,Deployability,update,updated,1338,"Sorry for the delay on the docstrings and so on, I think all suggestions should be incorporated now. However, thanks to Paul's suggestion of adapting the tutorial 1e. I realized that I made a ""mistake from the very beggining"", namely the function used to fit the correlation function is only good if the imaginary part of the spectral density is 0 at t=0, because I'm using. $C(t)=\sum_{k}a_{k}e^{-b_{k} t}e^{i c_{k} t}$. so . $C_{R}(t)=\sum_{k}a_{k}e^{-b_{k} t}cos(c_{k} t)$. $C_{I}(t)=\sum_{k}a_{k}e^{-b_{k} t}sin(c_{k} t)$. No matter how many terms I take $C_{I}(0)=0$. I should have realized before but this can be bypassed by excluding $t=0$ from the fit, and starting at a small t, you get a decent fit, as long as you don't look at C(0), and I never check for these situations before. The results of doing this are pretty decent, but updating tutorial 1e I realized it required higher calculation times for the HEOMSolver when compared to using another ansatz for the correlation function, since solving is the expensive bit then I changed the code use another function for fitting. $C(t)=\sum_{k}(a_{k}+i d_{k})e^{-b_{k} t}e^{i c_{k} t}$. The downside is that since this function has 4 parameters, it required changing other functions as well, luckily only functions starting with _, hopefully this won't delay the PR too much. I updated the tutorials with this as well, and added a bit so that passing the parameters for the fitting is easier (after this comment), if the change is not desirable we can just go back to the commit before this comment",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764
https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764:141,Energy Efficiency,adapt,adapting,141,"Sorry for the delay on the docstrings and so on, I think all suggestions should be incorporated now. However, thanks to Paul's suggestion of adapting the tutorial 1e. I realized that I made a ""mistake from the very beggining"", namely the function used to fit the correlation function is only good if the imaginary part of the spectral density is 0 at t=0, because I'm using. $C(t)=\sum_{k}a_{k}e^{-b_{k} t}e^{i c_{k} t}$. so . $C_{R}(t)=\sum_{k}a_{k}e^{-b_{k} t}cos(c_{k} t)$. $C_{I}(t)=\sum_{k}a_{k}e^{-b_{k} t}sin(c_{k} t)$. No matter how many terms I take $C_{I}(0)=0$. I should have realized before but this can be bypassed by excluding $t=0$ from the fit, and starting at a small t, you get a decent fit, as long as you don't look at C(0), and I never check for these situations before. The results of doing this are pretty decent, but updating tutorial 1e I realized it required higher calculation times for the HEOMSolver when compared to using another ansatz for the correlation function, since solving is the expensive bit then I changed the code use another function for fitting. $C(t)=\sum_{k}(a_{k}+i d_{k})e^{-b_{k} t}e^{i c_{k} t}$. The downside is that since this function has 4 parameters, it required changing other functions as well, luckily only functions starting with _, hopefully this won't delay the PR too much. I updated the tutorials with this as well, and added a bit so that passing the parameters for the fitting is easier (after this comment), if the change is not desirable we can just go back to the commit before this comment",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764
https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764:141,Modifiability,adapt,adapting,141,"Sorry for the delay on the docstrings and so on, I think all suggestions should be incorporated now. However, thanks to Paul's suggestion of adapting the tutorial 1e. I realized that I made a ""mistake from the very beggining"", namely the function used to fit the correlation function is only good if the imaginary part of the spectral density is 0 at t=0, because I'm using. $C(t)=\sum_{k}a_{k}e^{-b_{k} t}e^{i c_{k} t}$. so . $C_{R}(t)=\sum_{k}a_{k}e^{-b_{k} t}cos(c_{k} t)$. $C_{I}(t)=\sum_{k}a_{k}e^{-b_{k} t}sin(c_{k} t)$. No matter how many terms I take $C_{I}(0)=0$. I should have realized before but this can be bypassed by excluding $t=0$ from the fit, and starting at a small t, you get a decent fit, as long as you don't look at C(0), and I never check for these situations before. The results of doing this are pretty decent, but updating tutorial 1e I realized it required higher calculation times for the HEOMSolver when compared to using another ansatz for the correlation function, since solving is the expensive bit then I changed the code use another function for fitting. $C(t)=\sum_{k}(a_{k}+i d_{k})e^{-b_{k} t}e^{i c_{k} t}$. The downside is that since this function has 4 parameters, it required changing other functions as well, luckily only functions starting with _, hopefully this won't delay the PR too much. I updated the tutorials with this as well, and added a bit so that passing the parameters for the fitting is easier (after this comment), if the change is not desirable we can just go back to the commit before this comment",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764
https://github.com/qutip/qutip/pull/2260#issuecomment-1965979664:119,Testability,test,tests,119,"Somehow vscode published those review comments above before I was done reviewing. Only one more comment though: in the tests, you ignore some RuntimeWarnings here and there; it would be good to add a comment explaining why. Thank you for adding a good amount of tests!. If these last minor points get addressed, this looks good to me. Only those utility functions in the `bofin_fit` module are a bit of a mess - if we ever want to add more fitting methods, it will require some work. But it is non-public api and it seems to do the job for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1965979664
https://github.com/qutip/qutip/pull/2260#issuecomment-1965979664:262,Testability,test,tests,262,"Somehow vscode published those review comments above before I was done reviewing. Only one more comment though: in the tests, you ignore some RuntimeWarnings here and there; it would be good to add a comment explaining why. Thank you for adding a good amount of tests!. If these last minor points get addressed, this looks good to me. Only those utility functions in the `bofin_fit` module are a bit of a mess - if we ever want to add more fitting methods, it will require some work. But it is non-public api and it seems to do the job for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1965979664
https://github.com/qutip/qutip/pull/2261#issuecomment-1824959705:292,Availability,ping,ping,292,"@mcditoos Thanks more making the PR. Would you mind reverting all the unrelated changes? We don't mind small clean ups, but big clean ups should rather go into separate PRs and it should be clear why they are being made. Once you're ready for this to be reviewed, remove the draft status and ping me on the PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2261#issuecomment-1824959705
https://github.com/qutip/qutip/pull/2261#issuecomment-1824959705:190,Usability,clear,clear,190,"@mcditoos Thanks more making the PR. Would you mind reverting all the unrelated changes? We don't mind small clean ups, but big clean ups should rather go into separate PRs and it should be clear why they are being made. Once you're ready for this to be reviewed, remove the draft status and ping me on the PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2261#issuecomment-1824959705
https://github.com/qutip/qutip/pull/2262#issuecomment-1807564710:228,Usability,feedback,feedback,228,[![Coverage Status](https://coveralls.io/builds/63911753/badge)](https://coveralls.io/builds/63911753). coverage: 84.849% (+0.004%) from 84.845%; when pulling **250692b32c96081e1418d9a1e6b7c23393fe1ed9 on pmenczel:result-opt-no-feedback**; into **454b61529d7bf3c37f74c17925a749fcb046c364 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2262#issuecomment-1807564710
https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808:312,Deployability,release,release,312,"Welcome, and thanks for filing your first issue. `measurement_statistics_observable` determines the eigenvalues and eigenstates of the supplied operator, so it's likely to be slow as the size of the system grows. If there is a means to speed it up, we'd be happy to give that a try. You could also try the alpha release of QuTiP 5 (`pip install qutip==5.0.0a2`) and compare performance there. Are you only seeing the negative probabilities when `state` is a density matrix? Perhaps we can make the code a bit better and explicitly tidy up the small unphysical negative probabilities.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808
https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808:337,Deployability,install,install,337,"Welcome, and thanks for filing your first issue. `measurement_statistics_observable` determines the eigenvalues and eigenstates of the supplied operator, so it's likely to be slow as the size of the system grows. If there is a means to speed it up, we'd be happy to give that a try. You could also try the alpha release of QuTiP 5 (`pip install qutip==5.0.0a2`) and compare performance there. Are you only seeing the negative probabilities when `state` is a density matrix? Perhaps we can make the code a bit better and explicitly tidy up the small unphysical negative probabilities.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808
https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808:374,Performance,perform,performance,374,"Welcome, and thanks for filing your first issue. `measurement_statistics_observable` determines the eigenvalues and eigenstates of the supplied operator, so it's likely to be slow as the size of the system grows. If there is a means to speed it up, we'd be happy to give that a try. You could also try the alpha release of QuTiP 5 (`pip install qutip==5.0.0a2`) and compare performance there. Are you only seeing the negative probabilities when `state` is a density matrix? Perhaps we can make the code a bit better and explicitly tidy up the small unphysical negative probabilities.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808
https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769:410,Performance,optimiz,optimization,410,"The negative values problem is definitely present when `state` is a density matrix, and right now that is the only case I have tested. . I understand it will be very slow for larger systems (exponentially so), but in my application is seems to be much slower even than the time evolution of the function, which seems like it should be more computationally complex. Given that, I suspect there is some room for optimization. . What's the best way to tell if there are any relevant differences between 4.7.2 and the 5.0.x alpha?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769
https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769:127,Testability,test,tested,127,"The negative values problem is definitely present when `state` is a density matrix, and right now that is the only case I have tested. . I understand it will be very slow for larger systems (exponentially so), but in my application is seems to be much slower even than the time evolution of the function, which seems like it should be more computationally complex. Given that, I suspect there is some room for optimization. . What's the best way to tell if there are any relevant differences between 4.7.2 and the 5.0.x alpha?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769
https://github.com/qutip/qutip/issues/2265#issuecomment-1821020656:11,Usability,clear,clearing,11,"Thanks for clearing that up. I had tried to poke around to see what had changed, but I hadn't gone deep enough to see what changed with the qobjs themselves. . That's a good point about the eigenstate problem. I forgot about that because the observable I'm interested in is very very simple (it's diagonal), so it *seems* like it should be trivial to compute the measurement statistics. But to do that, qutip would have to know the observable is simple so it could take advantage of the symmetries. Are there any flags I can give it to tip it off? Or can I some how pass the list of eigenstates 'manually' so it doesn't need to find them itself?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1821020656
https://github.com/qutip/qutip/issues/2265#issuecomment-1821020656:284,Usability,simpl,simple,284,"Thanks for clearing that up. I had tried to poke around to see what had changed, but I hadn't gone deep enough to see what changed with the qobjs themselves. . That's a good point about the eigenstate problem. I forgot about that because the observable I'm interested in is very very simple (it's diagonal), so it *seems* like it should be trivial to compute the measurement statistics. But to do that, qutip would have to know the observable is simple so it could take advantage of the symmetries. Are there any flags I can give it to tip it off? Or can I some how pass the list of eigenstates 'manually' so it doesn't need to find them itself?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1821020656
https://github.com/qutip/qutip/issues/2265#issuecomment-1821020656:446,Usability,simpl,simple,446,"Thanks for clearing that up. I had tried to poke around to see what had changed, but I hadn't gone deep enough to see what changed with the qobjs themselves. . That's a good point about the eigenstate problem. I forgot about that because the observable I'm interested in is very very simple (it's diagonal), so it *seems* like it should be trivial to compute the measurement statistics. But to do that, qutip would have to know the observable is simple so it could take advantage of the symmetries. Are there any flags I can give it to tip it off? Or can I some how pass the list of eigenstates 'manually' so it doesn't need to find them itself?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1821020656
https://github.com/qutip/qutip/issues/2270#issuecomment-2028996738:29,Deployability,release,release,29,"It should be fixed with v5's release.; Now the documentation says that `c_ops` can be a list of `QobjEvo` or anything that can be interpreted as such, including functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2270#issuecomment-2028996738
https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751:7,Deployability,release,release,7,"In the release version `qutip-4.7.X`, it is set in `qutip/__init__.py`. On master it is at https://github.com/qutip/qutip/blob/253d91c2776fef5cc0025e3c537d046f6e9c97a1/qutip/settings.py#L159; It's a property and can't be changed, but we can change that if useful.; The condition is the same. Qutip's sparse `eig` is not safe for matrices with degenerate real part of the eigen value (#1998), but I have not seen issues with the dense one (calling lapack through numpy).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751
https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751:320,Safety,safe,safe,320,"In the release version `qutip-4.7.X`, it is set in `qutip/__init__.py`. On master it is at https://github.com/qutip/qutip/blob/253d91c2776fef5cc0025e3c537d046f6e9c97a1/qutip/settings.py#L159; It's a property and can't be changed, but we can change that if useful.; The condition is the same. Qutip's sparse `eig` is not safe for matrices with degenerate real part of the eigen value (#1998), but I have not seen issues with the dense one (calling lapack through numpy).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751
https://github.com/qutip/qutip/issues/2275#issuecomment-1839300126:18,Availability,error,error,18,"This is numerical error from the ODE solver.; Try changing the solver tolerance:; `sesolve(..., options=Options(atol=1e-10)`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2275#issuecomment-1839300126
https://github.com/qutip/qutip/issues/2275#issuecomment-1839300126:70,Availability,toler,tolerance,70,"This is numerical error from the ODE solver.; Try changing the solver tolerance:; `sesolve(..., options=Options(atol=1e-10)`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2275#issuecomment-1839300126
https://github.com/qutip/qutip/pull/2276#issuecomment-1846486935:4,Testability,test,tests,4,"The tests were failing because Kraus operators are defined up to a complex phase. Fixing the phase in the eigensolver helped with the operators that have non-zero `[0,0]` element. But where this element is 0, the function still may return Kraus operators like `-sigmax()` where one previously expected `sigmax()`. Which is still a correct operator, but it may fail tests in projects that rely on `qutip` if they compare operators element-wise, and not up to a global phase (like comparing eigenvectors or looking at an overlap).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2276#issuecomment-1846486935
https://github.com/qutip/qutip/pull/2276#issuecomment-1846486935:365,Testability,test,tests,365,"The tests were failing because Kraus operators are defined up to a complex phase. Fixing the phase in the eigensolver helped with the operators that have non-zero `[0,0]` element. But where this element is 0, the function still may return Kraus operators like `-sigmax()` where one previously expected `sigmax()`. Which is still a correct operator, but it may fail tests in projects that rely on `qutip` if they compare operators element-wise, and not up to a global phase (like comparing eigenvectors or looking at an overlap).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2276#issuecomment-1846486935
https://github.com/qutip/qutip/pull/2279#issuecomment-1866906699:215,Usability,guid,guide,215,[![Coverage Status](https://coveralls.io/builds/65270670/badge)](https://coveralls.io/builds/65270670). coverage: 84.18% (-0.02%) from 84.196%; when pulling **b1d582b2d0cee852dfb3a92471d0205257c1cf03 on Ericgig:doc.guide**; into **7fbb5672242600481d84ee4e5144c95748bf17dc on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2279#issuecomment-1866906699
https://github.com/qutip/qutip/pull/2281#issuecomment-1873806211:217,Deployability,patch,patch-,217,[![Coverage Status](https://coveralls.io/builds/64827370/badge)](https://coveralls.io/builds/64827370). coverage: 84.196%. remained the same; when pulling **1529237b401bf8f5271bf878498ca6cc9d07f772 on anonymousdouble:patch-1**; into **7fbb5672242600481d84ee4e5144c95748bf17dc on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2281#issuecomment-1873806211
https://github.com/qutip/qutip/pull/2283#issuecomment-1887804548:46,Deployability,release,release,46,"Thanks for merging!; Is it possible to make a release of qutip 4? Or, if you have a set release calendar, when to expect it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2283#issuecomment-1887804548
https://github.com/qutip/qutip/pull/2283#issuecomment-1887804548:88,Deployability,release,release,88,"Thanks for merging!; Is it possible to make a release of qutip 4? Or, if you have a set release calendar, when to expect it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2283#issuecomment-1887804548
https://github.com/qutip/qutip/pull/2283#issuecomment-1898819054:24,Deployability,release,release,24,"Hi @theodotk, the 4.7.4 release is in progress.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2283#issuecomment-1898819054
https://github.com/qutip/qutip/pull/2284#issuecomment-1878049498:22,Testability,test,tests,22,It seems that failing tests are not related to this change,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2284#issuecomment-1878049498
https://github.com/qutip/qutip/pull/2284#issuecomment-1883606705:110,Testability,test,tests,110,I see that there were PRs with ignoring the deprecation warnings.; Do i need to make another push to make the tests restart in this PR?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2284#issuecomment-1883606705
https://github.com/qutip/qutip/issues/2286#issuecomment-1881266191:81,Testability,test,tested,81,"Thank you for reporting. Everything in `qutip.distribution` is experimental: not tested and little documentation.; We probably won't have time to look at it soon, but we will keep the issue open until we do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2286#issuecomment-1881266191
https://github.com/qutip/qutip/pull/2291#issuecomment-1887970000:195,Integrability,depend,dependabot,195,[![Coverage Status](https://coveralls.io/builds/65026523/badge)](https://coveralls.io/builds/65026523). coverage: 84.185%. first build; when pulling **60ba0a25798e27b0be550158e789850136c1b45a on dependabot/pip/doc/jinja2-3.1.3**; into **e7853099194686cfb11ce7620639a78121e964dd on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2291#issuecomment-1887970000
https://github.com/qutip/qutip/issues/2293#issuecomment-1892426006:110,Deployability,release,released,110,We don't currently test or build for 3.12 on the `qutip-4.7.X` branch. Probably we should since 5 isn't fully released yet.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1892426006
https://github.com/qutip/qutip/issues/2293#issuecomment-1892426006:19,Testability,test,test,19,We don't currently test or build for 3.12 on the `qutip-4.7.X` branch. Probably we should since 5 isn't fully released yet.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1892426006
https://github.com/qutip/qutip/issues/2293#issuecomment-1892641379:167,Availability,avail,available,167,"Cython 0.29 is not compatible with python 3.12.; On debian, they have the module `python3-zombie-imp` which is a copy of the removed imp module, but it does not seems available on pip or conda. Thus cython jit (pyximport) is not working on 3.12 for almost everyone. Adding cython3 to 4.7.X is not a quick fix and we already choose not to do it. The best we can do is to run as if cython was not installed at runtime on 3.12 and release 5.0.0 soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1892641379
https://github.com/qutip/qutip/issues/2293#issuecomment-1892641379:395,Deployability,install,installed,395,"Cython 0.29 is not compatible with python 3.12.; On debian, they have the module `python3-zombie-imp` which is a copy of the removed imp module, but it does not seems available on pip or conda. Thus cython jit (pyximport) is not working on 3.12 for almost everyone. Adding cython3 to 4.7.X is not a quick fix and we already choose not to do it. The best we can do is to run as if cython was not installed at runtime on 3.12 and release 5.0.0 soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1892641379
https://github.com/qutip/qutip/issues/2293#issuecomment-1892641379:428,Deployability,release,release,428,"Cython 0.29 is not compatible with python 3.12.; On debian, they have the module `python3-zombie-imp` which is a copy of the removed imp module, but it does not seems available on pip or conda. Thus cython jit (pyximport) is not working on 3.12 for almost everyone. Adding cython3 to 4.7.X is not a quick fix and we already choose not to do it. The best we can do is to run as if cython was not installed at runtime on 3.12 and release 5.0.0 soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1892641379
https://github.com/qutip/qutip/issues/2293#issuecomment-1892805618:19,Testability,test,tests,19,"In any case, these tests still fail with HEAD on the qutip-4.7.X branch ([7a883d3](https://github.com/qutip/qutip/commit/7a883d3a4b0cbf10a5491c2b576f1b9ed85896fa))",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1892805618
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2686,Availability,avail,available,2686,"f Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ===================================================================; --- qutip.orig/qutip/about.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/about.py	2024-01-16 03:54:39.029027082 +0100; @@ -44,7 +44,8 @@; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; - print(""Cython Version: %s"" % cython_ver); + print(""Cython Version: %s%s"" % (cython_ver,; + """" if cython_ver == 'None' or qutip.settings.has_cython else "" (unsupported)"")); try:; import matplotlib; matplotlib_ver = matplotlib.__version__. ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2923,Availability,avail,available,2923,"f Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ===================================================================; --- qutip.orig/qutip/about.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/about.py	2024-01-16 03:54:39.029027082 +0100; @@ -44,7 +44,8 @@; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; - print(""Cython Version: %s"" % cython_ver); + print(""Cython Version: %s%s"" % (cython_ver,; + """" if cython_ver == 'None' or qutip.settings.has_cython else "" (unsupported)"")); try:; import matplotlib; matplotlib_ver = matplotlib.__version__. ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:52,Deployability,patch,patch,52,"I disabled cython support on python 3.12 with [this patch](https://salsa.debian.org/science-team/qutip/-/blob/master/debian/patches/python3.12_no_cython_support.patch?ref_type=heads):; ```; Index: qutip/qutip/__init__.py; ===================================================================; --- qutip.orig/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; @@ -53,25 +53,31 @@; except ImportError:; pass; else:; - from qutip.utilities import _version2int; - _cy_require = ""0.29.20""; - _cy_unsupported = ""3.0.0""; - if _version2int(_Cython.__version__) < _version2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install();",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:124,Deployability,patch,patches,124,"I disabled cython support on python 3.12 with [this patch](https://salsa.debian.org/science-team/qutip/-/blob/master/debian/patches/python3.12_no_cython_support.patch?ref_type=heads):; ```; Index: qutip/qutip/__init__.py; ===================================================================; --- qutip.orig/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; @@ -53,25 +53,31 @@; except ImportError:; pass; else:; - from qutip.utilities import _version2int; - _cy_require = ""0.29.20""; - _cy_unsupported = ""3.0.0""; - if _version2int(_Cython.__version__) < _version2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install();",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:161,Deployability,patch,patch,161,"I disabled cython support on python 3.12 with [this patch](https://salsa.debian.org/science-team/qutip/-/blob/master/debian/patches/python3.12_no_cython_support.patch?ref_type=heads):; ```; Index: qutip/qutip/__init__.py; ===================================================================; --- qutip.orig/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; @@ -53,25 +53,31 @@; except ImportError:; pass; else:; - from qutip.utilities import _version2int; - _cy_require = ""0.29.20""; - _cy_unsupported = ""3.0.0""; - if _version2int(_Cython.__version__) < _version2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install();",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:1330,Deployability,install,install,1330," +++ qutip/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; @@ -53,25 +53,31 @@; except ImportError:; pass; else:; - from qutip.utilities import _version2int; - _cy_require = ""0.29.20""; - _cy_unsupported = ""3.0.0""; - if _version2int(_Cython.__version__) < _version2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:1991,Deployability,install,install,1991,"er.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tup",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:693,Safety,detect,detected,693,"I disabled cython support on python 3.12 with [this patch](https://salsa.debian.org/science-team/qutip/-/blob/master/debian/patches/python3.12_no_cython_support.patch?ref_type=heads):; ```; Index: qutip/qutip/__init__.py; ===================================================================; --- qutip.orig/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; @@ -53,25 +53,31 @@; except ImportError:; pass; else:; - from qutip.utilities import _version2int; - _cy_require = ""0.29.20""; - _cy_unsupported = ""3.0.0""; - if _version2int(_Cython.__version__) < _version2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install();",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:1631,Safety,detect,detected,1631,"n2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qut",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2184,Testability,test,tests,2184,"tip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ================================================",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2302,Testability,test,tests,2302,"uilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ===================================================================; --- qutip.orig/qutip/about.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/about.py	2024-01-16 03:54:39.029027082 +0100; @@ -44,7 +44,8 @@; cytho",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2382,Testability,test,tests,2382,"2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ===================================================================; --- qutip.orig/qutip/about.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/about.py	2024-01-16 03:54:39.029027082 +0100; @@ -44,7 +44,8 @@; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None';",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2533,Testability,assert,assert,2533,"2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ===================================================================; --- qutip.orig/qutip/about.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/about.py	2024-01-16 03:54:39.029027082 +0100; @@ -44,7 +44,8 @@; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; - print(""Cython Version: %s"" % cython_ver); + print(""Cython Version: %s%s"" % (cython_ver,; + """" if cython_ver == 'None' or qutip.settings.has_cython else ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543
https://github.com/qutip/qutip/issues/2293#issuecomment-1969569230:31,Deployability,release,release,31,Should be fixed with the 4.7.5 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1969569230
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:144,Deployability,install,installed,144,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:413,Deployability,install,install,413,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:604,Deployability,install,install,604,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:689,Deployability,install,install,689,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:117,Testability,test,tests,117,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:172,Testability,test,tests,172,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:240,Testability,test,tests,240,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:368,Testability,test,testing,368,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:805,Testability,test,tests,805,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:902,Testability,test,tests,902,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386:929,Testability,test,tests,929,"Thank you for the review. > Could you add `mpi4py` to the requirement ins setup.cfg?; >; > You added the function to tests, but mpi4py is never installed for the automated tests. Did you try adding it to one of the job in `.github/workflow/tests.yml`? I am pretty sure it will run with only one process, but running the parallel function on one cpu is better than not testing it at all. If you tried and couldn't install mpi4py on github runner, please add a note about the issues somewhere. I have added it to setup.cfg, and now some tasks are failing.; * The documentation build fails because it can't install `mpi4py` (`mpi.h` is missing). I don't quite understand why that is... I can install `mpi4py` on my laptop without problems (it just uses regular parallel processes instead).; * The `mpi_pmap` tests are still being skipped. I'm sorry, but I don't understand what needs to be done with the `tests.yml`.; * The failing tests on ubuntu-latest, python 3.10 / 3.11 seem unrelated to my changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1903335386
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:738,Availability,failure,failures,738,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:47,Deployability,install,install,47,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:89,Deployability,install,installed,89,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:109,Deployability,install,install,109,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:590,Deployability,install,installing,590,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:781,Deployability,release,release,781,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:165,Integrability,depend,depending,165,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:78,Testability,test,test,78,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:182,Testability,test,test,182,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:206,Testability,test,test,206,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:290,Testability,test,test,290,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:389,Testability,test,test,389,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:492,Testability,test,tests,492,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:640,Testability,test,test,640,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729:733,Testability,test,test,733,"In the documentation, qutip is build with `pip install qutip[full]`, while in test it is installed with `pip install qutip[$QUTIP_TARGET]`, with the target changing depending on the test. We don't have any test using extra yet... The mpi4py team made a GitHub Actions workflow to run it in test: https://github.com/mpi4py/setup-mpi. You can add that workflow and the `extra` to have every test run with mpi:; ```; - uses: actions/checkout@v3; - uses: mpi4py/setup-mpi@v1; ```. `QUTIP_TARGET=""tests,graphics,semidefinite,ipython,extra"" `. By I am not sure it would work for windows. Also if installing mpi is slow, we may not want it in all test.; But conditional workflow are tricky so lets see want if it just works first. Yes, the test failures are related to last weekend scipy release, not this code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1904189729
https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136:105,Availability,failure,failures,105,"Hmmm. Now the documentation build works, and the macos test run works as well (except for unrelated test failures). The python 3.9 test runs fails to build mpi4py. Here, the problem solution would be [this](https://stackoverflow.com/a/73399242) (I've had the same problem before installing mpi4py on the RIKEN HPC). Should I add that?. All other test runs fail, seemingly because the first call to `mpi_pmap` hangs indefinitely. That's... hard to debug. Why would it work only on macos?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136
https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136:279,Deployability,install,installing,279,"Hmmm. Now the documentation build works, and the macos test run works as well (except for unrelated test failures). The python 3.9 test runs fails to build mpi4py. Here, the problem solution would be [this](https://stackoverflow.com/a/73399242) (I've had the same problem before installing mpi4py on the RIKEN HPC). Should I add that?. All other test runs fail, seemingly because the first call to `mpi_pmap` hangs indefinitely. That's... hard to debug. Why would it work only on macos?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136
https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136:55,Testability,test,test,55,"Hmmm. Now the documentation build works, and the macos test run works as well (except for unrelated test failures). The python 3.9 test runs fails to build mpi4py. Here, the problem solution would be [this](https://stackoverflow.com/a/73399242) (I've had the same problem before installing mpi4py on the RIKEN HPC). Should I add that?. All other test runs fail, seemingly because the first call to `mpi_pmap` hangs indefinitely. That's... hard to debug. Why would it work only on macos?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136
https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136:100,Testability,test,test,100,"Hmmm. Now the documentation build works, and the macos test run works as well (except for unrelated test failures). The python 3.9 test runs fails to build mpi4py. Here, the problem solution would be [this](https://stackoverflow.com/a/73399242) (I've had the same problem before installing mpi4py on the RIKEN HPC). Should I add that?. All other test runs fail, seemingly because the first call to `mpi_pmap` hangs indefinitely. That's... hard to debug. Why would it work only on macos?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136
https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136:131,Testability,test,test,131,"Hmmm. Now the documentation build works, and the macos test run works as well (except for unrelated test failures). The python 3.9 test runs fails to build mpi4py. Here, the problem solution would be [this](https://stackoverflow.com/a/73399242) (I've had the same problem before installing mpi4py on the RIKEN HPC). Should I add that?. All other test runs fail, seemingly because the first call to `mpi_pmap` hangs indefinitely. That's... hard to debug. Why would it work only on macos?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136
https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136:346,Testability,test,test,346,"Hmmm. Now the documentation build works, and the macos test run works as well (except for unrelated test failures). The python 3.9 test runs fails to build mpi4py. Here, the problem solution would be [this](https://stackoverflow.com/a/73399242) (I've had the same problem before installing mpi4py on the RIKEN HPC). Should I add that?. All other test runs fail, seemingly because the first call to `mpi_pmap` hangs indefinitely. That's... hard to debug. Why would it work only on macos?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136
https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182:616,Security,access,access,616,"Parallel map function having different behaviour on different OS is not new, it's quite annoying.; I am quite surprised (and sad) that it Mac that is going fine for this one. Most cluster are using linux, so I would be fine to just run the test once on linux... I understand that you are developing with a mpi enable cluster, not just your local machine. Do you use `mpiexec` when running the tests? Maybe not using it with pytest could have side effects. Maybe mpi4py's [discussions board](https://github.com/mpi4py/mpi4py/discussions) could help? They also have a google group, but it seems full of spam... I have access to a cluster and I will try it later this week. I will come back to you if I find something interesting. But I have little experience with mpi in python.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182
https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182:240,Testability,test,test,240,"Parallel map function having different behaviour on different OS is not new, it's quite annoying.; I am quite surprised (and sad) that it Mac that is going fine for this one. Most cluster are using linux, so I would be fine to just run the test once on linux... I understand that you are developing with a mpi enable cluster, not just your local machine. Do you use `mpiexec` when running the tests? Maybe not using it with pytest could have side effects. Maybe mpi4py's [discussions board](https://github.com/mpi4py/mpi4py/discussions) could help? They also have a google group, but it seems full of spam... I have access to a cluster and I will try it later this week. I will come back to you if I find something interesting. But I have little experience with mpi in python.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182
https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182:393,Testability,test,tests,393,"Parallel map function having different behaviour on different OS is not new, it's quite annoying.; I am quite surprised (and sad) that it Mac that is going fine for this one. Most cluster are using linux, so I would be fine to just run the test once on linux... I understand that you are developing with a mpi enable cluster, not just your local machine. Do you use `mpiexec` when running the tests? Maybe not using it with pytest could have side effects. Maybe mpi4py's [discussions board](https://github.com/mpi4py/mpi4py/discussions) could help? They also have a google group, but it seems full of spam... I have access to a cluster and I will try it later this week. I will come back to you if I find something interesting. But I have little experience with mpi in python.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:112,Deployability,install,install,112,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:361,Deployability,install,install,361,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:393,Deployability,install,install,393,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:631,Deployability,install,install,631,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:702,Deployability,install,installation,702,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:787,Deployability,install,installing,787,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:933,Deployability,install,install,933,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:40,Testability,test,tests,40,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:181,Testability,test,test,181,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:285,Testability,test,test-tmp,285,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:342,Testability,test,test-tmp,342,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:504,Testability,test,test-tmp,504,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:548,Testability,test,tests,548,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:588,Testability,test,tests,588,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:1089,Testability,test,tests,1089,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:1129,Testability,test,tests,1129,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:1348,Testability,test,tests,1348,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:1664,Testability,test,test,1664,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803
https://github.com/qutip/qutip/pull/2296#issuecomment-1912750964:20,Testability,test,tests,20,"I tried running the tests on the local cluster. (Linux, openmpi/4, python 3.10); It hanged on `test_map_pass_error` with `mpi4py.MPI.Exception: MPI_ERR_SPAWN: could not spawn processes`. But running the tests with `mpiexec -n 1 pytest ...` worked fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1912750964
https://github.com/qutip/qutip/pull/2296#issuecomment-1912750964:203,Testability,test,tests,203,"I tried running the tests on the local cluster. (Linux, openmpi/4, python 3.10); It hanged on `test_map_pass_error` with `mpi4py.MPI.Exception: MPI_ERR_SPAWN: could not spawn processes`. But running the tests with `mpiexec -n 1 pytest ...` worked fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1912750964
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1177,Availability,error,error,1177," it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1585,Availability,avail,available,1585,"torial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes than the number of available slots.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1638,Availability,avail,available,1638,"torial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes than the number of available slots.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:2425,Availability,avail,available,2425,"torial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes than the number of available slots.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:773,Deployability,install,installed,773,"It seems to work now (the failing test is unrelated). I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:831,Deployability,install,installed,831,"It seems to work now (the failing test is unrelated). I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1026,Deployability,install,install,1026,". I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1050,Deployability,install,installs,1050,". I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1085,Deployability,install,installs,1085,". I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1400,Deployability,install,install,1400,"tip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1183,Integrability,message,messages,1183," it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:34,Testability,test,test,34,"It seems to work now (the failing test is unrelated). I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:607,Testability,test,test,607,"It seems to work now (the failing test is unrelated). I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:707,Testability,test,tests,707,"It seems to work now (the failing test is unrelated). I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1447,Testability,test,test,1447,"tip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1732,Testability,test,tests,1732,"torial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes than the number of available slots.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:1925,Testability,log,logical,1925,"torial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes than the number of available slots.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:2350,Testability,test,test,2350,"torial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes than the number of available slots.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:254,Usability,guid,guide,254,"It seems to work now (the failing test is unrelated). I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:549,Usability,guid,guide,549,"It seems to work now (the failing test is unrelated). I will briefly summarize what I found out and changed. Setting up and using an MPI environment is surprisingly difficult, and I don't think it is in the scope of qutip to try and make that easier, or guide users to do that. The philosophy here is, if the user can get the `mpi4py.futures.MPIPoolExecutor` to work, then they can also use `mpi_pmap` in qutip. However, I did show in the tutorial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432:2135,Usability,clear,clear,2135,"torial notebook explicitly as an example how it works on the RIKEN cluster, and I refer to the mpi4py users guide. That being said, we do want to set up an automated test for this, and we do want to understand what went wrong in our initial attempts to set up those tests. The two main problems we encountered were (a) if mpi4py is installed with pip, all mpi_pmap calls hang; (b) if it is installed with conda, test_map_pass_error hangs sometimes.; The difference between pip and conda comes from the fact that mpi4py requires an MPI implementation. If we use mpi4py's GH workflow to install it with pip, it installs MPICH, and with conda, it installs OpenMPI by default. I noticed that in both cases where mpi_pmap hangs, there *are* error messages, but they are captured by pytest and then never printed because the program hangs... Regarding problem (a), in short, it looks like an MPICH bug to me. I thus decided to use OpenMPI instead, and added `conda install ""openmpi<5"" mpi4py` to just one of our test runs (the python 3.12 one). Regarding problem (b), the problem was that we requested more processes than the default number of slots available. With OpenMPI, the default number of slots available is the number of physical cpu cores (which seems to be 2 on the machine running our tests, leaving only one slot for a worker process). In the `parallel` module, if num_cpus is not provided, it defaults to `available_cpu_count()` (which is 4 on this machine, since there are 4 logical cpus). We could try to find a better default value for num_cpus for mpi_pmap, but I feel like writing that well would require deeper MPI knowledge than I have. What I did instead is, I tried to make it clear in the documentation that the default value might be unsuitable for MPI applications, and I emit a warning if the default value is used. At the same time, I set `OMPI_MCA_rmaps_base_oversubscribe=true` in the test run, which allows OpenMPI to create more processes than the number of available slots.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1923102432
https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503:231,Modifiability,plugin,plugin,231,"The stochastic solver are not thought for a lot of noise operators.; In v4, operations are all `CSR @ Dense_1D_array`.; In v5, you have more control on which storage is used for each operators, we support dense, csr, dia format (+ plugin for cupy, jax, tensor network in development.). But I fail to see how you can use sparsity for speed it up in this case in particular.; Could you write the equations / logic of the optimization here?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503
https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503:419,Performance,optimiz,optimization,419,"The stochastic solver are not thought for a lot of noise operators.; In v4, operations are all `CSR @ Dense_1D_array`.; In v5, you have more control on which storage is used for each operators, we support dense, csr, dia format (+ plugin for cupy, jax, tensor network in development.). But I fail to see how you can use sparsity for speed it up in this case in particular.; Could you write the equations / logic of the optimization here?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503
https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503:406,Testability,log,logic,406,"The stochastic solver are not thought for a lot of noise operators.; In v4, operations are all `CSR @ Dense_1D_array`.; In v5, you have more control on which storage is used for each operators, we support dense, csr, dia format (+ plugin for cupy, jax, tensor network in development.). But I fail to see how you can use sparsity for speed it up in this case in particular.; Could you write the equations / logic of the optimization here?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503
https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811:179,Energy Efficiency,allocate,allocate,179,"We don't use the same code for the sparse addition as in `v4`. v5 sparse addition is quite faster. But I expect it to be slower for 100 additions of 50 elements since you need to allocate memory for the 100 intermediate results, while for 1 addition with 5000 elements, there is only one memory allocation. But if you want to have a go at optimizing our basic operations, we will welcome any improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811
https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811:339,Performance,optimiz,optimizing,339,"We don't use the same code for the sparse addition as in `v4`. v5 sparse addition is quite faster. But I expect it to be slower for 100 additions of 50 elements since you need to allocate memory for the 100 intermediate results, while for 1 addition with 5000 elements, there is only one memory allocation. But if you want to have a go at optimizing our basic operations, we will welcome any improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811
https://github.com/qutip/qutip/issues/2298#issuecomment-1904583250:332,Performance,perform,performance,332,Ok so as I read it currently there is no iadd_ function for CSR matrices. Am I also right that there is no add_ operation for Dense + CSR? How does the current code deal with adding a Dense to a CSR matrix (I'm looking in `core/data/add.pyx`). I think replacing add_ with iadd and making a specialised iadd impl should help improve performance a lot.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904583250
https://github.com/qutip/qutip/issues/2298#issuecomment-1904621660:309,Energy Efficiency,allocate,allocate,309,"It will convert the `CSR` to `Dense` then use `add_dense`. `iadd` for sparse is not easy. When none-zero entry are not lining up, the array need to be expanded.; Also if the values cancel themselves, there is a need to remove an entry and more the others to fill the gap... Also our dispatcher, the code that allocate `add(Data, Data)` to each specialization `add_dense`, `add_sparse`, does not support inplace operation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904621660
https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589:412,Performance,perform,performance,412,"@Ericgig I'm just attempting some profiling with `cProfile` to make sure I'm optimising the right thing - do you know the best way to get it to work with the cython code. I've tried setting; ```; #cython: linetrace=True, profile=True, binding=True; #distutils: define_macros=CYTHON_TRACE_NOGIL=1; ```; But it doesn't appear to work.; When I use `pyinstrument` it appears that `_expect_csr_dense_ket` is the main performance bottleneck. This is probably because the function must iterate over all rows, even though most are empty. I think a COO format would be more suitable in this case - would you accept it if I added this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589
https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589:424,Performance,bottleneck,bottleneck,424,"@Ericgig I'm just attempting some profiling with `cProfile` to make sure I'm optimising the right thing - do you know the best way to get it to work with the cython code. I've tried setting; ```; #cython: linetrace=True, profile=True, binding=True; #distutils: define_macros=CYTHON_TRACE_NOGIL=1; ```; But it doesn't appear to work.; When I use `pyinstrument` it appears that `_expect_csr_dense_ket` is the main performance bottleneck. This is probably because the function must iterate over all rows, even though most are empty. I think a COO format would be more suitable in this case - would you accept it if I added this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589
https://github.com/qutip/qutip/issues/2298#issuecomment-1906400206:430,Testability,benchmark,benchmark,430,"It will be a lot of work to add a COO format, there are a few dozens of functions to implement (add, expect, mul, matmul, ptrace, eigen, kron, ...). We had students write new data formats over a summer for GSoC a few years ago and they were mostly working by the end, but not final... . Yes profiling cython is not easy, I managed once, but can't do it anymore.; Now I usually write multiple implementations of the same function, benchmark them and increment until I feel it's good enough.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1906400206
https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523:144,Availability,error,error,144,"About only storing kets, but not averaging into a dm, we can't do that yet, but it's easy to implement so if useful, we can add the option. The error is not in the `_to_dm`, but in the addition, which is done in the sparse CSR format. No dense conversion are made. But the `proj` operator does not have a tidyup step, so any non-zero are kept, however small they are. This is also an easy fix that could help. The `MemoryError` is also not that helpful, we should improve the error message to tell what size of arrays are allocated. Thank you for reporting these and trying the alpha version. I see you don't have cython, do you have a way to compile the source yourself? ; Once fixed, I would be curious to have you try the development version without waiting for a release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523
https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523:476,Availability,error,error,476,"About only storing kets, but not averaging into a dm, we can't do that yet, but it's easy to implement so if useful, we can add the option. The error is not in the `_to_dm`, but in the addition, which is done in the sparse CSR format. No dense conversion are made. But the `proj` operator does not have a tidyup step, so any non-zero are kept, however small they are. This is also an easy fix that could help. The `MemoryError` is also not that helpful, we should improve the error message to tell what size of arrays are allocated. Thank you for reporting these and trying the alpha version. I see you don't have cython, do you have a way to compile the source yourself? ; Once fixed, I would be curious to have you try the development version without waiting for a release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523
https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523:767,Deployability,release,release,767,"About only storing kets, but not averaging into a dm, we can't do that yet, but it's easy to implement so if useful, we can add the option. The error is not in the `_to_dm`, but in the addition, which is done in the sparse CSR format. No dense conversion are made. But the `proj` operator does not have a tidyup step, so any non-zero are kept, however small they are. This is also an easy fix that could help. The `MemoryError` is also not that helpful, we should improve the error message to tell what size of arrays are allocated. Thank you for reporting these and trying the alpha version. I see you don't have cython, do you have a way to compile the source yourself? ; Once fixed, I would be curious to have you try the development version without waiting for a release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523
https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523:522,Energy Efficiency,allocate,allocated,522,"About only storing kets, but not averaging into a dm, we can't do that yet, but it's easy to implement so if useful, we can add the option. The error is not in the `_to_dm`, but in the addition, which is done in the sparse CSR format. No dense conversion are made. But the `proj` operator does not have a tidyup step, so any non-zero are kept, however small they are. This is also an easy fix that could help. The `MemoryError` is also not that helpful, we should improve the error message to tell what size of arrays are allocated. Thank you for reporting these and trying the alpha version. I see you don't have cython, do you have a way to compile the source yourself? ; Once fixed, I would be curious to have you try the development version without waiting for a release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523
https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523:482,Integrability,message,message,482,"About only storing kets, but not averaging into a dm, we can't do that yet, but it's easy to implement so if useful, we can add the option. The error is not in the `_to_dm`, but in the addition, which is done in the sparse CSR format. No dense conversion are made. But the `proj` operator does not have a tidyup step, so any non-zero are kept, however small they are. This is also an easy fix that could help. The `MemoryError` is also not that helpful, we should improve the error message to tell what size of arrays are allocated. Thank you for reporting these and trying the alpha version. I see you don't have cython, do you have a way to compile the source yourself? ; Once fixed, I would be curious to have you try the development version without waiting for a release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2299#issuecomment-1904338523
https://github.com/qutip/qutip/issues/2299#issuecomment-1904394637:56,Deployability,install,installed,56,"Thanks for the quick response - currently I've just pip-installed the package, but I would be happy to use the main branch if you would be able to fix this. I would find this very useful - for the quantities I am interested in calculating I need much less than 800 repeats to get convergence. I understand it is possible to calculate the expectation directly in ssesolve but I find it is useful to save the states to a file so I have more freedom to calculate a range of different operators at a later date.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2299#issuecomment-1904394637
https://github.com/qutip/qutip/issues/2300#issuecomment-1906274768:213,Deployability,release,release,213,"The deprecation warning from `scipy==1.11` reads; `DeprecationWarning: scipy.array is deprecated and will be removed in SciPy 2.0.0, use numpy.array instead`. However, clearly this functionality broke before that release; with some discussion here: ; - https://github.com/scipy/scipy/issues/19065#issuecomment-1678439743; - https://github.com/scipy/scipy/pull/19067",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2300#issuecomment-1906274768
https://github.com/qutip/qutip/issues/2300#issuecomment-1906274768:168,Usability,clear,clearly,168,"The deprecation warning from `scipy==1.11` reads; `DeprecationWarning: scipy.array is deprecated and will be removed in SciPy 2.0.0, use numpy.array instead`. However, clearly this functionality broke before that release; with some discussion here: ; - https://github.com/scipy/scipy/issues/19065#issuecomment-1678439743; - https://github.com/scipy/scipy/pull/19067",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2300#issuecomment-1906274768
https://github.com/qutip/qutip/issues/2300#issuecomment-1906351746:232,Deployability,release,releases,232,"This commit, [1315742](https://github.com/qutip/qutip/commit/1315742843dd27a6505ef70b539fbcb4882a53f0), already has removed `from scipy import array` from `parallel.py`. But it appears this commit is not included in the most recent releases of 4.7.X. Edit:; The problem lies on this branch here: https://github.com/qutip/qutip/blob/qutip-4.7.X/qutip/parallel.py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2300#issuecomment-1906351746
https://github.com/qutip/qutip/issues/2300#issuecomment-1969569908:31,Deployability,release,release,31,Should be fixed with the 4.7.5 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2300#issuecomment-1969569908
https://github.com/qutip/qutip/pull/2303#issuecomment-1906570023:134,Availability,avail,available,134,"> Thank you for looking at this.; > ; > `store_state` should still be the final factor whether states are stored or not. It's the one available everywhere and for v4. `mesolve` with `store_state` will have `result.states` being the output density matrix. `mcsolve` with the same `store_state` and default options should return a similar result.; > ; > So it would be better to have the new option be `precompute_average_states` and have it only control if the average is compute when all trajectories is stored. The if the `average_states` property it use, it could compute the average then, but never do so if not used.; > ; > Please keep `result.states` and `result.final_states` as is. They have the same behaviour as in v4 and we want to keep them for backward compatibility.; > ; > `runs_...` and `average_...` are new to v5 and could be renamed, but it's not clear that `density_matricies` is the average while `final_states` are for each trajectories. `smesolve` and sometime for `mcsolve` individual trajectories states are already density matrices. Thus `smesolve`'s result density_matricies could work as well for all states from all trajectories, causing confusion.; > ; > You implemented the `density_matricies` property twice.; > ; > Having the options to keep only the final states without keeping all the trajectories is a good idea. Be careful that the trajectory result have the final state stored. So I'm not entirely sure what you want the behaviour to be for each set of options. I think it is confusing to return a density matrix if you request store_states - the density matrix is not the same as the state of the system, and surely v5 is the perfect time to clear up issues like this. Personally I found this behaviour very surprising when updating to V5. I do agree that `density_matricies` should maybe be `average_density_matricies`. I am happy to change `mesolve` as part of this for consistency. If you want to keep it backwards compatible would it be possible to send a li",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2303#issuecomment-1906570023
https://github.com/qutip/qutip/pull/2303#issuecomment-1906570023:865,Usability,clear,clear,865,"> Thank you for looking at this.; > ; > `store_state` should still be the final factor whether states are stored or not. It's the one available everywhere and for v4. `mesolve` with `store_state` will have `result.states` being the output density matrix. `mcsolve` with the same `store_state` and default options should return a similar result.; > ; > So it would be better to have the new option be `precompute_average_states` and have it only control if the average is compute when all trajectories is stored. The if the `average_states` property it use, it could compute the average then, but never do so if not used.; > ; > Please keep `result.states` and `result.final_states` as is. They have the same behaviour as in v4 and we want to keep them for backward compatibility.; > ; > `runs_...` and `average_...` are new to v5 and could be renamed, but it's not clear that `density_matricies` is the average while `final_states` are for each trajectories. `smesolve` and sometime for `mcsolve` individual trajectories states are already density matrices. Thus `smesolve`'s result density_matricies could work as well for all states from all trajectories, causing confusion.; > ; > You implemented the `density_matricies` property twice.; > ; > Having the options to keep only the final states without keeping all the trajectories is a good idea. Be careful that the trajectory result have the final state stored. So I'm not entirely sure what you want the behaviour to be for each set of options. I think it is confusing to return a density matrix if you request store_states - the density matrix is not the same as the state of the system, and surely v5 is the perfect time to clear up issues like this. Personally I found this behaviour very surprising when updating to V5. I do agree that `density_matricies` should maybe be `average_density_matricies`. I am happy to change `mesolve` as part of this for consistency. If you want to keep it backwards compatible would it be possible to send a li",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2303#issuecomment-1906570023
https://github.com/qutip/qutip/pull/2303#issuecomment-1906570023:1681,Usability,clear,clear,1681,"e one available everywhere and for v4. `mesolve` with `store_state` will have `result.states` being the output density matrix. `mcsolve` with the same `store_state` and default options should return a similar result.; > ; > So it would be better to have the new option be `precompute_average_states` and have it only control if the average is compute when all trajectories is stored. The if the `average_states` property it use, it could compute the average then, but never do so if not used.; > ; > Please keep `result.states` and `result.final_states` as is. They have the same behaviour as in v4 and we want to keep them for backward compatibility.; > ; > `runs_...` and `average_...` are new to v5 and could be renamed, but it's not clear that `density_matricies` is the average while `final_states` are for each trajectories. `smesolve` and sometime for `mcsolve` individual trajectories states are already density matrices. Thus `smesolve`'s result density_matricies could work as well for all states from all trajectories, causing confusion.; > ; > You implemented the `density_matricies` property twice.; > ; > Having the options to keep only the final states without keeping all the trajectories is a good idea. Be careful that the trajectory result have the final state stored. So I'm not entirely sure what you want the behaviour to be for each set of options. I think it is confusing to return a density matrix if you request store_states - the density matrix is not the same as the state of the system, and surely v5 is the perfect time to clear up issues like this. Personally I found this behaviour very surprising when updating to V5. I do agree that `density_matricies` should maybe be `average_density_matricies`. I am happy to change `mesolve` as part of this for consistency. If you want to keep it backwards compatible would it be possible to send a list of all combination of options and exactly what you want `states` to return in each case, just to prevent any back and forth.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2303#issuecomment-1906570023
https://github.com/qutip/qutip/pull/2303#issuecomment-1916236148:13,Deployability,update,updates,13,@Ericgig any updates on this? Also can you enable CI?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2303#issuecomment-1916236148
https://github.com/qutip/qutip/pull/2303#issuecomment-1925702584:35,Testability,test,tests,35,"@Ericgig Should now be passing all tests, and essentially be ready",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2303#issuecomment-1925702584
https://github.com/qutip/qutip/pull/2304#issuecomment-1908803360:12,Testability,test,test,12,"The failing test are related to #2301 not being merged in yet. I am not sure we want tests for this.; We have no control on the memory of the runner, which could change at any time.; There could be strange thing with virtual memory, swap, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2304#issuecomment-1908803360
https://github.com/qutip/qutip/pull/2304#issuecomment-1908803360:85,Testability,test,tests,85,"The failing test are related to #2301 not being merged in yet. I am not sure we want tests for this.; We have no control on the memory of the runner, which could change at any time.; There could be strange thing with virtual memory, swap, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2304#issuecomment-1908803360
https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742:77,Availability,error,error,77,Agreed that it is tricky to test. I mostly wanted the tests because the nice error messages might contain bugs. Happy to let this slide for now though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742
https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742:83,Integrability,message,messages,83,Agreed that it is tricky to test. I mostly wanted the tests because the nice error messages might contain bugs. Happy to let this slide for now though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742
https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742:28,Testability,test,test,28,Agreed that it is tricky to test. I mostly wanted the tests because the nice error messages might contain bugs. Happy to let this slide for now though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742
https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742:54,Testability,test,tests,54,Agreed that it is tricky to test. I mostly wanted the tests because the nice error messages might contain bugs. Happy to let this slide for now though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742
https://github.com/qutip/qutip/pull/2305#issuecomment-1908552067:89,Usability,clear,clear,89,"> There are other issues with scipy 1.12 for v4 in steadystate. . At a glance, it is not clear to me where the issues are. I confirmed that each `scipy` function used by `steadystate.py` exists and is successfully imported.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2305#issuecomment-1908552067
https://github.com/qutip/qutip/pull/2305#issuecomment-1908577398:97,Availability,error,errors,97,"The issue is not with import, but deprecation warnings. ; For our tests, warnings are considered errors.; This is why the tests using scipy 1.12 are still failing.; We will fix this on our side. Thank you again for your contribution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2305#issuecomment-1908577398
https://github.com/qutip/qutip/pull/2305#issuecomment-1908577398:66,Testability,test,tests,66,"The issue is not with import, but deprecation warnings. ; For our tests, warnings are considered errors.; This is why the tests using scipy 1.12 are still failing.; We will fix this on our side. Thank you again for your contribution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2305#issuecomment-1908577398
https://github.com/qutip/qutip/pull/2305#issuecomment-1908577398:122,Testability,test,tests,122,"The issue is not with import, but deprecation warnings. ; For our tests, warnings are considered errors.; This is why the tests using scipy 1.12 are still failing.; We will fix this on our side. Thank you again for your contribution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2305#issuecomment-1908577398
https://github.com/qutip/qutip/pull/2308#issuecomment-1911002664:189,Deployability,release,release,189,"@DnMGalan ; Thank you for contributing. Please write a towncrier entry. It's not about how small or large the issue, but a reminder for us to thank you for your contribution when doing the release. I don't think any one opened an issue about the problem with the 'l' style, but we would be grateful if you fixed it. ; You don't need to open a issue for it. You can solve it here or in another PR at your convenience.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1911002664
https://github.com/qutip/qutip/pull/2308#issuecomment-1911930396:97,Availability,error,error,97,"Hi @Ericgig, thank you for your feedback. I have already implemented the changes. To correct the error when plotting points with style 'l' I have made the script only sort the points when styles 'm' and 's' are specified as it was in V4.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1911930396
https://github.com/qutip/qutip/pull/2308#issuecomment-1911930396:32,Usability,feedback,feedback,32,"Hi @Ericgig, thank you for your feedback. I have already implemented the changes. To correct the error when plotting points with style 'l' I have made the script only sort the points when styles 'm' and 's' are specified as it was in V4.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1911930396
https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1661,Availability,error,error,1661,"ttps://github.com/qutip/qutip/assets/78165605/1c6f0d5b-080f-49e2-98f7-8ead19ef739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qut",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617
https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:534,Modifiability,variab,variables,534,"Sure! Here are the plots before the changes using the code posted in issue #1974. The bug we wanted to fix is that when choosing style 'm' and passing an array of colors as we did in V4, the scrip only plots one color, (additionally, i also plot one case with style 'l'):. ![M_self_test_old](https://github.com/qutip/qutip/assets/78165605/c0ed44c7-74d1-47f3-8787-254e4d6806d5) ![L_self_old](https://github.com/qutip/qutip/assets/78165605/66cfdb8c-18d2-45d9-a64e-97a28f72e10f). And these are the same plots after the changes using the variables `inner_point_color` (left graph) and `point_color` (right graph). As we can see for both variables we get the same result which is what we expected:. <img src=https://github.com/qutip/qutip/assets/78165605/1c6f0d5b-080f-49e2-98f7-8ead19ef739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/as",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617
https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:633,Modifiability,variab,variables,633,"Sure! Here are the plots before the changes using the code posted in issue #1974. The bug we wanted to fix is that when choosing style 'm' and passing an array of colors as we did in V4, the scrip only plots one color, (additionally, i also plot one case with style 'l'):. ![M_self_test_old](https://github.com/qutip/qutip/assets/78165605/c0ed44c7-74d1-47f3-8787-254e4d6806d5) ![L_self_old](https://github.com/qutip/qutip/assets/78165605/66cfdb8c-18d2-45d9-a64e-97a28f72e10f). And these are the same plots after the changes using the variables `inner_point_color` (left graph) and `point_color` (right graph). As we can see for both variables we get the same result which is what we expected:. <img src=https://github.com/qutip/qutip/assets/78165605/1c6f0d5b-080f-49e2-98f7-8ead19ef739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/as",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617
https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1904,Modifiability,variab,variables,1904,"739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/83c8cac0-f12e-4af4-96df-4be972b485d4 width=30% height=30%>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617
https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1947,Modifiability,variab,variable,1947,"739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/83c8cac0-f12e-4af4-96df-4be972b485d4 width=30% height=30%>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617
https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1643,Testability,test,tests,1643,"ttps://github.com/qutip/qutip/assets/78165605/1c6f0d5b-080f-49e2-98f7-8ead19ef739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qut",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617
https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1818,Testability,test,tests,1818,"739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/83c8cac0-f12e-4af4-96df-4be972b485d4 width=30% height=30%>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617
https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672:624,Availability,error,error,624,"- I agree that renaming the _inner_point_color variable is a good idea. - The case you mention of black point_color with style 'l' also occurs in V4 and is solved by defining the variable as a list, e.g., ['black'] (which also works with the changes I proposed). So basically I assumed it was an expected use case. - I asked this question about style 's' plotting two colors in issue #1974, since we are given the same colors for style 's' and 'm', and Neil suggested leaving it as is. The docstring in the add_points function already tells you to give a single color for style 's' and a list of colors for style 'm'. - The error you get using style 'm' with two colors is that you need to specify a color for each point (you have to pass to the function a list of colors of the same length as the length of the points). In view of this, I don't know which approach you prefer to apply, as it depends on the expected use case. Given that the code works, perhaps the priority would be to specify the expected use while defining as part of issue #1913 the modifications you consider appropriate (although maybe someone will catch it earlier if you define it as a new issue).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672
https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672:893,Integrability,depend,depends,893,"- I agree that renaming the _inner_point_color variable is a good idea. - The case you mention of black point_color with style 'l' also occurs in V4 and is solved by defining the variable as a list, e.g., ['black'] (which also works with the changes I proposed). So basically I assumed it was an expected use case. - I asked this question about style 's' plotting two colors in issue #1974, since we are given the same colors for style 's' and 'm', and Neil suggested leaving it as is. The docstring in the add_points function already tells you to give a single color for style 's' and a list of colors for style 'm'. - The error you get using style 'm' with two colors is that you need to specify a color for each point (you have to pass to the function a list of colors of the same length as the length of the points). In view of this, I don't know which approach you prefer to apply, as it depends on the expected use case. Given that the code works, perhaps the priority would be to specify the expected use while defining as part of issue #1913 the modifications you consider appropriate (although maybe someone will catch it earlier if you define it as a new issue).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672
https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672:47,Modifiability,variab,variable,47,"- I agree that renaming the _inner_point_color variable is a good idea. - The case you mention of black point_color with style 'l' also occurs in V4 and is solved by defining the variable as a list, e.g., ['black'] (which also works with the changes I proposed). So basically I assumed it was an expected use case. - I asked this question about style 's' plotting two colors in issue #1974, since we are given the same colors for style 's' and 'm', and Neil suggested leaving it as is. The docstring in the add_points function already tells you to give a single color for style 's' and a list of colors for style 'm'. - The error you get using style 'm' with two colors is that you need to specify a color for each point (you have to pass to the function a list of colors of the same length as the length of the points). In view of this, I don't know which approach you prefer to apply, as it depends on the expected use case. Given that the code works, perhaps the priority would be to specify the expected use while defining as part of issue #1913 the modifications you consider appropriate (although maybe someone will catch it earlier if you define it as a new issue).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672
https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672:179,Modifiability,variab,variable,179,"- I agree that renaming the _inner_point_color variable is a good idea. - The case you mention of black point_color with style 'l' also occurs in V4 and is solved by defining the variable as a list, e.g., ['black'] (which also works with the changes I proposed). So basically I assumed it was an expected use case. - I asked this question about style 's' plotting two colors in issue #1974, since we are given the same colors for style 's' and 'm', and Neil suggested leaving it as is. The docstring in the add_points function already tells you to give a single color for style 's' and a list of colors for style 'm'. - The error you get using style 'm' with two colors is that you need to specify a color for each point (you have to pass to the function a list of colors of the same length as the length of the points). In view of this, I don't know which approach you prefer to apply, as it depends on the expected use case. Given that the code works, perhaps the priority would be to specify the expected use while defining as part of issue #1913 the modifications you consider appropriate (although maybe someone will catch it earlier if you define it as a new issue).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672
https://github.com/qutip/qutip/pull/2310#issuecomment-1915073450:217,Deployability,release,release-,217,[![Coverage Status](https://coveralls.io/builds/65358635/badge)](https://coveralls.io/builds/65358635). coverage: 70.442%. remained the same; when pulling **c540878f3be02e5285af1162d535808f39f6a54c on Ericgig:prepare-release-4.7.5**; into **e4ba3bd12055d66515955435075a8e14a920764f on qutip:qutip-4.7.X**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2310#issuecomment-1915073450
https://github.com/qutip/qutip/pull/2314#issuecomment-1942727858:287,Availability,ping,ping,287,"It's fine to not split the PR in too many chunks.; Yes it's easier to review, but I don't want to have it half implemented/merged at release, which is coming soon.; You could just add `kron` here. The other can be implemented using matmul and can wait. It's fine to take some time. Just ping me when you want a re-review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2314#issuecomment-1942727858
https://github.com/qutip/qutip/pull/2314#issuecomment-1942727858:133,Deployability,release,release,133,"It's fine to not split the PR in too many chunks.; Yes it's easier to review, but I don't want to have it half implemented/merged at release, which is coming soon.; You could just add `kron` here. The other can be implemented using matmul and can wait. It's fine to take some time. Just ping me when you want a re-review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2314#issuecomment-1942727858
https://github.com/qutip/qutip/pull/2314#issuecomment-1946129803:41,Availability,error,error,41,Either `nnz` return `size_t` or raise an error when allocating matrix with too many elements.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2314#issuecomment-1946129803
https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043:417,Modifiability,variab,variable,417,"Thank you for the suggestions. (2) It should be easy. We could reuse the `parallel_map` as you said. I would make a good first contribution. . (1) We need to be careful about this. ; I can see case where the user think the correlation is gone by `tlist[-1]` but it is not, so it should be clear which output are `0` and which are not computed.; Also if we do that, maybe finer control could be given. We could have a variable `max_t_plus_tau` with default `np.inf`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043
https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043:289,Usability,clear,clear,289,"Thank you for the suggestions. (2) It should be easy. We could reuse the `parallel_map` as you said. I would make a good first contribution. . (1) We need to be careful about this. ; I can see case where the user think the correlation is gone by `tlist[-1]` but it is not, so it should be clear which output are `0` and which are not computed.; Also if we do that, maybe finer control could be given. We could have a variable `max_t_plus_tau` with default `np.inf`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043
https://github.com/qutip/qutip/issues/2316#issuecomment-1927803355:23,Testability,test,test,23,on aarch64 linux? same test passes on x64 linux and x64 / aarch64 darwin.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2316#issuecomment-1927803355
https://github.com/qutip/qutip/issues/2316#issuecomment-1928064297:60,Testability,test,test,60,"On x64, I had arch Linux in mind... I don't have a setup to test on aarch64, nor ever tried to emulate it. ; It may take some time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2316#issuecomment-1928064297
https://github.com/qutip/qutip/pull/2319#issuecomment-1930820031:208,Availability,avail,available,208,"As long as we do some test runs without MPI, I think this is fine. Perhaps we could also document somewhere that `mpi` is needed -- maybe just by raising a nice exception if it needs to be imported but isn't available?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2319#issuecomment-1930820031
https://github.com/qutip/qutip/pull/2319#issuecomment-1930820031:22,Testability,test,test,22,"As long as we do some test runs without MPI, I think this is fine. Perhaps we could also document somewhere that `mpi` is needed -- maybe just by raising a nice exception if it needs to be imported but isn't available?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2319#issuecomment-1930820031
https://github.com/qutip/qutip/pull/2319#issuecomment-1930838671:8,Testability,test,test,8,"We have test cases both with and without `mpi4py`.; I believe trying to use `mpi_pmap` without `mpi4py`, it will raise the default `ImportError`. ; @pmenczel can confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2319#issuecomment-1930838671
https://github.com/qutip/qutip/issues/2320#issuecomment-1932348944:521,Deployability,release,release,521,"It's in development. ; If you use qutip v5.0.0a2 on pypi or master branch here with [qutip-jax](https://github.com/qutip/qutip-jax), some solver can work on gpu. (We tested `sesolve` and `mesolve`, mcsolve should work, stochastic, HOEM, brmesolve don't.); The readthedocs of qutip-jax shows how to use it. qutip-jax is not up to date with the latest versions.; If you are interested in trying it, I will make it works with the latest jax version and qutip master.; Any and all feedback appreciated. We expect an official release of these features in March.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1932348944
https://github.com/qutip/qutip/issues/2320#issuecomment-1932348944:166,Testability,test,tested,166,"It's in development. ; If you use qutip v5.0.0a2 on pypi or master branch here with [qutip-jax](https://github.com/qutip/qutip-jax), some solver can work on gpu. (We tested `sesolve` and `mesolve`, mcsolve should work, stochastic, HOEM, brmesolve don't.); The readthedocs of qutip-jax shows how to use it. qutip-jax is not up to date with the latest versions.; If you are interested in trying it, I will make it works with the latest jax version and qutip master.; Any and all feedback appreciated. We expect an official release of these features in March.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1932348944
https://github.com/qutip/qutip/issues/2320#issuecomment-1932348944:477,Usability,feedback,feedback,477,"It's in development. ; If you use qutip v5.0.0a2 on pypi or master branch here with [qutip-jax](https://github.com/qutip/qutip-jax), some solver can work on gpu. (We tested `sesolve` and `mesolve`, mcsolve should work, stochastic, HOEM, brmesolve don't.); The readthedocs of qutip-jax shows how to use it. qutip-jax is not up to date with the latest versions.; If you are interested in trying it, I will make it works with the latest jax version and qutip master.; Any and all feedback appreciated. We expect an official release of these features in March.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1932348944
https://github.com/qutip/qutip/issues/2320#issuecomment-1933954768:63,Deployability,release,release,63,Thank you! I'll try qutip-jax. Looking forward to the official release!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1933954768
https://github.com/qutip/qutip/issues/2320#issuecomment-1938640761:11,Usability,simpl,simplest,11,Is there a simplest case I can run the `mesovle` on Linux with Nvidia GPU?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1938640761
https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917:474,Availability,down,download,474,"Just to add, I tried to benchmark Eric's jax data layer a bit more with an Ising model, the example is at the end of this colab notebook we made for a tutorial talk, which shows some crossover in performance at certain system sizes: https://colab.research.google.com/drive/1RcgX7oEzGjzPAF8Ryus54Q5UmyMddmLA?usp=sharing. ![benchmark](https://github.com/qutip/qutip/assets/5094429/15d2dfaa-b269-44f7-8334-878b8e2c5910). Note colab does not have free GPUs, so you will have to download and use it locally. also in the actual ising example, replace ; `with jax.default_device(jax.devices(""cpu"")[0]):` ; with; `with jax.default_device(jax.devices(""gpu"")[0]):`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917
https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917:196,Performance,perform,performance,196,"Just to add, I tried to benchmark Eric's jax data layer a bit more with an Ising model, the example is at the end of this colab notebook we made for a tutorial talk, which shows some crossover in performance at certain system sizes: https://colab.research.google.com/drive/1RcgX7oEzGjzPAF8Ryus54Q5UmyMddmLA?usp=sharing. ![benchmark](https://github.com/qutip/qutip/assets/5094429/15d2dfaa-b269-44f7-8334-878b8e2c5910). Note colab does not have free GPUs, so you will have to download and use it locally. also in the actual ising example, replace ; `with jax.default_device(jax.devices(""cpu"")[0]):` ; with; `with jax.default_device(jax.devices(""gpu"")[0]):`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917
https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917:24,Testability,benchmark,benchmark,24,"Just to add, I tried to benchmark Eric's jax data layer a bit more with an Ising model, the example is at the end of this colab notebook we made for a tutorial talk, which shows some crossover in performance at certain system sizes: https://colab.research.google.com/drive/1RcgX7oEzGjzPAF8Ryus54Q5UmyMddmLA?usp=sharing. ![benchmark](https://github.com/qutip/qutip/assets/5094429/15d2dfaa-b269-44f7-8334-878b8e2c5910). Note colab does not have free GPUs, so you will have to download and use it locally. also in the actual ising example, replace ; `with jax.default_device(jax.devices(""cpu"")[0]):` ; with; `with jax.default_device(jax.devices(""gpu"")[0]):`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917
https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917:322,Testability,benchmark,benchmark,322,"Just to add, I tried to benchmark Eric's jax data layer a bit more with an Ising model, the example is at the end of this colab notebook we made for a tutorial talk, which shows some crossover in performance at certain system sizes: https://colab.research.google.com/drive/1RcgX7oEzGjzPAF8Ryus54Q5UmyMddmLA?usp=sharing. ![benchmark](https://github.com/qutip/qutip/assets/5094429/15d2dfaa-b269-44f7-8334-878b8e2c5910). Note colab does not have free GPUs, so you will have to download and use it locally. also in the actual ising example, replace ; `with jax.default_device(jax.devices(""cpu"")[0]):` ; with; `with jax.default_device(jax.devices(""gpu"")[0]):`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917
https://github.com/qutip/qutip/issues/2320#issuecomment-2090460880:209,Testability,test,testing,209,"It should not affect the results of simulations. The diffrax package does not interact with complex number directly when used through qutip-jax. Gradient or other derivatives could be affected, this need more testing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2090460880
https://github.com/qutip/qutip/issues/2320#issuecomment-2090630204:373,Availability,error,error,373,"Thanks. I come across another problem when I try to run the following codes on a L4 GPU provided by google colab:; ```; import qutip; import qutip_jax. with qutip.CoreOptions(default_dtype=""jax""):; H = qutip.rand_herm(5); c_ops = [qutip.destroy(5)]; rho0 = qutip.basis(5, 4). result = qutip.mesolve(H, rho0, [0, 1], c_ops=c_ops, options={""method"": ""diffrax""}); ```; And an error will occur:; ```; JaxStackTraceBeforeTransformation: NotImplementedError: Schur decomposition is only implemented on the CPU backend. The preceding stack trace is the source of the JAX operation that, once transformed by JAX, triggered the following exception. --------------------. The above exception was the direct cause of the following exception:. NotImplementedError Traceback (most recent call last); [... skipping hidden 28 frame]. [/usr/local/lib/python3.10/site-packages/jax/_src/lax/linalg.py](https://localhost:8080/#) in _schur_lowering(ctx, *args, **kwargs); 2231 ; 2232 def _schur_lowering(ctx, *args, **kwargs):; -> 2233 raise NotImplementedError(; 2234 ""Schur decomposition is only implemented on the CPU backend.""); 2235 . NotImplementedError: Schur decomposition is only implemented on the CPU backend.; ```; So I assume the qutip-jax doesn't work with L4 GPU, right? What GPU or TPU can be used in this case?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2090630204
https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078:183,Deployability,integrat,integrator,183,"I don't know, since jax is developed by google I expect it to work well with gpus it provide through collab... We don't use schur decomposition for mesolve directly. I think it's the integrator from diffrax that does, if not it could be the norm (it's using trace norm which call sqrtm instead of trace, fixed in #2408). Maybe trying other ODE solver or not normalizing would work. Neill seems to have run most of his test using dopri:. ```; from diffrax import Dopri5, PIDController. options = {; ""method"": ""diffrax"",; ""normalize_output"": False,; ""stepsize_controller"" : PIDController(rtol=1e-8, atol=1e-6), # This is now the default.; ""solver"": Dopri5(),; }; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078
https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078:183,Integrability,integrat,integrator,183,"I don't know, since jax is developed by google I expect it to work well with gpus it provide through collab... We don't use schur decomposition for mesolve directly. I think it's the integrator from diffrax that does, if not it could be the norm (it's using trace norm which call sqrtm instead of trace, fixed in #2408). Maybe trying other ODE solver or not normalizing would work. Neill seems to have run most of his test using dopri:. ```; from diffrax import Dopri5, PIDController. options = {; ""method"": ""diffrax"",; ""normalize_output"": False,; ""stepsize_controller"" : PIDController(rtol=1e-8, atol=1e-6), # This is now the default.; ""solver"": Dopri5(),; }; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078
https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078:418,Testability,test,test,418,"I don't know, since jax is developed by google I expect it to work well with gpus it provide through collab... We don't use schur decomposition for mesolve directly. I think it's the integrator from diffrax that does, if not it could be the norm (it's using trace norm which call sqrtm instead of trace, fixed in #2408). Maybe trying other ODE solver or not normalizing would work. Neill seems to have run most of his test using dopri:. ```; from diffrax import Dopri5, PIDController. options = {; ""method"": ""diffrax"",; ""normalize_output"": False,; ""stepsize_controller"" : PIDController(rtol=1e-8, atol=1e-6), # This is now the default.; ""solver"": Dopri5(),; }; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078
https://github.com/qutip/qutip/issues/2320#issuecomment-2092884561:78,Integrability,depend,dependent,78,"Thank you!, it does work. But there is another problem regarding solving time-dependent Hamiltonian evolution in qutip-jax:; ```; import qutip as qt; import numpy as np; import qutip_jax; import jax; from math import pi; from diffrax import diffeqsolve, ODETerm, Dopri5, PIDController; sequence = np.linspace(0, 100, 100); wq = 2. * 2 * pi; g = 0.05 * 2 * pi. with qt.CoreOptions(default_dtype=""jaxdia""):; H0 = -0.5 * 2. * qt.sigmaz() + g * qt.sigmax(); H = [H0, [-0.5 * qt.sigmaz(), sequence]]; psi0 = qt.basis(2, 0); psi1 = qt.basis(2, 1); proj0 = psi0 @ psi0.dag(); proj1 = psi1 @ psi1.dag(); expect_ops = [proj1]; times = np.linspace(0, 100, 100); psi_init = psi1; options = {; ""method"": ""diffrax"", ; ""normalize_output"": False,; ""stepsize_controller"" : PIDController(rtol=1e-5, atol=1e-5),; ""solver"": Dopri5(); }; # result = mesolve(H, psi_init, times, e_ops=expect_ops); result = mesolve(H, psi_init, times, e_ops=expect_ops, options=options); ```; And this will give:; ```; TypeError Traceback (most recent call last); [<ipython-input-63-2fb6110bc952>](https://localhost:8080/#) in <cell line: 21>(); 19 }; 20 # result = mesolve(H, psi_init, times, e_ops=expect_ops); ---> 21 result = mesolve(H, psi_init, times, e_ops=expect_ops, options=options). 20 frames; [... skipping hidden 15 frame]. [... skipping hidden 1 frame]. [... skipping hidden 14 frame]. [... skipping hidden 1 frame]. [... skipping hidden 9 frame]. [... skipping hidden 2 frame]. [... skipping hidden 1 frame]. [... skipping hidden 1 frame]. [... skipping hidden 5 frame]. [/usr/local/lib/python3.10/site-packages/jax/_src/api_util.py](https://localhost:8080/#) in _shaped_abstractify_slow(x); 586 dtype = dtypes.canonicalize_dtype(x.dtype, allow_extended_dtype=True); 587 else:; --> 588 raise TypeError(; 589 f""Cannot interpret value of type {type(x)} as an abstract array; it ""; 590 ""does not have a dtype attribute""). TypeError: Cannot interpret value of type <class 'qutip.core.cy.coefficient.InterCoefficient'> as an abstr",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2092884561
https://github.com/qutip/qutip/issues/2320#issuecomment-2092884561:2104,Integrability,depend,dependent,2104,"``; import qutip as qt; import numpy as np; import qutip_jax; import jax; from math import pi; from diffrax import diffeqsolve, ODETerm, Dopri5, PIDController; sequence = np.linspace(0, 100, 100); wq = 2. * 2 * pi; g = 0.05 * 2 * pi. with qt.CoreOptions(default_dtype=""jaxdia""):; H0 = -0.5 * 2. * qt.sigmaz() + g * qt.sigmax(); H = [H0, [-0.5 * qt.sigmaz(), sequence]]; psi0 = qt.basis(2, 0); psi1 = qt.basis(2, 1); proj0 = psi0 @ psi0.dag(); proj1 = psi1 @ psi1.dag(); expect_ops = [proj1]; times = np.linspace(0, 100, 100); psi_init = psi1; options = {; ""method"": ""diffrax"", ; ""normalize_output"": False,; ""stepsize_controller"" : PIDController(rtol=1e-5, atol=1e-5),; ""solver"": Dopri5(); }; # result = mesolve(H, psi_init, times, e_ops=expect_ops); result = mesolve(H, psi_init, times, e_ops=expect_ops, options=options); ```; And this will give:; ```; TypeError Traceback (most recent call last); [<ipython-input-63-2fb6110bc952>](https://localhost:8080/#) in <cell line: 21>(); 19 }; 20 # result = mesolve(H, psi_init, times, e_ops=expect_ops); ---> 21 result = mesolve(H, psi_init, times, e_ops=expect_ops, options=options). 20 frames; [... skipping hidden 15 frame]. [... skipping hidden 1 frame]. [... skipping hidden 14 frame]. [... skipping hidden 1 frame]. [... skipping hidden 9 frame]. [... skipping hidden 2 frame]. [... skipping hidden 1 frame]. [... skipping hidden 1 frame]. [... skipping hidden 5 frame]. [/usr/local/lib/python3.10/site-packages/jax/_src/api_util.py](https://localhost:8080/#) in _shaped_abstractify_slow(x); 586 dtype = dtypes.canonicalize_dtype(x.dtype, allow_extended_dtype=True); 587 else:; --> 588 raise TypeError(; 589 f""Cannot interpret value of type {type(x)} as an abstract array; it ""; 590 ""does not have a dtype attribute""). TypeError: Cannot interpret value of type <class 'qutip.core.cy.coefficient.InterCoefficient'> as an abstract array; it does not have a dtype attribute; ```; Any other way we can solve the evolution with time-dependent Hamiltonian?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2092884561
https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208:297,Availability,avail,available,297,"I am not too familiar with poetry, but it seems to try to install Qutip from source. To build, you need cython with a working c++ compiler. Usually the c++ compiler is managed by the OS, not python, so you need to install is manually. My guess it that if you can tell poetry to use Qutip's wheels available on pypi instead of building from source, it should work. But if you need to build it from source, you will need to install Microsoft Visual C++ and do some setup. See https://cython.readthedocs.io/en/latest/src/quickstart/install.html. I am not sure if there is anything we can do on our side, but if we are missing something, feel free to tell us or make a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208
https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208:58,Deployability,install,install,58,"I am not too familiar with poetry, but it seems to try to install Qutip from source. To build, you need cython with a working c++ compiler. Usually the c++ compiler is managed by the OS, not python, so you need to install is manually. My guess it that if you can tell poetry to use Qutip's wheels available on pypi instead of building from source, it should work. But if you need to build it from source, you will need to install Microsoft Visual C++ and do some setup. See https://cython.readthedocs.io/en/latest/src/quickstart/install.html. I am not sure if there is anything we can do on our side, but if we are missing something, feel free to tell us or make a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208
https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208:214,Deployability,install,install,214,"I am not too familiar with poetry, but it seems to try to install Qutip from source. To build, you need cython with a working c++ compiler. Usually the c++ compiler is managed by the OS, not python, so you need to install is manually. My guess it that if you can tell poetry to use Qutip's wheels available on pypi instead of building from source, it should work. But if you need to build it from source, you will need to install Microsoft Visual C++ and do some setup. See https://cython.readthedocs.io/en/latest/src/quickstart/install.html. I am not sure if there is anything we can do on our side, but if we are missing something, feel free to tell us or make a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208
https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208:422,Deployability,install,install,422,"I am not too familiar with poetry, but it seems to try to install Qutip from source. To build, you need cython with a working c++ compiler. Usually the c++ compiler is managed by the OS, not python, so you need to install is manually. My guess it that if you can tell poetry to use Qutip's wheels available on pypi instead of building from source, it should work. But if you need to build it from source, you will need to install Microsoft Visual C++ and do some setup. See https://cython.readthedocs.io/en/latest/src/quickstart/install.html. I am not sure if there is anything we can do on our side, but if we are missing something, feel free to tell us or make a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208
https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208:529,Deployability,install,install,529,"I am not too familiar with poetry, but it seems to try to install Qutip from source. To build, you need cython with a working c++ compiler. Usually the c++ compiler is managed by the OS, not python, so you need to install is manually. My guess it that if you can tell poetry to use Qutip's wheels available on pypi instead of building from source, it should work. But if you need to build it from source, you will need to install Microsoft Visual C++ and do some setup. See https://cython.readthedocs.io/en/latest/src/quickstart/install.html. I am not sure if there is anything we can do on our side, but if we are missing something, feel free to tell us or make a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2322#issuecomment-1936053208
https://github.com/qutip/qutip/issues/2322#issuecomment-1948097986:5,Deployability,install,installing,5,"Yes, installing Microsoft visual C++ solved the problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2322#issuecomment-1948097986
https://github.com/qutip/qutip/pull/2325#issuecomment-1944589688:249,Performance,optimiz,optimized,249,"It would be hard to enforce since we accept functions returning `Qobj`.; If someone passed `dtype` in `args`, there is nothing we can do.; Also since the most common use case is `part @ state`, they don't interact much together and each part can be optimized for it's sparsity without issue. Mixed case are not that rare. Per default `sigmax` is `CSR` and `qeye` is `Dia` and I can't say what is `sigmax & qeye` without checking. So `QobjEvo([sigmax(), [qeye(2), f]])` mixes `CSR` and `Dia`.; How do we decide which one we quietly transform? Everything else just work with whatever type is used. So we can't have this raise an exception. Personally I think we should only mix in a family of dtypes, `Dense`, `Dia` and `CSR` can be mixed, but no mixing of jax with CSR, etc. But we don't have what we need to enforce it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2325#issuecomment-1944589688
https://github.com/qutip/qutip/issues/2326#issuecomment-1960288737:27,Availability,error,error,27,"This does not raise a type error for me in either qutip 4.7.X or qutip 5.0.0a.; ```python; >>> import qutip; >>> qutip.__version__; '4.7.3'; >>> x = qutip.sigmax(); >>> x += x; >>> x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 2.]; [2. 0.]]; ```; and; ```python; >>> import qutip; q>>> qutip.__version__; '5.0.0.dev0+ec33e6b'; >>> x = qutip.sigmax(); >>> x += x; >>> x; Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 2.]; [2. 0.]]; ```; Could you give a minimal reproducing example and the QuTiP version you're using?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2326#issuecomment-1960288737
https://github.com/qutip/qutip/issues/2326#issuecomment-1960290022:5,Availability,error,error,5,This error message suggests to me that one of the things you're trying to add might be a numpy array:; ```; TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None); ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2326#issuecomment-1960290022
https://github.com/qutip/qutip/issues/2326#issuecomment-1960290022:11,Integrability,message,message,11,This error message suggests to me that one of the things you're trying to add might be a numpy array:; ```; TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None); ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2326#issuecomment-1960290022
https://github.com/qutip/qutip/issues/2326#issuecomment-1961079240:7,Availability,error,error,7,"> This error message suggests to me that one of the things you're trying to add might be a numpy array:; > ; > ```; > TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None); > ```. Yes, you are right, sorry. I am closing the issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2326#issuecomment-1961079240
https://github.com/qutip/qutip/issues/2326#issuecomment-1961079240:13,Integrability,message,message,13,"> This error message suggests to me that one of the things you're trying to add might be a numpy array:; > ; > ```; > TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None); > ```. Yes, you are right, sorry. I am closing the issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2326#issuecomment-1961079240
https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496:1067,Safety,avoid,avoid,1067,"Yeah, on the practical side I was using those states to construct collapse operators, and then using these in steadystate() for a large range of parameters. Bit surprised to see what took 20 minutes in 4.7 took >5 hours in in v5 :0 I guess this is a combo of Liouvillian construction taking much longer as it then converts the Hamiltonian to Dense as well, and steady-state solving taking a bit longer too. Of course I can manually make those operators sparse (and then v5 just takes 7 mins!), but more generally, I think the logic of default_dtype is nice; essentially allows you to run QuTiP in that 'mode'. Also useful for cases like making jax objects, etc. ; I have another case where I actually want all operators to be dense, as I use .expm() a lot. . I think most functions in operators.py and states.py follow this logic, e.g., `basis()` in states.py: `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. I think it seems to make sense to apply it universally, irrespective of whether a particular object is naturally of one type or another, to avoid the cost of conversion when doing lots of repetitive things, avoid accidentally getting or making a particular type when you expect something different from default_dtype, etc. edit: Just to add, your suggestion of having two different default_dtypes could be nice too. I can imagine situations were you want to define both separately.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496
https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496:1134,Safety,avoid,avoid,1134,"Yeah, on the practical side I was using those states to construct collapse operators, and then using these in steadystate() for a large range of parameters. Bit surprised to see what took 20 minutes in 4.7 took >5 hours in in v5 :0 I guess this is a combo of Liouvillian construction taking much longer as it then converts the Hamiltonian to Dense as well, and steady-state solving taking a bit longer too. Of course I can manually make those operators sparse (and then v5 just takes 7 mins!), but more generally, I think the logic of default_dtype is nice; essentially allows you to run QuTiP in that 'mode'. Also useful for cases like making jax objects, etc. ; I have another case where I actually want all operators to be dense, as I use .expm() a lot. . I think most functions in operators.py and states.py follow this logic, e.g., `basis()` in states.py: `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. I think it seems to make sense to apply it universally, irrespective of whether a particular object is naturally of one type or another, to avoid the cost of conversion when doing lots of repetitive things, avoid accidentally getting or making a particular type when you expect something different from default_dtype, etc. edit: Just to add, your suggestion of having two different default_dtypes could be nice too. I can imagine situations were you want to define both separately.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496
https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496:526,Testability,log,logic,526,"Yeah, on the practical side I was using those states to construct collapse operators, and then using these in steadystate() for a large range of parameters. Bit surprised to see what took 20 minutes in 4.7 took >5 hours in in v5 :0 I guess this is a combo of Liouvillian construction taking much longer as it then converts the Hamiltonian to Dense as well, and steady-state solving taking a bit longer too. Of course I can manually make those operators sparse (and then v5 just takes 7 mins!), but more generally, I think the logic of default_dtype is nice; essentially allows you to run QuTiP in that 'mode'. Also useful for cases like making jax objects, etc. ; I have another case where I actually want all operators to be dense, as I use .expm() a lot. . I think most functions in operators.py and states.py follow this logic, e.g., `basis()` in states.py: `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. I think it seems to make sense to apply it universally, irrespective of whether a particular object is naturally of one type or another, to avoid the cost of conversion when doing lots of repetitive things, avoid accidentally getting or making a particular type when you expect something different from default_dtype, etc. edit: Just to add, your suggestion of having two different default_dtypes could be nice too. I can imagine situations were you want to define both separately.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496
https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496:824,Testability,log,logic,824,"Yeah, on the practical side I was using those states to construct collapse operators, and then using these in steadystate() for a large range of parameters. Bit surprised to see what took 20 minutes in 4.7 took >5 hours in in v5 :0 I guess this is a combo of Liouvillian construction taking much longer as it then converts the Hamiltonian to Dense as well, and steady-state solving taking a bit longer too. Of course I can manually make those operators sparse (and then v5 just takes 7 mins!), but more generally, I think the logic of default_dtype is nice; essentially allows you to run QuTiP in that 'mode'. Also useful for cases like making jax objects, etc. ; I have another case where I actually want all operators to be dense, as I use .expm() a lot. . I think most functions in operators.py and states.py follow this logic, e.g., `basis()` in states.py: `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. I think it seems to make sense to apply it universally, irrespective of whether a particular object is naturally of one type or another, to avoid the cost of conversion when doing lots of repetitive things, avoid accidentally getting or making a particular type when you expect something different from default_dtype, etc. edit: Just to add, your suggestion of having two different default_dtypes could be nice too. I can imagine situations were you want to define both separately.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496
https://github.com/qutip/qutip/issues/2328#issuecomment-1951474434:1205,Usability,simpl,simple,1205,"The current stats from `master` show that the fallback is quite mixed:; ```; 12 dtype = dtype or settings.core[""default_dtype""] or _data.CSR; 27 dtype = dtype or settings.core[""default_dtype""] or _data.Dense; 12 dtype = dtype or settings.core[""default_dtype""] or _data.Dia; ```; Perhaps we could create a small object describing the behaviour. Something like:; ```; class DefaultDataType:; state: ...; oper: ...; ```; And then one could either do `with CoreOptions(default_dtype=""CSR""):` (which sets everything to CSR) or `with CoreOptions(default_dtype=DefaultDatatype(state=""Dense"", oper=""CSR""):` (which chooses based on the type of the output). I don't know if `state` and `oper` are the correct set of distinctions to make. We already have some operators where `CSR` seems to the sensible default and others where the sensible default seems to be `Dia`. On the other hand eventually on probably wants to combine these operators into one system, so maybe picking a single operator default is the right thing to do. There is also the question of what should happen when operators are built from states. Perhaps in the end we can't really manage this for the user and they either have to live with a few simple tools we give them or explicitly set dtypes themselves?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1951474434
https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861:1056,Energy Efficiency,allocate,allocated,1056,"I am on the side on having 2 `default_dtype` options for the `Qobj` creation functions. I have some question as to how/where to make `default_dtype` more consistent. Applying the default at Qobj creation feels risky to me. In the solver it will end up converting the states before computing the expectation value. It could create strange interactions with operators and unitary transformations (`Qobj[Dense].dag() -> Qobj[CSR]`). `Qobj(scipy_csr)` could be converted to something else... However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion.; It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format? . In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. ps. Should `eigenstates` return the states in one operator instead of a list of kets? I guess the states were used to create the operators fed to `steadystate`, so operator output would be more practical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861
https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861:210,Safety,risk,risky,210,"I am on the side on having 2 `default_dtype` options for the `Qobj` creation functions. I have some question as to how/where to make `default_dtype` more consistent. Applying the default at Qobj creation feels risky to me. In the solver it will end up converting the states before computing the expectation value. It could create strange interactions with operators and unitary transformations (`Qobj[Dense].dag() -> Qobj[CSR]`). `Qobj(scipy_csr)` could be converted to something else... However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion.; It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format? . In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. ps. Should `eigenstates` return the states in one operator instead of a list of kets? I guess the states were used to create the operators fed to `steadystate`, so operator output would be more practical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861
https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861:600,Usability,clear,clear,600,"I am on the side on having 2 `default_dtype` options for the `Qobj` creation functions. I have some question as to how/where to make `default_dtype` more consistent. Applying the default at Qobj creation feels risky to me. In the solver it will end up converting the states before computing the expectation value. It could create strange interactions with operators and unitary transformations (`Qobj[Dense].dag() -> Qobj[CSR]`). `Qobj(scipy_csr)` could be converted to something else... However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion.; It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format? . In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. ps. Should `eigenstates` return the states in one operator instead of a list of kets? I guess the states were used to create the operators fed to `steadystate`, so operator output would be more practical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861
https://github.com/qutip/qutip/issues/2328#issuecomment-1953129675:204,Availability,avail,available,204,"Just adding some minor comments here, not really related to the core discussion; > We could have a warning when matrices over a certain size are allocated. I don't think it is good unless we can read the available memory and derive the warning threshold from that. On the cluster, we sometimes have up to hundreds of GB of memory. The threshold should be different from computer to computer. > Should eigenstates return the states in one operator instead of a list of kets?. I do often want eigenstates to return one operator. Many times I have to get the kets to NumPy array and recreate the unitary operator from them. Maybe we can have an additional argument to the function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953129675
https://github.com/qutip/qutip/issues/2328#issuecomment-1953129675:145,Energy Efficiency,allocate,allocated,145,"Just adding some minor comments here, not really related to the core discussion; > We could have a warning when matrices over a certain size are allocated. I don't think it is good unless we can read the available memory and derive the warning threshold from that. On the cluster, we sometimes have up to hundreds of GB of memory. The threshold should be different from computer to computer. > Should eigenstates return the states in one operator instead of a list of kets?. I do often want eigenstates to return one operator. Many times I have to get the kets to NumPy array and recreate the unitary operator from them. Maybe we can have an additional argument to the function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953129675
https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:742,Availability,down,down,742,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192
https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:574,Energy Efficiency,allocate,allocated,574,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192
https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:918,Integrability,depend,dependent,918,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192
https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:1456,Modifiability,layers,layers,1456,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192
https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:770,Performance,perform,performance,770,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192
https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:113,Usability,clear,clear,113,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192
https://github.com/qutip/qutip/issues/2328#issuecomment-1955804625:552,Performance,perform,performance,552,"This is just a comment - by coincidence, I also had a situation yesterday where my code was very slow because the matrices I used were accidentally dense. In my case, the reason was that I created operators like; ```; basis(N, i) * basis(N, j).dag(); ```; The default_dtype applies here but, if I hadn't been primed by seeing this issue, it might have taken me a long time to understand what is going on. It is somewhat surprising that qutip would, by default, create vectors / operators with only one non-zero entry as dense. I am sure there are good performance reasons for that, but it would be good to think about how we can help users not to run into such traps. Applying the default_dtype (or several of them) more broadly is certainly good. Has it been considered to include the dtype information in the output of printed `Qobj`s?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1955804625
https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978:38,Integrability,message,message,38,"I wanted to follow up on the previous message. Are there indeed important performance reasons why basis(N, n) is by default implemented densely:. `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. as opposed to . `dtype = dtype or settings.core[""default_dtype""] or _data.CSR` ?. I similarly have run into issues where much of my existing code using collapse operators of the form `basis(N, n) * basis(N, n).dag()` takes significantly longer to run (or runs out of memory) in 5.0.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978
https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978:74,Performance,perform,performance,74,"I wanted to follow up on the previous message. Are there indeed important performance reasons why basis(N, n) is by default implemented densely:. `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. as opposed to . `dtype = dtype or settings.core[""default_dtype""] or _data.CSR` ?. I similarly have run into issues where much of my existing code using collapse operators of the form `basis(N, n) * basis(N, n).dag()` takes significantly longer to run (or runs out of memory) in 5.0.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978
https://github.com/qutip/qutip/issues/2328#issuecomment-2028969439:171,Energy Efficiency,efficient,efficient,171,"Operation `oper @ ket` is a lot faster for `CSR @ Dense` than `CRS @ CSR`. Also for ket, csr matrices still need to have one entry per row, making them not that much more efficient than dense. (A well optimised `COO` would be nice here.). But it is only a good choice when they are used as kets, not when used as building tools for operators... We have functions to create such operators that I thought were more known that are set to use the appropriate sparse default:; `fock_dm(N, n)` is equivalent to `basis(N, n) * basis(N, n).dag()`.; `projection(N, n, m)` is equivalent to `basis(N, n) * basis(N, m).dag()`. For now I added an entry for this case in the migration guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-2028969439
https://github.com/qutip/qutip/issues/2328#issuecomment-2028969439:671,Usability,guid,guide,671,"Operation `oper @ ket` is a lot faster for `CSR @ Dense` than `CRS @ CSR`. Also for ket, csr matrices still need to have one entry per row, making them not that much more efficient than dense. (A well optimised `COO` would be nice here.). But it is only a good choice when they are used as kets, not when used as building tools for operators... We have functions to create such operators that I thought were more known that are set to use the appropriate sparse default:; `fock_dm(N, n)` is equivalent to `basis(N, n) * basis(N, n).dag()`.; `projection(N, n, m)` is equivalent to `basis(N, n) * basis(N, m).dag()`. For now I added an entry for this case in the migration guide.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-2028969439
https://github.com/qutip/qutip/pull/2329#issuecomment-1953218505:20,Safety,avoid,avoid,20,"It would be nice to avoid a proliferation of settings if we can. Could we perhaps add a casting function to the data layer somewhere? For example:; ```; if oper.isherm and ...:; out = oper.data.cast_to_real(out); ```; where for the JAX backend `cast_to_real` is something like `jax.numpy,real`. This is a little bit awkward if `oper.data` and `state.data` are different dtypes, because there are two possible functions to choose from, but perhaps that's okay?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-1953218505
https://github.com/qutip/qutip/pull/2329#issuecomment-1953261235:339,Deployability,release,release,339,"For jax, the issue is with `isherm`, not the casting. We cannot call it in jitted functions since they cannot branch depending on the input data. The casting itself cause issues with tensorflow. The `isherm_jax` could be set to always return `False`, but returning `False` only inside jitted function is too hacky and could break with jax release. When applied everywhere, it will have strange side effect such as `qeye(n) *2` is hermitian but `qeye(n)+qeye(n)` is not. Don't want that. If the `Qobj` are always the inputs of the function, then we could probably compute the hermiticity in `qobj_tree_flatten`, but it would not be any help when the object is build inside the function. I am somewhat at a lost of idea other than that... I see a helper function like `qutip_jax.set_as_default()` that would set all the settings for the user for the session in one go. Not have them manually updated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-1953261235
https://github.com/qutip/qutip/pull/2329#issuecomment-1953261235:890,Deployability,update,updated,890,"For jax, the issue is with `isherm`, not the casting. We cannot call it in jitted functions since they cannot branch depending on the input data. The casting itself cause issues with tensorflow. The `isherm_jax` could be set to always return `False`, but returning `False` only inside jitted function is too hacky and could break with jax release. When applied everywhere, it will have strange side effect such as `qeye(n) *2` is hermitian but `qeye(n)+qeye(n)` is not. Don't want that. If the `Qobj` are always the inputs of the function, then we could probably compute the hermiticity in `qobj_tree_flatten`, but it would not be any help when the object is build inside the function. I am somewhat at a lost of idea other than that... I see a helper function like `qutip_jax.set_as_default()` that would set all the settings for the user for the session in one go. Not have them manually updated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-1953261235
https://github.com/qutip/qutip/pull/2329#issuecomment-1953261235:117,Integrability,depend,depending,117,"For jax, the issue is with `isherm`, not the casting. We cannot call it in jitted functions since they cannot branch depending on the input data. The casting itself cause issues with tensorflow. The `isherm_jax` could be set to always return `False`, but returning `False` only inside jitted function is too hacky and could break with jax release. When applied everywhere, it will have strange side effect such as `qeye(n) *2` is hermitian but `qeye(n)+qeye(n)` is not. Don't want that. If the `Qobj` are always the inputs of the function, then we could probably compute the hermiticity in `qobj_tree_flatten`, but it would not be any help when the object is build inside the function. I am somewhat at a lost of idea other than that... I see a helper function like `qutip_jax.set_as_default()` that would set all the settings for the user for the session in one go. Not have them manually updated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-1953261235
https://github.com/qutip/qutip/pull/2329#issuecomment-2152637027:82,Safety,safe,safe,82,"Is there any possibility to make the JAX data layer `_data.isherm` JIT / autograd safe? If not, do we perhaps need a general way for the data layer to allow something like `_data.isherm(..., ensure_jit_safe=True)`? The syntax of my suggestion doesn't look great to me, but you understand the question.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-2152637027
https://github.com/qutip/qutip/issues/2331#issuecomment-1964255367:41,Availability,error,error,41,@gabbence95 ; Thank you for catching the error.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2331#issuecomment-1964255367
https://github.com/qutip/qutip/pull/2333#issuecomment-1963065768:7,Availability,error,errors,7,The CI errors all appear to the result of the coveralls.io service being down. Happy for this to be merged with the failures.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2333#issuecomment-1963065768
https://github.com/qutip/qutip/pull/2333#issuecomment-1963065768:73,Availability,down,down,73,The CI errors all appear to the result of the coveralls.io service being down. Happy for this to be merged with the failures.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2333#issuecomment-1963065768
https://github.com/qutip/qutip/pull/2333#issuecomment-1963065768:116,Availability,failure,failures,116,The CI errors all appear to the result of the coveralls.io service being down. Happy for this to be merged with the failures.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2333#issuecomment-1963065768
https://github.com/qutip/qutip/issues/2334#issuecomment-1962937455:155,Availability,error,error,155,Hi! How did you import the function `read_qasm`? Could also include your `import qutip ...` or `from qutip.qip import ...` statements? Does any warning or error message show up during the execution of the import?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2334#issuecomment-1962937455
https://github.com/qutip/qutip/issues/2334#issuecomment-1962937455:161,Integrability,message,message,161,Hi! How did you import the function `read_qasm`? Could also include your `import qutip ...` or `from qutip.qip import ...` statements? Does any warning or error message show up during the execution of the import?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2334#issuecomment-1962937455
https://github.com/qutip/qutip/issues/2334#issuecomment-1962951064:3,Availability,error,errors,3,No errors from the following:; ```; try:; from qutip import *; from qutip.qip import *; except ImportError:; !pip install --quiet qutip--4.7.5 qutip-qip; from qutip import *; from qutip.qip import *; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2334#issuecomment-1962951064
https://github.com/qutip/qutip/issues/2334#issuecomment-1962951064:114,Deployability,install,install,114,No errors from the following:; ```; try:; from qutip import *; from qutip.qip import *; except ImportError:; !pip install --quiet qutip--4.7.5 qutip-qip; from qutip import *; from qutip.qip import *; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2334#issuecomment-1962951064
https://github.com/qutip/qutip/issues/2334#issuecomment-1962960400:141,Deployability,release,release,141,"Ok, something must have happened here, `read_qasm` is not imported at all. It is hard to debug `from ... import *`. I don't think our recent release of `qutip==4.7.5` changed anything on the importation behaviour. It was just bug fix. You could try `from qutip.qip.qasm import read_qasm`. This should work as expected and will show the detailed reason if not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2334#issuecomment-1962960400
https://github.com/qutip/qutip/pull/2336#issuecomment-1967539515:31,Usability,clear,clear,31,Should we perhaps just change `clear` to set it to `None` instead of an empty list?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2336#issuecomment-1967539515
https://github.com/qutip/qutip/pull/2341#issuecomment-1978108039:61,Deployability,update,update,61,"probably there are more edge case and functions that need an update (sprepost() etc), but maybe for now this is a sufficient fix?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2341#issuecomment-1978108039
https://github.com/qutip/qutip/issues/2345#issuecomment-2008154917:71,Availability,error,error,71,"@nwlambert ; Unable to run the test cases in (entropy.py) it show this error ; <img width=""850"" alt=""Screenshot 2024-03-20 at 2 48 54AM"" src=""https://github.com/qutip/qutip/assets/147247481/710869a8-79e6-4941-b6d6-2ad0cf9fd76d"">; Can you please suggest me the solution to solve it ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2008154917
https://github.com/qutip/qutip/issues/2345#issuecomment-2008154917:31,Testability,test,test,31,"@nwlambert ; Unable to run the test cases in (entropy.py) it show this error ; <img width=""850"" alt=""Screenshot 2024-03-20 at 2 48 54AM"" src=""https://github.com/qutip/qutip/assets/147247481/710869a8-79e6-4941-b6d6-2ad0cf9fd76d"">; Can you please suggest me the solution to solve it ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2008154917
https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321:66,Deployability,install,installation,66,@vikas-chaudhary-2802 It looks like something went wrong with the installation. Make sure that you really installed the master branch and are testing it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321
https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321:106,Deployability,install,installed,106,@vikas-chaudhary-2802 It looks like something went wrong with the installation. Make sure that you really installed the master branch and are testing it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321
https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321:142,Testability,test,testing,142,@vikas-chaudhary-2802 It looks like something went wrong with the installation. Make sure that you really installed the master branch and are testing it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321
https://github.com/qutip/qutip/issues/2345#issuecomment-2016997897:98,Deployability,install,install,98,"Sorry @vikas-chaudhary-2802 I didn't notice your question last week. As boxi said, might be a bad install or you are using the wrong version. The ''how to contribute to qutip'' section of this tutorial might be useful for setting things up https://colab.research.google.com/drive/1RcgX7oEzGjzPAF8Ryus54Q5UmyMddmLA?usp=sharing",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2016997897
https://github.com/qutip/qutip/pull/2351#issuecomment-2001914855:206,Availability,error,errors,206,"@Ericgig I have made the changes upto best of my knowledge, I am not able to figure out how to apply phase fixing to the new operator type. . Also after a few iterations my local build seems to give cython errors, is there a wiki on how to sort that out?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2351#issuecomment-2001914855
https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346:7,Availability,error,error,7,"Cython error are quite vague, but there should not be any cython error here.; It could be errors inside a cython function. Could you send the log if it persist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346
https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346:65,Availability,error,error,65,"Cython error are quite vague, but there should not be any cython error here.; It could be errors inside a cython function. Could you send the log if it persist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346
https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346:90,Availability,error,errors,90,"Cython error are quite vague, but there should not be any cython error here.; It could be errors inside a cython function. Could you send the log if it persist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346
https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346:142,Testability,log,log,142,"Cython error are quite vague, but there should not be any cython error here.; It could be errors inside a cython function. Could you send the log if it persist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346
https://github.com/qutip/qutip/issues/2353#issuecomment-2004842390:132,Deployability,release,release,132,"In the development version `qutip.core.dimensions.to_tensor_rep` does just that.; I would be easy to add to a `Qobj` method. In the release version, `dims_to_tensor_perm` and `dims_to_tensor_shape` can be used to create the array.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2353#issuecomment-2004842390
https://github.com/qutip/qutip/issues/2353#issuecomment-2004881477:90,Deployability,release,release,90,"Ah, that would be great!. Thanks for pointing out those other functions as well. . In the release version, would the implementation be something like the following?; ```python; np.transpose(np.reshape(my_qobj.full(), dims_to_tensor_shape(my_qobj.dims)), dims_to_tensor_perm(my_qobj.dims)); ```; Do I perhaps want the inverse permutation of dims_to_tensor_perm? Should the numpy reshape use 'F' for the order parameter?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2353#issuecomment-2004881477
https://github.com/qutip/qutip/issues/2353#issuecomment-2007183867:1341,Availability,error,error-prone,1341,"I'll add that it might be worth addressing the fact that there are two common conventions for representing quantum states as tensors that each have their pros and cons. Perhaps this would be better placed in a separate issue, but I'll explain here anyway. Consider a joint state like $` |\psi_1 \psi_2 \rangle \langle \psi_3 \psi_4 | `$ where the dimensions of $` |\psi_i\rangle `$ are $` d_i `$. Two common representations of this abstract state as a tensor are; 1. $` (|\psi_1\rangle \otimes |\psi_2\rangle) \otimes (\langle \psi_3| \otimes \langle \psi_4|) `$, which has shape $`(d_1, d_2, d_3, d_4)`$; 2. $` (|\psi_1\rangle \otimes \langle \psi_3|) \otimes (|\psi_2\rangle \otimes \langle \psi_4|) `$, which has shape $` (d_1, d_3, d_2, d_4) `$. These two conventions essentially correspond to the ""super"" and ""choi"" representations for channels. Representation 1. is nice when you are doing most of your calculations with pure states, but then want a density matrix towards the end, which you can do with just `np.tensordot(my_ket_tensor, np.conj(my_ket_tensor), 0)`. Representation 2. is nice when you are working with density matrices and want to combine multiple subsystems, which you can do with `np.tensordot(my_density_tensor_1, my_density_tensor_2, 0)`. Doing either of these operations in the other representation involves very error-prone index permutation in my experience. When I said above that these two conventions should be ""addressed"" in some way, I was intentionally vague because I'm honestly not sure what the best way to do that would be. One option would be to simply mention it in the user guide somewhere, perhaps near the section on the Super and Choi representations. Another would be to support both conventions via optional parameters like `to_tensor_rep(my_qobj, convention='super')` or `to_tensor_rep(my_qobj, convention='choi')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2353#issuecomment-2007183867
https://github.com/qutip/qutip/issues/2353#issuecomment-2007183867:1587,Usability,simpl,simply,1587,"I'll add that it might be worth addressing the fact that there are two common conventions for representing quantum states as tensors that each have their pros and cons. Perhaps this would be better placed in a separate issue, but I'll explain here anyway. Consider a joint state like $` |\psi_1 \psi_2 \rangle \langle \psi_3 \psi_4 | `$ where the dimensions of $` |\psi_i\rangle `$ are $` d_i `$. Two common representations of this abstract state as a tensor are; 1. $` (|\psi_1\rangle \otimes |\psi_2\rangle) \otimes (\langle \psi_3| \otimes \langle \psi_4|) `$, which has shape $`(d_1, d_2, d_3, d_4)`$; 2. $` (|\psi_1\rangle \otimes \langle \psi_3|) \otimes (|\psi_2\rangle \otimes \langle \psi_4|) `$, which has shape $` (d_1, d_3, d_2, d_4) `$. These two conventions essentially correspond to the ""super"" and ""choi"" representations for channels. Representation 1. is nice when you are doing most of your calculations with pure states, but then want a density matrix towards the end, which you can do with just `np.tensordot(my_ket_tensor, np.conj(my_ket_tensor), 0)`. Representation 2. is nice when you are working with density matrices and want to combine multiple subsystems, which you can do with `np.tensordot(my_density_tensor_1, my_density_tensor_2, 0)`. Doing either of these operations in the other representation involves very error-prone index permutation in my experience. When I said above that these two conventions should be ""addressed"" in some way, I was intentionally vague because I'm honestly not sure what the best way to do that would be. One option would be to simply mention it in the user guide somewhere, perhaps near the section on the Super and Choi representations. Another would be to support both conventions via optional parameters like `to_tensor_rep(my_qobj, convention='super')` or `to_tensor_rep(my_qobj, convention='choi')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2353#issuecomment-2007183867
https://github.com/qutip/qutip/issues/2353#issuecomment-2007183867:1617,Usability,guid,guide,1617,"I'll add that it might be worth addressing the fact that there are two common conventions for representing quantum states as tensors that each have their pros and cons. Perhaps this would be better placed in a separate issue, but I'll explain here anyway. Consider a joint state like $` |\psi_1 \psi_2 \rangle \langle \psi_3 \psi_4 | `$ where the dimensions of $` |\psi_i\rangle `$ are $` d_i `$. Two common representations of this abstract state as a tensor are; 1. $` (|\psi_1\rangle \otimes |\psi_2\rangle) \otimes (\langle \psi_3| \otimes \langle \psi_4|) `$, which has shape $`(d_1, d_2, d_3, d_4)`$; 2. $` (|\psi_1\rangle \otimes \langle \psi_3|) \otimes (|\psi_2\rangle \otimes \langle \psi_4|) `$, which has shape $` (d_1, d_3, d_2, d_4) `$. These two conventions essentially correspond to the ""super"" and ""choi"" representations for channels. Representation 1. is nice when you are doing most of your calculations with pure states, but then want a density matrix towards the end, which you can do with just `np.tensordot(my_ket_tensor, np.conj(my_ket_tensor), 0)`. Representation 2. is nice when you are working with density matrices and want to combine multiple subsystems, which you can do with `np.tensordot(my_density_tensor_1, my_density_tensor_2, 0)`. Doing either of these operations in the other representation involves very error-prone index permutation in my experience. When I said above that these two conventions should be ""addressed"" in some way, I was intentionally vague because I'm honestly not sure what the best way to do that would be. One option would be to simply mention it in the user guide somewhere, perhaps near the section on the Super and Choi representations. Another would be to support both conventions via optional parameters like `to_tensor_rep(my_qobj, convention='super')` or `to_tensor_rep(my_qobj, convention='choi')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2353#issuecomment-2007183867
https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660:210,Availability,down,downgraded,210,"There is one particular setup where the sparse eigen solver segfault. This happen with pure scipy and is not related to qutip.; Looking into it, I saw that when we installed qutip, it updated scipy version. It downgraded scipy 1.12 to 1.11, thus we never tested for 1.12.; Also build isolation meant that the version of numpy, scipy and cython we set in our test matrix did not match the one at installation. This is not ideal for cython since the compilation version could have a major impact. I set it to not use build isolation and used the matrix set version to compile qutip.; This had the side effect of not using the setup that caused the segfault and solving the failing test issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660
https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660:164,Deployability,install,installed,164,"There is one particular setup where the sparse eigen solver segfault. This happen with pure scipy and is not related to qutip.; Looking into it, I saw that when we installed qutip, it updated scipy version. It downgraded scipy 1.12 to 1.11, thus we never tested for 1.12.; Also build isolation meant that the version of numpy, scipy and cython we set in our test matrix did not match the one at installation. This is not ideal for cython since the compilation version could have a major impact. I set it to not use build isolation and used the matrix set version to compile qutip.; This had the side effect of not using the setup that caused the segfault and solving the failing test issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660
https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660:184,Deployability,update,updated,184,"There is one particular setup where the sparse eigen solver segfault. This happen with pure scipy and is not related to qutip.; Looking into it, I saw that when we installed qutip, it updated scipy version. It downgraded scipy 1.12 to 1.11, thus we never tested for 1.12.; Also build isolation meant that the version of numpy, scipy and cython we set in our test matrix did not match the one at installation. This is not ideal for cython since the compilation version could have a major impact. I set it to not use build isolation and used the matrix set version to compile qutip.; This had the side effect of not using the setup that caused the segfault and solving the failing test issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660
https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660:395,Deployability,install,installation,395,"There is one particular setup where the sparse eigen solver segfault. This happen with pure scipy and is not related to qutip.; Looking into it, I saw that when we installed qutip, it updated scipy version. It downgraded scipy 1.12 to 1.11, thus we never tested for 1.12.; Also build isolation meant that the version of numpy, scipy and cython we set in our test matrix did not match the one at installation. This is not ideal for cython since the compilation version could have a major impact. I set it to not use build isolation and used the matrix set version to compile qutip.; This had the side effect of not using the setup that caused the segfault and solving the failing test issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660
https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660:255,Testability,test,tested,255,"There is one particular setup where the sparse eigen solver segfault. This happen with pure scipy and is not related to qutip.; Looking into it, I saw that when we installed qutip, it updated scipy version. It downgraded scipy 1.12 to 1.11, thus we never tested for 1.12.; Also build isolation meant that the version of numpy, scipy and cython we set in our test matrix did not match the one at installation. This is not ideal for cython since the compilation version could have a major impact. I set it to not use build isolation and used the matrix set version to compile qutip.; This had the side effect of not using the setup that caused the segfault and solving the failing test issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660
https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660:358,Testability,test,test,358,"There is one particular setup where the sparse eigen solver segfault. This happen with pure scipy and is not related to qutip.; Looking into it, I saw that when we installed qutip, it updated scipy version. It downgraded scipy 1.12 to 1.11, thus we never tested for 1.12.; Also build isolation meant that the version of numpy, scipy and cython we set in our test matrix did not match the one at installation. This is not ideal for cython since the compilation version could have a major impact. I set it to not use build isolation and used the matrix set version to compile qutip.; This had the side effect of not using the setup that caused the segfault and solving the failing test issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660
https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660:679,Testability,test,test,679,"There is one particular setup where the sparse eigen solver segfault. This happen with pure scipy and is not related to qutip.; Looking into it, I saw that when we installed qutip, it updated scipy version. It downgraded scipy 1.12 to 1.11, thus we never tested for 1.12.; Also build isolation meant that the version of numpy, scipy and cython we set in our test matrix did not match the one at installation. This is not ideal for cython since the compilation version could have a major impact. I set it to not use build isolation and used the matrix set version to compile qutip.; This had the side effect of not using the setup that caused the segfault and solving the failing test issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2361#issuecomment-2019207660
https://github.com/qutip/qutip/pull/2369#issuecomment-2029539933:1280,Safety,safe,safer,1280,"Thank you for your review. > The default seems to be a relative weight of `1`. Meaning that it should work fine in solver which does not use it (stochastic). But should they just keep using `Result` until we have a use for those weight?. I let them use `Result` again for now. I needed to add some lines [here](https://github.com/pmenczel/qutip/blob/weighted-trajectories/qutip/solver/result.py#L710) so that the new `MultiTrajResult` can deal with it. (Which might be a good idea anyway.). > It there a balancing tools for weight values? If there are 2 runs, can both have a relative weight of 10 or 0.1 without affecting the end results? If there are 2 starting kets that we want to merge with a weight of 10:1, does the actual values matter or only the ratio?. I have added a `merge` function that lets the user merge trajectory results with custom relative weights. I think trajectories with absolute or relative weights are handled consistently. Calling `result1 + result2` uses default values for the relative weights, chosen such that every trajectory contributes equally.; (That doesn't currently work for the stochastic solvers, but to my understanding, adding results didn't work for them previously either. It raises a `NotImplementedError` now.). > I feel it would be safer to compute the relative weight as `W(T) / sum_T(W(T))` instead of using the number of trajectories. Hmm unfortunately I think that this won't work. For the ""improved sampling"" case, the sum of the relative weights is not one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2369#issuecomment-2029539933
https://github.com/qutip/qutip/pull/2369#issuecomment-2095318521:610,Usability,guid,guide,610,"> It's nice to merge `McResultImprovedSampling` into `McResult`, but the overall complexity has increased... I believe it would be better to move `MultiTrajResult` to it's own file.; > ; > Did you review the `dynamics-nmmonte,rst`? Adding a note/example of using the improved sampling option there would be good. Thank you for the review. The complexity has increased, more than I expected when I started writing. I hope it is worth it?; I have extracted the `MultiTrajResult` and its subclasses to a new module, `qutip.solver.multitrajresult`. I have added a mention about the improved sampling option in the guide, and I will have a look at the tutorial notebook whether it makes sense to include somewhere there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2369#issuecomment-2095318521
https://github.com/qutip/qutip/issues/2370#issuecomment-2027673583:60,Testability,log,log,60,"Can you use `Qobj.expm()` with the identity `n ** x == (exp(log(n)) ** x == exp(x * log(n))`, which is true for any positive real `n`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2370#issuecomment-2027673583
https://github.com/qutip/qutip/issues/2370#issuecomment-2027673583:84,Testability,log,log,84,"Can you use `Qobj.expm()` with the identity `n ** x == (exp(log(n)) ** x == exp(x * log(n))`, which is true for any positive real `n`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2370#issuecomment-2027673583
https://github.com/qutip/qutip/pull/2371#issuecomment-2041904800:102,Testability,test,test,102,"Due to my exam collision, I was a little bit late. I apologize for that. Currently, I am working on a test case to check whether the negativity of a maximally entangled two-qubit state is close to 0.5, and I'm also verifying the operator, ket, and bra inputs. Once it's done, I will make a Seprate PR. Thank you for your help and support @nwlambert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2041904800
https://github.com/qutip/qutip/pull/2371#issuecomment-2042114519:38,Testability,test,test,38,"@vikas-chaudhary-2802 can you add the test to this PR? it can be very simple. if you feel like it will take some time, i can merge this and you can do a separate one later. @ytdHuang thanks for the suggestion, do you think it would be better to use that as the default method? in any case, lets do that in a separate issue/PR",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2042114519
https://github.com/qutip/qutip/pull/2371#issuecomment-2042114519:70,Usability,simpl,simple,70,"@vikas-chaudhary-2802 can you add the test to this PR? it can be very simple. if you feel like it will take some time, i can merge this and you can do a separate one later. @ytdHuang thanks for the suggestion, do you think it would be better to use that as the default method? in any case, lets do that in a separate issue/PR",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2042114519
https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610:24,Integrability,depend,depends,24,@nwlambert ; I think it depends on whether `sqrtm()` or `eigenenergies()` performs better (or less issues in general case) in `Qobj`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610
https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610:74,Performance,perform,performs,74,@nwlambert ; I think it depends on whether `sqrtm()` or `eigenenergies()` performs better (or less issues in general case) in `Qobj`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610
https://github.com/qutip/qutip/pull/2371#issuecomment-2049086230:17,Testability,test,test,17,"Hi, @nwlambert 1 test is failing , can you please suggest me how can i fix it ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2049086230
https://github.com/qutip/qutip/pull/2375#issuecomment-2030606847:219,Deployability,update,update-sphinx-rtd-theme-to-fix-search,219,[![Coverage Status](https://coveralls.io/builds/66647562/badge)](https://coveralls.io/builds/66647562). coverage: 86.032%. remained the same; when pulling **dc69fee10a5e4958649e997c3fee5057ca34e9bf on hodgestar:feature/update-sphinx-rtd-theme-to-fix-search**; into **7fcc3f3fb9d626c3057fed9721a11f32f5647266 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2375#issuecomment-2030606847
https://github.com/qutip/qutip/pull/2381#issuecomment-2035531513:203,Integrability,depend,dependabot,203,[![Coverage Status](https://coveralls.io/builds/66694701/badge)](https://coveralls.io/builds/66694701). coverage: 86.07% (+0.03%) from 86.039%; when pulling **f09cf77ec1f8fbadc692e37cce8173a84bc7847c on dependabot/pip/doc/pillow-10.3.0**; into **5d6dc220c910b7c7bf824aba5bc05fbbfa54f017 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2381#issuecomment-2035531513
https://github.com/qutip/qutip/pull/2382#issuecomment-2036003278:71,Availability,error,error,71,Thank you @magzpavz for catching this. Could you add some tests so the error doesn't reappears.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2382#issuecomment-2036003278
https://github.com/qutip/qutip/pull/2382#issuecomment-2036003278:58,Testability,test,tests,58,Thank you @magzpavz for catching this. Could you add some tests so the error doesn't reappears.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2382#issuecomment-2036003278
https://github.com/qutip/qutip/pull/2383#issuecomment-2045143602:180,Availability,avail,available,180,"Hey, thanks for the workaround with pinning scipy. How long does it typically take for a qutip version to show up on conda-forge after it is already released by you folks and made available on pypi?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2383#issuecomment-2045143602
https://github.com/qutip/qutip/pull/2383#issuecomment-2045143602:149,Deployability,release,released,149,"Hey, thanks for the workaround with pinning scipy. How long does it typically take for a qutip version to show up on conda-forge after it is already released by you folks and made available on pypi?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2383#issuecomment-2045143602
https://github.com/qutip/qutip/issues/2384#issuecomment-2046601871:375,Deployability,update,update,375,"Just to add that we also have operator evolution in the form. $$ \partial_t \begin{pmatrix} U \\\\ U' \end{pmatrix} = -i \begin{pmatrix} H & 0 \\\\ H' & H \end{pmatrix} \begin{pmatrix} U \\\\ U' \end{pmatrix}, $$. and similar with $U$ switched for a map and $H$ for some Lindblad superoperator, in goat, which seems to work fine in terms of the multiplication during the ODE update step. So, as suggested, it would seem that mainly we just want a nice, efficient method for constructing / extracting these objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2046601871
https://github.com/qutip/qutip/issues/2384#issuecomment-2046601871:453,Energy Efficiency,efficient,efficient,453,"Just to add that we also have operator evolution in the form. $$ \partial_t \begin{pmatrix} U \\\\ U' \end{pmatrix} = -i \begin{pmatrix} H & 0 \\\\ H' & H \end{pmatrix} \begin{pmatrix} U \\\\ U' \end{pmatrix}, $$. and similar with $U$ switched for a map and $H$ for some Lindblad superoperator, in goat, which seems to work fine in terms of the multiplication during the ODE update step. So, as suggested, it would seem that mainly we just want a nice, efficient method for constructing / extracting these objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2046601871
https://github.com/qutip/qutip/issues/2384#issuecomment-2307877982:603,Safety,avoid,avoid,603,"Diffrax and I suspect some other ODE solves have direct support for coupled ODEs -- https://docs.kidger.site/diffrax/examples/coupled_odes/. It looks like diffrax supports these directly. The QuTiP equivalent would appear to be something like a QobjEvo which has a list of terms for each element of the direct product in the output space and, in addition, knows which subspace in the input space each term acts on. The HEOM is very sparse (tri-block diagonal) and just constructing the RHS is slow, so I suspect it will be hard to make any implementation faster than what we have now without a means to avoid constructing the RHS entirely. It would be interesting to try the current HEOM with the diffrax coupled-ODE support and see how big the gain is (if any) before putting a lot of effort into making something similar ourselves. @Ericgig Any thought on how crazy / difficult it would be to make something like an coupled-ODE PyTree / QobjEvo in QuTiP?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2307877982
https://github.com/qutip/qutip/issues/2384#issuecomment-2307925552:63,Integrability,depend,dependent,63,"just to add, I had a reason to make the whole RHS in heom time-dependent recently, so i had to revert to the kronecker product of a big matrix and each Qobjevo, losing the nice fast RHS construction. so am keen to give this coupled ode approach a try!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2307925552
https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934:37,Deployability,integrat,integrators,37,"The easiest would be to make special integrators for HEOM which take a dict of `QobjEvo`: `system = {(from, to): H0,}` and list of states. Then we loop over the items: `drho[from] = QobjEvo(t) @ rho[to]`. As long as the state can be represented in an array, every ODE from scipy, jax, etc can be used. We have tools to stack, unstack, split columns, etc, so the conversion between array and list of `Dense` is easy and efficient. For scipy integrators, that would only need to change 3 methods. Would that work on the HEOM side?; This mean we would need specialised integrator in JAX etc, but would be a lot easier than the stochastic ones so I don't think it's an issue. Changing the `QobjEvo` would be more work, but doable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934
https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934:440,Deployability,integrat,integrators,440,"The easiest would be to make special integrators for HEOM which take a dict of `QobjEvo`: `system = {(from, to): H0,}` and list of states. Then we loop over the items: `drho[from] = QobjEvo(t) @ rho[to]`. As long as the state can be represented in an array, every ODE from scipy, jax, etc can be used. We have tools to stack, unstack, split columns, etc, so the conversion between array and list of `Dense` is easy and efficient. For scipy integrators, that would only need to change 3 methods. Would that work on the HEOM side?; This mean we would need specialised integrator in JAX etc, but would be a lot easier than the stochastic ones so I don't think it's an issue. Changing the `QobjEvo` would be more work, but doable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934
https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934:566,Deployability,integrat,integrator,566,"The easiest would be to make special integrators for HEOM which take a dict of `QobjEvo`: `system = {(from, to): H0,}` and list of states. Then we loop over the items: `drho[from] = QobjEvo(t) @ rho[to]`. As long as the state can be represented in an array, every ODE from scipy, jax, etc can be used. We have tools to stack, unstack, split columns, etc, so the conversion between array and list of `Dense` is easy and efficient. For scipy integrators, that would only need to change 3 methods. Would that work on the HEOM side?; This mean we would need specialised integrator in JAX etc, but would be a lot easier than the stochastic ones so I don't think it's an issue. Changing the `QobjEvo` would be more work, but doable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934
https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934:419,Energy Efficiency,efficient,efficient,419,"The easiest would be to make special integrators for HEOM which take a dict of `QobjEvo`: `system = {(from, to): H0,}` and list of states. Then we loop over the items: `drho[from] = QobjEvo(t) @ rho[to]`. As long as the state can be represented in an array, every ODE from scipy, jax, etc can be used. We have tools to stack, unstack, split columns, etc, so the conversion between array and list of `Dense` is easy and efficient. For scipy integrators, that would only need to change 3 methods. Would that work on the HEOM side?; This mean we would need specialised integrator in JAX etc, but would be a lot easier than the stochastic ones so I don't think it's an issue. Changing the `QobjEvo` would be more work, but doable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934
https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934:37,Integrability,integrat,integrators,37,"The easiest would be to make special integrators for HEOM which take a dict of `QobjEvo`: `system = {(from, to): H0,}` and list of states. Then we loop over the items: `drho[from] = QobjEvo(t) @ rho[to]`. As long as the state can be represented in an array, every ODE from scipy, jax, etc can be used. We have tools to stack, unstack, split columns, etc, so the conversion between array and list of `Dense` is easy and efficient. For scipy integrators, that would only need to change 3 methods. Would that work on the HEOM side?; This mean we would need specialised integrator in JAX etc, but would be a lot easier than the stochastic ones so I don't think it's an issue. Changing the `QobjEvo` would be more work, but doable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934
https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934:440,Integrability,integrat,integrators,440,"The easiest would be to make special integrators for HEOM which take a dict of `QobjEvo`: `system = {(from, to): H0,}` and list of states. Then we loop over the items: `drho[from] = QobjEvo(t) @ rho[to]`. As long as the state can be represented in an array, every ODE from scipy, jax, etc can be used. We have tools to stack, unstack, split columns, etc, so the conversion between array and list of `Dense` is easy and efficient. For scipy integrators, that would only need to change 3 methods. Would that work on the HEOM side?; This mean we would need specialised integrator in JAX etc, but would be a lot easier than the stochastic ones so I don't think it's an issue. Changing the `QobjEvo` would be more work, but doable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934
https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934:566,Integrability,integrat,integrator,566,"The easiest would be to make special integrators for HEOM which take a dict of `QobjEvo`: `system = {(from, to): H0,}` and list of states. Then we loop over the items: `drho[from] = QobjEvo(t) @ rho[to]`. As long as the state can be represented in an array, every ODE from scipy, jax, etc can be used. We have tools to stack, unstack, split columns, etc, so the conversion between array and list of `Dense` is easy and efficient. For scipy integrators, that would only need to change 3 methods. Would that work on the HEOM side?; This mean we would need specialised integrator in JAX etc, but would be a lot easier than the stochastic ones so I don't think it's an issue. Changing the `QobjEvo` would be more work, but doable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2310307934
https://github.com/qutip/qutip/issues/2386#issuecomment-2050649919:1654,Availability,down,downloading,1654,"Sorry for the delayed reply, here is what I've been trying to do:. N = 8; max_excitation = 1 ; num_levels = 2; dims = [num_levels] * N`. ann_operators = enr_destroy(dims, excitations = max_excitation); w_r = 2 * np.pi * 5; w = np.array([w_r] * N). J_r = 2 * np.pi * 0.4; J_t2 = 1.353 * J_r; J_t1 = 1.035 * J_r. J = np.array([J_t2, J_t1] + [J_r] * (N-5) + [J_t1, J_t2]). kappa = 2.92 * J_r; drive_amp = 2 * np.pi * 0.0001. mod_freq = 2 * np.pi * 0.87; mod_amp = mod_freq * 0.8. t = []. detuning_list = 2 * np.pi * np.linspace(-1, 1, 501). for detuning in detuning_list:; drive_w = (w_r - detuning). H_r = 0; for i, a in enumerate(ann_operators):; H_r += (w[i] - drive_w) * a.dag() * a. H_int = 0; for i in range(len(ann_operators)-1):; H_int += J[i] * (ann_operators[i].dag() * ann_operators[i+1] + ann_operators[i+1].dag() * ann_operators[i]). H_d = -1j * drive_amp * (ann_operators[0] - ann_operators[0].dag()). H = H_r + H_int + H_d; c_ops = [np.sqrt(kappa)*ann_operators[0], np.sqrt(kappa)*ann_operators[-1]]; Op_t = mod_amp * ann_operators[6].dag() * ann_operators[6]. rho_ss = steadystate_floquet(H, c_ops, Op_t, w_d = mod_freq). a_out = np.sqrt(kappa) * expect(ann_operators[-1], rho_ss); t.append(np.sqrt(kappa) * a_out/drive_amp). t = np.array(t). dB = 0. if dB:; plt.plot(detuning_list/2/np.pi, 20*np.log10(np.abs(t))); plt.xlabel(""Detuning (GHz)""); plt.ylabel(""|S21|(dB)""); plt.ylim(-10,0.01). else:; plt.plot(detuning_list/2/np.pi, (np.abs(t))); plt.xlabel(""Detuning (GHz)""); plt.ylabel(""|S21|""); plt.grid()`. Qutip 4.7:; ![image](https://github.com/qutip/qutip/assets/61804899/95a303ef-dcef-4fae-bace-5d6f5b7b24a1). Qutip 5.1.0 (installed by downloading a zip from the git as on April 11th):; ![image](https://github.com/qutip/qutip/assets/61804899/04d3e168-2893-435b-9818-91fe917c5d6b)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2050649919
https://github.com/qutip/qutip/issues/2386#issuecomment-2050649919:1641,Deployability,install,installed,1641,"Sorry for the delayed reply, here is what I've been trying to do:. N = 8; max_excitation = 1 ; num_levels = 2; dims = [num_levels] * N`. ann_operators = enr_destroy(dims, excitations = max_excitation); w_r = 2 * np.pi * 5; w = np.array([w_r] * N). J_r = 2 * np.pi * 0.4; J_t2 = 1.353 * J_r; J_t1 = 1.035 * J_r. J = np.array([J_t2, J_t1] + [J_r] * (N-5) + [J_t1, J_t2]). kappa = 2.92 * J_r; drive_amp = 2 * np.pi * 0.0001. mod_freq = 2 * np.pi * 0.87; mod_amp = mod_freq * 0.8. t = []. detuning_list = 2 * np.pi * np.linspace(-1, 1, 501). for detuning in detuning_list:; drive_w = (w_r - detuning). H_r = 0; for i, a in enumerate(ann_operators):; H_r += (w[i] - drive_w) * a.dag() * a. H_int = 0; for i in range(len(ann_operators)-1):; H_int += J[i] * (ann_operators[i].dag() * ann_operators[i+1] + ann_operators[i+1].dag() * ann_operators[i]). H_d = -1j * drive_amp * (ann_operators[0] - ann_operators[0].dag()). H = H_r + H_int + H_d; c_ops = [np.sqrt(kappa)*ann_operators[0], np.sqrt(kappa)*ann_operators[-1]]; Op_t = mod_amp * ann_operators[6].dag() * ann_operators[6]. rho_ss = steadystate_floquet(H, c_ops, Op_t, w_d = mod_freq). a_out = np.sqrt(kappa) * expect(ann_operators[-1], rho_ss); t.append(np.sqrt(kappa) * a_out/drive_amp). t = np.array(t). dB = 0. if dB:; plt.plot(detuning_list/2/np.pi, 20*np.log10(np.abs(t))); plt.xlabel(""Detuning (GHz)""); plt.ylabel(""|S21|(dB)""); plt.ylim(-10,0.01). else:; plt.plot(detuning_list/2/np.pi, (np.abs(t))); plt.xlabel(""Detuning (GHz)""); plt.ylabel(""|S21|""); plt.grid()`. Qutip 4.7:; ![image](https://github.com/qutip/qutip/assets/61804899/95a303ef-dcef-4fae-bace-5d6f5b7b24a1). Qutip 5.1.0 (installed by downloading a zip from the git as on April 11th):; ![image](https://github.com/qutip/qutip/assets/61804899/04d3e168-2893-435b-9818-91fe917c5d6b)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2050649919
https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504:28,Availability,down,down,28,"Thanks, this helps track it down. It seems not to be an issue with ENR per se, but with the floquet steadystate solver itself (it also appears without using ENR states). . I think I pinned it down to two small bugs in that seem to have crept in to the solver with the data layer updates, I will make a PR for it and ping you for some feedback, if thats ok. We lack a sufficiently robust test for this solver really, if you can suggest something tractable (very small example, potentially analytical solution we can check against), it would be very helpful.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504
https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504:192,Availability,down,down,192,"Thanks, this helps track it down. It seems not to be an issue with ENR per se, but with the floquet steadystate solver itself (it also appears without using ENR states). . I think I pinned it down to two small bugs in that seem to have crept in to the solver with the data layer updates, I will make a PR for it and ping you for some feedback, if thats ok. We lack a sufficiently robust test for this solver really, if you can suggest something tractable (very small example, potentially analytical solution we can check against), it would be very helpful.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504
https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504:316,Availability,ping,ping,316,"Thanks, this helps track it down. It seems not to be an issue with ENR per se, but with the floquet steadystate solver itself (it also appears without using ENR states). . I think I pinned it down to two small bugs in that seem to have crept in to the solver with the data layer updates, I will make a PR for it and ping you for some feedback, if thats ok. We lack a sufficiently robust test for this solver really, if you can suggest something tractable (very small example, potentially analytical solution we can check against), it would be very helpful.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504
https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504:380,Availability,robust,robust,380,"Thanks, this helps track it down. It seems not to be an issue with ENR per se, but with the floquet steadystate solver itself (it also appears without using ENR states). . I think I pinned it down to two small bugs in that seem to have crept in to the solver with the data layer updates, I will make a PR for it and ping you for some feedback, if thats ok. We lack a sufficiently robust test for this solver really, if you can suggest something tractable (very small example, potentially analytical solution we can check against), it would be very helpful.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504
https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504:279,Deployability,update,updates,279,"Thanks, this helps track it down. It seems not to be an issue with ENR per se, but with the floquet steadystate solver itself (it also appears without using ENR states). . I think I pinned it down to two small bugs in that seem to have crept in to the solver with the data layer updates, I will make a PR for it and ping you for some feedback, if thats ok. We lack a sufficiently robust test for this solver really, if you can suggest something tractable (very small example, potentially analytical solution we can check against), it would be very helpful.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504
https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504:387,Testability,test,test,387,"Thanks, this helps track it down. It seems not to be an issue with ENR per se, but with the floquet steadystate solver itself (it also appears without using ENR states). . I think I pinned it down to two small bugs in that seem to have crept in to the solver with the data layer updates, I will make a PR for it and ping you for some feedback, if thats ok. We lack a sufficiently robust test for this solver really, if you can suggest something tractable (very small example, potentially analytical solution we can check against), it would be very helpful.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504
https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504:334,Usability,feedback,feedback,334,"Thanks, this helps track it down. It seems not to be an issue with ENR per se, but with the floquet steadystate solver itself (it also appears without using ENR states). . I think I pinned it down to two small bugs in that seem to have crept in to the solver with the data layer updates, I will make a PR for it and ping you for some feedback, if thats ok. We lack a sufficiently robust test for this solver really, if you can suggest something tractable (very small example, potentially analytical solution we can check against), it would be very helpful.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2386#issuecomment-2051189504
https://github.com/qutip/qutip/issues/2389#issuecomment-2046571588:82,Usability,guid,guide,82,It is actually very similar to your solution. We should add this to the migration guide.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2389#issuecomment-2046571588
https://github.com/qutip/qutip/issues/2389#issuecomment-2046653469:58,Deployability,update,update-,58,"Thanks @BoxiLi ; Okay, embarrassingly, I was still in my `update-4,x` branch, so hence didn't find the file. Still, I did try a lot of stuff like `from qutip import hadamard_transform` (in other envs) that didn't work, before I found (with some help) that `from qutip import gates` is a good option. It seems like there was a deliberate choice not to expose the function names individually. A search for ""hadamard_transform"" or ""gates"" does not return anything helpful. Does it need pointing at in the docs build?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2389#issuecomment-2046653469
https://github.com/qutip/qutip/issues/2389#issuecomment-2046653469:351,Security,expose,expose,351,"Thanks @BoxiLi ; Okay, embarrassingly, I was still in my `update-4,x` branch, so hence didn't find the file. Still, I did try a lot of stuff like `from qutip import hadamard_transform` (in other envs) that didn't work, before I found (with some help) that `from qutip import gates` is a good option. It seems like there was a deliberate choice not to expose the function names individually. A search for ""hadamard_transform"" or ""gates"" does not return anything helpful. Does it need pointing at in the docs build?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2389#issuecomment-2046653469
https://github.com/qutip/qutip/issues/2389#issuecomment-2140841510:163,Availability,avail,available,163,"Hi, I would like to contribute to this issue as part of the UnitaryHack2024. I will incorporate a basic use of gates module to guide-basics.rst and a table of the available gates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2389#issuecomment-2140841510
https://github.com/qutip/qutip/issues/2389#issuecomment-2140841510:127,Usability,guid,guide-basics,127,"Hi, I would like to contribute to this issue as part of the UnitaryHack2024. I will incorporate a basic use of gates module to guide-basics.rst and a table of the available gates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2389#issuecomment-2140841510
https://github.com/qutip/qutip/pull/2392#issuecomment-2050867182:201,Integrability,depend,dependabot,201,[![Coverage Status](https://coveralls.io/builds/66870601/badge)](https://coveralls.io/builds/66870601). coverage: 86.048%. remained the same; when pulling **f6f539cd443a0c3afa5b148092542ece70672eac on dependabot/pip/doc/idna-3.7**; into **8035590df7ebde21bb34fcaadc63bea2d0c6e192 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2392#issuecomment-2050867182
https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426:15,Testability,test,test,15,"I adjusted the test to be sensitive to the original issues. new test is just a driven two-level system. not sure why the old test of a driven boson was insensitive to that test. i could make it sensitive by making the drive act on the frequency, like the example in #2386 but this is simpler. . also adjusted the test to compare a period of the dynamics from mesolve to the result from the steadystate solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426
https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426:64,Testability,test,test,64,"I adjusted the test to be sensitive to the original issues. new test is just a driven two-level system. not sure why the old test of a driven boson was insensitive to that test. i could make it sensitive by making the drive act on the frequency, like the example in #2386 but this is simpler. . also adjusted the test to compare a period of the dynamics from mesolve to the result from the steadystate solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426
https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426:125,Testability,test,test,125,"I adjusted the test to be sensitive to the original issues. new test is just a driven two-level system. not sure why the old test of a driven boson was insensitive to that test. i could make it sensitive by making the drive act on the frequency, like the example in #2386 but this is simpler. . also adjusted the test to compare a period of the dynamics from mesolve to the result from the steadystate solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426
https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426:172,Testability,test,test,172,"I adjusted the test to be sensitive to the original issues. new test is just a driven two-level system. not sure why the old test of a driven boson was insensitive to that test. i could make it sensitive by making the drive act on the frequency, like the example in #2386 but this is simpler. . also adjusted the test to compare a period of the dynamics from mesolve to the result from the steadystate solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426
https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426:313,Testability,test,test,313,"I adjusted the test to be sensitive to the original issues. new test is just a driven two-level system. not sure why the old test of a driven boson was insensitive to that test. i could make it sensitive by making the drive act on the frequency, like the example in #2386 but this is simpler. . also adjusted the test to compare a period of the dynamics from mesolve to the result from the steadystate solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426
https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426:284,Usability,simpl,simpler,284,"I adjusted the test to be sensitive to the original issues. new test is just a driven two-level system. not sure why the old test of a driven boson was insensitive to that test. i could make it sensitive by making the drive act on the frequency, like the example in #2386 but this is simpler. . also adjusted the test to compare a period of the dynamics from mesolve to the result from the steadystate solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426
https://github.com/qutip/qutip/pull/2395#issuecomment-2063018511:576,Availability,error,error,576,"Hi and thank you for your contribution! I see that this is still a draft, but I wanted to quickly point out qutip's existing `parallel` module: https://qutip.readthedocs.io/en/master/apidoc/functions.html#module-qutip.solver.parallel; The module offers functions which can either execute tasks serially (`serial_map`) or in parallel (`parallel_map`, `loky_pmap`, `mpi_pmap`). For example in the Monte Carlo solver, the `map` option decides which of these functions is used, allowing users to switch easily between serial and parallel execution. These functions also come with error handling already, and they select a default number of processes based on the CPU count. It would be nice to have such a `map` option for the calculation of correlation functions.; Are you planning to make similar modifications also to the other types of correlation function in the same module?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2395#issuecomment-2063018511
https://github.com/qutip/qutip/pull/2399#issuecomment-2069939373:113,Deployability,update,update,113,"Unrelated, but it might also be good to mention updating the sidebar links since we've occasionally forgotten to update those in the past.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2399#issuecomment-2069939373
https://github.com/qutip/qutip/pull/2399#issuecomment-2070114125:13,Deployability,update,updated,13,@hodgestar I updated the sidebar instructions.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2399#issuecomment-2070114125
https://github.com/qutip/qutip/issues/2400#issuecomment-2115958189:7,Deployability,update,updated,7,I have updated the issue description with a code snippet.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2115958189
https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:84,Availability,error,error,84,"While running the above example on a jupyter notebook I am faced with the following error ; ```; {; 	""name"": ""TypeError"",; 	""message"": ""_remove_margins.<locals>._get_coord_info_new() missing 1 required positional argument: 'renderer'"",; 	""stack"": ""---------------------------------------------------------------------------; TypeError Traceback (most recent call last); File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/pyplot.py:265, in _draw_all_if_interactive(); 263 def _draw_all_if_interactive() -> None:; 264 if matplotlib.is_interactive():; --> 265 draw_all(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/_pylab_helpers.py:131, in Gcf.draw_all(cls, force); 129 for manager in cls.get_all_fig_managers():; 130 if force or manager.canvas.figure.stale:; --> 131 manager.canvas.draw_idle(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backend_bases.py:1919, in FigureCanvasBase.draw_idle(self, *args, **kwargs); 1917 if not self._is_idle_drawing:; 1918 with self._idle_draw_cntx():; -> 1919 self.draw(*args, **kwargs). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backends/backend_agg.py:387, in FigureCanvasAgg.draw(self); 384 # Acquire a lock on the shared font cache.; 385 with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 386 else nullcontext()):; --> 387 self.figure.draw(self.renderer); 388 # A GUI class may be need to update a window using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903
https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:1507,Deployability,update,update,1507,"interactive() -> None:; 264 if matplotlib.is_interactive():; --> 265 draw_all(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/_pylab_helpers.py:131, in Gcf.draw_all(cls, force); 129 for manager in cls.get_all_fig_managers():; 130 if force or manager.canvas.figure.stale:; --> 131 manager.canvas.draw_idle(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backend_bases.py:1919, in FigureCanvasBase.draw_idle(self, *args, **kwargs); 1917 if not self._is_idle_drawing:; 1918 with self._idle_draw_cntx():; -> 1919 self.draw(*args, **kwargs). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backends/backend_agg.py:387, in FigureCanvasAgg.draw(self); 384 # Acquire a lock on the shared font cache.; 385 with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 386 else nullcontext()):; --> 387 self.figure.draw(self.renderer); 388 # A GUI class may be need to update a window using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:72, in allow_rasterization.<locals>.draw_wrapper(artist, renderer); 69 if artist.get_agg_filter() is not None:; 70 renderer.start_filter(); ---> 72 return draw(artist, renderer); 73 finally:; 74 if artist.get_agg_filter() is not None:. File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/figure.py:3155, in Figure.draw(self, renderer); 3152 # ValueError can occur when resizing a window.; 3154 self.patch.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903
https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:2519,Deployability,patch,patch,2519," using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:72, in allow_rasterization.<locals>.draw_wrapper(artist, renderer); 69 if artist.get_agg_filter() is not None:; 70 renderer.start_filter(); ---> 72 return draw(artist, renderer); 73 finally:; 74 if artist.get_agg_filter() is not None:. File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/figure.py:3155, in Figure.draw(self, renderer); 3152 # ValueError can occur when resizing a window.; 3154 self.patch.draw(renderer); -> 3155 mimage._draw_list_compositing_images(; 3156 renderer, self, artists, self.suppressComposite); 3158 renderer.close_group('figure'); 3159 finally:. File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/image.py:132, in _draw_list_compositing_images(renderer, parent, artists, suppress_composite); 130 if not_composite or not has_images:; 131 for a in artists:; --> 132 a.draw(renderer); 133 else:; 134 # Composite any adjacent images together; 135 image_group = []. File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:72, in allow_rasterization.<locals>.draw_wrapper(artist, renderer); 69 if artist.get_agg_filter() is not None:; 70 renderer.start_filter(); ---> 72 return draw(artist, renderer); 73 finally:; 74 if artist.get_agg_filter() is not None:. File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/mpl_toolkits/mplot3d/axes3d.py:455, in Axes3D.draw(self, renderer);",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903
https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:125,Integrability,message,message,125,"While running the above example on a jupyter notebook I am faced with the following error ; ```; {; 	""name"": ""TypeError"",; 	""message"": ""_remove_margins.<locals>._get_coord_info_new() missing 1 required positional argument: 'renderer'"",; 	""stack"": ""---------------------------------------------------------------------------; TypeError Traceback (most recent call last); File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/pyplot.py:265, in _draw_all_if_interactive(); 263 def _draw_all_if_interactive() -> None:; 264 if matplotlib.is_interactive():; --> 265 draw_all(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/_pylab_helpers.py:131, in Gcf.draw_all(cls, force); 129 for manager in cls.get_all_fig_managers():; 130 if force or manager.canvas.figure.stale:; --> 131 manager.canvas.draw_idle(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backend_bases.py:1919, in FigureCanvasBase.draw_idle(self, *args, **kwargs); 1917 if not self._is_idle_drawing:; 1918 with self._idle_draw_cntx():; -> 1919 self.draw(*args, **kwargs). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backends/backend_agg.py:387, in FigureCanvasAgg.draw(self); 384 # Acquire a lock on the shared font cache.; 385 with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 386 else nullcontext()):; --> 387 self.figure.draw(self.renderer); 388 # A GUI class may be need to update a window using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903
https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:1798,Integrability,wrap,wraps,1798,"31 manager.canvas.draw_idle(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backend_bases.py:1919, in FigureCanvasBase.draw_idle(self, *args, **kwargs); 1917 if not self._is_idle_drawing:; 1918 with self._idle_draw_cntx():; -> 1919 self.draw(*args, **kwargs). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backends/backend_agg.py:387, in FigureCanvasAgg.draw(self); 384 # Acquire a lock on the shared font cache.; 385 with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 386 else nullcontext()):; --> 387 self.figure.draw(self.renderer); 388 # A GUI class may be need to update a window using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:72, in allow_rasterization.<locals>.draw_wrapper(artist, renderer); 69 if artist.get_agg_filter() is not None:; 70 renderer.start_filter(); ---> 72 return draw(artist, renderer); 73 finally:; 74 if artist.get_agg_filter() is not None:. File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/figure.py:3155, in Figure.draw(self, renderer); 3152 # ValueError can occur when resizing a window.; 3154 self.patch.draw(renderer); -> 3155 mimage._draw_list_compositing_images(; 3156 renderer, self, artists, self.suppressComposite); 3158 renderer.close_group('figure'); 3159 finally:. File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/image.py:132, in _draw_list_compositing_images(renderer, pare",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903
https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:1332,Performance,cache,cache,1332,"--------------; TypeError Traceback (most recent call last); File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/pyplot.py:265, in _draw_all_if_interactive(); 263 def _draw_all_if_interactive() -> None:; 264 if matplotlib.is_interactive():; --> 265 draw_all(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/_pylab_helpers.py:131, in Gcf.draw_all(cls, force); 129 for manager in cls.get_all_fig_managers():; 130 if force or manager.canvas.figure.stale:; --> 131 manager.canvas.draw_idle(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backend_bases.py:1919, in FigureCanvasBase.draw_idle(self, *args, **kwargs); 1917 if not self._is_idle_drawing:; 1918 with self._idle_draw_cntx():; -> 1919 self.draw(*args, **kwargs). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backends/backend_agg.py:387, in FigureCanvasAgg.draw(self); 384 # Acquire a lock on the shared font cache.; 385 with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 386 else nullcontext()):; --> 387 self.figure.draw(self.renderer); 388 # A GUI class may be need to update a window using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:72, in allow_rasterization.<locals>.draw_wrapper(artist, renderer); 69 if artist.get_agg_filter() is not None:; 70 renderer.start_filter(); ---> 72 return draw(artist, renderer); 73 finally:; 74 if artist.get_agg_filter() is",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903
https://github.com/qutip/qutip/issues/2400#issuecomment-2146968944:98,Availability,error,error,98,I can reproduce it with matplotlib `3.9` but actually I am not sure if it is a qutip problem. The error message seems pure matplotlib,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2146968944
https://github.com/qutip/qutip/issues/2400#issuecomment-2146968944:104,Integrability,message,message,104,I can reproduce it with matplotlib `3.9` but actually I am not sure if it is a qutip problem. The error message seems pure matplotlib,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2146968944
https://github.com/qutip/qutip/pull/2401#issuecomment-2072875831:105,Deployability,release,release,105,"> Thank you for the fix. Could you add a towncrier entry so we don't forget your contribution during new release. I had forgotten. Thank you, it is added!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2401#issuecomment-2072875831
https://github.com/qutip/qutip/issues/2406#issuecomment-2074966338:362,Integrability,wrap,wrap,362,"Thanks for pointing this out.. I had a quick play around, this seems to be some overhead from the normalization flag in mesolve. In v5 if I use ` options = {""normalize_output"": False}` I see basically same runtimes as v4.7. we should probably think about making this default to false if its having such a big cost. To make it really ""like for like"" you can also wrap it so that it uses CSR format for everything . ```; with qt.CoreOptions(default_dtype=""csr""):; kwargs = init(); options = {""normalize_output"": False}; %timeit qt.mesolve(**kwargs, options = options); ```. Which data-type is best for is a bit problem dependent. let us know if this gives you comparable results!. On the topic of dynamiqs, you might be interested in trying out the jax/jaxdia data layer, there's some examples here ; https://github.com/nwlambert/QuTiP-Jax-GPU-example. We also tried this example with dynamiqs (with its double precision setting), I think you guys came out slightly ahead speed-wise because I think you dont vectorize/use superoperators, which seems to suit jax/diffrax! though if i did that manually with qutip we essentially get the same, which I guess makes sense. The jaxdia data layer lets us go to a few more spins (more with sesolve, not so many with mesolve!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2406#issuecomment-2074966338
https://github.com/qutip/qutip/issues/2406#issuecomment-2074966338:617,Integrability,depend,dependent,617,"Thanks for pointing this out.. I had a quick play around, this seems to be some overhead from the normalization flag in mesolve. In v5 if I use ` options = {""normalize_output"": False}` I see basically same runtimes as v4.7. we should probably think about making this default to false if its having such a big cost. To make it really ""like for like"" you can also wrap it so that it uses CSR format for everything . ```; with qt.CoreOptions(default_dtype=""csr""):; kwargs = init(); options = {""normalize_output"": False}; %timeit qt.mesolve(**kwargs, options = options); ```. Which data-type is best for is a bit problem dependent. let us know if this gives you comparable results!. On the topic of dynamiqs, you might be interested in trying out the jax/jaxdia data layer, there's some examples here ; https://github.com/nwlambert/QuTiP-Jax-GPU-example. We also tried this example with dynamiqs (with its double precision setting), I think you guys came out slightly ahead speed-wise because I think you dont vectorize/use superoperators, which seems to suit jax/diffrax! though if i did that manually with qutip we essentially get the same, which I guess makes sense. The jaxdia data layer lets us go to a few more spins (more with sesolve, not so many with mesolve!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2406#issuecomment-2074966338
https://github.com/qutip/qutip/pull/2408#issuecomment-2077231842:787,Integrability,depend,dependant,787,"The only operator we normalise are density matrices, so `isoper` work as well. Propagator computation turn the normalisation off. Other cases should only happen when the user pass an arbitrary super operator. I which case they probably don't want any normalisation on our side. My issue is that in these cases, we still set the `isherm` flag while not having any ideas what the user is trying to do:; ```; >>> H = qt.qeye(2) * 1j; >>> L = qt.spre(H); >>> qt.mesolve(L, qt.basis(2,1), [0, 1]).final_state; Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[0.+0.j 0.+0.j ]; [0.+0.j 1.+1.55740849j]]; ```. We don't set the flag when the input are super operators? We try to check if the Liouvillian preserve hermiticity (not easy for time dependant operator)? Junk in, junk out?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2408#issuecomment-2077231842
https://github.com/qutip/qutip/pull/2408#issuecomment-2078385711:264,Integrability,depend,dependant,264,"> My issue is that in these cases, we still set the `isherm` flag while not having any ideas what the user is trying to do:; > ; > We don't set the flag when the input are super operators? We try to check if the Liouvillian preserve hermiticity (not easy for time dependant operator)? Junk in, junk out?. A problem can also happen if the input is not a superoperator:. ```; H = qt.sigmaz() + 1j * qt.sigmax(); initial = qt.ket2dm(qt.basis(2, 0)); qt.mesolve(H, initial, [0, 1], c_ops=[qt.sigmam()]).final_state; > Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; > Qobj data =; > [[ 0.51118445+0.j -0.11358048+0.24945183j]; > [ 0.11358048+0.24945183j 0.32517255+0.j ]]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2408#issuecomment-2078385711
https://github.com/qutip/qutip/issues/2412#issuecomment-2085295423:187,Deployability,install,install,187,"Version 5 does not officially support python 3.8.; We seems to have miss something in the requirement needed to have pip find version 4 instead. If you really want v5, you could probably install it without build-isolation, something like:; ```; pip install numpy>=1.19.0 scipy>=1.8.0 cython==0.27.37 setuptools packaging ; pip install --no-build-isolation qutip; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2085295423
https://github.com/qutip/qutip/issues/2412#issuecomment-2085295423:249,Deployability,install,install,249,"Version 5 does not officially support python 3.8.; We seems to have miss something in the requirement needed to have pip find version 4 instead. If you really want v5, you could probably install it without build-isolation, something like:; ```; pip install numpy>=1.19.0 scipy>=1.8.0 cython==0.27.37 setuptools packaging ; pip install --no-build-isolation qutip; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2085295423
https://github.com/qutip/qutip/issues/2412#issuecomment-2085295423:327,Deployability,install,install,327,"Version 5 does not officially support python 3.8.; We seems to have miss something in the requirement needed to have pip find version 4 instead. If you really want v5, you could probably install it without build-isolation, something like:; ```; pip install numpy>=1.19.0 scipy>=1.8.0 cython==0.27.37 setuptools packaging ; pip install --no-build-isolation qutip; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2085295423
https://github.com/qutip/qutip/issues/2412#issuecomment-2085323516:192,Deployability,install,installation,192,"> Version 5 does not officially support python 3.8. Oh, I saw nothing about this in the [changelog](https://qutip.readthedocs.io/en/v5.0.1/changelog.html) nor the [requirements section of the installation instructions](https://qutip.readthedocs.io/en/v5.0.1/installation.html#general-requirements), which says Python 3.6+ is supported. I will try with the `--no-build-isolation` once I get back to my computer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2085323516
https://github.com/qutip/qutip/issues/2412#issuecomment-2085323516:258,Deployability,install,installation,258,"> Version 5 does not officially support python 3.8. Oh, I saw nothing about this in the [changelog](https://qutip.readthedocs.io/en/v5.0.1/changelog.html) nor the [requirements section of the installation instructions](https://qutip.readthedocs.io/en/v5.0.1/installation.html#general-requirements), which says Python 3.6+ is supported. I will try with the `--no-build-isolation` once I get back to my computer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2085323516
https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162:21,Availability,error,error,21,"Aha I understand the error now, `oldest-supported-numpy` requires numpy 1.17, but qutip requires >1.19. I tried to install manually with `pip install wheel setuptools packaging numpy cython scipy` and then `pip install --no-build-isolation qutip` but now I get some Cython compilation errors. I think I will stick with v4 for now. I suppose with the updates to the docs in #2413, this issue is resolved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162
https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162:285,Availability,error,errors,285,"Aha I understand the error now, `oldest-supported-numpy` requires numpy 1.17, but qutip requires >1.19. I tried to install manually with `pip install wheel setuptools packaging numpy cython scipy` and then `pip install --no-build-isolation qutip` but now I get some Cython compilation errors. I think I will stick with v4 for now. I suppose with the updates to the docs in #2413, this issue is resolved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162
https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162:115,Deployability,install,install,115,"Aha I understand the error now, `oldest-supported-numpy` requires numpy 1.17, but qutip requires >1.19. I tried to install manually with `pip install wheel setuptools packaging numpy cython scipy` and then `pip install --no-build-isolation qutip` but now I get some Cython compilation errors. I think I will stick with v4 for now. I suppose with the updates to the docs in #2413, this issue is resolved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162
https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162:142,Deployability,install,install,142,"Aha I understand the error now, `oldest-supported-numpy` requires numpy 1.17, but qutip requires >1.19. I tried to install manually with `pip install wheel setuptools packaging numpy cython scipy` and then `pip install --no-build-isolation qutip` but now I get some Cython compilation errors. I think I will stick with v4 for now. I suppose with the updates to the docs in #2413, this issue is resolved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162
https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162:211,Deployability,install,install,211,"Aha I understand the error now, `oldest-supported-numpy` requires numpy 1.17, but qutip requires >1.19. I tried to install manually with `pip install wheel setuptools packaging numpy cython scipy` and then `pip install --no-build-isolation qutip` but now I get some Cython compilation errors. I think I will stick with v4 for now. I suppose with the updates to the docs in #2413, this issue is resolved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162
https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162:350,Deployability,update,updates,350,"Aha I understand the error now, `oldest-supported-numpy` requires numpy 1.17, but qutip requires >1.19. I tried to install manually with `pip install wheel setuptools packaging numpy cython scipy` and then `pip install --no-build-isolation qutip` but now I get some Cython compilation errors. I think I will stick with v4 for now. I suppose with the updates to the docs in #2413, this issue is resolved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2412#issuecomment-2092495162
https://github.com/qutip/qutip/pull/2416#issuecomment-2094907328:135,Testability,test,tests,135,Note to reviewers:; - Codeclimate is not passing because too many return statements... It's an easy fix but is it worth it?; - Current tests already test for this new implementation (for two and three qubits),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094907328
https://github.com/qutip/qutip/pull/2416#issuecomment-2094907328:149,Testability,test,test,149,Note to reviewers:; - Codeclimate is not passing because too many return statements... It's an easy fix but is it worth it?; - Current tests already test for this new implementation (for two and three qubits),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094907328
https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281:342,Availability,reliab,reliably,342,"Thanks for reviewing! Sounds good, will make those changes ASAP. . Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. I have done a lot of testing independently though and the implementation seems to work very reliably (often giving more accurate results than the semidefinite program).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281
https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281:101,Deployability,install,install,101,"Thanks for reviewing! Sounds good, will make those changes ASAP. . Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. I have done a lot of testing independently though and the implementation seems to work very reliably (often giving more accurate results than the semidefinite program).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281
https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281:240,Deployability,pipeline,pipeline,240,"Thanks for reviewing! Sounds good, will make those changes ASAP. . Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. I have done a lot of testing independently though and the implementation seems to work very reliably (often giving more accurate results than the semidefinite program).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281
https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281:182,Testability,test,tests,182,"Thanks for reviewing! Sounds good, will make those changes ASAP. . Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. I have done a lot of testing independently though and the implementation seems to work very reliably (often giving more accurate results than the semidefinite program).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281
https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281:271,Testability,test,testing,271,"Thanks for reviewing! Sounds good, will make those changes ASAP. . Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. I have done a lot of testing independently though and the implementation seems to work very reliably (often giving more accurate results than the semidefinite program).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094916281
https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396:36,Deployability,install,install,36,"> Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. That's fine. The CI pipeline does test with cvxpy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396
https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396:175,Deployability,pipeline,pipeline,175,"> Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. That's fine. The CI pipeline does test with cvxpy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396
https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396:205,Deployability,pipeline,pipeline,205,"> Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. That's fine. The CI pipeline does test with cvxpy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396
https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396:117,Testability,test,tests,117,"> Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. That's fine. The CI pipeline does test with cvxpy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396
https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396:219,Testability,test,test,219,"> Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. That's fine. The CI pipeline does test with cvxpy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396
https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691:441,Deployability,pipeline,pipeline,441,"Made another quick change. We know from Prop. 3.44 of (Watrous, 2018) that the diamond norm of CPTP channel is 1. So I added a quick `if` statement that checks this. Also refactored `dnorm` so there's only one return statement to make code climate happy. Looks like it's unhappy with something else and maybe made the logic harder to follow. Please advise if you have a preference. Again, can't really run tests locally, so approving the CI pipeline would be fantastic.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691
https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691:171,Modifiability,refactor,refactored,171,"Made another quick change. We know from Prop. 3.44 of (Watrous, 2018) that the diamond norm of CPTP channel is 1. So I added a quick `if` statement that checks this. Also refactored `dnorm` so there's only one return statement to make code climate happy. Looks like it's unhappy with something else and maybe made the logic harder to follow. Please advise if you have a preference. Again, can't really run tests locally, so approving the CI pipeline would be fantastic.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691
https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691:318,Testability,log,logic,318,"Made another quick change. We know from Prop. 3.44 of (Watrous, 2018) that the diamond norm of CPTP channel is 1. So I added a quick `if` statement that checks this. Also refactored `dnorm` so there's only one return statement to make code climate happy. Looks like it's unhappy with something else and maybe made the logic harder to follow. Please advise if you have a preference. Again, can't really run tests locally, so approving the CI pipeline would be fantastic.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691
https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691:406,Testability,test,tests,406,"Made another quick change. We know from Prop. 3.44 of (Watrous, 2018) that the diamond norm of CPTP channel is 1. So I added a quick `if` statement that checks this. Also refactored `dnorm` so there's only one return statement to make code climate happy. Looks like it's unhappy with something else and maybe made the logic harder to follow. Please advise if you have a preference. Again, can't really run tests locally, so approving the CI pipeline would be fantastic.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691
https://github.com/qutip/qutip/pull/2416#issuecomment-2102739118:135,Deployability,release,release,135,"Hi @Ericgig and @hodgestar. As it's the first time I've contributed, I was curious what the process is to merge. Do you wait for a new release or is it merged to `main` as soon as the PR has been approved?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2102739118
https://github.com/qutip/qutip/pull/2418#issuecomment-2096947774:200,Integrability,depend,dependabot,200,[![Coverage Status](https://coveralls.io/builds/67331867/badge)](https://coveralls.io/builds/67331867). coverage: 86.09%. remained the same; when pulling **cd85b13838714b55b18b7471d9ba9885be47d55f on dependabot/pip/doc/jinja2-3.1.4**; into **b6ed047def88f220318cb6337a4cfbf59971ce72 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2418#issuecomment-2096947774
https://github.com/qutip/qutip/pull/2421#issuecomment-2108725817:136,Availability,down,downstream,136,Numpy is maintaining a list of project versions that support numpy 2 -- https://github.com/numpy/numpy/issues/26191. They're waiting of downstream packages to be ready before release. We could add ourselves there if we liked.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2421#issuecomment-2108725817
https://github.com/qutip/qutip/pull/2421#issuecomment-2108725817:175,Deployability,release,release,175,Numpy is maintaining a list of project versions that support numpy 2 -- https://github.com/numpy/numpy/issues/26191. They're waiting of downstream packages to be ready before release. We could add ourselves there if we liked.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2421#issuecomment-2108725817
https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018:108,Availability,error,errors,108,"I actually have a question about this automatic normalization. Do we really need this to hide the numerical errors? Wouldn't it be better to just expose the error since it will be proportional to `atol` anyway (and if not, something went wrong)? Which group of users will this auto-normalization benefit?. Sometimes an unnormalised state at the ends can also indicate that there is something wrong with the Hamiltonian, e.g., it is not hermitian due to some typos.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018
https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018:157,Availability,error,error,157,"I actually have a question about this automatic normalization. Do we really need this to hide the numerical errors? Wouldn't it be better to just expose the error since it will be proportional to `atol` anyway (and if not, something went wrong)? Which group of users will this auto-normalization benefit?. Sometimes an unnormalised state at the ends can also indicate that there is something wrong with the Hamiltonian, e.g., it is not hermitian due to some typos.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018
https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018:146,Security,expose,expose,146,"I actually have a question about this automatic normalization. Do we really need this to hide the numerical errors? Wouldn't it be better to just expose the error since it will be proportional to `atol` anyway (and if not, something went wrong)? Which group of users will this auto-normalization benefit?. Sometimes an unnormalised state at the ends can also indicate that there is something wrong with the Hamiltonian, e.g., it is not hermitian due to some typos.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018
https://github.com/qutip/qutip/pull/2427#issuecomment-2115919319:81,Availability,error,error,81,"We mostly added it to `mesolve` since we always had it for `sesolve`.; Numerical error is not well understood by all users and we can get issues that the solver are wrong because the trace, norm, populations etc. is not constant.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2427#issuecomment-2115919319
https://github.com/qutip/qutip/pull/2429#issuecomment-2116072715:15,Deployability,release,released,15,"Matplolib 3.9 (released 20h ago) is not imported properly in python 3.9:; https://github.com/qutip/qutip/actions/runs/9118045396/job/25070276189; ```; $ conda list; ...; loky 3.4.1 pypi_0 pypi; matplotlib 3.9.0 pypi_0 pypi; matplotlib-inline 0.1.7 pypi_0 pypi; ...; $ python -c ""import qutip; qutip.about()""; /home/runner/work/qutip/qutip/qutip/__init__.py:24: UserWarning: matplotlib not found: Graphics will not work.; ```; In master we no longer support python 3.9, so for the micro release I just set an upper limit on the matplotlib version in python 3.9 tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2429#issuecomment-2116072715
https://github.com/qutip/qutip/pull/2429#issuecomment-2116072715:486,Deployability,release,release,486,"Matplolib 3.9 (released 20h ago) is not imported properly in python 3.9:; https://github.com/qutip/qutip/actions/runs/9118045396/job/25070276189; ```; $ conda list; ...; loky 3.4.1 pypi_0 pypi; matplotlib 3.9.0 pypi_0 pypi; matplotlib-inline 0.1.7 pypi_0 pypi; ...; $ python -c ""import qutip; qutip.about()""; /home/runner/work/qutip/qutip/qutip/__init__.py:24: UserWarning: matplotlib not found: Graphics will not work.; ```; In master we no longer support python 3.9, so for the micro release I just set an upper limit on the matplotlib version in python 3.9 tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2429#issuecomment-2116072715
https://github.com/qutip/qutip/pull/2429#issuecomment-2116072715:560,Testability,test,tests,560,"Matplolib 3.9 (released 20h ago) is not imported properly in python 3.9:; https://github.com/qutip/qutip/actions/runs/9118045396/job/25070276189; ```; $ conda list; ...; loky 3.4.1 pypi_0 pypi; matplotlib 3.9.0 pypi_0 pypi; matplotlib-inline 0.1.7 pypi_0 pypi; ...; $ python -c ""import qutip; qutip.about()""; /home/runner/work/qutip/qutip/qutip/__init__.py:24: UserWarning: matplotlib not found: Graphics will not work.; ```; In master we no longer support python 3.9, so for the micro release I just set an upper limit on the matplotlib version in python 3.9 tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2429#issuecomment-2116072715
https://github.com/qutip/qutip/issues/2431#issuecomment-2118997182:178,Availability,error,error,178,"I updated my qutip to V5 and I tried ; ```; cmap = 'jet'; fig, ax = plot_spin_distribution(Q, THETA, PHI, ""3d"", cmap=cmap); ```; to change the color map of the sphere, but I get error; ```; fig, ax = plot_spin_distribution(Q, THETA, PHI, ""3d"", cmap=cmap); NameError: name 'plot_spin_distribution' is not defined. Did you mean: 'plot_spin_distribution_2d'?; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2431#issuecomment-2118997182
https://github.com/qutip/qutip/issues/2431#issuecomment-2118997182:2,Deployability,update,updated,2,"I updated my qutip to V5 and I tried ; ```; cmap = 'jet'; fig, ax = plot_spin_distribution(Q, THETA, PHI, ""3d"", cmap=cmap); ```; to change the color map of the sphere, but I get error; ```; fig, ax = plot_spin_distribution(Q, THETA, PHI, ""3d"", cmap=cmap); NameError: name 'plot_spin_distribution' is not defined. Did you mean: 'plot_spin_distribution_2d'?; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2431#issuecomment-2118997182
https://github.com/qutip/qutip/pull/2434#issuecomment-2121810266:201,Integrability,depend,dependabot,201,[![Coverage Status](https://coveralls.io/builds/67603901/badge)](https://coveralls.io/builds/67603901). coverage: 86.266%. remained the same; when pulling **0bbe13562c4c4f43d9f229b3654810d6ad080e3c on dependabot/pip/doc/requests-2.32.0**; into **ec617416dd4294fd97f08261dd508c032be84787 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2434#issuecomment-2121810266
https://github.com/qutip/qutip/pull/2435#issuecomment-2123699766:34,Testability,test,test,34,"Thanks @DnMGalan ! can you make a test for it? . Also could you share an example for the issue with the small finite frequency? historically it was there to fix an some edge cases that fail at w=0, but sounds like you found the opposite?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2123699766
https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531:49,Testability,test,test,49,"Hi @nwlambert,. Sure! This is the code I used to test the changes:. ```; import numpy as np; from qutip import *. Gamma_r = 0.5; Gamma_l = 0.1. n_ket = (1)/(Gamma_l + Gamma_r)*Qobj([[Gamma_r],[Gamma_l]], ); n_bra = Qobj([[1, 1]]). Id = Qobj([[1, 0], [0, 1]]). L = Qobj([[-Gamma_l, Gamma_r], [Gamma_l, -Gamma_r]],). I_ops = Qobj([[0, Gamma_r], [0, 0]]). L_s = sprepost(L, Id). I_s = sprepost(I_ops, Id). current, noise, skw = third_cumulant(L_s, rhoss=n_ket*n_bra, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""). print(current, noise, skw); ```; It is based in a simple analytical example I found in a paper, which contains the expressions to check the results. This is the paper (page 7, the section ""Toy model""): [here is the paper](https://orbit.dtu.dk/en/publications/current-and-current-fluctuations-in-quantum-shuttles). As you can see it is really simple, although I had to make some changes to be able to applied in QuTip (I hope this doesn't lead to major fails). The effect of the frequency for the case when it is not defined in the function can be observed using the same example, just don't modify that part and you will see it, then you can try the solution I propose ( I don't know if I explained myself correctly).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531
https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531:569,Usability,simpl,simple,569,"Hi @nwlambert,. Sure! This is the code I used to test the changes:. ```; import numpy as np; from qutip import *. Gamma_r = 0.5; Gamma_l = 0.1. n_ket = (1)/(Gamma_l + Gamma_r)*Qobj([[Gamma_r],[Gamma_l]], ); n_bra = Qobj([[1, 1]]). Id = Qobj([[1, 0], [0, 1]]). L = Qobj([[-Gamma_l, Gamma_r], [Gamma_l, -Gamma_r]],). I_ops = Qobj([[0, Gamma_r], [0, 0]]). L_s = sprepost(L, Id). I_s = sprepost(I_ops, Id). current, noise, skw = third_cumulant(L_s, rhoss=n_ket*n_bra, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""). print(current, noise, skw); ```; It is based in a simple analytical example I found in a paper, which contains the expressions to check the results. This is the paper (page 7, the section ""Toy model""): [here is the paper](https://orbit.dtu.dk/en/publications/current-and-current-fluctuations-in-quantum-shuttles). As you can see it is really simple, although I had to make some changes to be able to applied in QuTip (I hope this doesn't lead to major fails). The effect of the frequency for the case when it is not defined in the function can be observed using the same example, just don't modify that part and you will see it, then you can try the solution I propose ( I don't know if I explained myself correctly).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531
https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531:861,Usability,simpl,simple,861,"Hi @nwlambert,. Sure! This is the code I used to test the changes:. ```; import numpy as np; from qutip import *. Gamma_r = 0.5; Gamma_l = 0.1. n_ket = (1)/(Gamma_l + Gamma_r)*Qobj([[Gamma_r],[Gamma_l]], ); n_bra = Qobj([[1, 1]]). Id = Qobj([[1, 0], [0, 1]]). L = Qobj([[-Gamma_l, Gamma_r], [Gamma_l, -Gamma_r]],). I_ops = Qobj([[0, Gamma_r], [0, 0]]). L_s = sprepost(L, Id). I_s = sprepost(I_ops, Id). current, noise, skw = third_cumulant(L_s, rhoss=n_ket*n_bra, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""). print(current, noise, skw); ```; It is based in a simple analytical example I found in a paper, which contains the expressions to check the results. This is the paper (page 7, the section ""Toy model""): [here is the paper](https://orbit.dtu.dk/en/publications/current-and-current-fluctuations-in-quantum-shuttles). As you can see it is really simple, although I had to make some changes to be able to applied in QuTip (I hope this doesn't lead to major fails). The effect of the frequency for the case when it is not defined in the function can be observed using the same example, just don't modify that part and you will see it, then you can try the solution I propose ( I don't know if I explained myself correctly).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531
https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607:86,Integrability,depend,dependence,86,"thanks Dani, I think if you encode the problem in a more standard qutip structure the dependence on the small frequencies disappears;; ```; d = destroy(2).dag(); L_s = liouvillian(0*d.dag()*d, [np.sqrt(Gamma_l) *d, np.sqrt(Gamma_r) *d.dag()]); rho_ss = steadystate(L_s); I_s = Gamma_r * sprepost(d.dag(),d); current, noise, skw = third_cumulant(L_s, rhoss=rho_ss, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""); ```. So I would prefer to revert the pseudo_inverse change (which is there originally to catch a different issue with the noise exploding). But nice example! this would make a great test I think. For the third_cumulant itself, maybe better to combine with the existing countstat_current_noise function, and provide the third cumulant, and support J_ops!=I_ops, as options?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607
https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607:601,Testability,test,test,601,"thanks Dani, I think if you encode the problem in a more standard qutip structure the dependence on the small frequencies disappears;; ```; d = destroy(2).dag(); L_s = liouvillian(0*d.dag()*d, [np.sqrt(Gamma_l) *d, np.sqrt(Gamma_r) *d.dag()]); rho_ss = steadystate(L_s); I_s = Gamma_r * sprepost(d.dag(),d); current, noise, skw = third_cumulant(L_s, rhoss=rho_ss, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""); ```. So I would prefer to revert the pseudo_inverse change (which is there originally to catch a different issue with the noise exploding). But nice example! this would make a great test I think. For the third_cumulant itself, maybe better to combine with the existing countstat_current_noise function, and provide the third cumulant, and support J_ops!=I_ops, as options?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607
https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:152,Energy Efficiency,efficient,efficient,152,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230
https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:1026,Modifiability,variab,variable,1026,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230
https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:79,Safety,avoid,avoid,79,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230
https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:290,Safety,avoid,avoids,290,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230
https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:312,Testability,log,logic,312,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230
https://github.com/qutip/qutip/pull/2435#issuecomment-2183962093:7,Deployability,update,update,7,"I will update this pull request so that it is ready for review, although, I think maybe some changes in the code style will be needed. One thing I would like to mention is that the _noise_direct function seems to yield a more accurate result than the noise_pseudoinv function, this may be due to the selected method (for the case of noise_pseudoinv), the discussion we had at the beginning about not including the low value of the frenquency or some mistake I made testing? In any case I just wanted to point out that even though both functions work, noise_direct gives a more accurate result to the analytical one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2183962093
https://github.com/qutip/qutip/pull/2435#issuecomment-2183962093:465,Testability,test,testing,465,"I will update this pull request so that it is ready for review, although, I think maybe some changes in the code style will be needed. One thing I would like to mention is that the _noise_direct function seems to yield a more accurate result than the noise_pseudoinv function, this may be due to the selected method (for the case of noise_pseudoinv), the discussion we had at the beginning about not including the low value of the frenquency or some mistake I made testing? In any case I just wanted to point out that even though both functions work, noise_direct gives a more accurate result to the analytical one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2183962093
https://github.com/qutip/qutip/pull/2437#issuecomment-2139114804:37,Testability,test,tests,37,Hm I'll have a look at those failing tests next week. But probably just too few times in `tlist`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2437#issuecomment-2139114804
https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143:546,Deployability,update,updated,546,"Thanks for the review!. > * Should we stop the user from passing a list of kets to `mcsolve` directly?; > Presently it work but it's not documented (and list `ntraj` don't.). You are right, done. Of course we could also allow the same arguments for `mcsolve` as for `run`, but I thought it might be good to keep the `mcsolve` interface simpler. > * It would be nice to have the trajectories per initial state information stored in the result somewhere. I have added that information and checking it in a test. Edit: I forgot that I still haven't updated the docs. Will do that. Edit 2: Done",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143
https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143:326,Integrability,interface,interface,326,"Thanks for the review!. > * Should we stop the user from passing a list of kets to `mcsolve` directly?; > Presently it work but it's not documented (and list `ntraj` don't.). You are right, done. Of course we could also allow the same arguments for `mcsolve` as for `run`, but I thought it might be good to keep the `mcsolve` interface simpler. > * It would be nice to have the trajectories per initial state information stored in the result somewhere. I have added that information and checking it in a test. Edit: I forgot that I still haven't updated the docs. Will do that. Edit 2: Done",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143
https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143:504,Testability,test,test,504,"Thanks for the review!. > * Should we stop the user from passing a list of kets to `mcsolve` directly?; > Presently it work but it's not documented (and list `ntraj` don't.). You are right, done. Of course we could also allow the same arguments for `mcsolve` as for `run`, but I thought it might be good to keep the `mcsolve` interface simpler. > * It would be nice to have the trajectories per initial state information stored in the result somewhere. I have added that information and checking it in a test. Edit: I forgot that I still haven't updated the docs. Will do that. Edit 2: Done",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143
https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143:336,Usability,simpl,simpler,336,"Thanks for the review!. > * Should we stop the user from passing a list of kets to `mcsolve` directly?; > Presently it work but it's not documented (and list `ntraj` don't.). You are right, done. Of course we could also allow the same arguments for `mcsolve` as for `run`, but I thought it might be good to keep the `mcsolve` interface simpler. > * It would be nice to have the trajectories per initial state information stored in the result somewhere. I have added that information and checking it in a test. Edit: I forgot that I still haven't updated the docs. Will do that. Edit 2: Done",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2437#issuecomment-2149017143
https://github.com/qutip/qutip/issues/2438#issuecomment-2134117269:31,Deployability,upgrade,upgraded,31,"Thanks for your quick reply, I upgraded qutip and the issue is indeed fixed",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2438#issuecomment-2134117269
https://github.com/qutip/qutip/pull/2439#issuecomment-2137151588:207,Deployability,update,updates,207,[![Coverage Status](https://coveralls.io/builds/67764030/badge)](https://coveralls.io/builds/67764030). coverage: 86.27%. first build; when pulling **bb554d0ecb8d299e3fd859ba2218c82d62ef58ed on pmenczel:doc-updates**; into **e450d6df3cb54961e455234c37c4abe84d614039 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2439#issuecomment-2137151588
https://github.com/qutip/qutip/pull/2441#issuecomment-2141948066:55,Usability,guid,guide,55,"Good point, I didn't notice that it is under the basic guide section. What about add it as a subsection (Quantum Gates) after [Qubit (two-level) systems](https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-states.html#qubit-two-level-systems).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2141948066
https://github.com/qutip/qutip/pull/2441#issuecomment-2141948066:198,Usability,guid,guide,198,"Good point, I didn't notice that it is under the basic guide section. What about add it as a subsection (Quantum Gates) after [Qubit (two-level) systems](https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-states.html#qubit-two-level-systems).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2141948066
https://github.com/qutip/qutip/pull/2441#issuecomment-2141948066:204,Usability,guid,guide-states,204,"Good point, I didn't notice that it is under the basic guide section. What about add it as a subsection (Quantum Gates) after [Qubit (two-level) systems](https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-states.html#qubit-two-level-systems).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2141948066
https://github.com/qutip/qutip/pull/2441#issuecomment-2142731183:43,Deployability,update,update,43,"Hi, thanks for the feedback. I will try to update it taking these comments into account. The names of the gates in the table are the same that appear in https://github.com/qutip/qutip/blob/master/qutip/core/gates.py, I can put them in lowercase to exactly match the functions in the code. I also see that the module ""qutip.core.gates"" is missing in [ https://qutip.readthedocs.io/en/master/_modules/index.html](url) so I will also added there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2142731183
https://github.com/qutip/qutip/pull/2441#issuecomment-2142731183:19,Usability,feedback,feedback,19,"Hi, thanks for the feedback. I will try to update it taking these comments into account. The names of the gates in the table are the same that appear in https://github.com/qutip/qutip/blob/master/qutip/core/gates.py, I can put them in lowercase to exactly match the functions in the code. I also see that the module ""qutip.core.gates"" is missing in [ https://qutip.readthedocs.io/en/master/_modules/index.html](url) so I will also added there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2142731183
https://github.com/qutip/qutip/pull/2441#issuecomment-2144146337:223,Safety,detect,detected,223,"Hi, is the first time that I use sphinx and I am having trouble generating the apidoc. I understand that I have to run sphinx-apidoc to generate the .rst files from /qutip but I don't know where to put them, so they can be detected by autodoc. I tried but every time I run ""make html"" I get ""autodoc: failed to import module"".",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2144146337
https://github.com/qutip/qutip/pull/2441#issuecomment-2144791759:366,Usability,simpl,simply,366,"I think you don't need to generate the apidoc manually. To add the API docs, all you need is to add the path `qutip.core.gates` to https://github.com/qutip/qutip/blob/master/doc/apidoc/functions.rst#quantum-objects. `make html` should then automatically read all the functions in the file and generate the API doc. To modify the API doc, e.g. adding new things, one simply edits the docstrings in each of the Python function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2144791759
https://github.com/qutip/qutip/pull/2441#issuecomment-2148198178:368,Usability,simpl,simply,368,"> I think you don't need to generate the apidoc manually. To add the API docs, all you need is to add the path `qutip.core.gates` to https://github.com/qutip/qutip/blob/master/doc/apidoc/functions.rst#quantum-objects. `make html` should then automatically read all the functions in the file and generate the API doc. To modify the API doc, e.g. adding new things, one simply edits the docstrings in each of the Python function. Yes, that was the first thing that I have tried but I think there is a problem with the env and the python version. I did the same with qutip-qip docs with no problems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148198178
https://github.com/qutip/qutip/pull/2441#issuecomment-2148346368:104,Availability,error,error,104,"Could you push the code you have right now? We have CI that builds documentation, which will reveal the error you mentioned in more detail. Maybe I can help then.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148346368
https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068:143,Energy Efficiency,charge,charge,143,"The CI is still running but have you tried to align with other qutip API docs like this?; ```; .. automodule:: qutip.core.operators; :members: charge, commutator, create, destroy, displace, fcreate, fdestroy, jmat, num, qeye, identity, momentum, phase, position, qdiags, qutrit_ops, qzero, sigmam, sigmap, sigmax, sigmay, sigmaz, spin_Jx, spin_Jy, spin_Jz, spin_Jm, spin_Jp, squeeze, squeezing, tunneling, qeye_like, qzero_like; ```; I am not sure if autosummary is fully configured in qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068
https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068:472,Modifiability,config,configured,472,"The CI is still running but have you tried to align with other qutip API docs like this?; ```; .. automodule:: qutip.core.operators; :members: charge, commutator, create, destroy, displace, fcreate, fdestroy, jmat, num, qeye, identity, momentum, phase, position, qdiags, qutrit_ops, qzero, sigmam, sigmap, sigmax, sigmay, sigmaz, spin_Jx, spin_Jy, spin_Jz, spin_Jm, spin_Jp, squeeze, squeezing, tunneling, qeye_like, qzero_like; ```; I am not sure if autosummary is fully configured in qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068
https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542:17,Availability,error,error,17,"According to the error message; ```; WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); ```; That should be the error source. Lets use; ```; .. automodule:: qutip.core.gates; :members: ...; ```; first and see if it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542
https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542:421,Availability,error,error,421,"According to the error message; ```; WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); ```; That should be the error source. Lets use; ```; .. automodule:: qutip.core.gates; :members: ...; ```; first and see if it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542
https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542:23,Integrability,message,message,23,"According to the error message; ```; WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); ```; That should be the error source. Lets use; ```; .. automodule:: qutip.core.gates; :members: ...; ```; first and see if it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542
https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542:118,Modifiability,inherit,inheritance,118,"According to the error message; ```; WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); ```; That should be the error source. Lets use; ```; .. automodule:: qutip.core.gates; :members: ...; ```; first and see if it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542
https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542:256,Modifiability,inherit,inheritance,256,"According to the error message; ```; WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); ```; That should be the error source. Lets use; ```; .. automodule:: qutip.core.gates; :members: ...; ```; first and see if it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542
https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661:19,Availability,error,error,19,"> According to the error message; > ; > ```; > WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); > WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); > ```; > ; > That should be the error source. Lets use; > ; > ```; > .. automodule:: qutip.core.gates; > :members: ...; > ```; > ; > first and see if it works. Thank you, lets try that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661
https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661:441,Availability,error,error,441,"> According to the error message; > ; > ```; > WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); > WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); > ```; > ; > That should be the error source. Lets use; > ; > ```; > .. automodule:: qutip.core.gates; > :members: ...; > ```; > ; > first and see if it works. Thank you, lets try that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661
https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661:25,Integrability,message,message,25,"> According to the error message; > ; > ```; > WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); > WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); > ```; > ; > That should be the error source. Lets use; > ; > ```; > .. automodule:: qutip.core.gates; > :members: ...; > ```; > ; > first and see if it works. Thank you, lets try that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661
https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661:128,Modifiability,inherit,inheritance,128,"> According to the error message; > ; > ```; > WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); > WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); > ```; > ; > That should be the error source. Lets use; > ; > ```; > .. automodule:: qutip.core.gates; > :members: ...; > ```; > ; > first and see if it works. Thank you, lets try that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661
https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661:268,Modifiability,inherit,inheritance,268,"> According to the error message; > ; > ```; > WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); > WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); > ```; > ; > That should be the error source. Lets use; > ; > ```; > .. automodule:: qutip.core.gates; > :members: ...; > ```; > ; > first and see if it works. Thank you, lets try that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661
https://github.com/qutip/qutip/pull/2441#issuecomment-2154798793:162,Usability,guid,guide,162,Any new progress on this? The API doc is generated successfully. Although it would be nice to have more detailed description to each functions. The rendered user guide now reads like; ![image](https://github.com/qutip/qutip/assets/12125783/e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07); with names as strings. It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians. ![image](https://github.com/qutip/qutip/assets/12125783/ad856f69-e0f2-49a2-9ab0-f88e84444373),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2154798793
https://github.com/qutip/qutip/pull/2441#issuecomment-2154798793:453,Usability,guid,guide,453,Any new progress on this? The API doc is generated successfully. Although it would be nice to have more detailed description to each functions. The rendered user guide now reads like; ![image](https://github.com/qutip/qutip/assets/12125783/e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07); with names as strings. It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians. ![image](https://github.com/qutip/qutip/assets/12125783/ad856f69-e0f2-49a2-9ab0-f88e84444373),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2154798793
https://github.com/qutip/qutip/pull/2441#issuecomment-2154798793:459,Usability,guid,guide-tensor,459,Any new progress on this? The API doc is generated successfully. Although it would be nice to have more detailed description to each functions. The rendered user guide now reads like; ![image](https://github.com/qutip/qutip/assets/12125783/e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07); with names as strings. It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians. ![image](https://github.com/qutip/qutip/assets/12125783/ad856f69-e0f2-49a2-9ab0-f88e84444373),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2154798793
https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051:2208,Deployability,update,update,2208,"e-user-images.githubusercontent.com/12125783/337660051-e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjAwNTEtZTRmYTNkMGEtY2E1YS00MGU3LWFiNWItMjgzYzMwZjBkZTA3LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTk5YmExMTE2NGZhZmFmZWZiYjQ2YTU0ZTlmOWNmZDg1MzI5NWQyM2UxNWIzNDUwYWYwOTdjNmZhYzU2ZDBlZDAmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.c_jkyvIGwDUsmTXLIAr5LI0-u2IhfVNWo2orjBvElfk) with names as strings.; > ; > It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians; > ; > ![image](https://private-user-images.githubusercontent.com/12125783/337661271-ad856f69-e0f2-49a2-9ab0-f88e84444373.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjEyNzEtYWQ4NTZmNjktZTBmMi00OWEyLTlhYjAtZjg4ZTg0NDQ0MzczLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTAzYTljNGFhMDMxY2RkNmU1ZWRiZjk1YzNkODllNjdjOTlkNDIxMDBhNDgxOTI0MWEyNmFlZjM1MTZjY2I5NTkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.D6pMkAw1y3WWyirs_J8dFthmGjY4V6rIMr6JUHYZ19Y). Thank you for being so clear with the explanation, now I am able to build the html. I have done this update.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051
https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051:171,Usability,guid,guide,171,> Any new progress on this? The API doc is generated successfully. Although it would be nice to have more detailed description to each functions.; > ; > The rendered user guide now reads like ![image](https://private-user-images.githubusercontent.com/12125783/337660051-e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjAwNTEtZTRmYTNkMGEtY2E1YS00MGU3LWFiNWItMjgzYzMwZjBkZTA3LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTk5YmExMTE2NGZhZmFmZWZiYjQ2YTU0ZTlmOWNmZDg1MzI5NWQyM2UxNWIzNDUwYWYwOTdjNmZhYzU2ZDBlZDAmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.c_jkyvIGwDUsmTXLIAr5LI0-u2IhfVNWo2orjBvElfk) with names as strings.; > ; > It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians; > ; > ![image](https://private-user-images.githubusercontent.com/12125783/337661271-ad856f69-e0f2-49a2-9ab0-f88e84444373.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjEyNzEtYWQ4NTZmNjktZTBmMi00OWEyLTlhYjAtZjg4ZTg0NDQ0MzczLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTAzYTljNGFhMDMxY2RkNmU1ZWRiZjk1YzNkODllNjdjOTlkNDIxMDBhNDgxOTI0MWEyNmFlZjM1MTZjY2I5NTkmWC1BbXotU2lnbmVk,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051
https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051:1202,Usability,guid,guide,1202,"rivate-user-images.githubusercontent.com/12125783/337660051-e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjAwNTEtZTRmYTNkMGEtY2E1YS00MGU3LWFiNWItMjgzYzMwZjBkZTA3LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTk5YmExMTE2NGZhZmFmZWZiYjQ2YTU0ZTlmOWNmZDg1MzI5NWQyM2UxNWIzNDUwYWYwOTdjNmZhYzU2ZDBlZDAmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.c_jkyvIGwDUsmTXLIAr5LI0-u2IhfVNWo2orjBvElfk) with names as strings.; > ; > It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians; > ; > ![image](https://private-user-images.githubusercontent.com/12125783/337661271-ad856f69-e0f2-49a2-9ab0-f88e84444373.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjEyNzEtYWQ4NTZmNjktZTBmMi00OWEyLTlhYjAtZjg4ZTg0NDQ0MzczLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTAzYTljNGFhMDMxY2RkNmU1ZWRiZjk1YzNkODllNjdjOTlkNDIxMDBhNDgxOTI0MWEyNmFlZjM1MTZjY2I5NTkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.D6pMkAw1y3WWyirs_J8dFthmGjY4V6rIMr6JUHYZ19Y). Thank you for being so clear with the explanation, now I am able to build the html. I have done this upd",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051
https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051:1208,Usability,guid,guide-tensor,1208,"rivate-user-images.githubusercontent.com/12125783/337660051-e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjAwNTEtZTRmYTNkMGEtY2E1YS00MGU3LWFiNWItMjgzYzMwZjBkZTA3LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTk5YmExMTE2NGZhZmFmZWZiYjQ2YTU0ZTlmOWNmZDg1MzI5NWQyM2UxNWIzNDUwYWYwOTdjNmZhYzU2ZDBlZDAmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.c_jkyvIGwDUsmTXLIAr5LI0-u2IhfVNWo2orjBvElfk) with names as strings.; > ; > It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians; > ; > ![image](https://private-user-images.githubusercontent.com/12125783/337661271-ad856f69-e0f2-49a2-9ab0-f88e84444373.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjEyNzEtYWQ4NTZmNjktZTBmMi00OWEyLTlhYjAtZjg4ZTg0NDQ0MzczLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTAzYTljNGFhMDMxY2RkNmU1ZWRiZjk1YzNkODllNjdjOTlkNDIxMDBhNDgxOTI0MWEyNmFlZjM1MTZjY2I5NTkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.D6pMkAw1y3WWyirs_J8dFthmGjY4V6rIMr6JUHYZ19Y). Thank you for being so clear with the explanation, now I am able to build the html. I have done this upd",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051
https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051:2130,Usability,clear,clear,2130,"e-user-images.githubusercontent.com/12125783/337660051-e4fa3d0a-ca5a-40e7-ab5b-283c30f0de07.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjAwNTEtZTRmYTNkMGEtY2E1YS00MGU3LWFiNWItMjgzYzMwZjBkZTA3LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTk5YmExMTE2NGZhZmFmZWZiYjQ2YTU0ZTlmOWNmZDg1MzI5NWQyM2UxNWIzNDUwYWYwOTdjNmZhYzU2ZDBlZDAmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.c_jkyvIGwDUsmTXLIAr5LI0-u2IhfVNWo2orjBvElfk) with names as strings.; > ; > It would be nice to make them clickable object that links to the function signatures. Like the `tensor` in https://qutip.readthedocs.io/en/qutip-5.0.x/guide/guide-tensor.html#example-constructing-composite-hamiltonians; > ; > ![image](https://private-user-images.githubusercontent.com/12125783/337661271-ad856f69-e0f2-49a2-9ab0-f88e84444373.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTc3NzY1MzMsIm5iZiI6MTcxNzc3NjIzMywicGF0aCI6Ii8xMjEyNTc4My8zMzc2NjEyNzEtYWQ4NTZmNjktZTBmMi00OWEyLTlhYjAtZjg4ZTg0NDQ0MzczLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA2MDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNjA3VDE2MDM1M1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTAzYTljNGFhMDMxY2RkNmU1ZWRiZjk1YzNkODllNjdjOTlkNDIxMDBhNDgxOTI0MWEyNmFlZjM1MTZjY2I5NTkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.D6pMkAw1y3WWyirs_J8dFthmGjY4V6rIMr6JUHYZ19Y). Thank you for being so clear with the explanation, now I am able to build the html. I have done this update.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2155132051
https://github.com/qutip/qutip/pull/2442#issuecomment-2143466419:101,Deployability,update,update,101,"ahh this is the link I referred to, looks like there is not a lot of content on this. I will try and update the code with fixes they have recommended but I think this issue is still ongoing with matplotlib",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2143466419
https://github.com/qutip/qutip/pull/2442#issuecomment-2145034602:134,Deployability,update,updated,134,"So I applied the solution to the code , its doesn't work well in ourcase, their solution does okay for the preset angle ; This is the updated code with custom ordering ; <img width=""661"" alt=""image"" src=""https://github.com/qutip/qutip/assets/54374648/0e02b27c-d09c-4f13-8d29-1031e2f0c92a"">; <img width=""647"" alt=""image"" src=""https://github.com/qutip/qutip/assets/54374648/37c62667-cf01-4d37-9c20-770b6fc3da8f"">; It messes up the older pic, so I feel its best to make custom ordering a parameter users can choose to opt for, they can choose between min, max, average and custom ; While this solution improves it after 2 days of searching this seems like a common problem and a solution is yet to come by from matplotlib ; reference ; https://github.com/matplotlib/matplotlib/issues/25534#issue-1637116709. Some improvements comes from adding the bars one by one ourself ; https://www.mail-archive.com/matplotlib-users@lists.sourceforge.net/msg19740.html#:~:text=As%20for%20the,will%20have%20problems",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2145034602
https://github.com/qutip/qutip/pull/2442#issuecomment-2145125136:25,Deployability,update,update,25,This looks great! Please update the code. And maybe with a few inline comments/docs/link to that post so that people understand a bit how it works.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2145125136
https://github.com/qutip/qutip/pull/2442#issuecomment-2145262488:330,Deployability,update,updates,330,"Looks good in general. Will have a closer test later today. There are some unnecessary style changes to other parts of the code. Especially `'` to `""` was quite unnecessary... It is not massive but it makes it a bit hard to identify which is the essential change. How hard is it to revert the changes of `'` to `""`? Other styling updates like removing unused importations are fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2145262488
https://github.com/qutip/qutip/pull/2442#issuecomment-2145262488:42,Testability,test,test,42,"Looks good in general. Will have a closer test later today. There are some unnecessary style changes to other parts of the code. Especially `'` to `""` was quite unnecessary... It is not massive but it makes it a bit hard to identify which is the essential change. How hard is it to revert the changes of `'` to `""`? Other styling updates like removing unused importations are fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2145262488
https://github.com/qutip/qutip/pull/2442#issuecomment-2145360068:332,Deployability,update,updates,332,"> Looks good in general. Will have a closer test later today. There are some unnecessary style changes to other parts of the code. Especially `'` to `""` was quite unnecessary... It is not massive but it makes it a bit hard to identify which is the essential change. How hard is it to revert the changes of `'` to `""`? Other styling updates like removing unused importations are fine. it was done by a linter ,I can remove it but it was done to make it consistent with the other areas, I can revert it. the main part is the 2 function change and the ones inside the loop",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2145360068
https://github.com/qutip/qutip/pull/2442#issuecomment-2145360068:44,Testability,test,test,44,"> Looks good in general. Will have a closer test later today. There are some unnecessary style changes to other parts of the code. Especially `'` to `""` was quite unnecessary... It is not massive but it makes it a bit hard to identify which is the essential change. How hard is it to revert the changes of `'` to `""`? Other styling updates like removing unused importations are fine. it was done by a linter ,I can remove it but it was done to make it consistent with the other areas, I can revert it. the main part is the 2 function change and the ones inside the loop",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2145360068
https://github.com/qutip/qutip/pull/2442#issuecomment-2146951100:239,Testability,log,log,239,"Tried a few more options, looks good. Yeah, I know it is from a linter. Personally, I'm fine since the change is not massive. If others think this might mess up the code history, please speak up. Please add a Towncrier file for the change log. I'll wait for one or two days, if no one comments, will merge.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2146951100
https://github.com/qutip/qutip/pull/2442#issuecomment-2147354527:255,Testability,log,log,255,"> Tried a few more options, looks good.; > ; > Yeah, I know it is from a linter. Personally, I'm fine since the change is not massive. If others think this might mess up the code history, please speak up.; > ; > Please add a Towncrier file for the change log.; > ; > I'll wait for one or two days, if no one comments, will merge. Sounds good, I will add the Towncrier file shortly and open an issue for the new bug",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2147354527
https://github.com/qutip/qutip/pull/2442#issuecomment-2147402235:253,Testability,log,log,253,"> > Tried a few more options, looks good.; > > Yeah, I know it is from a linter. Personally, I'm fine since the change is not massive. If others think this might mess up the code history, please speak up.; > > Please add a Towncrier file for the change log.; > > I'll wait for one or two days, if no one comments, will merge.; > ; > Sounds good,; Ha, Def will ; I will add the Towncrier file shortly and open an issue for the new bug",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2147402235
https://github.com/qutip/qutip/pull/2442#issuecomment-2151598711:37,Deployability,update,updates,37,@Ericgig I have pushed the requested updates,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2151598711
https://github.com/qutip/qutip/issues/2450#issuecomment-2162159107:24,Testability,benchmark,benchmark,24,"I wanted to use them to benchmark some of the results I got with other solvers. ; I think I was able to make it work locally by fiddling with the `Explicit_RungeKutta` class. Would you want me to open a PR for it, if you'd like?. <img width=""1274"" alt=""image"" src=""https://github.com/qutip/qutip/assets/23234279/625df0d7-5c5c-4acb-9946-894ab61919e6"">",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2450#issuecomment-2162159107
https://github.com/qutip/qutip/pull/2455#issuecomment-2169216457:149,Availability,down,down,149,"Thank you for these fixes! Sorry, it will take me a bit until I can have a proper look (vacation next week). It would help if you could break the PR down a bit. Perhaps into things related to the general multitrajresult, and things related to the stochastic solvers?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2455#issuecomment-2169216457
https://github.com/qutip/qutip/pull/2457#issuecomment-2188429294:44,Deployability,release,release,44,@rgommers I believe @Ericgig is planning to release them in 5.0.3.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2457#issuecomment-2188429294
https://github.com/qutip/qutip/issues/2468#issuecomment-2186847059:86,Deployability,install,installing,86,"I think it was indeed a version problem, but I can't tell exactly why it happened. Re-installing dependencies from scratch seems to have solved the issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2468#issuecomment-2186847059
https://github.com/qutip/qutip/issues/2468#issuecomment-2186847059:97,Integrability,depend,dependencies,97,"I think it was indeed a version problem, but I can't tell exactly why it happened. Re-installing dependencies from scratch seems to have solved the issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2468#issuecomment-2186847059
https://github.com/qutip/qutip/pull/2471#issuecomment-2195248966:57,Deployability,release,release,57,@Ericgig I assume this one needs to be merged before the release. If its ready should we merge it now?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2471#issuecomment-2195248966
https://github.com/qutip/qutip/issues/2472#issuecomment-2191420632:37,Deployability,patch,patch,37,"Scipy 1.14 is not supported yet. The patch will release with 5.0.3, ~~hopefully today~~, tomorrow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2472#issuecomment-2191420632
https://github.com/qutip/qutip/issues/2472#issuecomment-2191420632:48,Deployability,release,release,48,"Scipy 1.14 is not supported yet. The patch will release with 5.0.3, ~~hopefully today~~, tomorrow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2472#issuecomment-2191420632
https://github.com/qutip/qutip/pull/2477#issuecomment-2197209540:60,Deployability,release,release,60,@AGaliciaMartinez I will add comment here in the for future release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2197209540
https://github.com/qutip/qutip/pull/2477#issuecomment-2199701824:60,Testability,Test,TestPyPi,60,"Hey @Ericgig, if I understand correctly, you want to remove TestPyPi in this PR. Is that correct?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199701824
https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342:57,Deployability,deploy,deploy,57,"No, if `test` is used for the branch name, it will still deploy to testpypi. Both `deploy to ...` jobs were cut and pasted with only 2 lines changed so I merged them so we don't forget to update one without the other. I also added more feedback to the job that would show uploaded files even for a dry run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342
https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342:83,Deployability,deploy,deploy,83,"No, if `test` is used for the branch name, it will still deploy to testpypi. Both `deploy to ...` jobs were cut and pasted with only 2 lines changed so I merged them so we don't forget to update one without the other. I also added more feedback to the job that would show uploaded files even for a dry run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342
https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342:188,Deployability,update,update,188,"No, if `test` is used for the branch name, it will still deploy to testpypi. Both `deploy to ...` jobs were cut and pasted with only 2 lines changed so I merged them so we don't forget to update one without the other. I also added more feedback to the job that would show uploaded files even for a dry run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342
https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342:8,Testability,test,test,8,"No, if `test` is used for the branch name, it will still deploy to testpypi. Both `deploy to ...` jobs were cut and pasted with only 2 lines changed so I merged them so we don't forget to update one without the other. I also added more feedback to the job that would show uploaded files even for a dry run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342
https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342:67,Testability,test,testpypi,67,"No, if `test` is used for the branch name, it will still deploy to testpypi. Both `deploy to ...` jobs were cut and pasted with only 2 lines changed so I merged them so we don't forget to update one without the other. I also added more feedback to the job that would show uploaded files even for a dry run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342
https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342:236,Usability,feedback,feedback,236,"No, if `test` is used for the branch name, it will still deploy to testpypi. Both `deploy to ...` jobs were cut and pasted with only 2 lines changed so I merged them so we don't forget to update one without the other. I also added more feedback to the job that would show uploaded files even for a dry run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199969342
https://github.com/qutip/qutip/issues/2481#issuecomment-2206199762:78,Availability,avail,available,78,"The `Qobj.data` is not a scipy csr matrices, most attributes are not directly available. `Qobj.data_as` convert it usual format scipy, numpy, etc.; ```; csr = qutip.qeye(3, dtype=""CSR"").data_as(""csr_matrix""); csr.nnz; ```; or ; ```; qutip.qeye(3, dtype=""CSR"").data.as_scipy().nnz; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2481#issuecomment-2206199762
https://github.com/qutip/qutip/issues/2481#issuecomment-2208274271:105,Modifiability,variab,variable,105,"I did that and it fixed the issue, but wouldn't it make more sense to have nnz be a directly retrievable variable of a dtype = ""CSR"" Qobj?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2481#issuecomment-2208274271
https://github.com/qutip/qutip/pull/2483#issuecomment-2211556415:205,Integrability,depend,dependabot,205,[![Coverage Status](https://coveralls.io/builds/68491593/badge)](https://coveralls.io/builds/68491593). coverage: 85.104% (+0.007%) from 85.097%; when pulling **03b6f7e3e739836b1b0c8f6a797b94b87db64e3c on dependabot/pip/doc/certifi-2024.7.4**; into **4f34877035d9ec8ecd3ad3675260c9f06b09ec79 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2483#issuecomment-2211556415
https://github.com/qutip/qutip/pull/2484#issuecomment-2214437849:1,Testability,log,logm,1,"`logm` still does not work, I am unable to figure out the reason.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2484#issuecomment-2214437849
https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388:203,Deployability,update,update,203,"No, `dtype` should always be respected, even for jax.; So the default need to be changed.; One options would be to set `dtype=None` for the default and then if it's `None` and sparse, then use dense. (+ update the docstring and tests.); Another options would be to remove the `dtype` parameter and replace it with `sparse` like `eigenenergies`. But I would like to keep support for both for a while has we should no introduce breaking change outside of major release which won't come anytime soon (detect if the user input a dtype and warn it in that case, but still give him his intended behaviour.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388
https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388:459,Deployability,release,release,459,"No, `dtype` should always be respected, even for jax.; So the default need to be changed.; One options would be to set `dtype=None` for the default and then if it's `None` and sparse, then use dense. (+ update the docstring and tests.); Another options would be to remove the `dtype` parameter and replace it with `sparse` like `eigenenergies`. But I would like to keep support for both for a while has we should no introduce breaking change outside of major release which won't come anytime soon (detect if the user input a dtype and warn it in that case, but still give him his intended behaviour.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388
https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388:498,Safety,detect,detect,498,"No, `dtype` should always be respected, even for jax.; So the default need to be changed.; One options would be to set `dtype=None` for the default and then if it's `None` and sparse, then use dense. (+ update the docstring and tests.); Another options would be to remove the `dtype` parameter and replace it with `sparse` like `eigenenergies`. But I would like to keep support for both for a while has we should no introduce breaking change outside of major release which won't come anytime soon (detect if the user input a dtype and warn it in that case, but still give him his intended behaviour.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388
https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388:228,Testability,test,tests,228,"No, `dtype` should always be respected, even for jax.; So the default need to be changed.; One options would be to set `dtype=None` for the default and then if it's `None` and sparse, then use dense. (+ update the docstring and tests.); Another options would be to remove the `dtype` parameter and replace it with `sparse` like `eigenenergies`. But I would like to keep support for both for a while has we should no introduce breaking change outside of major release which won't come anytime soon (detect if the user input a dtype and warn it in that case, but still give him his intended behaviour.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388
https://github.com/qutip/qutip/issues/2489#issuecomment-2228684459:10,Testability,log,logic,10,"With that logic, we could say that the `c_ops`, `sc_ops` etc. are part of the system and should come right after the Hamiltonian. While this feels right to me, it would break too many code... Since HEOM is new and somewhat niche, I think it would be more doable to bring in line with other, even if it's the worst order. But it would be hard to do it smoothly, so it may be best to just let it be.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2489#issuecomment-2228684459
https://github.com/qutip/qutip/pull/2490#issuecomment-2229030829:12,Testability,test,tested,12,"Yes, I have tested and it works both with `numpy` and `jax.numpy`. Should I just change the base branch to `dev.major`?; Is `numpy_backend` getting successfully imported in `metrics` and `entropy` enough or we should write separate tests?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2490#issuecomment-2229030829
https://github.com/qutip/qutip/pull/2490#issuecomment-2229030829:232,Testability,test,tests,232,"Yes, I have tested and it works both with `numpy` and `jax.numpy`. Should I just change the base branch to `dev.major`?; Is `numpy_backend` getting successfully imported in `metrics` and `entropy` enough or we should write separate tests?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2490#issuecomment-2229030829
https://github.com/qutip/qutip/pull/2490#issuecomment-2235671204:29,Testability,test,tests,29,After shifting to `core` the tests have started interfering with each other. It would be better if we could keep the `numpy_backend` class to qutip not `core`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2490#issuecomment-2235671204
https://github.com/qutip/qutip/issues/2495#issuecomment-2245373244:1107,Energy Efficiency,energy,energy,1107,"This is not a bug in QuTiP _per se_, but an artifact of the Fock space cutoff. In a numerical calculation, we can only use finite matrices, but the ladder operators can not be represented with finite matrices (Stone-von Neumann theorem). You can try printing `a * a.dag() - a.dag() * a` for different values of `dim`. You will find that it gives the expected result (identity matrix) except in the very bottom right matrix element. That matrix element however deviates a lot, and the more you increase `dims` the more it will deviate. So if you compute the trace distance of `a * a.dag()` and `a.dag() * a + 1`, you will get a large number instead of zero. In your example, the basic problem is the same. Usually this is not a problem because we assume the cutoff is larger than the number of excitations in any state we are looking at. In other words, in vector form, the bottom-most entries of any state are very (exponentially) small, and the deviations in the operators in those entries then don't play a role. However, when calculating a norm (such as the trace distance), entries corresponding to low-energy states or to high-energy states contribute equally, and we can get nonsensical results. You could try projecting out high-energy states before calculating the norm:; ```; dim = 25; dim2 = 10. a = destroy(dim); D = (a.dag() - a).expm(); a_displaced = D.dag() * a * D. proj = sum(projection(dim, i, i) for i in range(dim2)); diff = a_displaced - (a + 1); print((proj * diff * proj).norm('tr')); # 1.3039375636172088e-07; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2495#issuecomment-2245373244
https://github.com/qutip/qutip/issues/2495#issuecomment-2245373244:1132,Energy Efficiency,energy,energy,1132,"This is not a bug in QuTiP _per se_, but an artifact of the Fock space cutoff. In a numerical calculation, we can only use finite matrices, but the ladder operators can not be represented with finite matrices (Stone-von Neumann theorem). You can try printing `a * a.dag() - a.dag() * a` for different values of `dim`. You will find that it gives the expected result (identity matrix) except in the very bottom right matrix element. That matrix element however deviates a lot, and the more you increase `dims` the more it will deviate. So if you compute the trace distance of `a * a.dag()` and `a.dag() * a + 1`, you will get a large number instead of zero. In your example, the basic problem is the same. Usually this is not a problem because we assume the cutoff is larger than the number of excitations in any state we are looking at. In other words, in vector form, the bottom-most entries of any state are very (exponentially) small, and the deviations in the operators in those entries then don't play a role. However, when calculating a norm (such as the trace distance), entries corresponding to low-energy states or to high-energy states contribute equally, and we can get nonsensical results. You could try projecting out high-energy states before calculating the norm:; ```; dim = 25; dim2 = 10. a = destroy(dim); D = (a.dag() - a).expm(); a_displaced = D.dag() * a * D. proj = sum(projection(dim, i, i) for i in range(dim2)); diff = a_displaced - (a + 1); print((proj * diff * proj).norm('tr')); # 1.3039375636172088e-07; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2495#issuecomment-2245373244
https://github.com/qutip/qutip/issues/2495#issuecomment-2245373244:1236,Energy Efficiency,energy,energy,1236,"This is not a bug in QuTiP _per se_, but an artifact of the Fock space cutoff. In a numerical calculation, we can only use finite matrices, but the ladder operators can not be represented with finite matrices (Stone-von Neumann theorem). You can try printing `a * a.dag() - a.dag() * a` for different values of `dim`. You will find that it gives the expected result (identity matrix) except in the very bottom right matrix element. That matrix element however deviates a lot, and the more you increase `dims` the more it will deviate. So if you compute the trace distance of `a * a.dag()` and `a.dag() * a + 1`, you will get a large number instead of zero. In your example, the basic problem is the same. Usually this is not a problem because we assume the cutoff is larger than the number of excitations in any state we are looking at. In other words, in vector form, the bottom-most entries of any state are very (exponentially) small, and the deviations in the operators in those entries then don't play a role. However, when calculating a norm (such as the trace distance), entries corresponding to low-energy states or to high-energy states contribute equally, and we can get nonsensical results. You could try projecting out high-energy states before calculating the norm:; ```; dim = 25; dim2 = 10. a = destroy(dim); D = (a.dag() - a).expm(); a_displaced = D.dag() * a * D. proj = sum(projection(dim, i, i) for i in range(dim2)); diff = a_displaced - (a + 1); print((proj * diff * proj).norm('tr')); # 1.3039375636172088e-07; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2495#issuecomment-2245373244
https://github.com/qutip/qutip/issues/2495#issuecomment-2245390570:1123,Energy Efficiency,energy,energy,1123,"> This is not a bug in QuTiP _per se_, but an artifact of the Fock space cutoff. In a numerical calculation, we can only use finite matrices, but the ladder operators can not be represented with finite matrices (Stone-von Neumann theorem).; > ; > You can try printing `a * a.dag() - a.dag() * a` for different values of `dim`. You will find that it gives the expected result (identity matrix) except in the very bottom right matrix element. That matrix element however deviates a lot, and the more you increase `dims` the more it will deviate. So if you compute the trace distance of `a * a.dag()` and `a.dag() * a + 1`, you will get a large number instead of zero. In your example, the basic problem is the same.; > ; > Usually this is not a problem because we assume the cutoff is larger than the number of excitations in any state we are looking at. In other words, in vector form, the bottom-most entries of any state are very (exponentially) small, and the deviations in the operators in those entries then don't play a role. However, when calculating a norm (such as the trace distance), entries corresponding to low-energy states or to high-energy states contribute equally, and we can get nonsensical results.; > ; > You could try projecting out high-energy states before calculating the norm:; > ; > ```; > dim = 25; > dim2 = 10; > ; > a = destroy(dim); > D = (a.dag() - a).expm(); > a_displaced = D.dag() * a * D; > ; > proj = sum(projection(dim, i, i) for i in range(dim2)); > diff = a_displaced - (a + 1); > print((proj * diff * proj).norm('tr')); > # 1.3039375636172088e-07; > ```. Hi Paul, thank you very much for your response! Its really helpful :) From what I tried so far, and if I understand you correctly, as I will eventually calculate their expectation values with respect to some vectors, that abnormal large number at the corner of their matrix would be suppressed and the final results would be the same, or?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2495#issuecomment-2245390570
https://github.com/qutip/qutip/issues/2495#issuecomment-2245390570:1148,Energy Efficiency,energy,energy,1148,"> This is not a bug in QuTiP _per se_, but an artifact of the Fock space cutoff. In a numerical calculation, we can only use finite matrices, but the ladder operators can not be represented with finite matrices (Stone-von Neumann theorem).; > ; > You can try printing `a * a.dag() - a.dag() * a` for different values of `dim`. You will find that it gives the expected result (identity matrix) except in the very bottom right matrix element. That matrix element however deviates a lot, and the more you increase `dims` the more it will deviate. So if you compute the trace distance of `a * a.dag()` and `a.dag() * a + 1`, you will get a large number instead of zero. In your example, the basic problem is the same.; > ; > Usually this is not a problem because we assume the cutoff is larger than the number of excitations in any state we are looking at. In other words, in vector form, the bottom-most entries of any state are very (exponentially) small, and the deviations in the operators in those entries then don't play a role. However, when calculating a norm (such as the trace distance), entries corresponding to low-energy states or to high-energy states contribute equally, and we can get nonsensical results.; > ; > You could try projecting out high-energy states before calculating the norm:; > ; > ```; > dim = 25; > dim2 = 10; > ; > a = destroy(dim); > D = (a.dag() - a).expm(); > a_displaced = D.dag() * a * D; > ; > proj = sum(projection(dim, i, i) for i in range(dim2)); > diff = a_displaced - (a + 1); > print((proj * diff * proj).norm('tr')); > # 1.3039375636172088e-07; > ```. Hi Paul, thank you very much for your response! Its really helpful :) From what I tried so far, and if I understand you correctly, as I will eventually calculate their expectation values with respect to some vectors, that abnormal large number at the corner of their matrix would be suppressed and the final results would be the same, or?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2495#issuecomment-2245390570
https://github.com/qutip/qutip/issues/2495#issuecomment-2245390570:1259,Energy Efficiency,energy,energy,1259,"> This is not a bug in QuTiP _per se_, but an artifact of the Fock space cutoff. In a numerical calculation, we can only use finite matrices, but the ladder operators can not be represented with finite matrices (Stone-von Neumann theorem).; > ; > You can try printing `a * a.dag() - a.dag() * a` for different values of `dim`. You will find that it gives the expected result (identity matrix) except in the very bottom right matrix element. That matrix element however deviates a lot, and the more you increase `dims` the more it will deviate. So if you compute the trace distance of `a * a.dag()` and `a.dag() * a + 1`, you will get a large number instead of zero. In your example, the basic problem is the same.; > ; > Usually this is not a problem because we assume the cutoff is larger than the number of excitations in any state we are looking at. In other words, in vector form, the bottom-most entries of any state are very (exponentially) small, and the deviations in the operators in those entries then don't play a role. However, when calculating a norm (such as the trace distance), entries corresponding to low-energy states or to high-energy states contribute equally, and we can get nonsensical results.; > ; > You could try projecting out high-energy states before calculating the norm:; > ; > ```; > dim = 25; > dim2 = 10; > ; > a = destroy(dim); > D = (a.dag() - a).expm(); > a_displaced = D.dag() * a * D; > ; > proj = sum(projection(dim, i, i) for i in range(dim2)); > diff = a_displaced - (a + 1); > print((proj * diff * proj).norm('tr')); > # 1.3039375636172088e-07; > ```. Hi Paul, thank you very much for your response! Its really helpful :) From what I tried so far, and if I understand you correctly, as I will eventually calculate their expectation values with respect to some vectors, that abnormal large number at the corner of their matrix would be suppressed and the final results would be the same, or?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2495#issuecomment-2245390570
https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:241,Deployability,patch,patch,241,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367
https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:116,Integrability,depend,dependancy,116,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367
https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:333,Performance,Load,LoadLibrary,333,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367
https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:62,Safety,detect,detection,62,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367
https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:140,Testability,test,tests,140,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367
https://github.com/qutip/qutip/issues/2496#issuecomment-2243348834:455,Deployability,patch,patch,455,"Thank you for your swift response Eric. . Your suggestion helped me out. Apparently the relevant .dll file in my \Library\bin\ folder was named 'mkl_rt.2.dll', rather than 'mkl_rt.dll'. I duplicated the my file and renamed it and now everything works as expected. . It seems when qutip is checking for mkl with qutip.settings._find_mkl() it specifically looks for '\mkl_rt.dll'. Probably including the possibility for a deviation of the above form should patch it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243348834
https://github.com/qutip/qutip/issues/2500#issuecomment-2248041684:91,Deployability,install,installed,91,The issue seems that your version of `cvxpy` is not compatible with the version of `scipy` installed.; Try to update it and import it directly.; `cvxpy` is optional so you could also uninstall it before importing qutip.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2500#issuecomment-2248041684
https://github.com/qutip/qutip/issues/2500#issuecomment-2248041684:110,Deployability,update,update,110,The issue seems that your version of `cvxpy` is not compatible with the version of `scipy` installed.; Try to update it and import it directly.; `cvxpy` is optional so you could also uninstall it before importing qutip.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2500#issuecomment-2248041684
https://github.com/qutip/qutip/issues/2501#issuecomment-2249532978:985,Deployability,Install,Installed,985,"New information:; I ran the same script on another PC and it reproduced the same result as 3 years ago. Also, I didn't encounter the same importing problem as reported in #2500 .; I am reproducing the qutip.about() output below for this other PC:. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.21.5; Scipy Version: 1.7.3; Cython Version: None; Matplotlib Version: 3.5.1; Python Version: 3.9.9; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\ychao\Anaconda3\envs\qutip-env\lib\site-packages\qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249532978
https://github.com/qutip/qutip/issues/2501#issuecomment-2249532978:1057,Deployability,Install,Installation,1057,"New information:; I ran the same script on another PC and it reproduced the same result as 3 years ago. Also, I didn't encounter the same importing problem as reported in #2500 .; I am reproducing the qutip.about() output below for this other PC:. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.21.5; Scipy Version: 1.7.3; Cython Version: None; Matplotlib Version: 3.5.1; Python Version: 3.9.9; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\ychao\Anaconda3\envs\qutip-env\lib\site-packages\qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249532978
https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375:767,Availability,down,down,767,"Just a few comments:; * The changes in behavior are probably due to a different QuTiP version. Your `qutip.about()` output shows that you have installed version 5.0.3 on the one PC and version 4.6.2 on the other. Version 5 was recently released, and it is a major update and changes many of the internals of QuTiP. Old code should still work with version 5 in the majority of cases, but it is not guaranteed to always work. For old code, you might therefore prefer to use version 4 (the latest release of version 4 is v4.7.6).; * Your notebooks are rather long, and for a person who has not written them it can be hard to figure out what they do. If you would like to investigate in detail where the different behavior comes from, I would recommend to try to boil it down to a *short, self-contained* example script that gives different results in versions 4 and 5.; * The differing plots show values with a magnitude of $10^{-14}$ or so. That is rather small. By default, QuTiP's solvers use tolerances of $10^{-12}$, so you should not expect the numerical results to have a higher precision than that. In numerical calculations, it is generally recommended to rescale your units such that your parameters and results have a magnitude around $1$ if possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375
https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375:993,Availability,toler,tolerances,993,"Just a few comments:; * The changes in behavior are probably due to a different QuTiP version. Your `qutip.about()` output shows that you have installed version 5.0.3 on the one PC and version 4.6.2 on the other. Version 5 was recently released, and it is a major update and changes many of the internals of QuTiP. Old code should still work with version 5 in the majority of cases, but it is not guaranteed to always work. For old code, you might therefore prefer to use version 4 (the latest release of version 4 is v4.7.6).; * Your notebooks are rather long, and for a person who has not written them it can be hard to figure out what they do. If you would like to investigate in detail where the different behavior comes from, I would recommend to try to boil it down to a *short, self-contained* example script that gives different results in versions 4 and 5.; * The differing plots show values with a magnitude of $10^{-14}$ or so. That is rather small. By default, QuTiP's solvers use tolerances of $10^{-12}$, so you should not expect the numerical results to have a higher precision than that. In numerical calculations, it is generally recommended to rescale your units such that your parameters and results have a magnitude around $1$ if possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375
https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375:143,Deployability,install,installed,143,"Just a few comments:; * The changes in behavior are probably due to a different QuTiP version. Your `qutip.about()` output shows that you have installed version 5.0.3 on the one PC and version 4.6.2 on the other. Version 5 was recently released, and it is a major update and changes many of the internals of QuTiP. Old code should still work with version 5 in the majority of cases, but it is not guaranteed to always work. For old code, you might therefore prefer to use version 4 (the latest release of version 4 is v4.7.6).; * Your notebooks are rather long, and for a person who has not written them it can be hard to figure out what they do. If you would like to investigate in detail where the different behavior comes from, I would recommend to try to boil it down to a *short, self-contained* example script that gives different results in versions 4 and 5.; * The differing plots show values with a magnitude of $10^{-14}$ or so. That is rather small. By default, QuTiP's solvers use tolerances of $10^{-12}$, so you should not expect the numerical results to have a higher precision than that. In numerical calculations, it is generally recommended to rescale your units such that your parameters and results have a magnitude around $1$ if possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375
https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375:236,Deployability,release,released,236,"Just a few comments:; * The changes in behavior are probably due to a different QuTiP version. Your `qutip.about()` output shows that you have installed version 5.0.3 on the one PC and version 4.6.2 on the other. Version 5 was recently released, and it is a major update and changes many of the internals of QuTiP. Old code should still work with version 5 in the majority of cases, but it is not guaranteed to always work. For old code, you might therefore prefer to use version 4 (the latest release of version 4 is v4.7.6).; * Your notebooks are rather long, and for a person who has not written them it can be hard to figure out what they do. If you would like to investigate in detail where the different behavior comes from, I would recommend to try to boil it down to a *short, self-contained* example script that gives different results in versions 4 and 5.; * The differing plots show values with a magnitude of $10^{-14}$ or so. That is rather small. By default, QuTiP's solvers use tolerances of $10^{-12}$, so you should not expect the numerical results to have a higher precision than that. In numerical calculations, it is generally recommended to rescale your units such that your parameters and results have a magnitude around $1$ if possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375
https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375:264,Deployability,update,update,264,"Just a few comments:; * The changes in behavior are probably due to a different QuTiP version. Your `qutip.about()` output shows that you have installed version 5.0.3 on the one PC and version 4.6.2 on the other. Version 5 was recently released, and it is a major update and changes many of the internals of QuTiP. Old code should still work with version 5 in the majority of cases, but it is not guaranteed to always work. For old code, you might therefore prefer to use version 4 (the latest release of version 4 is v4.7.6).; * Your notebooks are rather long, and for a person who has not written them it can be hard to figure out what they do. If you would like to investigate in detail where the different behavior comes from, I would recommend to try to boil it down to a *short, self-contained* example script that gives different results in versions 4 and 5.; * The differing plots show values with a magnitude of $10^{-14}$ or so. That is rather small. By default, QuTiP's solvers use tolerances of $10^{-12}$, so you should not expect the numerical results to have a higher precision than that. In numerical calculations, it is generally recommended to rescale your units such that your parameters and results have a magnitude around $1$ if possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375
https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375:494,Deployability,release,release,494,"Just a few comments:; * The changes in behavior are probably due to a different QuTiP version. Your `qutip.about()` output shows that you have installed version 5.0.3 on the one PC and version 4.6.2 on the other. Version 5 was recently released, and it is a major update and changes many of the internals of QuTiP. Old code should still work with version 5 in the majority of cases, but it is not guaranteed to always work. For old code, you might therefore prefer to use version 4 (the latest release of version 4 is v4.7.6).; * Your notebooks are rather long, and for a person who has not written them it can be hard to figure out what they do. If you would like to investigate in detail where the different behavior comes from, I would recommend to try to boil it down to a *short, self-contained* example script that gives different results in versions 4 and 5.; * The differing plots show values with a magnitude of $10^{-14}$ or so. That is rather small. By default, QuTiP's solvers use tolerances of $10^{-12}$, so you should not expect the numerical results to have a higher precision than that. In numerical calculations, it is generally recommended to rescale your units such that your parameters and results have a magnitude around $1$ if possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2249560375
https://github.com/qutip/qutip/issues/2501#issuecomment-2250974952:94,Integrability,wrap,wrap,94,I believe the detailed comments from [pmenczel](https://github.com/pmenczel) is sufficient to wrap up this case.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2501#issuecomment-2250974952
https://github.com/qutip/qutip/pull/2502#issuecomment-2295659950:487,Integrability,depend,dependent,487,"Thank you Eric, this must have been a lot of work. I haven't had time yet to look at it in full detail, but I have a few preliminary comments / questions:; * Having the no-jump trajectory not count towards the `ntraj` seems like a good idea to me. In particular the handling of the seeds becomes much more sane.; * Also the change of having the weights part of the multi-result instead of the the trajectory-results makes a lot of sense in hindsight.; * What is the reason that the time-dependent weights are still part of the trajectory result? That seems a bit inconsistent to me and I wonder if the `TrajectoryResult` class could perhaps just be removed?; * We now have three names for more-or-less the same concept, ""no jump"", ""deterministic"" and ""absolute"". I guess the ""no jump"" name is used within the mcsolve module, which is fine. In the multitrajresult module, perhaps we could use either ""deterministic"" or ""absolute"" always? (Out of those, I would probably prefer ""deterministic"")",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2295659950
https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851:240,Availability,avail,available,240,"> * What is the reason that the time-dependent weights are still part of the trajectory result? That seems a bit inconsistent to me and I wonder if the `TrajectoryResult` class could perhaps just be removed?. The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I will look into it this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851
https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851:37,Integrability,depend,dependent,37,"> * What is the reason that the time-dependent weights are still part of the trajectory result? That seems a bit inconsistent to me and I wonder if the `TrajectoryResult` class could perhaps just be removed?. The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I will look into it this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851
https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851:218,Integrability,depend,dependent,218,"> * What is the reason that the time-dependent weights are still part of the trajectory result? That seems a bit inconsistent to me and I wonder if the `TrajectoryResult` class could perhaps just be removed?. The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I will look into it this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851
https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851:482,Testability,log,logic,482,"> * What is the reason that the time-dependent weights are still part of the trajectory result? That seems a bit inconsistent to me and I wonder if the `TrajectoryResult` class could perhaps just be removed?. The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I will look into it this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851
https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851:510,Usability,simpl,simplify,510,"> * What is the reason that the time-dependent weights are still part of the trajectory result? That seems a bit inconsistent to me and I wonder if the `TrajectoryResult` class could perhaps just be removed?. The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I will look into it this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851
https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958:33,Availability,avail,available,33,"> The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I do think it would be good to keep the `trace` property on the trajectories, but for the purpose of calculating the weighted averages, it could perhaps be treated like the other types of weights that we have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958
https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958:11,Integrability,depend,dependent,11,"> The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I do think it would be good to keep the `trace` property on the trajectories, but for the purpose of calculating the weighted averages, it could perhaps be treated like the other types of weights that we have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958
https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958:275,Testability,log,logic,275,"> The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I do think it would be good to keep the `trace` property on the trajectories, but for the purpose of calculating the weighted averages, it could perhaps be treated like the other types of weights that we have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958
https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958:303,Usability,simpl,simplify,303,"> The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I do think it would be good to keep the `trace` property on the trajectories, but for the purpose of calculating the weighted averages, it could perhaps be treated like the other types of weights that we have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958
https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530:29,Availability,failure,failure,29,"It will cause a lot of tests failure not related to changes, We will get tests failure due to new version of jax or a deprecation in numpy /scipy will have to be fixed in multiple repos for the tests to work as we are seen with the present failure. It require commitment to keep everything working and up to date so I would like to hear from the maintainers of the other projects before merging. ; Also should other projects such as `qutip-cupy`, `qutip-qtrl` be included?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530
https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530:79,Availability,failure,failure,79,"It will cause a lot of tests failure not related to changes, We will get tests failure due to new version of jax or a deprecation in numpy /scipy will have to be fixed in multiple repos for the tests to work as we are seen with the present failure. It require commitment to keep everything working and up to date so I would like to hear from the maintainers of the other projects before merging. ; Also should other projects such as `qutip-cupy`, `qutip-qtrl` be included?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530
https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530:240,Availability,failure,failure,240,"It will cause a lot of tests failure not related to changes, We will get tests failure due to new version of jax or a deprecation in numpy /scipy will have to be fixed in multiple repos for the tests to work as we are seen with the present failure. It require commitment to keep everything working and up to date so I would like to hear from the maintainers of the other projects before merging. ; Also should other projects such as `qutip-cupy`, `qutip-qtrl` be included?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530
https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530:23,Testability,test,tests,23,"It will cause a lot of tests failure not related to changes, We will get tests failure due to new version of jax or a deprecation in numpy /scipy will have to be fixed in multiple repos for the tests to work as we are seen with the present failure. It require commitment to keep everything working and up to date so I would like to hear from the maintainers of the other projects before merging. ; Also should other projects such as `qutip-cupy`, `qutip-qtrl` be included?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530
https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530:73,Testability,test,tests,73,"It will cause a lot of tests failure not related to changes, We will get tests failure due to new version of jax or a deprecation in numpy /scipy will have to be fixed in multiple repos for the tests to work as we are seen with the present failure. It require commitment to keep everything working and up to date so I would like to hear from the maintainers of the other projects before merging. ; Also should other projects such as `qutip-cupy`, `qutip-qtrl` be included?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530
https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530:194,Testability,test,tests,194,"It will cause a lot of tests failure not related to changes, We will get tests failure due to new version of jax or a deprecation in numpy /scipy will have to be fixed in multiple repos for the tests to work as we are seen with the present failure. It require commitment to keep everything working and up to date so I would like to hear from the maintainers of the other projects before merging. ; Also should other projects such as `qutip-cupy`, `qutip-qtrl` be included?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2504#issuecomment-2286479530
https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618:525,Safety,avoid,avoided,525,"@Ericgig When I read the description of this PR I thought you might have implemented something that might be even faster. Instead of having the numpy proxy have dynamic access via `__getattr__` we could do either of the following:. * When the numpy backend is set, actually copy the attributes across to the proxy objects so that they are looked up in `__dict__` in the ordinary way without having to fall back to `__getattr__`.; * Do the same as the above but define the attributes as slots so that the `__dict__` lookup is avoided.; * Or implement `__getattribute__` so that the original `__dict__` lookup is never checked.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618
https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618:169,Security,access,access,169,"@Ericgig When I read the description of this PR I thought you might have implemented something that might be even faster. Instead of having the numpy proxy have dynamic access via `__getattr__` we could do either of the following:. * When the numpy backend is set, actually copy the attributes across to the proxy objects so that they are looked up in `__dict__` in the ordinary way without having to fall back to `__getattr__`.; * Do the same as the above but define the attributes as slots so that the `__dict__` lookup is avoided.; * Or implement `__getattribute__` so that the original `__dict__` lookup is never checked.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618
https://github.com/qutip/qutip/pull/2510#issuecomment-2296970652:16,Availability,failure,failure,16,Not sure if the failure on windows is related to the numpy release or not. It's a different issue so I will merge this and look at it another time.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2510#issuecomment-2296970652
https://github.com/qutip/qutip/pull/2510#issuecomment-2296970652:59,Deployability,release,release,59,Not sure if the failure on windows is related to the numpy release or not. It's a different issue so I will merge this and look at it another time.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2510#issuecomment-2296970652
https://github.com/qutip/qutip/pull/2519#issuecomment-2406431381:137,Usability,clear,clear,137,"thanks eric, I like the option of creation and full. Took me a moment to understand the meaning of the ''missing'' option. is there some clear situation where someone would use this? perhaps there is a better name too? . for `default_dtype_range`, how about `default_dtype_scope`?. i will try and play with the PR, see if it does what i would expect",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2406431381
https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:302,Availability,down,down,302,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422
https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:313,Deployability,integrat,integrators,313,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422
https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:313,Integrability,integrat,integrators,313,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422
https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:88,Modifiability,plugin,plugins,88,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422
https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:351,Safety,safe,safe,351,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422
https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815:610,Integrability,wrap,wrapper,610,"I had a quick play with the feature, for the cases I had stumbled on before, with `eigenstates()' ignoring default_dtype, using the scope of 'full' covers it now. I understand having this work with just 'creation' scope is problematic because you want to make sure the dtype is not used on results lists. heom+full breaks with dia and dense, as expected!. speaking of heom, manually converting the RHS to jaxdia and doing stuff it worked fine. i think generalizing the RHS construction in heom away from csr is probably very difficult without huge performance drop in the construction, so perhaps some kind of wrapper or option to do conversion of types after construction would be fine?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815
https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815:548,Performance,perform,performance,548,"I had a quick play with the feature, for the cases I had stumbled on before, with `eigenstates()' ignoring default_dtype, using the scope of 'full' covers it now. I understand having this work with just 'creation' scope is problematic because you want to make sure the dtype is not used on results lists. heom+full breaks with dia and dense, as expected!. speaking of heom, manually converting the RHS to jaxdia and doing stuff it worked fine. i think generalizing the RHS construction in heom away from csr is probably very difficult without huge performance drop in the construction, so perhaps some kind of wrapper or option to do conversion of types after construction would be fine?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815
https://github.com/qutip/qutip/issues/2520#issuecomment-2323132801:1412,Energy Efficiency,efficient,efficient,1412,"Hi, interesting, thank you for your detailed description!. > When the transformation is made for DrudeLorentzBath, the result generated differs from that for DrudeLorentzPadeBath (and it is not about the number of frequencies used). First of all, are you sure that either of `DrudeLorentzBath` and `DrudeLorentzPadeBath` give the right solution? Because the `ck_real` / `vk_real` are supposed to be the coefficients / exponents of the real part of the correlation function (and the others the imaginary part), and if you plug in imaginary parameters, then terms that previously were only in the real parts could pick up imaginary parts etc. Perhaps this kind of thing cancels out when you add the two unphysical D-L baths to get the shifted D-L bath?. Regarding your proposed solution -- I would say, in the case where `gamma` is not real, the spectral density is unphysical and there is no *a priori* correct way to handle this case. In other words, in a sense, the code before the change is wrong (or right) and the code after the change is just as wrong (or right). I therefore think it wouldn't hurt to implement this change so that your use case can be supported. However, I would want to be very sure that in the case where the parameters are all real, the results are not affected by the change. Is that so? Only asking because that is not clear to me at first glance. A more ""complete"" and probably more efficient solution would be to add a whole new `ShiftedDrudeLorentzBath`, and to put in analytically derived formulas for the Matsubara / Pade expansion coefficients. (As a first step, you could also calculate these coefficients manually and create a `BosonicBath` object from them directly.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2520#issuecomment-2323132801
https://github.com/qutip/qutip/issues/2520#issuecomment-2323132801:1347,Usability,clear,clear,1347,"Hi, interesting, thank you for your detailed description!. > When the transformation is made for DrudeLorentzBath, the result generated differs from that for DrudeLorentzPadeBath (and it is not about the number of frequencies used). First of all, are you sure that either of `DrudeLorentzBath` and `DrudeLorentzPadeBath` give the right solution? Because the `ck_real` / `vk_real` are supposed to be the coefficients / exponents of the real part of the correlation function (and the others the imaginary part), and if you plug in imaginary parameters, then terms that previously were only in the real parts could pick up imaginary parts etc. Perhaps this kind of thing cancels out when you add the two unphysical D-L baths to get the shifted D-L bath?. Regarding your proposed solution -- I would say, in the case where `gamma` is not real, the spectral density is unphysical and there is no *a priori* correct way to handle this case. In other words, in a sense, the code before the change is wrong (or right) and the code after the change is just as wrong (or right). I therefore think it wouldn't hurt to implement this change so that your use case can be supported. However, I would want to be very sure that in the case where the parameters are all real, the results are not affected by the change. Is that so? Only asking because that is not clear to me at first glance. A more ""complete"" and probably more efficient solution would be to add a whole new `ShiftedDrudeLorentzBath`, and to put in analytically derived formulas for the Matsubara / Pade expansion coefficients. (As a first step, you could also calculate these coefficients manually and create a `BosonicBath` object from them directly.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2520#issuecomment-2323132801
https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274:2315,Energy Efficiency,efficient,efficient,2315,"t to think that the unphysical part goes away when two baths are added [1], one with $+i\Omega$ and the other with $-i\Omega$. > However, I would want to be very sure that in the case where the parameters are all real, the results are not affected by the change. Is that so? Only asking because that is not clear to me at first glance. You are very much in the right to be absolutely sure before making a change. As far as I understand and have tested, it will not change the real case because the changes are as follows (I have removed all the other lines in between for clarity):. ```python; - ck_real = [np.real(eta) for eta in eta_p]; + ck_real = [eta for eta in eta_p]. - ck_imag = [np.imag(eta_p[0])]; + ck_imag = [-lam*gamma]. - eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0) - 1.0j)]; + eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0))]; ```; if `gamma` is real, `lam * gamma * self._cot(gamma * beta / 2.0)` would be real, and hence `ck_real` would stay the same as before, and the same can be said for `ck_imag`. After all, this is how it is done for `DrudeLorentzBath`, so it should not impact anything. > A more ""complete"" and probably more efficient solution would be to add a whole new ShiftedDrudeLorentzBath, and to put in analytically derived formulas for the Matsubara / Pade expansion coefficients. (As a first step, you could also calculate these coefficients manually and create a BosonicBath object from them directly.). This is what I have been using locally. I have made a `ShiftedDrudeLorentzBath` and have done exactly what you said. I raised this issue to point out a possible extension of use cases with `DrudeLorentzPadeBath`. [2] T. Kramer, M. Noack, A. Reinefeld, M. Rodrguez, and Y. Zelinskyy, Efficient calculation of open quantum system dynamics and time-resolved spectroscopy with distributed memory HEOM (DM-HEOM), Journal of Computational Chemistry, vol. 39, no. 22, p. 1779, Jun. 2018, doi: [10.1002/jcc.25354](https://doi.org/10.1002/jcc.25354).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274
https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274:2890,Energy Efficiency,Efficient,Efficient,2890,"t to think that the unphysical part goes away when two baths are added [1], one with $+i\Omega$ and the other with $-i\Omega$. > However, I would want to be very sure that in the case where the parameters are all real, the results are not affected by the change. Is that so? Only asking because that is not clear to me at first glance. You are very much in the right to be absolutely sure before making a change. As far as I understand and have tested, it will not change the real case because the changes are as follows (I have removed all the other lines in between for clarity):. ```python; - ck_real = [np.real(eta) for eta in eta_p]; + ck_real = [eta for eta in eta_p]. - ck_imag = [np.imag(eta_p[0])]; + ck_imag = [-lam*gamma]. - eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0) - 1.0j)]; + eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0))]; ```; if `gamma` is real, `lam * gamma * self._cot(gamma * beta / 2.0)` would be real, and hence `ck_real` would stay the same as before, and the same can be said for `ck_imag`. After all, this is how it is done for `DrudeLorentzBath`, so it should not impact anything. > A more ""complete"" and probably more efficient solution would be to add a whole new ShiftedDrudeLorentzBath, and to put in analytically derived formulas for the Matsubara / Pade expansion coefficients. (As a first step, you could also calculate these coefficients manually and create a BosonicBath object from them directly.). This is what I have been using locally. I have made a `ShiftedDrudeLorentzBath` and have done exactly what you said. I raised this issue to point out a possible extension of use cases with `DrudeLorentzPadeBath`. [2] T. Kramer, M. Noack, A. Reinefeld, M. Rodrguez, and Y. Zelinskyy, Efficient calculation of open quantum system dynamics and time-resolved spectroscopy with distributed memory HEOM (DM-HEOM), Journal of Computational Chemistry, vol. 39, no. 22, p. 1779, Jun. 2018, doi: [10.1002/jcc.25354](https://doi.org/10.1002/jcc.25354).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274
https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274:666,Testability,test,test,666,"Thank you for such a quick response. I'm sorry for not getting back to you sooner. > First of all, are you sure that either of DrudeLorentzBath and DrudeLorentzPadeBath give the right solution? Because the ck_real / vk_real are supposed to be the coefficients / exponents of the real part of the correlation function (and the others the imaginary part), and if you plug in imaginary parameters, then terms that previously were only in the real parts could pick up imaginary parts etc. Perhaps this kind of thing cancels out when you add the two unphysical D-L baths to get the shifted D-L bath?. One can use the analytic expression for monomer absorption spectra to test which Drude-Lorentz bath is correct. Also, one can use [DM-HEOM](https://github.com/noma/dm-heom) [2], where they have implemented the ""Shifted Drude Lorentz Bath"" [1]. Compared with their Matsubara implementation, it gives the same density matrix evolution (up to the numerical accuracy) as QuTiP's HEOM gives with `DrudeLorentzBath` and $\gamma \rightarrow \gamma \pm \Omega$ and $\lambda \rightarrow \lambda/2$. But it is not the case for `DrudeLorentzPadeBath`. You are right to think that the unphysical part goes away when two baths are added [1], one with $+i\Omega$ and the other with $-i\Omega$. > However, I would want to be very sure that in the case where the parameters are all real, the results are not affected by the change. Is that so? Only asking because that is not clear to me at first glance. You are very much in the right to be absolutely sure before making a change. As far as I understand and have tested, it will not change the real case because the changes are as follows (I have removed all the other lines in between for clarity):. ```python; - ck_real = [np.real(eta) for eta in eta_p]; + ck_real = [eta for eta in eta_p]. - ck_imag = [np.imag(eta_p[0])]; + ck_imag = [-lam*gamma]. - eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0) - 1.0j)]; + eta_p = [lam * gamma * (self._cot(gamma * beta / 2",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274
https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274:1594,Testability,test,tested,1594,"sorption spectra to test which Drude-Lorentz bath is correct. Also, one can use [DM-HEOM](https://github.com/noma/dm-heom) [2], where they have implemented the ""Shifted Drude Lorentz Bath"" [1]. Compared with their Matsubara implementation, it gives the same density matrix evolution (up to the numerical accuracy) as QuTiP's HEOM gives with `DrudeLorentzBath` and $\gamma \rightarrow \gamma \pm \Omega$ and $\lambda \rightarrow \lambda/2$. But it is not the case for `DrudeLorentzPadeBath`. You are right to think that the unphysical part goes away when two baths are added [1], one with $+i\Omega$ and the other with $-i\Omega$. > However, I would want to be very sure that in the case where the parameters are all real, the results are not affected by the change. Is that so? Only asking because that is not clear to me at first glance. You are very much in the right to be absolutely sure before making a change. As far as I understand and have tested, it will not change the real case because the changes are as follows (I have removed all the other lines in between for clarity):. ```python; - ck_real = [np.real(eta) for eta in eta_p]; + ck_real = [eta for eta in eta_p]. - ck_imag = [np.imag(eta_p[0])]; + ck_imag = [-lam*gamma]. - eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0) - 1.0j)]; + eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0))]; ```; if `gamma` is real, `lam * gamma * self._cot(gamma * beta / 2.0)` would be real, and hence `ck_real` would stay the same as before, and the same can be said for `ck_imag`. After all, this is how it is done for `DrudeLorentzBath`, so it should not impact anything. > A more ""complete"" and probably more efficient solution would be to add a whole new ShiftedDrudeLorentzBath, and to put in analytically derived formulas for the Matsubara / Pade expansion coefficients. (As a first step, you could also calculate these coefficients manually and create a BosonicBath object from them directly.). This is what I have been using locally. I",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274
https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274:1456,Usability,clear,clear,1456,"ts could pick up imaginary parts etc. Perhaps this kind of thing cancels out when you add the two unphysical D-L baths to get the shifted D-L bath?. One can use the analytic expression for monomer absorption spectra to test which Drude-Lorentz bath is correct. Also, one can use [DM-HEOM](https://github.com/noma/dm-heom) [2], where they have implemented the ""Shifted Drude Lorentz Bath"" [1]. Compared with their Matsubara implementation, it gives the same density matrix evolution (up to the numerical accuracy) as QuTiP's HEOM gives with `DrudeLorentzBath` and $\gamma \rightarrow \gamma \pm \Omega$ and $\lambda \rightarrow \lambda/2$. But it is not the case for `DrudeLorentzPadeBath`. You are right to think that the unphysical part goes away when two baths are added [1], one with $+i\Omega$ and the other with $-i\Omega$. > However, I would want to be very sure that in the case where the parameters are all real, the results are not affected by the change. Is that so? Only asking because that is not clear to me at first glance. You are very much in the right to be absolutely sure before making a change. As far as I understand and have tested, it will not change the real case because the changes are as follows (I have removed all the other lines in between for clarity):. ```python; - ck_real = [np.real(eta) for eta in eta_p]; + ck_real = [eta for eta in eta_p]. - ck_imag = [np.imag(eta_p[0])]; + ck_imag = [-lam*gamma]. - eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0) - 1.0j)]; + eta_p = [lam * gamma * (self._cot(gamma * beta / 2.0))]; ```; if `gamma` is real, `lam * gamma * self._cot(gamma * beta / 2.0)` would be real, and hence `ck_real` would stay the same as before, and the same can be said for `ck_imag`. After all, this is how it is done for `DrudeLorentzBath`, so it should not impact anything. > A more ""complete"" and probably more efficient solution would be to add a whole new ShiftedDrudeLorentzBath, and to put in analytically derived formulas for the Matsubara",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2520#issuecomment-2358685274
https://github.com/qutip/qutip/pull/2523#issuecomment-2332246101:90,Availability,error,error,90,"The stuff in `doc/contrib` does not seems to have been used anywhere. I erased it and not error/warnings appeared, but can't tell you what it was used for.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2523#issuecomment-2332246101
https://github.com/qutip/qutip/issues/2525#issuecomment-2334203314:178,Deployability,install,install,178,"Thank you for your interest.; You are looking at the development version of the documentation (`master` instead of `latest`).; If you want to try that function, you will need to install qutip from source or wait until the 5.1 release. (Should be released this fall.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2525#issuecomment-2334203314
https://github.com/qutip/qutip/issues/2525#issuecomment-2334203314:226,Deployability,release,release,226,"Thank you for your interest.; You are looking at the development version of the documentation (`master` instead of `latest`).; If you want to try that function, you will need to install qutip from source or wait until the 5.1 release. (Should be released this fall.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2525#issuecomment-2334203314
https://github.com/qutip/qutip/issues/2525#issuecomment-2334203314:246,Deployability,release,released,246,"Thank you for your interest.; You are looking at the development version of the documentation (`master` instead of `latest`).; If you want to try that function, you will need to install qutip from source or wait until the 5.1 release. (Should be released this fall.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2525#issuecomment-2334203314
https://github.com/qutip/qutip/pull/2526#issuecomment-2334653751:16,Testability,test,tests,16,"Failing windows tests are related to mkl, not this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2526#issuecomment-2334653751
https://github.com/qutip/qutip/pull/2527#issuecomment-2334801778:24,Deployability,install,install,24,"If needed, you can also install some things with `pip` in the `pip:` section at the bottom.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2527#issuecomment-2334801778
https://github.com/qutip/qutip/issues/2530#issuecomment-2400673404:158,Usability,clear,clearly,158,"Could you send the example?; If it's constant, I am surprised that you cannot get under one minute after converting to csr. Looking back at the code and it's clearly optimised for dense. ; `from_eigbasis` does something like `Dense @ CSR @ Dense.dag()`, since we don't have `Dense @ CSR` it convert to dense representation. It would work better with anything but CSR...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2400673404
https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:129,Deployability,install,install,129,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583
https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:473,Energy Efficiency,power,power,473,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583
https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:534,Energy Efficiency,power,power,534,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583
https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:1089,Energy Efficiency,Energy,Energy,1089,"this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""store_states"": True, ""progress_bar"": True} . #standard; result_ising = Ising_solve(N, g0, J0, ga",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583
https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:108,Integrability,depend,depends,108,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583
https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:296,Integrability,depend,depend,296,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583
https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:748,Modifiability,coupling,couplings,748,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583
https://github.com/qutip/qutip/issues/2530#issuecomment-2405171533:201,Integrability,depend,depend,201,"There is a bug in `brmesolve`. When it prepare the system, it convert everything to `QobjEvo` to allows list format. But then `bloch_redfield_tensor` use `Qobj` vs `QobjEvo` to determine if the system depend on time (since the spectra could depend on time and there is no check for that, we use the class of the corresponding `a_op`). Therefore, when using `brmesolve`, it always use the time-dependent version that compute the eigen states at each time step...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2405171533
https://github.com/qutip/qutip/issues/2530#issuecomment-2405171533:241,Integrability,depend,depend,241,"There is a bug in `brmesolve`. When it prepare the system, it convert everything to `QobjEvo` to allows list format. But then `bloch_redfield_tensor` use `Qobj` vs `QobjEvo` to determine if the system depend on time (since the spectra could depend on time and there is no check for that, we use the class of the corresponding `a_op`). Therefore, when using `brmesolve`, it always use the time-dependent version that compute the eigen states at each time step...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2405171533
https://github.com/qutip/qutip/issues/2530#issuecomment-2405171533:393,Integrability,depend,dependent,393,"There is a bug in `brmesolve`. When it prepare the system, it convert everything to `QobjEvo` to allows list format. But then `bloch_redfield_tensor` use `Qobj` vs `QobjEvo` to determine if the system depend on time (since the spectra could depend on time and there is no check for that, we use the class of the corresponding `a_op`). Therefore, when using `brmesolve`, it always use the time-dependent version that compute the eigen states at each time step...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2405171533
https://github.com/qutip/qutip/issues/2532#issuecomment-2356706508:619,Integrability,depend,dependent,619,"I also just tried an mesolve simulation after removing the collapse operators (in Qutip 4.7) and now the propagator results seem to match; ```shell; results = mesolve(H, psi_0, t, c_ops = []); U = propagator(H, t, c_ops=[]); plt.plot(t, expect(a_u.dag() * a_u, results.states), label=""mesolve""); for i in range(len(t)):; plt.plot(t[i], expect(a_u.dag() * a_u, U[i]*psi_0), ""x"", color=""orange""); plt.ylabel(""Population""); plt.xlabel(""Time""); plt.legend(); plt.show()```. ![image](https://github.com/user-attachments/assets/ae1f3097-044e-419b-98f1-1f0462edb9f2). It makes me think that the propagator is not using a time-dependent collapse operator possibly?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2532#issuecomment-2356706508
https://github.com/qutip/qutip/issues/2532#issuecomment-2357056333:0,Deployability,Update,Update,0,"Update: I managed to find the propagator in a somewhat makeshift manner by sending an identity matrix to mesolve (although with reduced dimensions than in the code above):. ```shell; results = mesolve(H, psi_0, t, c_ops = c_ops) ### Dimensions here are [2,2,2] as compared to [3,3,7] above; plt.plot(t, expect(a_u.dag() * a_u, results.states), label=""mesolve""); for i in range(len(t)):; rho_vec = mat2vec(0.full()); rho_T = Qobj(vec2mat(U_me.states[i].data * rho_vec), dims = 0.dims); plt.plot(t[i], expect(a_u.dag() * a_u, rho_T), ""x"", color=""orange""); plt.ylabel(""Population""); plt.xlabel(""Time""); plt.legend(); plt.show(); ```. ![image](https://github.com/user-attachments/assets/f65f25df-db91-49d6-a92a-77c3dced0900). If there's a better way of doing it, please let me know!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2532#issuecomment-2357056333
https://github.com/qutip/qutip/issues/2532#issuecomment-2357056333:128,Energy Efficiency,reduce,reduced,128,"Update: I managed to find the propagator in a somewhat makeshift manner by sending an identity matrix to mesolve (although with reduced dimensions than in the code above):. ```shell; results = mesolve(H, psi_0, t, c_ops = c_ops) ### Dimensions here are [2,2,2] as compared to [3,3,7] above; plt.plot(t, expect(a_u.dag() * a_u, results.states), label=""mesolve""); for i in range(len(t)):; rho_vec = mat2vec(0.full()); rho_T = Qobj(vec2mat(U_me.states[i].data * rho_vec), dims = 0.dims); plt.plot(t[i], expect(a_u.dag() * a_u, rho_T), ""x"", color=""orange""); plt.ylabel(""Population""); plt.xlabel(""Time""); plt.legend(); plt.show(); ```. ![image](https://github.com/user-attachments/assets/f65f25df-db91-49d6-a92a-77c3dced0900). If there's a better way of doing it, please let me know!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2532#issuecomment-2357056333
https://github.com/qutip/qutip/issues/2532#issuecomment-2400426686:20,Integrability,depend,dependent,20,"For v5, to use time dependent `c_ops`, you would need to make the `QobjEvo` first:; ```; c_ops = [QobjEvo(op, tlist=t) for op in c_ops]; ```; and pass `tlist=t` to the propagator function. `H` taking list format but `c_ops` only prebuild `QobjEvo` is bad design. We will fix. But for the spline times, I believe it's better to keep it independent on the output times. It is useful be able to have different times for the output and input pulse sampling. So I improve the documentation for that issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2532#issuecomment-2400426686
https://github.com/qutip/qutip/pull/2533#issuecomment-2400118195:154,Modifiability,extend,extend,154,"We had it before and it introduced issues that lead us to remove it, see #1278, #1433, #1611... It also limits us to what is a `Qobj` which we have ideas extend.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2533#issuecomment-2400118195
https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:1120,Energy Efficiency,power,power,1120,"r a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would require some thinking about how environments ca",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525
https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:1904,Energy Efficiency,power,power,1904,"y replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would require some thinking about how environments can best be passed to those solvers.) Similarly, QuTiP could automatically compute Markovian embeddings with pseudomodes or reaction coordinates.; * The module provides a framework for the idea of approximating one environment by another (multi-exponential) one, and more approximation methods could be added in the future. For example, Gerardo has been working on a method fitting the power spectrum using the so-called AAA algorithm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525
https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:2431,Energy Efficiency,power,power,2431,"y replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would require some thinking about how environments can best be passed to those solvers.) Similarly, QuTiP could automatically compute Markovian embeddings with pseudomodes or reaction coordinates.; * The module provides a framework for the idea of approximating one environment by another (multi-exponential) one, and more approximation methods could be added in the future. For example, Gerardo has been working on a method fitting the power spectrum using the so-called AAA algorithm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525
https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:1273,Integrability,interface,interface,1273,"ed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would require some thinking about how environments can best be passed to those solvers.) Similarly, QuTiP could automatically compute Markovian embeddings with pseudomodes or reaction coordinates.; * The module provides a framework for the idea of approximating one environment by an",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525
https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:737,Modifiability,coupling,coupling,737,"Thank you for all your work @gsuarezr . Just for a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525
https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:1032,Modifiability,coupling,coupling,1032,"r a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would require some thinking about how environments ca",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525
https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:580,Safety,avoid,avoid,580,"Thank you for all your work @gsuarezr . Just for a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525
https://github.com/qutip/qutip/pull/2534#issuecomment-2372823795:141,Integrability,wrap,wrap,141,"Just another small issue, I found that if I use UnderDampedEnvironment.spectral_density() with brmesolve(), it fails in numpy 2.1.1 unless I wrap the SD function in another function. Strangely works without needing to wrap it in numpy 1.26.4. Seems to some difference in the way zero-dimensional arrays are treated, but not super sure.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2372823795
https://github.com/qutip/qutip/pull/2534#issuecomment-2372823795:218,Integrability,wrap,wrap,218,"Just another small issue, I found that if I use UnderDampedEnvironment.spectral_density() with brmesolve(), it fails in numpy 2.1.1 unless I wrap the SD function in another function. Strangely works without needing to wrap it in numpy 1.26.4. Seems to some difference in the way zero-dimensional arrays are treated, but not super sure.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2372823795
https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464:397,Deployability,integrat,integrating,397,"> Just another small issue, I found that if I use UnderDampedEnvironment.spectral_density() with brmesolve(), it fails in numpy 2.1.1 unless I wrap the SD function in another function. Strangely works without needing to wrap it in numpy 1.26.4. Seems to some difference in the way zero-dimensional arrays are treated, but not super sure. I noticed that as well,.I didn't fix it because we are not integrating with the solvers yet, but could check if the argument of correlation function is an array, and if it's not do the .item() bit, just so that brmesolve works smoothly",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464
https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464:143,Integrability,wrap,wrap,143,"> Just another small issue, I found that if I use UnderDampedEnvironment.spectral_density() with brmesolve(), it fails in numpy 2.1.1 unless I wrap the SD function in another function. Strangely works without needing to wrap it in numpy 1.26.4. Seems to some difference in the way zero-dimensional arrays are treated, but not super sure. I noticed that as well,.I didn't fix it because we are not integrating with the solvers yet, but could check if the argument of correlation function is an array, and if it's not do the .item() bit, just so that brmesolve works smoothly",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464
https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464:220,Integrability,wrap,wrap,220,"> Just another small issue, I found that if I use UnderDampedEnvironment.spectral_density() with brmesolve(), it fails in numpy 2.1.1 unless I wrap the SD function in another function. Strangely works without needing to wrap it in numpy 1.26.4. Seems to some difference in the way zero-dimensional arrays are treated, but not super sure. I noticed that as well,.I didn't fix it because we are not integrating with the solvers yet, but could check if the argument of correlation function is an array, and if it's not do the .item() bit, just so that brmesolve works smoothly",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464
https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464:397,Integrability,integrat,integrating,397,"> Just another small issue, I found that if I use UnderDampedEnvironment.spectral_density() with brmesolve(), it fails in numpy 2.1.1 unless I wrap the SD function in another function. Strangely works without needing to wrap it in numpy 1.26.4. Seems to some difference in the way zero-dimensional arrays are treated, but not super sure. I noticed that as well,.I didn't fix it because we are not integrating with the solvers yet, but could check if the argument of correlation function is an array, and if it's not do the .item() bit, just so that brmesolve works smoothly",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2372966464
https://github.com/qutip/qutip/pull/2534#issuecomment-2437142464:18,Deployability,update,updates,18,"Thank you for the updates, @gsuarezr !. To give a brief summary of the progress: on our todo-list we have the following items left:; * Neill's comment above and one TODO comment I left somewhere in the code earlier; * Finishing tests for the environment module and the fitting utility function; * Adding tests for the HEOM solver using the new API; * Updating (at least some of) the HEOM tutorial notebooks to show off the new features. The main code and documentation is converging from our side, and I think ready for more detailed reviews.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2437142464
https://github.com/qutip/qutip/pull/2534#issuecomment-2437142464:228,Testability,test,tests,228,"Thank you for the updates, @gsuarezr !. To give a brief summary of the progress: on our todo-list we have the following items left:; * Neill's comment above and one TODO comment I left somewhere in the code earlier; * Finishing tests for the environment module and the fitting utility function; * Adding tests for the HEOM solver using the new API; * Updating (at least some of) the HEOM tutorial notebooks to show off the new features. The main code and documentation is converging from our side, and I think ready for more detailed reviews.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2437142464
https://github.com/qutip/qutip/pull/2534#issuecomment-2437142464:304,Testability,test,tests,304,"Thank you for the updates, @gsuarezr !. To give a brief summary of the progress: on our todo-list we have the following items left:; * Neill's comment above and one TODO comment I left somewhere in the code earlier; * Finishing tests for the environment module and the fitting utility function; * Adding tests for the HEOM solver using the new API; * Updating (at least some of) the HEOM tutorial notebooks to show off the new features. The main code and documentation is converging from our side, and I think ready for more detailed reviews.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2437142464
https://github.com/qutip/qutip/issues/2535#issuecomment-2370679738:120,Deployability,update,updated,120,"The fix seems to be rather straight forward in that the `_get_coord_info_new` function in `_remove_margins` needs to be updated to the new matplotlib one. . I could get on it myself later this week and create a PR. However this fix would probably lead to an incompatibility with `matplotlib<=3.9`, how would this be generally handled?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2535#issuecomment-2370679738
https://github.com/qutip/qutip/issues/2536#issuecomment-2372741589:144,Availability,error,error,144,"Hi Sabhyata21, thank you for the report. Could you please include the output of the command `qutip.about()`? Because your code does not give an error on my setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2536#issuecomment-2372741589
https://github.com/qutip/qutip/issues/2536#issuecomment-2373078683:1350,Availability,error,error,1350,"QuTiP: Quantum Toolbox in Python. ================================. Copyright (c) QuTiP team 2011 and later. Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed,; Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman, Simon Cross, Asier; Galicia, Paul Menczel, and Patrick Hopf. Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco; Nori and Will Zeng. Original developers: R. J. Johansson & P. D. Nation. Previous lead developers: Chris Granade & A. Grimsmo. Currently developed through wide collaboration. See https://github.com/qutip; for details. QuTiP Version: 5.0.4. Numpy Version: 1.24.3. Scipy Version: 1.14.1. Cython Version: None. Matplotlib Version: 3.7.2. Python Version: 3.11.5. Number of CPUs: 16. BLAS Info: INTEL MKL. INTEL MKL Ext: False. Platform Info: Windows (AMD64). Installation path: C:\Users\sabhy\anaconda3\Lib\site-packages\qutip. ================================================================================. Please cite QuTiP in your publication. ================================================================================. For your convenience a bibtex reference can be easily generated using; `qutip.cite()`. On Wed, Sep 25, 2024 at 4:09AM Paul ***@***.***> wrote:. > Could you please include the output of the command qutip.about()? Because; > your code does not give an error on my setup.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/2536#issuecomment-2372741589>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AJVIYE6VAXW7QIVMRM4WQTDZYILLZAVCNFSM6AAAAABOYAR32CVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGNZSG42DCNJYHE>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2536#issuecomment-2373078683
https://github.com/qutip/qutip/issues/2536#issuecomment-2373078683:827,Deployability,Install,Installation,827,"QuTiP: Quantum Toolbox in Python. ================================. Copyright (c) QuTiP team 2011 and later. Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed,; Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman, Simon Cross, Asier; Galicia, Paul Menczel, and Patrick Hopf. Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco; Nori and Will Zeng. Original developers: R. J. Johansson & P. D. Nation. Previous lead developers: Chris Granade & A. Grimsmo. Currently developed through wide collaboration. See https://github.com/qutip; for details. QuTiP Version: 5.0.4. Numpy Version: 1.24.3. Scipy Version: 1.14.1. Cython Version: None. Matplotlib Version: 3.7.2. Python Version: 3.11.5. Number of CPUs: 16. BLAS Info: INTEL MKL. INTEL MKL Ext: False. Platform Info: Windows (AMD64). Installation path: C:\Users\sabhy\anaconda3\Lib\site-packages\qutip. ================================================================================. Please cite QuTiP in your publication. ================================================================================. For your convenience a bibtex reference can be easily generated using; `qutip.cite()`. On Wed, Sep 25, 2024 at 4:09AM Paul ***@***.***> wrote:. > Could you please include the output of the command qutip.about()? Because; > your code does not give an error on my setup.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/2536#issuecomment-2372741589>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AJVIYE6VAXW7QIVMRM4WQTDZYILLZAVCNFSM6AAAAABOYAR32CVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGNZSG42DCNJYHE>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2536#issuecomment-2373078683
https://github.com/qutip/qutip/issues/2536#issuecomment-2373078683:1744,Integrability,Message,Message,1744,"QuTiP: Quantum Toolbox in Python. ================================. Copyright (c) QuTiP team 2011 and later. Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed,; Neill Lambert, Eric Gigure, Boxi Li, Jake Lishman, Simon Cross, Asier; Galicia, Paul Menczel, and Patrick Hopf. Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco; Nori and Will Zeng. Original developers: R. J. Johansson & P. D. Nation. Previous lead developers: Chris Granade & A. Grimsmo. Currently developed through wide collaboration. See https://github.com/qutip; for details. QuTiP Version: 5.0.4. Numpy Version: 1.24.3. Scipy Version: 1.14.1. Cython Version: None. Matplotlib Version: 3.7.2. Python Version: 3.11.5. Number of CPUs: 16. BLAS Info: INTEL MKL. INTEL MKL Ext: False. Platform Info: Windows (AMD64). Installation path: C:\Users\sabhy\anaconda3\Lib\site-packages\qutip. ================================================================================. Please cite QuTiP in your publication. ================================================================================. For your convenience a bibtex reference can be easily generated using; `qutip.cite()`. On Wed, Sep 25, 2024 at 4:09AM Paul ***@***.***> wrote:. > Could you please include the output of the command qutip.about()? Because; > your code does not give an error on my setup.; >; > ; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/2536#issuecomment-2372741589>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AJVIYE6VAXW7QIVMRM4WQTDZYILLZAVCNFSM6AAAAABOYAR32CVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGNZSG42DCNJYHE>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2536#issuecomment-2373078683
https://github.com/qutip/qutip/issues/2536#issuecomment-2375830378:92,Availability,error,error,92,"Using the exact same qutip, numpy, scipy and python versions, I still cannot reproduce your error. Perhaps something messed up your installation? I would recommend trying again in a fresh conda environment.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2536#issuecomment-2375830378
https://github.com/qutip/qutip/issues/2536#issuecomment-2375830378:132,Deployability,install,installation,132,"Using the exact same qutip, numpy, scipy and python versions, I still cannot reproduce your error. Perhaps something messed up your installation? I would recommend trying again in a fresh conda environment.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2536#issuecomment-2375830378
https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920:304,Deployability,continuous,continuously,304,"Congratulations, you have rediscovered the quantum Zeno effect :-) There is nothing wrong with qutip here, I think. You don't write what your system is exactly, but I assume something like $H=\sigma_x$ and jump operator $\sigma_-$. The effect of the environment can be thought of as measuring the system continuously, with a strength proportional to the coupling rate, which you call jump rate. Jump rate is indeed a slightly misleading (but commonly used) name. Its meaning is the reciprocal of the expected time until a jump, if the system is in the excited state. However, due to the continuous measurement and the quantum Zeno effect, the system rarely makes it to the excited state in the first place. Mathematically, where it comes from is that the deterministic trajectory evolution (between the jumps) is given not by the system Hamiltonian, but by an effective (non hermitian) Hamiltonian. In the limit of large coupling rates, this effective Hamiltonian becomes approximately diagonal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920
https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920:587,Deployability,continuous,continuous,587,"Congratulations, you have rediscovered the quantum Zeno effect :-) There is nothing wrong with qutip here, I think. You don't write what your system is exactly, but I assume something like $H=\sigma_x$ and jump operator $\sigma_-$. The effect of the environment can be thought of as measuring the system continuously, with a strength proportional to the coupling rate, which you call jump rate. Jump rate is indeed a slightly misleading (but commonly used) name. Its meaning is the reciprocal of the expected time until a jump, if the system is in the excited state. However, due to the continuous measurement and the quantum Zeno effect, the system rarely makes it to the excited state in the first place. Mathematically, where it comes from is that the deterministic trajectory evolution (between the jumps) is given not by the system Hamiltonian, but by an effective (non hermitian) Hamiltonian. In the limit of large coupling rates, this effective Hamiltonian becomes approximately diagonal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920
https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920:354,Modifiability,coupling,coupling,354,"Congratulations, you have rediscovered the quantum Zeno effect :-) There is nothing wrong with qutip here, I think. You don't write what your system is exactly, but I assume something like $H=\sigma_x$ and jump operator $\sigma_-$. The effect of the environment can be thought of as measuring the system continuously, with a strength proportional to the coupling rate, which you call jump rate. Jump rate is indeed a slightly misleading (but commonly used) name. Its meaning is the reciprocal of the expected time until a jump, if the system is in the excited state. However, due to the continuous measurement and the quantum Zeno effect, the system rarely makes it to the excited state in the first place. Mathematically, where it comes from is that the deterministic trajectory evolution (between the jumps) is given not by the system Hamiltonian, but by an effective (non hermitian) Hamiltonian. In the limit of large coupling rates, this effective Hamiltonian becomes approximately diagonal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920
https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920:921,Modifiability,coupling,coupling,921,"Congratulations, you have rediscovered the quantum Zeno effect :-) There is nothing wrong with qutip here, I think. You don't write what your system is exactly, but I assume something like $H=\sigma_x$ and jump operator $\sigma_-$. The effect of the environment can be thought of as measuring the system continuously, with a strength proportional to the coupling rate, which you call jump rate. Jump rate is indeed a slightly misleading (but commonly used) name. Its meaning is the reciprocal of the expected time until a jump, if the system is in the excited state. However, due to the continuous measurement and the quantum Zeno effect, the system rarely makes it to the excited state in the first place. Mathematically, where it comes from is that the deterministic trajectory evolution (between the jumps) is given not by the system Hamiltonian, but by an effective (non hermitian) Hamiltonian. In the limit of large coupling rates, this effective Hamiltonian becomes approximately diagonal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920
https://github.com/qutip/qutip/issues/2539#issuecomment-2400213467:202,Availability,down,down,202,"Can you please say something about result.photocurrent? I can see it contains all the jumps from all the trajectories, but what is the meaning of the value associated with each jump? It believe it goes down when I increase the number of trajectories or timesteps, so I think it is perhaps dividing by those numbers? But I don't know what else it might depend on. Thanks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2400213467
https://github.com/qutip/qutip/issues/2539#issuecomment-2400213467:352,Integrability,depend,depend,352,"Can you please say something about result.photocurrent? I can see it contains all the jumps from all the trajectories, but what is the meaning of the value associated with each jump? It believe it goes down when I increase the number of trajectories or timesteps, so I think it is perhaps dividing by those numbers? But I don't know what else it might depend on. Thanks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2400213467
https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615:45,Safety,detect,detector,45,"Hi Emily,. The photocurrent is the number of detector clicks (i.e., jumps) per unit time, averaged over all trajectories. For sufficiently many trajectories, it will approximate $tr[C_n \rho(t) C_n^\dagger]$. If I'm not mistaken, you should find that; ```math; x = \frac{1}{\Delta t} \frac{1}{N_t}; ```; where $\Delta t$ is the spacing in your `tlist` and $N_t$ the number of trajectories. The integer (photocurrent/x) is simply the number of clicks in that time interval in all trajectories; we multiply with x for the ""per unit time, averaged over all trajectories"" that I wrote above. Paul. (PS. I only noticed your username now - is it possible we had a chat at QTD in August? Hope you are doing well!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615
https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615:422,Usability,simpl,simply,422,"Hi Emily,. The photocurrent is the number of detector clicks (i.e., jumps) per unit time, averaged over all trajectories. For sufficiently many trajectories, it will approximate $tr[C_n \rho(t) C_n^\dagger]$. If I'm not mistaken, you should find that; ```math; x = \frac{1}{\Delta t} \frac{1}{N_t}; ```; where $\Delta t$ is the spacing in your `tlist` and $N_t$ the number of trajectories. The integer (photocurrent/x) is simply the number of clicks in that time interval in all trajectories; we multiply with x for the ""per unit time, averaged over all trajectories"" that I wrote above. Paul. (PS. I only noticed your username now - is it possible we had a chat at QTD in August? Hope you are doing well!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615
https://github.com/qutip/qutip/issues/2539#issuecomment-2405574712:64,Integrability,depend,dependence,64,"Yes, we chatted at QTD! :); Today when I do this I do not see a dependence in x on the jump rate, and yes, it is just the formula you gave. I don't quite understand what went wrong yesterday such that I was seeing a dependence on the jump rate. That was on a different computer, so perhaps its time to restart that one.; Emily",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2405574712
https://github.com/qutip/qutip/issues/2539#issuecomment-2405574712:216,Integrability,depend,dependence,216,"Yes, we chatted at QTD! :); Today when I do this I do not see a dependence in x on the jump rate, and yes, it is just the formula you gave. I don't quite understand what went wrong yesterday such that I was seeing a dependence on the jump rate. That was on a different computer, so perhaps its time to restart that one.; Emily",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2405574712
https://github.com/qutip/qutip/pull/2545#issuecomment-2415262480:108,Security,expose,exposed,108,Thanks @fmayo96. Question: Should the `einsum` function be in `dimensions.py`? And should it be internal or exposed via the public API? It looks generically useful but what specific use cases do we have in mind?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2545#issuecomment-2415262480
https://github.com/qutip/qutip/pull/2545#issuecomment-2415282442:4,Usability,simpl,simplest,4,"The simplest use case is the circuit simulation, where e.g. single qubit unitaries are multiplied to multiqubit states. For Hamiltonian dynamics I cannot immediately think of an application cause usually you need to sum many terms. Unless we develop a troterrizatiom solver, which is actually quite common, especially for distributed computation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2545#issuecomment-2415282442
https://github.com/qutip/qutip/pull/2545#issuecomment-2417329528:57,Testability,test,tests,57,"I have corrected the code for compound systems and added tests for two and three qubits. I am not sure about which is the best place for this function, I made it to solve the Issue #2340. If you consider it fits better in a different place I will be happy to modify it",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2545#issuecomment-2417329528
https://github.com/qutip/qutip/pull/2545#issuecomment-2422290060:116,Usability,feedback,feedback,116,"Oh, I am sorry, I have misunderstood what you wanted. I think that now I have fixed it. Thank you very much for the feedback!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2545#issuecomment-2422290060
https://github.com/qutip/qutip/issues/2546#issuecomment-2416283354:70,Usability,guid,guidelines,70,Sure! I can prepare everything this evening following the development guidelines and send a pull request. Thanks!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2546#issuecomment-2416283354
https://github.com/qutip/qutip/issues/2547#issuecomment-2417585366:275,Deployability,update,update,275,"For product between `Qobj` `@` is strongly recommended. `*` should only be used for `Qobj * scalar`. `*` still exist for historical reason (qutip predate the addition of the `@` operator) and changing it's behaviour could break codes, so we prefer to not touch it. We should update the documentation to use `@`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2547#issuecomment-2417585366
https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426:258,Deployability,update,updated,258,"Ok, I added the tests. Took me a little moment, first time I'm doing this. Are these sufficient or should I add something else?; It's not rigorously testing everything but for sure the things that I adjusted. I also stumbled upon a deprecation warning, so I updated the syntax for the `colormaps`. With the tests for `HarmonicOscillatorWaveFunction` and `HarmonicOscillatorProbabilityFunction` I got the warning `ComplexWarning: Casting complex values to real discards the imaginary part` in two instances. Not sure how I should proceed, so I wanted to ask. Should I just ignore it and keep it like it was or search for where exactly this happens and adjust it so it explicitly calls np.real(), or maybe np.abs()? Thanks a lot for the help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426
https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426:16,Testability,test,tests,16,"Ok, I added the tests. Took me a little moment, first time I'm doing this. Are these sufficient or should I add something else?; It's not rigorously testing everything but for sure the things that I adjusted. I also stumbled upon a deprecation warning, so I updated the syntax for the `colormaps`. With the tests for `HarmonicOscillatorWaveFunction` and `HarmonicOscillatorProbabilityFunction` I got the warning `ComplexWarning: Casting complex values to real discards the imaginary part` in two instances. Not sure how I should proceed, so I wanted to ask. Should I just ignore it and keep it like it was or search for where exactly this happens and adjust it so it explicitly calls np.real(), or maybe np.abs()? Thanks a lot for the help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426
https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426:149,Testability,test,testing,149,"Ok, I added the tests. Took me a little moment, first time I'm doing this. Are these sufficient or should I add something else?; It's not rigorously testing everything but for sure the things that I adjusted. I also stumbled upon a deprecation warning, so I updated the syntax for the `colormaps`. With the tests for `HarmonicOscillatorWaveFunction` and `HarmonicOscillatorProbabilityFunction` I got the warning `ComplexWarning: Casting complex values to real discards the imaginary part` in two instances. Not sure how I should proceed, so I wanted to ask. Should I just ignore it and keep it like it was or search for where exactly this happens and adjust it so it explicitly calls np.real(), or maybe np.abs()? Thanks a lot for the help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426
https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426:307,Testability,test,tests,307,"Ok, I added the tests. Took me a little moment, first time I'm doing this. Are these sufficient or should I add something else?; It's not rigorously testing everything but for sure the things that I adjusted. I also stumbled upon a deprecation warning, so I updated the syntax for the `colormaps`. With the tests for `HarmonicOscillatorWaveFunction` and `HarmonicOscillatorProbabilityFunction` I got the warning `ComplexWarning: Casting complex values to real discards the imaginary part` in two instances. Not sure how I should proceed, so I wanted to ask. Should I just ignore it and keep it like it was or search for where exactly this happens and adjust it so it explicitly calls np.real(), or maybe np.abs()? Thanks a lot for the help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420588426
https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916:157,Availability,error,error,157,"Thank you for the tests. ; These tests will already ensure future changes don't break anything so we are quite grateful for them as is. We treat warnings as error during automated tests, so the casting warnings need to be fixed.; You change `self.data` to `self.data.real` in all 3 `visualize_...` functions. It will show same plot without the warnings. Maybe if there are interest, we could add an option as to what to show (real, imag, abs, ...), but not in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916
https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916:18,Testability,test,tests,18,"Thank you for the tests. ; These tests will already ensure future changes don't break anything so we are quite grateful for them as is. We treat warnings as error during automated tests, so the casting warnings need to be fixed.; You change `self.data` to `self.data.real` in all 3 `visualize_...` functions. It will show same plot without the warnings. Maybe if there are interest, we could add an option as to what to show (real, imag, abs, ...), but not in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916
https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916:33,Testability,test,tests,33,"Thank you for the tests. ; These tests will already ensure future changes don't break anything so we are quite grateful for them as is. We treat warnings as error during automated tests, so the casting warnings need to be fixed.; You change `self.data` to `self.data.real` in all 3 `visualize_...` functions. It will show same plot without the warnings. Maybe if there are interest, we could add an option as to what to show (real, imag, abs, ...), but not in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916
https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916:180,Testability,test,tests,180,"Thank you for the tests. ; These tests will already ensure future changes don't break anything so we are quite grateful for them as is. We treat warnings as error during automated tests, so the casting warnings need to be fixed.; You change `self.data` to `self.data.real` in all 3 `visualize_...` functions. It will show same plot without the warnings. Maybe if there are interest, we could add an option as to what to show (real, imag, abs, ...), but not in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2548#issuecomment-2420725916
https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908:579,Modifiability,coupling,coupling,579,"You are measuring the expectation of sigmax, if you measure the expectation value of sigmaz, or the population, you will not observe such a big oscillation but very small oscillations. Not sure what you want to achieve, but your detuning is negligibly small compared to the frequency. It has little effect. Also I'm not sure if there is a typo `v_0` and `drive_detuning` seems to have the unit of frequency, and 2*pi* frequency. You have a time-independent Hamiltonian, so if you want to compute the ZZ interaction, you can simply diagonalize the matrix and see if you have a ZZ coupling term.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908
https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908:524,Usability,simpl,simply,524,"You are measuring the expectation of sigmax, if you measure the expectation value of sigmaz, or the population, you will not observe such a big oscillation but very small oscillations. Not sure what you want to achieve, but your detuning is negligibly small compared to the frequency. It has little effect. Also I'm not sure if there is a typo `v_0` and `drive_detuning` seems to have the unit of frequency, and 2*pi* frequency. You have a time-independent Hamiltonian, so if you want to compute the ZZ interaction, you can simply diagonalize the matrix and see if you have a ZZ coupling term.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908
https://github.com/qutip/qutip/pull/2550#issuecomment-2439085075:41,Testability,test,tests,41,"> thanks, looks good to me! not sure why tests are failing. Definitely not related to this change, but weird. Had a brief look but couldn't make much sense of it :/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/2550#issuecomment-2439085075
https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658:80,Safety,safe,safer,80,"It could be that a pulse is too thin and missed.; When working with pulse, it's safer to always set [max_step](https://qutip.readthedocs.io/en/latest/guide/dynamics/dynamics-time.html#working-with-pulses).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658
https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658:150,Usability,guid,guide,150,"It could be that a pulse is too thin and missed.; When working with pulse, it's safer to always set [max_step](https://qutip.readthedocs.io/en/latest/guide/dynamics/dynamics-time.html#working-with-pulses).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658
