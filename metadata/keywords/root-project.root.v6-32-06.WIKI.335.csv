id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html532/ROOT__Math__Minimizer.html:400,Modifiability,Plug-in,Plug-in,400,". ROOT::Math::Minimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Minimizer. class ROOT::Math::Minimizer. Abstract Minimizer class, defining the interface for the various minimizer; (like Minuit2, Minuit, GSL, etc..); Plug-in's exist in ROOT to be able to instantiate the derived classes like; ROOT::Math::GSLMinimizer or ROOT::Math::Minuit2Minimizer via the; plug-in manager. Provides interface for setting the function to be minimized.; The function must implemente the multi-dimensional generic interface; ROOT::Math::IBaseFunctionMultiDim.; If the function provides gradient calculation; (implements the ROOT::Math::IGradientFunctionMultiDim interface) this will be; used by the Minimizer. It Defines also interface for setting the initial values for the function variables (which are the parameters in; of the model function in case of solving for fitting) and especifying their limits. It defines the interface to set and retrieve basic minimization parameters; (for specific Minimizer parameters one must use the derived classes). Then it defines the interface to retrieve the result of minimization ( minimum X values, function value,; gradient, error on the mimnimum, etc...). @ingroup MultiMin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Minimizer(); virtual voidClear(); virtual boolContour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double*) const; virtual boolGetHessianMatrix(",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:542,Modifiability,plug-in,plug-in,542,". ROOT::Math::Minimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Minimizer. class ROOT::Math::Minimizer. Abstract Minimizer class, defining the interface for the various minimizer; (like Minuit2, Minuit, GSL, etc..); Plug-in's exist in ROOT to be able to instantiate the derived classes like; ROOT::Math::GSLMinimizer or ROOT::Math::Minuit2Minimizer via the; plug-in manager. Provides interface for setting the function to be minimized.; The function must implemente the multi-dimensional generic interface; ROOT::Math::IBaseFunctionMultiDim.; If the function provides gradient calculation; (implements the ROOT::Math::IGradientFunctionMultiDim interface) this will be; used by the Minimizer. It Defines also interface for setting the initial values for the function variables (which are the parameters in; of the model function in case of solving for fitting) and especifying their limits. It defines the interface to set and retrieve basic minimization parameters; (for specific Minimizer parameters one must use the derived classes). Then it defines the interface to retrieve the result of minimization ( minimum X values, function value,; gradient, error on the mimnimum, etc...). @ingroup MultiMin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Minimizer(); virtual voidClear(); virtual boolContour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double*) const; virtual boolGetHessianMatrix(",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:950,Modifiability,variab,variables,950,". ROOT::Math::Minimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Minimizer. class ROOT::Math::Minimizer. Abstract Minimizer class, defining the interface for the various minimizer; (like Minuit2, Minuit, GSL, etc..); Plug-in's exist in ROOT to be able to instantiate the derived classes like; ROOT::Math::GSLMinimizer or ROOT::Math::Minuit2Minimizer via the; plug-in manager. Provides interface for setting the function to be minimized.; The function must implemente the multi-dimensional generic interface; ROOT::Math::IBaseFunctionMultiDim.; If the function provides gradient calculation; (implements the ROOT::Math::IGradientFunctionMultiDim interface) this will be; used by the Minimizer. It Defines also interface for setting the initial values for the function variables (which are the parameters in; of the model function in case of solving for fitting) and especifying their limits. It defines the interface to set and retrieve basic minimization parameters; (for specific Minimizer parameters one must use the derived classes). Then it defines the interface to retrieve the result of minimization ( minimum X values, function value,; gradient, error on the mimnimum, etc...). @ingroup MultiMin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Minimizer(); virtual voidClear(); virtual boolContour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double*) const; virtual boolGetHessianMatrix(",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:4485,Modifiability,Inherit,Inheritance,4485,", const string& name, double val, double step, double upper); voidSetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string&) const; virtual stringVariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:4498,Modifiability,Inherit,Inherited,4498,", const string& name, double val, double step, double upper); voidSetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string&) const; virtual stringVariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:4980,Modifiability,variab,variable,4980,"nt) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; ret",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:5114,Modifiability,variab,variable,5114,"tected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGr",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:5381,Modifiability,variab,variable,5381,"te); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). uns",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:5503,Modifiability,variab,variable,5503,"itance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesEr",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:5628,Modifiability,variab,variable,5628," (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at ",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:5729,Modifiability,variab,variables,5729,"ltiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the ma",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:6304,Modifiability,variab,variables,6304,", const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix ",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:6383,Modifiability,variab,variables,6383,"erride if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:6707,Modifiability,variab,variable,6707,"he values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accura",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:6765,Modifiability,variab,variables,6765,"he values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accura",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:6902,Modifiability,variab,variable,6902," minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coeffi",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:7015,Modifiability,variab,variables,7015,"nst; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned ",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:7178,Modifiability,variab,variable,7178,"inimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the cor",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:7425,Modifiability,variab,variable,7425,"r of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& err",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:7472,Modifiability,variab,variables,7472,"r of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& err",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:7905,Modifiability,variab,variable,7905,"; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function mi",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:7931,Modifiability,variab,variable,7931," array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set bef",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:8064,Modifiability,variab,variable,8064,"e the; values were obtained only to variable parameters. { return false; }. bool GetHessianMatrix(double* ) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array will be filled as h[i *ndim + j]. { return false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:8420,Modifiability,variab,variable,8420,"n false; }. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string Variable",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:8904,Modifiability,variab,variable,8904," between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:8916,Modifiability,Variab,Variable,8916,"ro. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned ",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9537,Modifiability,Variab,VariableName,9537,"runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 f",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9584,Modifiability,variab,variables,9584,"runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 f",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9636,Modifiability,variab,variable,9636,"runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 f",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9679,Modifiability,variab,variable,9679,"runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 f",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9732,Modifiability,Variab,VariableIndex,9732,"bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Min",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9782,Modifiability,variab,variable,9782,"bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Min",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9799,Modifiability,variab,variable,9799,"bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Min",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9835,Modifiability,variab,variable,9835,"bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Min",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:9908,Modifiability,config,configuration,9908," i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCa",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:5834,Performance,perform,perform,5834,"ction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) cons",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:8701,Performance,perform,perform,8701,"ariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int Vari",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:10731,Performance,perform,performed,10731,");}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in g",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:11140,Performance,perform,perform,11140,"t; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:4421,Security,validat,validated,4421,"dSetOptions(const ROOT::Math::MinimizerOptions& opt); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int strategyLevel); voidSetTolerance(double tol); virtual boolSetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidSetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string&) const; virtual stringVariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimited",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:10758,Security,validat,validation,10758,");}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in g",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__Minimizer.html:4621,Usability,Clear,Clear,4621,"ring& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string&) const; virtual stringVariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false",MatchSource.WIKI,root/html532/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:2435,Availability,error,error,2435,"(int maxcall); static voidSetDefaultMaxIterations(int maxiter); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); static voidSetDefaultPrecision(double prec); static voidSetDefaultPrintLevel(int level); static voidSetDefaultStrategy(int strat); static voidSetDefaultTolerance(double tol); voidSetErrorDef(double err); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetMaxFunctionCalls(unsigned int maxfcn); voidSetMaxIterations(unsigned int maxiter); voidSetMinimizerAlgorithm(const char* type); voidSetMinimizerType(const char* type); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int stra); voidSetTolerance(double tol); intStrategy() const; doubleTolerance() const. Data Members; private:. stringfAlgoTypeMinimizer algorithmic specification (Migrad, Minimize, ...); doublefErrorDeferror definition (=1. for getting 1 sigma error for chi2 fits); ROOT::Math::IOptions*fExtraOptionsextra options ; intfLeveldebug print level ; intfMaxCallsmaximum number of function calls; intfMaxItermaximum number of iterations; stringfMinimTypeMinimizer type (Minuit, Minuit2, etc..; doublefPrecisionprecision of the objective function evaluation (value <=0 means left to default); intfStrategyminimizer strategy (used by Minuit); doublefToleranceminimize tolerance to reach solution. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultMinimizer(const char* type, const char* algo = 0); static methods for setting and retrieving the default options. void SetDefaultErrorDef(double up). void SetDefaultTolerance(double tol). void SetDefaultPrecision(double prec). void SetDefaultMaxFunctionCalls(int maxcall). void SetDefaultMaxIterations(int maxiter). void SetDefaultStrategy(int strat). void SetDefaultPrintLevel(int level). const std::string & DefaultMinimizerType(). const std::string & DefaultMinimizerAlgo(). double DefaultErrorDef(). double DefaultTolerance(). double DefaultPrecision(). i",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:2851,Availability,toler,tolerance,2851,"oidSetDefaultStrategy(int strat); static voidSetDefaultTolerance(double tol); voidSetErrorDef(double err); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetMaxFunctionCalls(unsigned int maxfcn); voidSetMaxIterations(unsigned int maxiter); voidSetMinimizerAlgorithm(const char* type); voidSetMinimizerType(const char* type); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int stra); voidSetTolerance(double tol); intStrategy() const; doubleTolerance() const. Data Members; private:. stringfAlgoTypeMinimizer algorithmic specification (Migrad, Minimize, ...); doublefErrorDeferror definition (=1. for getting 1 sigma error for chi2 fits); ROOT::Math::IOptions*fExtraOptionsextra options ; intfLeveldebug print level ; intfMaxCallsmaximum number of function calls; intfMaxItermaximum number of iterations; stringfMinimTypeMinimizer type (Minuit, Minuit2, etc..; doublefPrecisionprecision of the objective function evaluation (value <=0 means left to default); intfStrategyminimizer strategy (used by Minuit); doublefToleranceminimize tolerance to reach solution. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultMinimizer(const char* type, const char* algo = 0); static methods for setting and retrieving the default options. void SetDefaultErrorDef(double up). void SetDefaultTolerance(double tol). void SetDefaultPrecision(double prec). void SetDefaultMaxFunctionCalls(int maxcall). void SetDefaultMaxIterations(int maxiter). void SetDefaultStrategy(int strat). void SetDefaultPrintLevel(int level). const std::string & DefaultMinimizerType(). const std::string & DefaultMinimizerAlgo(). double DefaultErrorDef(). double DefaultTolerance(). double DefaultPrecision(). int DefaultMaxFunctionCalls(). int DefaultMaxIterations(). int DefaultStrategy(). int DefaultPrintLevel(). ROOT::Math::IOptions & Default(const char* name); retrieve extra options - if not existing create a IOptions. ROOT::Math::IOpti",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:4758,Availability,Toler,Tolerance,4758,"IOptions * FindDefault(const char* name); find extra options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print all the default options for the name given. MinimizerOptions(IOptions * extraOpts = 0); constructor using the default options; pass optionally a pointer to the additional options; otehrwise look if they exist for this default minimizer; and in that case they are copied in the constructed instance. ~MinimizerOptions(); destructor. MinimizerOptions(const MinimizerOptions & opt); copy constructor. MinimizerOptions & operator=(const ROOT::Math::MinimizerOptions& opt); assignment operators. int PrintLevel() const; non-static methods for retrivieng options ; set print level. { return fLevel; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. int Strategy() const; strategy. { return fStrategy; }. double Tolerance() const; absolute tolerance. { return fTolerance; }. double Precision() const; precision in the objective funciton calculation (value <=0 means left to default). { return fPrecision; }. double ErrorDef() const; error definition. { return fErrorDef; }. IOptions * ExtraOptions() const; return extra options (NULL pointer if they are not present). { return fExtraOptions; }. const std::string & MinimizerType() const; type of minimizer. { return fMinimType; }. const std::string & MinimizerAlgorithm() const; type of algorithm. { return fAlgoType; }. void Print(ostream& os = std::cout) const; print all the options. void SetPrintLevel(int level); non-static methods for setting options ; set print level. { fLevel = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { fMaxIter = maxiter; }. void SetTolerance(double tol); set the",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:4786,Availability,toler,tolerance,4786,"IOptions * FindDefault(const char* name); find extra options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print all the default options for the name given. MinimizerOptions(IOptions * extraOpts = 0); constructor using the default options; pass optionally a pointer to the additional options; otehrwise look if they exist for this default minimizer; and in that case they are copied in the constructed instance. ~MinimizerOptions(); destructor. MinimizerOptions(const MinimizerOptions & opt); copy constructor. MinimizerOptions & operator=(const ROOT::Math::MinimizerOptions& opt); assignment operators. int PrintLevel() const; non-static methods for retrivieng options ; set print level. { return fLevel; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. int Strategy() const; strategy. { return fStrategy; }. double Tolerance() const; absolute tolerance. { return fTolerance; }. double Precision() const; precision in the objective funciton calculation (value <=0 means left to default). { return fPrecision; }. double ErrorDef() const; error definition. { return fErrorDef; }. IOptions * ExtraOptions() const; return extra options (NULL pointer if they are not present). { return fExtraOptions; }. const std::string & MinimizerType() const; type of minimizer. { return fMinimType; }. const std::string & MinimizerAlgorithm() const; type of algorithm. { return fAlgoType; }. void Print(ostream& os = std::cout) const; print all the options. void SetPrintLevel(int level); non-static methods for setting options ; set print level. { fLevel = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { fMaxIter = maxiter; }. void SetTolerance(double tol); set the",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:4961,Availability,Error,ErrorDef,4961,en. MinimizerOptions(IOptions * extraOpts = 0); constructor using the default options; pass optionally a pointer to the additional options; otehrwise look if they exist for this default minimizer; and in that case they are copied in the constructed instance. ~MinimizerOptions(); destructor. MinimizerOptions(const MinimizerOptions & opt); copy constructor. MinimizerOptions & operator=(const ROOT::Math::MinimizerOptions& opt); assignment operators. int PrintLevel() const; non-static methods for retrivieng options ; set print level. { return fLevel; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. int Strategy() const; strategy. { return fStrategy; }. double Tolerance() const; absolute tolerance. { return fTolerance; }. double Precision() const; precision in the objective funciton calculation (value <=0 means left to default). { return fPrecision; }. double ErrorDef() const; error definition. { return fErrorDef; }. IOptions * ExtraOptions() const; return extra options (NULL pointer if they are not present). { return fExtraOptions; }. const std::string & MinimizerType() const; type of minimizer. { return fMinimType; }. const std::string & MinimizerAlgorithm() const; type of algorithm. { return fAlgoType; }. void Print(ostream& os = std::cout) const; print all the options. void SetPrintLevel(int level); non-static methods for setting options ; set print level. { fLevel = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { fMaxIter = maxiter; }. void SetTolerance(double tol); set the tolerance. { fTolerance = tol; }. void SetPrecision(double prec); set the precision. { fPrecision = prec; }. void SetStrategy(int stra); set the strategy. { fStrategy = stra; }. void SetErrorDef(double,MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:4979,Availability,error,error,4979,en. MinimizerOptions(IOptions * extraOpts = 0); constructor using the default options; pass optionally a pointer to the additional options; otehrwise look if they exist for this default minimizer; and in that case they are copied in the constructed instance. ~MinimizerOptions(); destructor. MinimizerOptions(const MinimizerOptions & opt); copy constructor. MinimizerOptions & operator=(const ROOT::Math::MinimizerOptions& opt); assignment operators. int PrintLevel() const; non-static methods for retrivieng options ; set print level. { return fLevel; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. int Strategy() const; strategy. { return fStrategy; }. double Tolerance() const; absolute tolerance. { return fTolerance; }. double Precision() const; precision in the objective funciton calculation (value <=0 means left to default). { return fPrecision; }. double ErrorDef() const; error definition. { return fErrorDef; }. IOptions * ExtraOptions() const; return extra options (NULL pointer if they are not present). { return fExtraOptions; }. const std::string & MinimizerType() const; type of minimizer. { return fMinimType; }. const std::string & MinimizerAlgorithm() const; type of algorithm. { return fAlgoType; }. void Print(ostream& os = std::cout) const; print all the options. void SetPrintLevel(int level); non-static methods for setting options ; set print level. { fLevel = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { fMaxIter = maxiter; }. void SetTolerance(double tol); set the tolerance. { fTolerance = tol; }. void SetPrecision(double prec); set the precision. { fPrecision = prec; }. void SetStrategy(int stra); set the strategy. { fStrategy = stra; }. void SetErrorDef(double,MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:5774,Availability,toler,tolerance,5774,"turn fMaxIter; }. int Strategy() const; strategy. { return fStrategy; }. double Tolerance() const; absolute tolerance. { return fTolerance; }. double Precision() const; precision in the objective funciton calculation (value <=0 means left to default). { return fPrecision; }. double ErrorDef() const; error definition. { return fErrorDef; }. IOptions * ExtraOptions() const; return extra options (NULL pointer if they are not present). { return fExtraOptions; }. const std::string & MinimizerType() const; type of minimizer. { return fMinimType; }. const std::string & MinimizerAlgorithm() const; type of algorithm. { return fAlgoType; }. void Print(ostream& os = std::cout) const; print all the options. void SetPrintLevel(int level); non-static methods for setting options ; set print level. { fLevel = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { fMaxIter = maxiter; }. void SetTolerance(double tol); set the tolerance. { fTolerance = tol; }. void SetPrecision(double prec); set the precision. { fPrecision = prec; }. void SetStrategy(int stra); set the strategy. { fStrategy = stra; }. void SetErrorDef(double err); set error def. { fErrorDef = err; }. void SetMinimizerType(const char* type); set minimizer type. { fMinimType = type; }. void SetMinimizerAlgorithm(const char* type); set minimizer algorithm. { fAlgoType = type; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: MinimizerOptions.h 36905 2010-11-24 15:44:34Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:5986,Availability,error,error,5986,"turn fMaxIter; }. int Strategy() const; strategy. { return fStrategy; }. double Tolerance() const; absolute tolerance. { return fTolerance; }. double Precision() const; precision in the objective funciton calculation (value <=0 means left to default). { return fPrecision; }. double ErrorDef() const; error definition. { return fErrorDef; }. IOptions * ExtraOptions() const; return extra options (NULL pointer if they are not present). { return fExtraOptions; }. const std::string & MinimizerType() const; type of minimizer. { return fMinimType; }. const std::string & MinimizerAlgorithm() const; type of algorithm. { return fAlgoType; }. void Print(ostream& os = std::cout) const; print all the options. void SetPrintLevel(int level); non-static methods for setting options ; set print level. { fLevel = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { fMaxIter = maxiter; }. void SetTolerance(double tol); set the tolerance. { fTolerance = tol; }. void SetPrecision(double prec); set the precision. { fPrecision = prec; }. void SetStrategy(int stra); set the strategy. { fStrategy = stra; }. void SetErrorDef(double err); set error def. { fErrorDef = err; }. void SetMinimizerType(const char* type); set minimizer type. { fMinimType = type; }. void SetMinimizerAlgorithm(const char* type); set minimizer algorithm. { fAlgoType = type; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: MinimizerOptions.h 36905 2010-11-24 15:44:34Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:2894,Modifiability,Inherit,Inheritance,2894,"th::IOptions& opt); voidSetMaxFunctionCalls(unsigned int maxfcn); voidSetMaxIterations(unsigned int maxiter); voidSetMinimizerAlgorithm(const char* type); voidSetMinimizerType(const char* type); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int stra); voidSetTolerance(double tol); intStrategy() const; doubleTolerance() const. Data Members; private:. stringfAlgoTypeMinimizer algorithmic specification (Migrad, Minimize, ...); doublefErrorDeferror definition (=1. for getting 1 sigma error for chi2 fits); ROOT::Math::IOptions*fExtraOptionsextra options ; intfLeveldebug print level ; intfMaxCallsmaximum number of function calls; intfMaxItermaximum number of iterations; stringfMinimTypeMinimizer type (Minuit, Minuit2, etc..; doublefPrecisionprecision of the objective function evaluation (value <=0 means left to default); intfStrategyminimizer strategy (used by Minuit); doublefToleranceminimize tolerance to reach solution. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultMinimizer(const char* type, const char* algo = 0); static methods for setting and retrieving the default options. void SetDefaultErrorDef(double up). void SetDefaultTolerance(double tol). void SetDefaultPrecision(double prec). void SetDefaultMaxFunctionCalls(int maxcall). void SetDefaultMaxIterations(int maxiter). void SetDefaultStrategy(int strat). void SetDefaultPrintLevel(int level). const std::string & DefaultMinimizerType(). const std::string & DefaultMinimizerAlgo(). double DefaultErrorDef(). double DefaultTolerance(). double DefaultPrecision(). int DefaultMaxFunctionCalls(). int DefaultMaxIterations(). int DefaultStrategy(). int DefaultPrintLevel(). ROOT::Math::IOptions & Default(const char* name); retrieve extra options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find extra options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std:",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html:2907,Modifiability,Inherit,Inherited,2907,"th::IOptions& opt); voidSetMaxFunctionCalls(unsigned int maxfcn); voidSetMaxIterations(unsigned int maxiter); voidSetMinimizerAlgorithm(const char* type); voidSetMinimizerType(const char* type); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int stra); voidSetTolerance(double tol); intStrategy() const; doubleTolerance() const. Data Members; private:. stringfAlgoTypeMinimizer algorithmic specification (Migrad, Minimize, ...); doublefErrorDeferror definition (=1. for getting 1 sigma error for chi2 fits); ROOT::Math::IOptions*fExtraOptionsextra options ; intfLeveldebug print level ; intfMaxCallsmaximum number of function calls; intfMaxItermaximum number of iterations; stringfMinimTypeMinimizer type (Minuit, Minuit2, etc..; doublefPrecisionprecision of the objective function evaluation (value <=0 means left to default); intfStrategyminimizer strategy (used by Minuit); doublefToleranceminimize tolerance to reach solution. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultMinimizer(const char* type, const char* algo = 0); static methods for setting and retrieving the default options. void SetDefaultErrorDef(double up). void SetDefaultTolerance(double tol). void SetDefaultPrecision(double prec). void SetDefaultMaxFunctionCalls(int maxcall). void SetDefaultMaxIterations(int maxiter). void SetDefaultStrategy(int strat). void SetDefaultPrintLevel(int level). const std::string & DefaultMinimizerType(). const std::string & DefaultMinimizerAlgo(). double DefaultErrorDef(). double DefaultTolerance(). double DefaultPrecision(). int DefaultMaxFunctionCalls(). int DefaultMaxIterations(). int DefaultStrategy(). int DefaultPrintLevel(). ROOT::Math::IOptions & Default(const char* name); retrieve extra options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find extra options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std:",MatchSource.WIKI,root/html532/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MinimizerOptions.html
https://root.cern/root/html532/ROOT__Math__MiserParameters.html:958,Modifiability,Inherit,Inheritance,958,". ROOT::Math::MiserParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::MiserParameters. class ROOT::Math::MiserParameters. Function Members (Methods); public:. ~MiserParameters(); ROOT::Math::MiserParametersMiserParameters(size_t dim = 10); ROOT::Math::MiserParametersMiserParameters(const ROOT::Math::MiserParameters&); ROOT::Math::MiserParametersMiserParameters(const ROOT::Math::IOptions& opt, size_t dim = 10); ROOT::Math::IOptions*operator()() const; ROOT::Math::MiserParameters&operator=(const ROOT::Math::IOptions& opt); ROOT::Math::MiserParameters&operator=(const ROOT::Math::MiserParameters&); voidSetDefaultValues(size_t dim = 10). Data Members; public:. doublealpha; doubledither; doubleestimate_frac; size_tmin_calls; size_tmin_calls_per_bisection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultValues(). VegasParameters & operator=(const ROOT::Math::IOptions& opt). ROOT::Math::IOptions * operator()() const; convert to options (return object is managed by the user). MiserParameters(size_t dim = 10); constructor of default parameters; needs dimension since min_calls = 16 * dim. { SetDefaultValues(dim); }. MiserParameters(const ROOT::Math::IOptions& opt, size_t dim = 10); construct from GenAlgoOptions; parameter not specified are ignored. MiserParameters & operator=(const ROOT::Math::IOptions& opt). » Author: Magdalena Slawinska 08/2007 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: MCParameters.h 36806 2010-11-20 11:09:14Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__MiserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MiserParameters.html
https://root.cern/root/html532/ROOT__Math__MiserParameters.html:971,Modifiability,Inherit,Inherited,971,". ROOT::Math::MiserParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::MiserParameters. class ROOT::Math::MiserParameters. Function Members (Methods); public:. ~MiserParameters(); ROOT::Math::MiserParametersMiserParameters(size_t dim = 10); ROOT::Math::MiserParametersMiserParameters(const ROOT::Math::MiserParameters&); ROOT::Math::MiserParametersMiserParameters(const ROOT::Math::IOptions& opt, size_t dim = 10); ROOT::Math::IOptions*operator()() const; ROOT::Math::MiserParameters&operator=(const ROOT::Math::IOptions& opt); ROOT::Math::MiserParameters&operator=(const ROOT::Math::MiserParameters&); voidSetDefaultValues(size_t dim = 10). Data Members; public:. doublealpha; doubledither; doubleestimate_frac; size_tmin_calls; size_tmin_calls_per_bisection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultValues(). VegasParameters & operator=(const ROOT::Math::IOptions& opt). ROOT::Math::IOptions * operator()() const; convert to options (return object is managed by the user). MiserParameters(size_t dim = 10); constructor of default parameters; needs dimension since min_calls = 16 * dim. { SetDefaultValues(dim); }. MiserParameters(const ROOT::Math::IOptions& opt, size_t dim = 10); construct from GenAlgoOptions; parameter not specified are ignored. MiserParameters & operator=(const ROOT::Math::IOptions& opt). » Author: Magdalena Slawinska 08/2007 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: MCParameters.h 36806 2010-11-20 11:09:14Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__MiserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__MiserParameters.html
https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:1619,Availability,avail,available,1619,"ng like; Parameteric 1D, Multi-Dim or gradient parametric. A parameteric function is a Generic Function with parameters, so; it is a function object which carries a state, the parameters.; The parameters are described with a standard vector of doubles. This class contains the default implementations for the methods defined in the; IParamFunction interface for dealing with parameters; Specific parameteric function classes should derive from this class if they want to profit from; default implementations for the abstract methods.; The derived classes need to implement only the DoEvalPar( x, p) and Clone() methods for non-gradient; parameteric functions or DoParameterDerivative(x,p,ipar) for gradient par functions. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<IParamGradFunction>, ROOT::Math::Polynomial::ParFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>&operator=(const ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>&); doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:588,Integrability,interface,interface,588,". ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. class ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>: public ROOT::Math::IParametricGradFunctionOneDim. Base template class for all Parametric Functions.; The template argument is the type of parameteric function interface is implementing like; Parameteric 1D, Multi-Dim or gradient parametric. A parameteric function is a Generic Function with parameters, so; it is a function object which carries a state, the parameters.; The parameters are described with a standard vector of doubles. This class contains the default implementations for the methods defined in the; IParamFunction interface for dealing with parameters; Specific parameteric function classes should derive from this class if they want to profit from; default implementations for the abstract methods.; The derived classes need to implement only the DoEvalPar( x, p) and Clone() methods for non-gradient; parameteric functions or DoParameterDerivative(x,p,ipar) for gradient par functions. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<IParamGradFunction>, ROOT::Math::Polynomial::ParFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:959,Integrability,interface,interface,959,"OOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. class ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>: public ROOT::Math::IParametricGradFunctionOneDim. Base template class for all Parametric Functions.; The template argument is the type of parameteric function interface is implementing like; Parameteric 1D, Multi-Dim or gradient parametric. A parameteric function is a Generic Function with parameters, so; it is a function object which carries a state, the parameters.; The parameters are described with a standard vector of doubles. This class contains the default implementations for the methods defined in the; IParamFunction interface for dealing with parameters; Specific parameteric function classes should derive from this class if they want to profit from; default implementations for the abstract methods.; The derived classes need to implement only the DoEvalPar( x, p) and Clone() methods for non-gradient; parameteric functions or DoParameterDerivative(x,p,ipar) for gradient par functions. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<IParamGradFunction>, ROOT::Math::Polynomial::ParFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:3363,Modifiability,Inherit,Inheritance,3363,"OOT::Math::IParametricGradFunctionOneDim>&operator=(const ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>&); doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, double* grad) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double* x, double* grad) const; virtual voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, const double* p, double* grad) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Data Members; protected:. vector<double>fParams. private:. unsigned intfNpar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const double * Parameters() const; copying constructors (can use default ones). Access the parameter values. { return &fParams.front(); }. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. unsigned int NPar() const. Return the number of parameters. { return fNpar; }. » Last changed: root/mathmore:$Id: ParamFunction.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:3376,Modifiability,Inherit,Inherited,3376,"OOT::Math::IParametricGradFunctionOneDim>&operator=(const ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>&); doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, double* grad) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double* x, double* grad) const; virtual voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, const double* p, double* grad) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Data Members; protected:. vector<double>fParams. private:. unsigned intfNpar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const double * Parameters() const; copying constructors (can use default ones). Access the parameter values. { return &fParams.front(); }. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. unsigned int NPar() const. Return the number of parameters. { return fNpar; }. » Last changed: root/mathmore:$Id: ParamFunction.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:3520,Security,Access,Access,3520,"OOT::Math::IParametricGradFunctionOneDim>&operator=(const ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>&); doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, double* grad) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double* x, double* grad) const; virtual voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, const double* p, double* grad) const; voidROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Data Members; protected:. vector<double>fParams. private:. unsigned intfNpar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const double * Parameters() const; copying constructors (can use default ones). Access the parameter values. { return &fParams.front(); }. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. unsigned int NPar() const. Return the number of parameters. { return fNpar; }. » Last changed: root/mathmore:$Id: ParamFunction.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
https://root.cern/root/html532/ROOT__Math__ParamFunctor.html:819,Modifiability,Inherit,Inheritance,819,". ROOT::Math::ParamFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::ParamFunctor. class ROOT::Math::ParamFunctor. Function Members (Methods); public:. virtual~ParamFunctor(); boolEmpty(); void*GetImpl(); doubleoperator()(double* x, double* p); ROOT::Math::ParamFunctor&operator=(const ROOT::Math::ParamFunctor& rhs); ROOT::Math::ParamFunctorParamFunctor(); ROOT::Math::ParamFunctorParamFunctor(ROOT::Math::ParamFunctor::FreeFunc f); ROOT::Math::ParamFunctorParamFunctor(const ROOT::Math::ParamFunctor& rhs); voidSetFunction(ROOT::Math::ParamFunctor::Impl* f). Data Members; private:. ROOT::Math::ParamFunctor::Impl*fImpl. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(double* x, double* p); virtual double operator() (const double * x, const double *p) const = 0;. ParamMemFunHandler& operator=(const ROOT::Math::ParamFunctor& rhs). ParamFunctor(). Default constructor. {}. ParamFunctor(const PtrObj& p, MemFn memFn). construct from a pointer to member function (multi-dim type). {}. explicit ParamFunctor( const Func & f). construct from another generic Functor of multi-dimension. {}. virtual ~ParamFunctor(). Destructor (no operations). void * GetImpl(); { return (void *) fImpl; }. bool Empty(); { return fImpl == 0; }. void SetFunction(ROOT::Math::ParamFunctor::Impl* f). » Author: L. Moneta Mon Nov 13 15:58:13 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: ParamFunctor.h 26722 2008-12-08 10:35:18Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunctor.html
https://root.cern/root/html532/ROOT__Math__ParamFunctor.html:832,Modifiability,Inherit,Inherited,832,". ROOT::Math::ParamFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::ParamFunctor. class ROOT::Math::ParamFunctor. Function Members (Methods); public:. virtual~ParamFunctor(); boolEmpty(); void*GetImpl(); doubleoperator()(double* x, double* p); ROOT::Math::ParamFunctor&operator=(const ROOT::Math::ParamFunctor& rhs); ROOT::Math::ParamFunctorParamFunctor(); ROOT::Math::ParamFunctorParamFunctor(ROOT::Math::ParamFunctor::FreeFunc f); ROOT::Math::ParamFunctorParamFunctor(const ROOT::Math::ParamFunctor& rhs); voidSetFunction(ROOT::Math::ParamFunctor::Impl* f). Data Members; private:. ROOT::Math::ParamFunctor::Impl*fImpl. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(double* x, double* p); virtual double operator() (const double * x, const double *p) const = 0;. ParamMemFunHandler& operator=(const ROOT::Math::ParamFunctor& rhs). ParamFunctor(). Default constructor. {}. ParamFunctor(const PtrObj& p, MemFn memFn). construct from a pointer to member function (multi-dim type). {}. explicit ParamFunctor( const Func & f). construct from another generic Functor of multi-dimension. {}. virtual ~ParamFunctor(). Destructor (no operations). void * GetImpl(); { return (void *) fImpl; }. bool Empty(); { return fImpl == 0; }. void SetFunction(ROOT::Math::ParamFunctor::Impl* f). » Author: L. Moneta Mon Nov 13 15:58:13 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: ParamFunctor.h 26722 2008-12-08 10:35:18Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__ParamFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__ParamFunctor.html
https://root.cern/root/html532/ROOT__Math__Plane3D.html:716,Availability,avail,available,716,". ROOT::Math::Plane3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Plane3D. class ROOT::Math::Plane3D. Class describing a geometrical plane in 3 dimensions.; A Plane3D is a 2 dimensional surface spanned by two linearly independent vectors.; The plane is described by the equation; \f$ a*x + b*y + c*z + d = 0 \f$ where (a,b,c) are the components of the; normal vector to the plane \f$ n = (a,b,c) \f$ and \f$ d = - n \dot x \f$, where x is any point; belonging to plane.; More information on the mathematics describing a plane in 3D is available on; <A HREF=http://mathworld.wolfram.com/Plane.html>MathWord</A>.; The Plane3D class contains the 4 scalar values in double which represent the; four coefficients, fA, fB, fC, fD. fA, fB, fC are the normal components normalized to 1,; i.e. fA**2 + fB**2 + fC**2 = 1. @ingroup GenVector. Function Members (Methods); public:. ~Plane3D(); ROOT::Math::Plane3D::ScalarA(); ROOT::Math::Plane3D::ScalarB(); ROOT::Math::Plane3D::ScalarC(); ROOT::Math::Plane3D::ScalarD(); ROOT::Math::Plane3D::ScalarDistance(const ROOT::Math::Plane3D::Point& p) const; ROOT::Math::Plane3D::ScalarHesseDistance() const; ROOT::Math::Plane3D::VectorNormal() const; booloperator!=(const ROOT::Math::Plane3D& rhs) const; ROOT::Math::Plane3D&operator=(const ROOT::Math::Plane3D& plane); booloperator==(const ROOT::Math::Plane3D& rhs) const; ROOT::Math::Plane3DPlane3D(); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D&); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Point& p1, const ROOT::Math::Plane3D::Point& p2, const ROOT::Math::Plane3D::Point& p3); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Scalar& a, const ROOT::Math::Plane3D::Scalar& b, const ROOT::Math::Plane3D::Scal",MatchSource.WIKI,root/html532/ROOT__Math__Plane3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Plane3D.html
https://root.cern/root/html532/ROOT__Math__Plane3D.html:2572,Modifiability,Inherit,Inheritance,2572,"t ROOT::Math::Plane3D&); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Point& p1, const ROOT::Math::Plane3D::Point& p2, const ROOT::Math::Plane3D::Point& p3); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Scalar& a, const ROOT::Math::Plane3D::Scalar& b, const ROOT::Math::Plane3D::Scalar& c, const ROOT::Math::Plane3D::Scalar& d); ROOT::Math::Plane3D::PointProjectOntoPlane(const ROOT::Math::Plane3D::Point& p) const. protected:. voidNormalize(). private:. voidBuildFrom3Points(const ROOT::Math::Plane3D::Point& p1, const ROOT::Math::Plane3D::Point& p2, const ROOT::Math::Plane3D::Point& p3); voidBuildFromVecAndPoint(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). Data Members; private:. ROOT::Math::Plane3D::ScalarfA; ROOT::Math::Plane3D::ScalarfB; ROOT::Math::Plane3D::ScalarfC; ROOT::Math::Plane3D::ScalarfD. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; D(). default constructor create plane z = 0. { }. Plane3D(const ROOT::Math::Plane3D::Scalar& a, const ROOT::Math::Plane3D::Scalar& b, const ROOT::Math::Plane3D::Scalar& c, const ROOT::Math::Plane3D::Scalar& d). generic constructors from the four scalar values describing the plane; 	 according to the equation ax + by + cz + d = 0; \param a scalar value; \param b scalar value; \param c scalar value; \param d sxcalar value. Plane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). constructor a Plane3D from a normal vector and a point coplanar to the plane; 	 \param n normal expressed as a ROOT::Math::DisplacementVector3D<Cartesian3D<double> >; 	 \param p point expressed as a ROOT::Math::PositionVector3D<Cartesian3D<double> >. BuildFromVecAndPoint(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). Plane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). Construc",MatchSource.WIKI,root/html532/ROOT__Math__Plane3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Plane3D.html
https://root.cern/root/html532/ROOT__Math__Plane3D.html:2585,Modifiability,Inherit,Inherited,2585,"t ROOT::Math::Plane3D&); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Point& p1, const ROOT::Math::Plane3D::Point& p2, const ROOT::Math::Plane3D::Point& p3); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Scalar& a, const ROOT::Math::Plane3D::Scalar& b, const ROOT::Math::Plane3D::Scalar& c, const ROOT::Math::Plane3D::Scalar& d); ROOT::Math::Plane3D::PointProjectOntoPlane(const ROOT::Math::Plane3D::Point& p) const. protected:. voidNormalize(). private:. voidBuildFrom3Points(const ROOT::Math::Plane3D::Point& p1, const ROOT::Math::Plane3D::Point& p2, const ROOT::Math::Plane3D::Point& p3); voidBuildFromVecAndPoint(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). Data Members; private:. ROOT::Math::Plane3D::ScalarfA; ROOT::Math::Plane3D::ScalarfB; ROOT::Math::Plane3D::ScalarfC; ROOT::Math::Plane3D::ScalarfD. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; D(). default constructor create plane z = 0. { }. Plane3D(const ROOT::Math::Plane3D::Scalar& a, const ROOT::Math::Plane3D::Scalar& b, const ROOT::Math::Plane3D::Scalar& c, const ROOT::Math::Plane3D::Scalar& d). generic constructors from the four scalar values describing the plane; 	 according to the equation ax + by + cz + d = 0; \param a scalar value; \param b scalar value; \param c scalar value; \param d sxcalar value. Plane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). constructor a Plane3D from a normal vector and a point coplanar to the plane; 	 \param n normal expressed as a ROOT::Math::DisplacementVector3D<Cartesian3D<double> >; 	 \param p point expressed as a ROOT::Math::PositionVector3D<Cartesian3D<double> >. BuildFromVecAndPoint(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). Plane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p). Construc",MatchSource.WIKI,root/html532/ROOT__Math__Plane3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Plane3D.html
https://root.cern/root/html532/ROOT__Math__Polar2D_Double32_t_.html:2106,Modifiability,Inherit,Inheritance,2106," const; ROOT::Math::Polar2D<Double32_t>Polar2D<Double32_t>(); ROOT::Math::Polar2D<Double32_t>Polar2D<Double32_t>(const ROOT::Math::Polar2D<Double32_t>& v); ROOT::Math::Polar2D<Double32_t>Polar2D<Double32_t>(Double32_t r, Double32_t phi); ROOT::Math::Polar2D<Double32_t>::ScalarR() const; voidRotate(Double32_t angle); voidScale(Double32_t a); voidSetCoordinates(ROOT::Math::Polar2D<Double32_t>::Scalar r, ROOT::Math::Polar2D<Double32_t>::Scalar phi); voidSetPhi(const Double32_t& phi); voidSetR(const Double32_t& r); voidSetX(ROOT::Math::Polar2D<Double32_t>::Scalar a); voidSetXY(ROOT::Math::Polar2D<Double32_t>::Scalar a, ROOT::Math::Polar2D<Double32_t>::Scalar b); voidSetY(ROOT::Math::Polar2D<Double32_t>::Scalar a); ROOT::Math::Polar2D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Polar2D<Double32_t>::ScalarY() const; Double32_ty() const. private:. static doublepi(); voidRestrict(). Data Members; private:. Double32_tfPhi; Double32_tfR. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar2D & operator=(const ROOT::Math::Polar2D<Double32_t>& v). assignment operator. void SetCoordinates(ROOT::Math::Polar2D<Double32_t>::Scalar r, ROOT::Math::Polar2D<Double32_t>::Scalar phi). Set internal data based on 2 Scalar numbers. { fR=r; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar2D<Double32_t>::Scalar& r, ROOT::Math::Polar2D<Double32_t>::Scalar& phi) const. get internal data into 2 Scalar numbers. {r=fR; phi=fPhi;}. Scalar R() const; { return fR;}. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fR*std::cos(fPhi);}. Scalar Y() const; { return fR*std::sin(fPhi);}. Scalar Mag2() const; { return fR*fR;}. void SetR(const Double32_t& r); setters (only for data members). set the r coordinate value keeping phi constant. void SetPhi(const Double32_t& phi). set the phi coordinate value keeping r constant. Restrict(). void SetXY(ROOT::Math::Polar2D<Double32_t>::Scalar a, ROOT::Math::Polar2D<Double32_t",MatchSource.WIKI,root/html532/ROOT__Math__Polar2D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar2D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Polar2D_Double32_t_.html:2119,Modifiability,Inherit,Inherited,2119," const; ROOT::Math::Polar2D<Double32_t>Polar2D<Double32_t>(); ROOT::Math::Polar2D<Double32_t>Polar2D<Double32_t>(const ROOT::Math::Polar2D<Double32_t>& v); ROOT::Math::Polar2D<Double32_t>Polar2D<Double32_t>(Double32_t r, Double32_t phi); ROOT::Math::Polar2D<Double32_t>::ScalarR() const; voidRotate(Double32_t angle); voidScale(Double32_t a); voidSetCoordinates(ROOT::Math::Polar2D<Double32_t>::Scalar r, ROOT::Math::Polar2D<Double32_t>::Scalar phi); voidSetPhi(const Double32_t& phi); voidSetR(const Double32_t& r); voidSetX(ROOT::Math::Polar2D<Double32_t>::Scalar a); voidSetXY(ROOT::Math::Polar2D<Double32_t>::Scalar a, ROOT::Math::Polar2D<Double32_t>::Scalar b); voidSetY(ROOT::Math::Polar2D<Double32_t>::Scalar a); ROOT::Math::Polar2D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Polar2D<Double32_t>::ScalarY() const; Double32_ty() const. private:. static doublepi(); voidRestrict(). Data Members; private:. Double32_tfPhi; Double32_tfR. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar2D & operator=(const ROOT::Math::Polar2D<Double32_t>& v). assignment operator. void SetCoordinates(ROOT::Math::Polar2D<Double32_t>::Scalar r, ROOT::Math::Polar2D<Double32_t>::Scalar phi). Set internal data based on 2 Scalar numbers. { fR=r; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar2D<Double32_t>::Scalar& r, ROOT::Math::Polar2D<Double32_t>::Scalar& phi) const. get internal data into 2 Scalar numbers. {r=fR; phi=fPhi;}. Scalar R() const; { return fR;}. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fR*std::cos(fPhi);}. Scalar Y() const; { return fR*std::sin(fPhi);}. Scalar Mag2() const; { return fR*fR;}. void SetR(const Double32_t& r); setters (only for data members). set the r coordinate value keeping phi constant. void SetPhi(const Double32_t& phi). set the phi coordinate value keeping r constant. Restrict(). void SetXY(ROOT::Math::Polar2D<Double32_t>::Scalar a, ROOT::Math::Polar2D<Double32_t",MatchSource.WIKI,root/html532/ROOT__Math__Polar2D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar2D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Polar2D_double_.html:2064,Modifiability,Inherit,Inheritance,2064,"; booloperator==(const ROOT::Math::Polar2D<double>& rhs) const; ROOT::Math::Polar2D<double>::ScalarPhi() const; ROOT::Math::Polar2D<double>Polar2D<double>(); ROOT::Math::Polar2D<double>Polar2D<double>(const ROOT::Math::Polar2D<double>& v); ROOT::Math::Polar2D<double>Polar2D<double>(double r, double phi); ROOT::Math::Polar2D<double>::ScalarR() const; voidRotate(double angle); voidScale(double a); voidSetCoordinates(ROOT::Math::Polar2D<double>::Scalar r, ROOT::Math::Polar2D<double>::Scalar phi); voidSetPhi(const double& phi); voidSetR(const double& r); voidSetX(ROOT::Math::Polar2D<double>::Scalar a); voidSetXY(ROOT::Math::Polar2D<double>::Scalar a, ROOT::Math::Polar2D<double>::Scalar b); voidSetY(ROOT::Math::Polar2D<double>::Scalar a); ROOT::Math::Polar2D<double>::ScalarX() const; doublex() const; ROOT::Math::Polar2D<double>::ScalarY() const; doubley() const. private:. static doublepi(); voidRestrict(). Data Members; private:. doublefPhi; doublefR. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar2D & operator=(const ROOT::Math::Polar2D<double>& v). assignment operator. void SetCoordinates(ROOT::Math::Polar2D<double>::Scalar r, ROOT::Math::Polar2D<double>::Scalar phi). Set internal data based on 2 Scalar numbers. { fR=r; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar2D<double>::Scalar& r, ROOT::Math::Polar2D<double>::Scalar& phi) const. get internal data into 2 Scalar numbers. {r=fR; phi=fPhi;}. Scalar R() const; { return fR;}. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fR*std::cos(fPhi);}. Scalar Y() const; { return fR*std::sin(fPhi);}. Scalar Mag2() const; { return fR*fR;}. void SetR(const double& r); setters (only for data members). set the r coordinate value keeping phi constant. void SetPhi(const double& phi). set the phi coordinate value keeping r constant. Restrict(). void SetXY(ROOT::Math::Polar2D<double>::Scalar a, ROOT::Math::Polar2D<double>::Scalar b). set all values using c",MatchSource.WIKI,root/html532/ROOT__Math__Polar2D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar2D_double_.html
https://root.cern/root/html532/ROOT__Math__Polar2D_double_.html:2077,Modifiability,Inherit,Inherited,2077,"; booloperator==(const ROOT::Math::Polar2D<double>& rhs) const; ROOT::Math::Polar2D<double>::ScalarPhi() const; ROOT::Math::Polar2D<double>Polar2D<double>(); ROOT::Math::Polar2D<double>Polar2D<double>(const ROOT::Math::Polar2D<double>& v); ROOT::Math::Polar2D<double>Polar2D<double>(double r, double phi); ROOT::Math::Polar2D<double>::ScalarR() const; voidRotate(double angle); voidScale(double a); voidSetCoordinates(ROOT::Math::Polar2D<double>::Scalar r, ROOT::Math::Polar2D<double>::Scalar phi); voidSetPhi(const double& phi); voidSetR(const double& r); voidSetX(ROOT::Math::Polar2D<double>::Scalar a); voidSetXY(ROOT::Math::Polar2D<double>::Scalar a, ROOT::Math::Polar2D<double>::Scalar b); voidSetY(ROOT::Math::Polar2D<double>::Scalar a); ROOT::Math::Polar2D<double>::ScalarX() const; doublex() const; ROOT::Math::Polar2D<double>::ScalarY() const; doubley() const. private:. static doublepi(); voidRestrict(). Data Members; private:. doublefPhi; doublefR. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar2D & operator=(const ROOT::Math::Polar2D<double>& v). assignment operator. void SetCoordinates(ROOT::Math::Polar2D<double>::Scalar r, ROOT::Math::Polar2D<double>::Scalar phi). Set internal data based on 2 Scalar numbers. { fR=r; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar2D<double>::Scalar& r, ROOT::Math::Polar2D<double>::Scalar& phi) const. get internal data into 2 Scalar numbers. {r=fR; phi=fPhi;}. Scalar R() const; { return fR;}. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fR*std::cos(fPhi);}. Scalar Y() const; { return fR*std::sin(fPhi);}. Scalar Mag2() const; { return fR*fR;}. void SetR(const double& r); setters (only for data members). set the r coordinate value keeping phi constant. void SetPhi(const double& phi). set the phi coordinate value keeping r constant. Restrict(). void SetXY(ROOT::Math::Polar2D<double>::Scalar a, ROOT::Math::Polar2D<double>::Scalar b). set all values using c",MatchSource.WIKI,root/html532/ROOT__Math__Polar2D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar2D_double_.html
https://root.cern/root/html532/ROOT__Math__Polar3D_Double32_t_.html:3046,Modifiability,Inherit,Inheritance,3046,"2_t>::Scalar phi); voidSetEta(ROOT::Math::Polar3D<Double32_t>::Scalar eta); voidSetPhi(const Double32_t& phi); voidSetR(const Double32_t& r); voidSetRho(ROOT::Math::Polar3D<Double32_t>::Scalar rho); voidSetTheta(const Double32_t& theta); voidSetX(ROOT::Math::Polar3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::Polar3D<Double32_t>::Scalar xx, ROOT::Math::Polar3D<Double32_t>::Scalar yy, ROOT::Math::Polar3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::Polar3D<Double32_t>::Scalar yy); voidSetZ(ROOT::Math::Polar3D<Double32_t>::Scalar zz); ROOT::Math::Polar3D<Double32_t>::ScalarTheta() const; ROOT::Math::Polar3D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Polar3D<Double32_t>::ScalarY() const; Double32_ty() const; ROOT::Math::Polar3D<Double32_t>::ScalarZ() const; Double32_tz() const. private:. static ROOT::Math::Polar3D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfPhi; Double32_tfR; Double32_tfTheta. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar3D & operator=(const ROOT::Math::Polar3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::Polar3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fR=src[0]; fTheta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fR; dest[1] = fTheta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Polar3D<Double32_t>::Scalar r, ROOT::Math::Polar3D<Double32_t>::Scalar theta, ROOT::Math::Polar3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fR=r; fTheta=theta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<Double32_t>::Scalar& r, ROOT::Math::Polar3D<Double32_t>::Scalar& theta, ROOT::Math::Polar3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers. {r=fR; theta=fTheta; phi=fPhi;}. Scalar R() c",MatchSource.WIKI,root/html532/ROOT__Math__Polar3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Polar3D_Double32_t_.html:3059,Modifiability,Inherit,Inherited,3059,"2_t>::Scalar phi); voidSetEta(ROOT::Math::Polar3D<Double32_t>::Scalar eta); voidSetPhi(const Double32_t& phi); voidSetR(const Double32_t& r); voidSetRho(ROOT::Math::Polar3D<Double32_t>::Scalar rho); voidSetTheta(const Double32_t& theta); voidSetX(ROOT::Math::Polar3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::Polar3D<Double32_t>::Scalar xx, ROOT::Math::Polar3D<Double32_t>::Scalar yy, ROOT::Math::Polar3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::Polar3D<Double32_t>::Scalar yy); voidSetZ(ROOT::Math::Polar3D<Double32_t>::Scalar zz); ROOT::Math::Polar3D<Double32_t>::ScalarTheta() const; ROOT::Math::Polar3D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Polar3D<Double32_t>::ScalarY() const; Double32_ty() const; ROOT::Math::Polar3D<Double32_t>::ScalarZ() const; Double32_tz() const. private:. static ROOT::Math::Polar3D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfPhi; Double32_tfR; Double32_tfTheta. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar3D & operator=(const ROOT::Math::Polar3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::Polar3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fR=src[0]; fTheta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fR; dest[1] = fTheta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Polar3D<Double32_t>::Scalar r, ROOT::Math::Polar3D<Double32_t>::Scalar theta, ROOT::Math::Polar3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fR=r; fTheta=theta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<Double32_t>::Scalar& r, ROOT::Math::Polar3D<Double32_t>::Scalar& theta, ROOT::Math::Polar3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers. {r=fR; theta=fTheta; phi=fPhi;}. Scalar R() c",MatchSource.WIKI,root/html532/ROOT__Math__Polar3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Polar3D_double_.html:2818,Modifiability,Inherit,Inheritance,2818,"3D<double>::Scalar r, ROOT::Math::Polar3D<double>::Scalar theta, ROOT::Math::Polar3D<double>::Scalar phi); voidSetEta(ROOT::Math::Polar3D<double>::Scalar eta); voidSetPhi(const double& phi); voidSetR(const double& r); voidSetRho(ROOT::Math::Polar3D<double>::Scalar rho); voidSetTheta(const double& theta); voidSetX(ROOT::Math::Polar3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::Polar3D<double>::Scalar xx, ROOT::Math::Polar3D<double>::Scalar yy, ROOT::Math::Polar3D<double>::Scalar zz); voidSetY(ROOT::Math::Polar3D<double>::Scalar yy); voidSetZ(ROOT::Math::Polar3D<double>::Scalar zz); ROOT::Math::Polar3D<double>::ScalarTheta() const; ROOT::Math::Polar3D<double>::ScalarX() const; doublex() const; ROOT::Math::Polar3D<double>::ScalarY() const; doubley() const; ROOT::Math::Polar3D<double>::ScalarZ() const; doublez() const. private:. static ROOT::Math::Polar3D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefPhi; doublefR; doublefTheta. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar3D & operator=(const ROOT::Math::Polar3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::Polar3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fR=src[0]; fTheta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fR; dest[1] = fTheta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Polar3D<double>::Scalar r, ROOT::Math::Polar3D<double>::Scalar theta, ROOT::Math::Polar3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fR=r; fTheta=theta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<double>::Scalar& r, ROOT::Math::Polar3D<double>::Scalar& theta, ROOT::Math::Polar3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers. {r=fR; theta=fTheta; phi=fPhi;}. Scalar R() const; { return fR;}. Scalar Phi() co",MatchSource.WIKI,root/html532/ROOT__Math__Polar3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar3D_double_.html
https://root.cern/root/html532/ROOT__Math__Polar3D_double_.html:2831,Modifiability,Inherit,Inherited,2831,"3D<double>::Scalar r, ROOT::Math::Polar3D<double>::Scalar theta, ROOT::Math::Polar3D<double>::Scalar phi); voidSetEta(ROOT::Math::Polar3D<double>::Scalar eta); voidSetPhi(const double& phi); voidSetR(const double& r); voidSetRho(ROOT::Math::Polar3D<double>::Scalar rho); voidSetTheta(const double& theta); voidSetX(ROOT::Math::Polar3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::Polar3D<double>::Scalar xx, ROOT::Math::Polar3D<double>::Scalar yy, ROOT::Math::Polar3D<double>::Scalar zz); voidSetY(ROOT::Math::Polar3D<double>::Scalar yy); voidSetZ(ROOT::Math::Polar3D<double>::Scalar zz); ROOT::Math::Polar3D<double>::ScalarTheta() const; ROOT::Math::Polar3D<double>::ScalarX() const; doublex() const; ROOT::Math::Polar3D<double>::ScalarY() const; doubley() const; ROOT::Math::Polar3D<double>::ScalarZ() const; doublez() const. private:. static ROOT::Math::Polar3D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefPhi; doublefR; doublefTheta. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polar3D & operator=(const ROOT::Math::Polar3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::Polar3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fR=src[0]; fTheta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fR; dest[1] = fTheta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Polar3D<double>::Scalar r, ROOT::Math::Polar3D<double>::Scalar theta, ROOT::Math::Polar3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fR=r; fTheta=theta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Polar3D<double>::Scalar& r, ROOT::Math::Polar3D<double>::Scalar& theta, ROOT::Math::Polar3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers. {r=fR; theta=fTheta; phi=fPhi;}. Scalar R() const; { return fR;}. Scalar Phi() co",MatchSource.WIKI,root/html532/ROOT__Math__Polar3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polar3D_double_.html
https://root.cern/root/html532/ROOT__Math__Polynomial.html:777,Integrability,interface,interface,777,". ROOT::Math::Polynomial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Polynomial. class ROOT::Math::Polynomial: public ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>, public ROOT::Math::IGradientOneDim. Parametric Function class describing polynomials of order n. <em>P(x) = p[0] + p[1]*x + p[2]*x**2 + ....... + p[n]*x**n</em>. The class implements also the derivatives, \a dP(x)/dx and the \a dP(x)/dp[i]. The class provides also the method to find the roots of the polynomial.; It uses analytical methods up to quartic polynomials. Implements both the Parameteric function interface and the gradient interface; since it provides the analytical gradient with respect to x. @ingroup ParamFunc. Function Members (Methods); public:. virtual~Polynomial(); virtual ROOT::Math::IGenFunction*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; const vector<std::complex<double> >&FindNumRoots(); vector<double>FindRealRoots(); const vector<std::complex<double> >&FindRoots(); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; virtual unsigned intROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::Polynomial&operator=(const ROOT::Math::Polynomial&); unsigned intOrder() const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0)",MatchSource.WIKI,root/html532/ROOT__Math__Polynomial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html
https://root.cern/root/html532/ROOT__Math__Polynomial.html:804,Integrability,interface,interface,804,". ROOT::Math::Polynomial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Polynomial. class ROOT::Math::Polynomial: public ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>, public ROOT::Math::IGradientOneDim. Parametric Function class describing polynomials of order n. <em>P(x) = p[0] + p[1]*x + p[2]*x**2 + ....... + p[n]*x**n</em>. The class implements also the derivatives, \a dP(x)/dx and the \a dP(x)/dp[i]. The class provides also the method to find the roots of the polynomial.; It uses analytical methods up to quartic polynomials. Implements both the Parameteric function interface and the gradient interface; since it provides the analytical gradient with respect to x. @ingroup ParamFunc. Function Members (Methods); public:. virtual~Polynomial(); virtual ROOT::Math::IGenFunction*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; const vector<std::complex<double> >&FindNumRoots(); vector<double>FindRealRoots(); const vector<std::complex<double> >&FindRoots(); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; virtual unsigned intROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::Polynomial&operator=(const ROOT::Math::Polynomial&); unsigned intOrder() const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0)",MatchSource.WIKI,root/html532/ROOT__Math__Polynomial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html
https://root.cern/root/html532/ROOT__Math__Polynomial.html:5671,Integrability,interface,interface,5671,"struct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id: Polynomial.h 37160 2010-12-01 21:52:04Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Polynomial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html
https://root.cern/root/html532/ROOT__Math__Polynomial.html:3835,Modifiability,Inherit,Inheritance,3835,"ctionOneDim>::Parameters() const; ROOT::Math::PolynomialPolynomial(unsigned int n = 0); ROOT::Math::PolynomialPolynomial(const ROOT::Math::Polynomial&); ROOT::Math::PolynomialPolynomial(double a, double b); ROOT::Math::PolynomialPolynomial(double a, double b, double c); ROOT::Math::PolynomialPolynomial(double a, double b, double c, double d); ROOT::Math::PolynomialPolynomial(double a, double b, double c, double d, double e); virtual voidROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::SetParameters(const double* p). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; protected:. vector<double>ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::fParams. private:. vector<double>fDerived_params; unsigned intfOrder; vector<std::complex<double> >fRoots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polynomial(unsigned int n = 0). Construct a Polynomial function of order n.; The number of Parameters is n+1. Polynomial(double a, double b). Construct a Polynomial of degree 1 : a*x + b. Polynomial(double a, double b, double c). Construct a Polynomial of degree 2 : a*x**2 + b*x + c. Polynomial(double a, double b, double c, double d). Construct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ",MatchSource.WIKI,root/html532/ROOT__Math__Polynomial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html
https://root.cern/root/html532/ROOT__Math__Polynomial.html:3848,Modifiability,Inherit,Inherited,3848,"ctionOneDim>::Parameters() const; ROOT::Math::PolynomialPolynomial(unsigned int n = 0); ROOT::Math::PolynomialPolynomial(const ROOT::Math::Polynomial&); ROOT::Math::PolynomialPolynomial(double a, double b); ROOT::Math::PolynomialPolynomial(double a, double b, double c); ROOT::Math::PolynomialPolynomial(double a, double b, double c, double d); ROOT::Math::PolynomialPolynomial(double a, double b, double c, double d, double e); virtual voidROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::SetParameters(const double* p). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; protected:. vector<double>ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::fParams. private:. vector<double>fDerived_params; unsigned intfOrder; vector<std::complex<double> >fRoots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Polynomial(unsigned int n = 0). Construct a Polynomial function of order n.; The number of Parameters is n+1. Polynomial(double a, double b). Construct a Polynomial of degree 1 : a*x + b. Polynomial(double a, double b, double c). Construct a Polynomial of degree 2 : a*x**2 + b*x + c. Polynomial(double a, double b, double c, double d). Construct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ",MatchSource.WIKI,root/html532/ROOT__Math__Polynomial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html
https://root.cern/root/html532/ROOT__Math__Polynomial.html:5562,Performance,Optimiz,Optimized,5562,"struct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id: Polynomial.h 37160 2010-12-01 21:52:04Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Polynomial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html
https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:7001,Modifiability,Inherit,Inheritance,7001,"<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b); ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>&SetY(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector2D & operator=(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). SetXY(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:7014,Modifiability,Inherit,Inherited,7014,"<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b); ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>&SetY(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector2D & operator=(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). SetXY(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:8853,Security,access,access,8853,"h::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. PositionVector2D<CoordSystem, Tag>& SetX(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); It is physically meaningless to speak of the unit vector corresponding; to a point.; ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. PositionVector2D<CoordSystem, Tag>& SetY(ROOT::",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:6787,Modifiability,Inherit,Inheritance,6787,">&SetXY(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b); ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>&SetY(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector2D & operator=(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). SetXY(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:6800,Modifiability,Inherit,Inherited,6800,">&SetXY(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b); ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>&SetY(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector2D & operator=(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). SetXY(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:8603,Security,access,access,8603,"onVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. PositionVector2D<CoordSystem, Tag>& SetX(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); It is physically meaningless to speak of the unit vector corresponding; to a point.; ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. PositionVector2D<CoordSystem, Tag>& SetY(ROOT::Math",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10026,Modifiability,Inherit,Inheritance,10026,"::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. ",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10039,Modifiability,Inherit,Inherited,10039,"::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. ",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:12704,Security,access,access,12704,"DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:9830,Modifiability,Inherit,Inheritance,9830,"temTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCo",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:9843,Modifiability,Inherit,Inherited,9843,"temTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCo",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:12494,Security,access,access,12494,"Math::GlobalCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:9754,Modifiability,Inherit,Inheritance,9754,"nateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordin",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:9767,Modifiability,Inherit,Inherited,9767,"nateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordin",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:12404,Security,access,access,12404,"ROOT::Math::LocalCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:13334,Modifiability,Inherit,Inheritance,13334,"ath::DefaultCoordinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. PositionVector3D<CoordSystem, Tag>& SetCoordinates(",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:13347,Modifiability,Inherit,Inherited,13347,"ath::DefaultCoordinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. PositionVector3D<CoordSystem, Tag>& SetCoordinates(",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:15872,Security,access,access,15872,"double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10184,Modifiability,Inherit,Inheritance,10184,"const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10197,Modifiability,Inherit,Inherited,10197,"const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:12890,Security,access,access,12890,"rdinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:10001,Modifiability,Inherit,Inheritance,10001,"dinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordin",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:10014,Modifiability,Inherit,Inherited,10014,"dinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordin",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:12651,Security,access,access,12651,"OT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10421,Modifiability,Inherit,Inheritance,10421,"ionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style ar",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10434,Modifiability,Inherit,Inherited,10434,"ionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style ar",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13169,Security,access,access,13169,"g>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:10220,Modifiability,Inherit,Inheritance,10220,"::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array o",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:10233,Modifiability,Inherit,Inherited,10233,"::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array o",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:12954,Security,access,access,12954,"temTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:10144,Modifiability,Inherit,Inheritance,10144,"T::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 S",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:10157,Modifiability,Inherit,Inherited,10157,"T::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 S",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:12864,Security,access,access,12864,"teSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:13761,Modifiability,Inherit,Inheritance,13761,"Theta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. PositionVector3D<CoordSystem, T",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:13774,Modifiability,Inherit,Inherited,13774,"Theta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. PositionVector3D<CoordSystem, T",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:16364,Security,access,access,16364,"ltCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9710,Modifiability,Inherit,Inheritance,9710,"ath::DefaultCoordinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCo",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9723,Modifiability,Inherit,Inherited,9723,"ath::DefaultCoordinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCo",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:12332,Security,access,access,12332,"le32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:12674,Modifiability,Inherit,Inheritance,12674,"T::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. PositionVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::Posi",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:12687,Modifiability,Inherit,Inherited,12687,"T::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarTheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalartheta() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PositionVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). SetXYZ(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). const CoordSystem & Coordinates() const. Retrieve a copy of the coordinates object. PositionVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. PositionVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::Posi",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:15160,Security,access,access,15160,"ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:7010,Energy Efficiency,energy,energy,7010,"}. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() con",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:7029,Energy Efficiency,energy,energy,7029,"st; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= C",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:7068,Energy Efficiency,energy,energy,7068,"eturn E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; T",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:4615,Modifiability,Inherit,Inheritance,4615,"Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz); ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarT() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalart() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarTheta() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarX() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalarx() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarY() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalary() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarZ() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfE; Double32_tfEta; Double32_tfPhi; Double32_tfPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& e) const. get internal data",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:4628,Modifiability,Inherit,Inherited,4628,"Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz); ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarT() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalart() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarTheta() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarX() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalarx() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarY() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalary() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::ScalarZ() const; ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfE; Double32_tfEta; Double32_tfPhi; Double32_tfPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& e) const. get internal data",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:5833,Security,access,accessors,5833,"ternal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& e) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; e = fE; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const; { return fPhi; }. Scalar E() const; { return fE; }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial c",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html:6654,Energy Efficiency,energy,energy,6654,"}. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<double>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility seci",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html:6673,Energy Efficiency,energy,energy,6673,"st; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<double>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==============",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html:6712,Energy Efficiency,energy,energy,6712,"eturn E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<double>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate sy",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html:4299,Modifiability,Inherit,Inheritance,4299,"t); voidSetPx(ROOT::Math::PtEtaPhiE4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiE4D<double>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiE4D<double>::Scalar pz); ROOT::Math::PtEtaPhiE4D<double>::ScalarT() const; ROOT::Math::PtEtaPhiE4D<double>::Scalart() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarTheta() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarX() const; ROOT::Math::PtEtaPhiE4D<double>::Scalarx() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarY() const; ROOT::Math::PtEtaPhiE4D<double>::Scalary() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarZ() const; ROOT::Math::PtEtaPhiE4D<double>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiE4D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefE; doublefEta; doublefPhi; doublefPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PtEtaPhiE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fE",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html:4312,Modifiability,Inherit,Inherited,4312,"t); voidSetPx(ROOT::Math::PtEtaPhiE4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiE4D<double>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiE4D<double>::Scalar pz); ROOT::Math::PtEtaPhiE4D<double>::ScalarT() const; ROOT::Math::PtEtaPhiE4D<double>::Scalart() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarTheta() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarX() const; ROOT::Math::PtEtaPhiE4D<double>::Scalarx() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarY() const; ROOT::Math::PtEtaPhiE4D<double>::Scalary() const; ROOT::Math::PtEtaPhiE4D<double>::ScalarZ() const; ROOT::Math::PtEtaPhiE4D<double>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiE4D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefE; doublefEta; doublefPhi; doublefPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PtEtaPhiE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fE",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html:5477,Security,access,accessors,5477,"PhiE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; e = fE; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const; { return fPhi; }. Scalar E() const; { return fE; }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial c",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:3521,Energy Efficiency,energy,energy,3521,"M4D<Double32_t>(const ROOT::Math::PtEtaPhiM4D<Double32_t>& v); ROOT::Math::PtEtaPhiM4D<Double32_t>PtEtaPhiM4D<Double32_t>(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPy() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPz() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarR() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarRho() const; voidScale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a); voidSetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src); voidSetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); voidSetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy); voidSetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta); voidSetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); voidSetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi); voidSetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); voidSetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalart() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scala",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:6772,Energy Efficiency,energy,energy,6772,to 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set ,MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:6806,Energy Efficiency,Energy,Energy,6806,ass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt valu,MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:6845,Energy Efficiency,energy,energy,6845,ass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt valu,MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:7400,Energy Efficiency,energy,energy,7400,"() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:7446,Energy Efficiency,energy,energy,7446,"nst; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need a",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:8407,Energy Efficiency,energy,energy,8407,"RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This pag",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:8588,Energy Efficiency,energy,energy,8588,"RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This pag",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:9352,Energy Efficiency,energy,energy,9352,"- otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:4852,Modifiability,Inherit,Inheritance,4852,"_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalart() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalary() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarZ() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarpi(); voidRestrictNegMass(); voidRestrictPhi(). Data Members; private:. Double32_tfEta; Double32_tfM; Double32_tfPhi; Double32_tfPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coo",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:4865,Modifiability,Inherit,Inherited,4865,"_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalart() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalary() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarZ() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarpi(); voidRestrictNegMass(); voidRestrictPhi(). Data Members; private:. Double32_tfEta; Double32_tfM; Double32_tfPhi; Double32_tfPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coo",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:7548,Safety,avoid,avoid,7548,"const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors ",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:5971,Security,access,accessors,5971," documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { ",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:3301,Energy Efficiency,energy,energy,3301,"tEtaPhiM4D<double>PtEtaPhiM4D<double>(); ROOT::Math::PtEtaPhiM4D<double>PtEtaPhiM4D<double>(const ROOT::Math::PtEtaPhiM4D<double>& v); ROOT::Math::PtEtaPhiM4D<double>PtEtaPhiM4D<double>(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); ROOT::Math::PtEtaPhiM4D<double>::ScalarPx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarPy() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarPz() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarR() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarRho() const; voidScale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a); voidSetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src); voidSetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); voidSetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy); voidSetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta); voidSetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); voidSetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi); voidSetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); voidSetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz); ROOT::Math::PtEtaPhiM4D<double>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<double>::Scalart() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<double>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<double>::Scalary() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarZ() const; ROOT::Math",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:6412,Energy Efficiency,energy,energy,6412,to 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coor,MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:6446,Energy Efficiency,Energy,Energy,6446,ass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. v,MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:6485,Energy Efficiency,energy,energy,6485,ass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. v,MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:7040,Energy Efficiency,energy,energy,7040,"() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (wo",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:7086,Energy Efficiency,energy,energy,7086,"nst; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); there",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:8015,Energy Efficiency,energy,energy,8015,"ar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatic",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:8196,Energy Efficiency,energy,energy,8196,"ar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatic",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:8940,Energy Efficiency,energy,energy,8940,"M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:4532,Modifiability,Inherit,Inheritance,4532,"PtEtaPhiM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz); ROOT::Math::PtEtaPhiM4D<double>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<double>::Scalart() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<double>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<double>::Scalary() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarZ() const; ROOT::Math::PtEtaPhiM4D<double>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiM4D<double>::Scalarpi(); voidRestrictNegMass(); voidRestrictPhi(). Data Members; private:. doublefEta; doublefM; doublefPhi; doublefPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar prop",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:4545,Modifiability,Inherit,Inherited,4545,"PtEtaPhiM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz); ROOT::Math::PtEtaPhiM4D<double>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<double>::Scalart() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<double>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<double>::Scalary() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarZ() const; ROOT::Math::PtEtaPhiM4D<double>::Scalarz() const. private:. static ROOT::Math::PtEtaPhiM4D<double>::Scalarpi(); voidRestrictNegMass(); voidRestrictPhi(). Data Members; private:. doublefEta; doublefM; doublefPhi; doublefPt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar prop",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:7188,Safety,avoid,avoid,7188,"const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data member",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:5611,Security,access,accessors,5611,"d Members; Includes; Libraries. Function documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { ",MatchSource.WIKI,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html:413,Energy Efficiency,energy,energy,413,". ROOT::Math::PxPyPzE4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzE4D<Double32_t>. class ROOT::Math::PxPyPzE4D<Double32_t>. Class describing a 4D cartesian coordinate system (x, y, z, t coordinates); or momentum-energy vectors stored as (Px, Py, Pz, E).; The metric used is (-,-,-,+). @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzE4D<Double32_t>(); ROOT::Math::PxPyPzE4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& e) const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzE4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzE4D<Double32_t>&operator=(const ROOT::Math::PxPyPzE4D<Double32_t>& v); booloperator==(const ROOT::Math::PxPyPzE4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarP() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarP2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarPerp() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarPerp2() const; ROOT::Math::PxPyPzE4D<Do",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html:6678,Energy Efficiency,energy,energy,6678,"{ return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return fT*fT - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz). set Z value. void SetE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). set all values using cartesian coordinates. void Negate(); ------ Manipulations -------------. negate the 4-vector. { fX = -fX; fY = -fY; fZ = -fZ; fT = -fT;}. void Scale(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ==========",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html:6724,Energy Efficiency,energy,energy,6724,"fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return fT*fT - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz). set Z value. void SetE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). set all values using cartesian coordinates. void Negate(); ------ Manipulations -------------. negate the 4-vector. { fX = -fX; fY = -fY; fZ = -fZ; fT = -fT;}. void Scale(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ================",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html:4361,Modifiability,Inherit,Inheritance,4361,"th::PxPyPzE4D<Double32_t>::Scalar pt); voidSetPx(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz); ROOT::Math::PxPyPzE4D<Double32_t>::ScalarT() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalart() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarTheta() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarX() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalarx() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarY() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalary() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarZ() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalarz() const. Data Members; private:. Double32_tfT; Double32_tfX; Double32_tfY; Double32_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html:4374,Modifiability,Inherit,Inherited,4374,"th::PxPyPzE4D<Double32_t>::Scalar pt); voidSetPx(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz); ROOT::Math::PxPyPzE4D<Double32_t>::ScalarT() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalart() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarTheta() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarX() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalarx() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarY() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalary() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarZ() const; ROOT::Math::PxPyPzE4D<Double32_t>::Scalarz() const. Data Members; private:. Double32_tfT; Double32_tfX; Double32_tfY; Double32_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html:5501,Security,access,accessors,5501," SetCoordinates(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar E() const; { return fT;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return s",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html:401,Energy Efficiency,energy,energy,401,". ROOT::Math::PxPyPzE4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzE4D<double>. class ROOT::Math::PxPyPzE4D<double>. Class describing a 4D cartesian coordinate system (x, y, z, t coordinates); or momentum-energy vectors stored as (Px, Py, Pz, E).; The metric used is (-,-,-,+). @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzE4D<double>(); ROOT::Math::PxPyPzE4D<double>::ScalarE() const; ROOT::Math::PxPyPzE4D<double>::ScalarEt() const; ROOT::Math::PxPyPzE4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzE4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const; ROOT::Math::PxPyPzE4D<double>::ScalarM() const; ROOT::Math::PxPyPzE4D<double>::ScalarM2() const; ROOT::Math::PxPyPzE4D<double>::ScalarMag() const; ROOT::Math::PxPyPzE4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzE4D<double>::ScalarMt() const; ROOT::Math::PxPyPzE4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzE4D<double>& rhs) const; ROOT::Math::PxPyPzE4D<double>&operator=(const ROOT::Math::PxPyPzE4D<double>& v); booloperator==(const ROOT::Math::PxPyPzE4D<double>& rhs) const; ROOT::Math::PxPyPzE4D<double>::ScalarP() const; ROOT::Math::PxPyPzE4D<double>::ScalarP2() const; ROOT::Math::PxPyPzE4D<double>::ScalarPerp() const; ROOT::Math::PxPyPzE4D<double>::ScalarPerp2() const; ROOT::Math::PxPyPzE4D<double>::ScalarPhi() const; ROOT::Math::PxPyPzE4D<double>::ScalarPt() const; ROOT::Math::PxPyPzE4D<double>::Scalar",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html:6326,Energy Efficiency,energy,energy,6326,"{ return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return fT*fT - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzE4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzE4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzE4D<double>::Scalar pz). set Z value. void SetE(ROOT::Math::PxPyPzE4D<double>::Scalar e). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). set all values using cartesian coordinates. void Negate(); ------ Manipulations -------------. negate the 4-vector. { fX = -fX; fY = -fY; fZ = -fZ; fT = -fT;}. void Scale(const ROOT::Math::PxPyPzE4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==========",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html:6372,Energy Efficiency,energy,energy,6372,"fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return fT*fT - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzE4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzE4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzE4D<double>::Scalar pz). set Z value. void SetE(ROOT::Math::PxPyPzE4D<double>::Scalar e). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). set all values using cartesian coordinates. void Negate(); ------ Manipulations -------------. negate the 4-vector. { fX = -fX; fY = -fY; fZ = -fZ; fT = -fT;}. void Scale(const ROOT::Math::PxPyPzE4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordina",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html:4049,Modifiability,Inherit,Inheritance,4049,"Scalar m); voidSetPhi(ROOT::Math::PxPyPzE4D<double>::Scalar phi); voidSetPt(ROOT::Math::PxPyPzE4D<double>::Scalar pt); voidSetPx(ROOT::Math::PxPyPzE4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e); voidSetPy(ROOT::Math::PxPyPzE4D<double>::Scalar py); voidSetPz(ROOT::Math::PxPyPzE4D<double>::Scalar pz); ROOT::Math::PxPyPzE4D<double>::ScalarT() const; ROOT::Math::PxPyPzE4D<double>::Scalart() const; ROOT::Math::PxPyPzE4D<double>::ScalarTheta() const; ROOT::Math::PxPyPzE4D<double>::ScalarX() const; ROOT::Math::PxPyPzE4D<double>::Scalarx() const; ROOT::Math::PxPyPzE4D<double>::ScalarY() const; ROOT::Math::PxPyPzE4D<double>::Scalary() const; ROOT::Math::PxPyPzE4D<double>::ScalarZ() const; ROOT::Math::PxPyPzE4D<double>::Scalarz() const. Data Members; private:. doublefT; doublefX; doublefY; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordin",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html:4062,Modifiability,Inherit,Inherited,4062,"Scalar m); voidSetPhi(ROOT::Math::PxPyPzE4D<double>::Scalar phi); voidSetPt(ROOT::Math::PxPyPzE4D<double>::Scalar pt); voidSetPx(ROOT::Math::PxPyPzE4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e); voidSetPy(ROOT::Math::PxPyPzE4D<double>::Scalar py); voidSetPz(ROOT::Math::PxPyPzE4D<double>::Scalar pz); ROOT::Math::PxPyPzE4D<double>::ScalarT() const; ROOT::Math::PxPyPzE4D<double>::Scalart() const; ROOT::Math::PxPyPzE4D<double>::ScalarTheta() const; ROOT::Math::PxPyPzE4D<double>::ScalarX() const; ROOT::Math::PxPyPzE4D<double>::Scalarx() const; ROOT::Math::PxPyPzE4D<double>::ScalarY() const; ROOT::Math::PxPyPzE4D<double>::Scalary() const; ROOT::Math::PxPyPzE4D<double>::ScalarZ() const; ROOT::Math::PxPyPzE4D<double>::Scalarz() const. Data Members; private:. doublefT; doublefX; doublefY; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordin",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html:5149,Security,access,accessors,5149," Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar E() const; { return fT;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return s",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzE4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:528,Availability,error,errors,528,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Dou",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:378,Energy Efficiency,energy,energy,378,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Dou",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:3482,Energy Efficiency,energy,energy,3482,"th::PxPyPzM4D<Double32_t>::ScalarPx() const; ROOT::Math::PxPyPzM4D<Double32_t>PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>PxPyPzM4D<Double32_t>(const ROOT::Math::PxPyPzM4D<Double32_t>& v); ROOT::Math::PxPyPzM4D<Double32_t>PxPyPzM4D<Double32_t>(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarPy() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarPz() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarR() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarRho() const; voidScale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a); voidSetCoordinates(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* src); voidSetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m); voidSetE(Double32_t energy); voidSetEta(Double32_t eta); voidSetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m); voidSetPhi(Double32_t phi); voidSetPt(Double32_t pt); voidSetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarT() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalart() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarX() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarx() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarY() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalary() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarZ() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarz() const.",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:5935,Energy Efficiency,Energy,Energy,5935,"est[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. S",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:6472,Energy Efficiency,energy,energy,6472,to 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scala,MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:6921,Energy Efficiency,energy,energy,6921,"resentation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:6967,Energy Efficiency,energy,energy,6967,"() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPy",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:7726,Energy Efficiency,energy,energy,7726,"return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathco",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:7908,Energy Efficiency,energy,energy,7908," Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatica",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:8548,Energy Efficiency,energy,energy,8548,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:4597,Modifiability,Inherit,Inheritance,4597," pt); voidSetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarT() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalart() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarX() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarx() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarY() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalary() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarZ() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarz() const. private:. voidRestrictNegMass(). Data Members; private:. Double32_tfM; Double32_tfX; Double32_tfY; Double32_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:4610,Modifiability,Inherit,Inherited,4610," pt); voidSetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarT() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalart() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarX() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarx() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarY() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalary() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarZ() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarz() const. private:. voidRestrictNegMass(). Data Members; private:. Double32_tfM; Double32_tfX; Double32_tfY; Double32_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:512,Safety,avoid,avoid,512,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Dou",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:8620,Safety,avoid,avoid,8620,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:5657,Security,access,accessors,5657,"nheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { ret",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:516,Availability,error,errors,516,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPz",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:366,Energy Efficiency,energy,energy,366,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPz",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:3262,Energy Efficiency,energy,energy,3262,"Perp2() const; ROOT::Math::PxPyPzM4D<double>::ScalarPhi() const; ROOT::Math::PxPyPzM4D<double>::ScalarPt() const; ROOT::Math::PxPyPzM4D<double>::ScalarPt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarPx() const; ROOT::Math::PxPyPzM4D<double>PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>PxPyPzM4D<double>(const ROOT::Math::PxPyPzM4D<double>& v); ROOT::Math::PxPyPzM4D<double>PxPyPzM4D<double>(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m); ROOT::Math::PxPyPzM4D<double>::ScalarPy() const; ROOT::Math::PxPyPzM4D<double>::ScalarPz() const; ROOT::Math::PxPyPzM4D<double>::ScalarR() const; ROOT::Math::PxPyPzM4D<double>::ScalarRho() const; voidScale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a); voidSetCoordinates(const ROOT::Math::PxPyPzM4D<double>::Scalar* src); voidSetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m); voidSetE(double energy); voidSetEta(double eta); voidSetM(ROOT::Math::PxPyPzM4D<double>::Scalar m); voidSetPhi(double phi); voidSetPt(double pt); voidSetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz); ROOT::Math::PxPyPzM4D<double>::ScalarT() const; ROOT::Math::PxPyPzM4D<double>::Scalart() const; ROOT::Math::PxPyPzM4D<double>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<double>::ScalarX() const; ROOT::Math::PxPyPzM4D<double>::Scalarx() const; ROOT::Math::PxPyPzM4D<double>::ScalarY() const; ROOT::Math::PxPyPzM4D<double>::Scalary() const; ROOT::Math::PxPyPzM4D<double>::ScalarZ() const; ROOT::Math::PxPyPzM4D<double>::Scalarz() const.",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:5579,Energy Efficiency,Energy,Energy,5579,"n array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. S",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:6116,Energy Efficiency,energy,energy,6116,"to 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::Px",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:6565,Energy Efficiency,energy,energy,6565,"resentation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:6611,Energy Efficiency,energy,energy,6611,"() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:7338,Energy Efficiency,energy,energy,7338,"n Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:7520,Energy Efficiency,energy,energy,7520,"lar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For c",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:8140,Energy Efficiency,energy,energy,8140,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:4281,Modifiability,Inherit,Inheritance,4281,"OT::Math::PxPyPzM4D<double>::Scalar m); voidSetPhi(double phi); voidSetPt(double pt); voidSetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz); ROOT::Math::PxPyPzM4D<double>::ScalarT() const; ROOT::Math::PxPyPzM4D<double>::Scalart() const; ROOT::Math::PxPyPzM4D<double>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<double>::ScalarX() const; ROOT::Math::PxPyPzM4D<double>::Scalarx() const; ROOT::Math::PxPyPzM4D<double>::ScalarY() const; ROOT::Math::PxPyPzM4D<double>::Scalary() const; ROOT::Math::PxPyPzM4D<double>::ScalarZ() const; ROOT::Math::PxPyPzM4D<double>::Scalarz() const. private:. voidRestrictNegMass(). Data Members; private:. doublefM; doublefX; doublefY; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate access",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:4294,Modifiability,Inherit,Inherited,4294,"OT::Math::PxPyPzM4D<double>::Scalar m); voidSetPhi(double phi); voidSetPt(double pt); voidSetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz); ROOT::Math::PxPyPzM4D<double>::ScalarT() const; ROOT::Math::PxPyPzM4D<double>::Scalart() const; ROOT::Math::PxPyPzM4D<double>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<double>::ScalarX() const; ROOT::Math::PxPyPzM4D<double>::Scalarx() const; ROOT::Math::PxPyPzM4D<double>::ScalarY() const; ROOT::Math::PxPyPzM4D<double>::Scalary() const; ROOT::Math::PxPyPzM4D<double>::ScalarZ() const; ROOT::Math::PxPyPzM4D<double>::Scalarz() const. private:. voidRestrictNegMass(). Data Members; private:. doublefM; doublefX; doublefY; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate access",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:500,Safety,avoid,avoid,500,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPz",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:8212,Safety,avoid,avoid,8212,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:5301,Security,access,accessors,5301,"efX; doublefY; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { ret",MatchSource.WIKI,root/html532/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html
https://root.cern/root/html532/ROOT__Math__Quaternion.html:3783,Modifiability,Inherit,Inheritance,3783,"ationX const& r); ROOT::Math::Quaternion&operator=(ROOT::Math::RotationY const& r); ROOT::Math::Quaternion&operator=(ROOT::Math::RotationZ const& r); ROOT::Math::Quaternion&operator=(const ROOT::Math::Quaternion&); booloperator==(const ROOT::Math::Quaternion& rhs) const; ROOT::Math::QuaternionQuaternion(); ROOT::Math::QuaternionQuaternion(const ROOT::Math::Quaternion&); ROOT::Math::QuaternionQuaternion(ROOT::Math::Quaternion::Scalar u, ROOT::Math::Quaternion::Scalar i, ROOT::Math::Quaternion::Scalar j, ROOT::Math::Quaternion::Scalar k); voidRectify(); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::Quaternion::Scalar u, ROOT::Math::Quaternion::Scalar i, ROOT::Math::Quaternion::Scalar j, ROOT::Math::Quaternion::Scalar k); ROOT::Math::Quaternion::ScalarU() const. Data Members; private:. ROOT::Math::Quaternion::ScalarfI; ROOT::Math::Quaternion::ScalarfJ; ROOT::Math::Quaternion::ScalarfK; ROOT::Math::Quaternion::ScalarfU. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Quaternion(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. Quaternion(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of four Scalars. { SetComponents(begin,end); }. explicit Quaternion(const ROOT::Math::Quaternion& ); ======== Construction From other Rotation Forms ==================. Construct from another supported rotation type (see gv_detail::convert ). {gv_detail::convert(r,*this);}. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from |Q| = 1; orthonormality. Quaternion & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the four components given an iterator to the start of; ",MatchSource.WIKI,root/html532/ROOT__Math__Quaternion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Quaternion.html
https://root.cern/root/html532/ROOT__Math__Quaternion.html:3796,Modifiability,Inherit,Inherited,3796,"ationX const& r); ROOT::Math::Quaternion&operator=(ROOT::Math::RotationY const& r); ROOT::Math::Quaternion&operator=(ROOT::Math::RotationZ const& r); ROOT::Math::Quaternion&operator=(const ROOT::Math::Quaternion&); booloperator==(const ROOT::Math::Quaternion& rhs) const; ROOT::Math::QuaternionQuaternion(); ROOT::Math::QuaternionQuaternion(const ROOT::Math::Quaternion&); ROOT::Math::QuaternionQuaternion(ROOT::Math::Quaternion::Scalar u, ROOT::Math::Quaternion::Scalar i, ROOT::Math::Quaternion::Scalar j, ROOT::Math::Quaternion::Scalar k); voidRectify(); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::Quaternion::Scalar u, ROOT::Math::Quaternion::Scalar i, ROOT::Math::Quaternion::Scalar j, ROOT::Math::Quaternion::Scalar k); ROOT::Math::Quaternion::ScalarU() const. Data Members; private:. ROOT::Math::Quaternion::ScalarfI; ROOT::Math::Quaternion::ScalarfJ; ROOT::Math::Quaternion::ScalarfK; ROOT::Math::Quaternion::ScalarfU. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Quaternion(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. Quaternion(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of four Scalars. { SetComponents(begin,end); }. explicit Quaternion(const ROOT::Math::Quaternion& ); ======== Construction From other Rotation Forms ==================. Construct from another supported rotation type (see gv_detail::convert ). {gv_detail::convert(r,*this);}. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from |Q| = 1; orthonormality. Quaternion & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the four components given an iterator to the start of; ",MatchSource.WIKI,root/html532/ROOT__Math__Quaternion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Quaternion.html
https://root.cern/root/html532/ROOT__Math__Quaternion.html:5417,Security,Access,Access,5417,"mall deviations from |Q| = 1; orthonormality. Quaternion & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the four components given an iterator to the start of; the desired data, and another to the end (4 past start). void GetComponents(IT begin, IT end). Get the components into data specified by an iterator begin; and another to the end of the desired data (4 past start). void GetComponents(double* begin) const. Get the components into data specified by an iterator begin. void SetComponents(ROOT::Math::Quaternion::Scalar u, ROOT::Math::Quaternion::Scalar i, ROOT::Math::Quaternion::Scalar j, ROOT::Math::Quaternion::Scalar k). Set the components based on four Scalars. The sum of the squares of; these Scalars should be 1; no checking is done. Scalar U() const. Access to the four quaternion components:; U() is the coefficient of the identity Pauli matrix,; I(), J() and K() are the coefficients of sigma_x, sigma_y, sigma_z. { return fU; }. Scalar I() const; { return fI; }. Scalar J() const; { return fJ; }. Scalar K() const; { return fK; }. XYZVector operator()(const ROOT::Math::Quaternion::XYZVector& v) const. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert a rotation in place. { fI = -fI; fJ = -fJ; fK = -fK; }. Quaternion Inverse() const. Return inverse of a rotation. { return Quaternion(fU, -fI, -fJ, -fK); }. Scalar Distance(const ROOT::Math::Quaternion& q) const. Distance between two rotations in Quaternion form; Note: The rotation group is isomorphic to a 3-sphere; with diametrically opposite points identified.; The (rotation group-invariant) is the smaller; of the two possible angles between the images of; the two totations on that sphere. Thus the distance; is never greater than pi/2. return ! operator==(rhs). Quaternion operator*(RotationX const & r1, Quaterni",MatchSource.WIKI,root/html532/ROOT__Math__Quaternion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Quaternion.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html:2346,Modifiability,Inherit,Inheritance,2346,"sigma); vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(const ROOT::Math::GSLRngGFSR4& e); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(const ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngGFSR4fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html:2359,Modifiability,Inherit,Inherited,2359,"sigma); vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(const ROOT::Math::GSLRngGFSR4& e); ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>Random<ROOT::Math::GSLRngGFSR4>(const ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngGFSR4fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html:3850,Testability,Log,LogNormal,3850,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html:3888,Testability,Log,Log,3888,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngGFSR4_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html:2295,Modifiability,Inherit,Inheritance,2295,"); doubleLogNormal(double zeta, double sigma); vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngMT>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngMT>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(const ROOT::Math::GSLRngMT& e); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(const ROOT::Math::Random<ROOT::Math::GSLRngMT>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngMTfEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngMT_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html:2308,Modifiability,Inherit,Inherited,2308,"); doubleLogNormal(double zeta, double sigma); vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngMT>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngMT>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(const ROOT::Math::GSLRngMT& e); ROOT::Math::Random<ROOT::Math::GSLRngMT>Random<ROOT::Math::GSLRngMT>(const ROOT::Math::Random<ROOT::Math::GSLRngMT>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngMTfEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngMT_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html:3799,Testability,Log,LogNormal,3799,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngMT_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html:3837,Testability,Log,Log,3837,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngMT_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngMT_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html:2397,Modifiability,Inherit,Inheritance,2397,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(const ROOT::Math::GSLRngRanLuxD1& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxD1fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html:2410,Modifiability,Inherit,Inherited,2410,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(const ROOT::Math::GSLRngRanLuxD1& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>Random<ROOT::Math::GSLRngRanLuxD1>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxD1fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html:3901,Testability,Log,LogNormal,3901,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html:3939,Testability,Log,Log,3939,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html:2397,Modifiability,Inherit,Inheritance,2397,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(const ROOT::Math::GSLRngRanLuxD2& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxD2fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html:2410,Modifiability,Inherit,Inherited,2410,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(const ROOT::Math::GSLRngRanLuxD2& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>Random<ROOT::Math::GSLRngRanLuxD2>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxD2fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html:3901,Testability,Log,LogNormal,3901,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html:3939,Testability,Log,Log,3939,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxD2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html:2397,Modifiability,Inherit,Inheritance,2397,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(const ROOT::Math::GSLRngRanLuxS1& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxS1fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html:2410,Modifiability,Inherit,Inherited,2410,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(const ROOT::Math::GSLRngRanLuxS1& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>Random<ROOT::Math::GSLRngRanLuxS1>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxS1fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html:3901,Testability,Log,LogNormal,3901,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html:3939,Testability,Log,Log,3939,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS1_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html:2397,Modifiability,Inherit,Inheritance,2397,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(const ROOT::Math::GSLRngRanLuxS2& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxS2fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html:2410,Modifiability,Inherit,Inherited,2410,"(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(const ROOT::Math::GSLRngRanLuxS2& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>Random<ROOT::Math::GSLRngRanLuxS2>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxS2fEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html:3901,Testability,Log,LogNormal,3901,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html:3939,Testability,Log,Log,3939,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLuxS2_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html:2363,Modifiability,Inherit,Inheritance,2363,"r<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLux>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(const ROOT::Math::GSLRngRanLux& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLux>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxfEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html:2376,Modifiability,Inherit,Inherited,2376,"r<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngRanLux>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(const ROOT::Math::GSLRngRanLux& e); ROOT::Math::Random<ROOT::Math::GSLRngRanLux>Random<ROOT::Math::GSLRngRanLux>(const ROOT::Math::Random<ROOT::Math::GSLRngRanLux>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngRanLuxfEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html:3867,Testability,Log,LogNormal,3867,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html:3905,Testability,Log,Log,3905,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngRanLux_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html:2329,Modifiability,Inherit,Inheritance,2329,"zeta, double sigma); vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngTaus>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngTaus>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(const ROOT::Math::GSLRngTaus& e); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(const ROOT::Math::Random<ROOT::Math::GSLRngTaus>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngTausfEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html:2342,Modifiability,Inherit,Inherited,2342,"zeta, double sigma); vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p); unsigned intNegativeBinomial(double n, double prob); ROOT::Math::Random<ROOT::Math::GSLRngTaus>&operator=(const ROOT::Math::Random<ROOT::Math::GSLRngTaus>&); unsigned intPoisson(double mu); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(unsigned int seed); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(const ROOT::Math::GSLRngTaus& e); ROOT::Math::Random<ROOT::Math::GSLRngTaus>Random<ROOT::Math::GSLRngTaus>(const ROOT::Math::Random<ROOT::Math::GSLRngTaus>&); doubleRndm(); voidRndmArray(int n, double* array); voidSetSeed(unsigned int seed); voidSphere(double& x, double& y, double& z, double r = 1); doubletDist(double nu); stringType() const; doubleUniform(double x = 1.0). Data Members; private:. ROOT::Math::GSLRngTausfEngine. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; fEngine. SetSeed(unsigned int seed). double Uniform(double x = 1.0). Generate random numbers between ]0,1]; 0 is excluded and 1 is included. double Rndm(). Generate random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. void RndmArray(int n, double* array). Generate an array of random numbers between ]0,1]; 0 is excluded and 1 is included; Function to preserve ROOT Trandom compatibility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Meth",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html:3833,Testability,Log,LogNormal,3833,"ility. std::string Type() const. Return the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z monet",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html
https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html:3871,Testability,Log,Log,3871,"turn the type (name) of the used generator. unsigned int EngineSize() const. Return the size of the generator state. double Gaus(double mean = 0, double sigma = 1); Random Distributions; 	Use naming and signatures compatible with ROOT TRandom. Gaussian distribution. Default method (use Ziggurat). double GausBM(double mean = 0, double sigma = 1). Gaussian distribution (Box-Muller method). double GausR(double mean = 0, double sigma = 1). Gaussian distribution (Ratio Method). double GaussianTail(double a, double sigma = 1). Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y). Bivariate Gaussian distribution with correlation. double Exp(double tau). Exponential distribution. double BreitWigner(double mean = 0., double gamma = 1). Breit Wigner distribution. double Landau(double mean = 0, double sigma = 1). Landau distribution. double Gamma(double a, double b). Gamma distribution. double LogNormal(double zeta, double sigma). Log Normal distribution. double ChiSquare(double nu). Chi square distribution. double FDist(double nu1, double nu2). F distrbution. double tDist(double nu). t student distribution. void Circle(double& x, double& y, double r = 1). generate random numbers in a 2D circle of radious 1. void Sphere(double& x, double& y, double& z, double r = 1). generate random numbers in a 3D sphere of radious 1. unsigned int Poisson(double mu). Poisson distribution. unsigned int Binomial(unsigned int ntot, double prob). Binomial distribution. unsigned int NegativeBinomial(double n, double prob). Negative Binomial distribution; First parameter is n, second is probability; To be consistent with Random::Binomial. std::vector<unsigned int> Multinomial(unsigned int ntot, const vector<double>& p). Multinomial distribution. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: Random.h 37442 2010-12-09 16:36:55Z moneta $ » Last generated: 2011-11-03 20",MatchSource.WIKI,root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Random_-p1GSLRngTaus_.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:988,Availability,error,error,988,". ROOT::Math::RichardsonDerivator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RichardsonDerivator. class ROOT::Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::M",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:1029,Availability,error,error,1029,". ROOT::Math::RichardsonDerivator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RichardsonDerivator. class ROOT::Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::M",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:1111,Availability,error,error,1111,"eader . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RichardsonDerivator. class ROOT::Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(double h = 0.001); ROOT::Math::RichardsonDerivatorR",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:1167,Availability,error,error,1167,"eader . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RichardsonDerivator. class ROOT::Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(double h = 0.001); ROOT::Math::RichardsonDerivatorR",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:3382,Availability,Error,Error,3382,"ected:. const ROOT::Math::IGenFunction*fFunctionpointer to function; boolfFunctionCopiedflag to control if function is copied in the class; doublefLastErrorerror estimate of last derivative calculation; doublefStepSizestep size used for derivative calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RichardsonDerivator(); Destructor: Removes function if needed. . RichardsonDerivator(double h = 0.001); Default Constructor.; Give optionally the step size for derivation. By default is 0.001, which is fine for x ~ 1; Increase if x is in averga larger or decrease if x is smaller. RichardsonDerivator(const ROOT::Math::IGenFunction& f, double h = 0.001, bool copyFunc = false); Construct from function and step size. RichardsonDerivator(const ROOT::Math::RichardsonDerivator& rhs). Copy constructor. RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:3434,Availability,Error,Error,3434,"ected:. const ROOT::Math::IGenFunction*fFunctionpointer to function; boolfFunctionCopiedflag to control if function is copied in the class; doublefLastErrorerror estimate of last derivative calculation; doublefStepSizestep size used for derivative calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RichardsonDerivator(); Destructor: Removes function if needed. . RichardsonDerivator(double h = 0.001); Default Constructor.; Give optionally the step size for derivation. By default is 0.001, which is fine for x ~ 1; Increase if x is in averga larger or decrease if x is smaller. RichardsonDerivator(const ROOT::Math::IGenFunction& f, double h = 0.001, bool copyFunc = false); Construct from function and step size. RichardsonDerivator(const ROOT::Math::RichardsonDerivator& rhs). Copy constructor. RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:4211,Availability,error,error,4211," RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:4251,Availability,error,error,4251," RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:4268,Availability,error,error,4268," RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:4290,Availability,error,error,4290," RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:4327,Availability,error,error,4327," RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:4460,Availability,error,error,4460," Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::De",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:5417,Availability,error,error,5417,"making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your fun",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:5457,Availability,error,error,5457,"making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your fun",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:5474,Availability,error,error,5474,"making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your fun",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:5496,Availability,error,error,5496,"making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your fun",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:5533,Availability,error,error,5533,"making the step size h smaller. double operator()(double x); { return Derivative1(x); }. double Derivative1(const ROOT::Math::IGenFunction& f, double x, double h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your fun",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:5666,Availability,error,error,5666,"le h). First Derivative calculation passing function and step-size. double Derivative2(double x). Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpola",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:6566,Availability,error,error,6566," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:6606,Availability,error,error,6606," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:6623,Availability,error,error,6623," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:6645,Availability,error,error,6645," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:6682,Availability,error,error,6682," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:6815,Availability,error,error,6815," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:1285,Deployability,a/b,a/bookcpdf,1285,"Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(double h = 0.001); ROOT::Math::RichardsonDerivatorRichardsonDerivator(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(const ROOT::Math::IGenFunction& f, double",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:910,Integrability,depend,depending,910,". ROOT::Math::RichardsonDerivator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RichardsonDerivator. class ROOT::Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::M",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:2699,Modifiability,Inherit,Inheritance,2699,"leDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(double h = 0.001); ROOT::Math::RichardsonDerivatorRichardsonDerivator(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(const ROOT::Math::IGenFunction& f, double h = 0.001, bool copyFunc = false); voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetStepSize(double h). Data Members; protected:. const ROOT::Math::IGenFunction*fFunctionpointer to function; boolfFunctionCopiedflag to control if function is copied in the class; doublefLastErrorerror estimate of last derivative calculation; doublefStepSizestep size used for derivative calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RichardsonDerivator(); Destructor: Removes function if needed. . RichardsonDerivator(double h = 0.001); Default Constructor.; Give optionally the step size for derivation. By default is 0.001, which is fine for x ~ 1; Increase if x is in averga larger or decrease if x is smaller. RichardsonDerivator(const ROOT::Math::IGenFunction& f, double h = 0.001, bool copyFunc = false); Construct from function and step size. RichardsonDerivator(const ROOT::Math::RichardsonDerivator& rhs). Copy constructor. RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, deriva",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:2712,Modifiability,Inherit,Inherited,2712,"leDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(double h = 0.001); ROOT::Math::RichardsonDerivatorRichardsonDerivator(const ROOT::Math::RichardsonDerivator& rhs); ROOT::Math::RichardsonDerivatorRichardsonDerivator(const ROOT::Math::IGenFunction& f, double h = 0.001, bool copyFunc = false); voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetStepSize(double h). Data Members; protected:. const ROOT::Math::IGenFunction*fFunctionpointer to function; boolfFunctionCopiedflag to control if function is copied in the class; doublefLastErrorerror estimate of last derivative calculation; doublefStepSizestep size used for derivative calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RichardsonDerivator(); Destructor: Removes function if needed. . RichardsonDerivator(double h = 0.001); Default Constructor.; Give optionally the step size for derivation. By default is 0.001, which is fine for x ~ 1; Increase if x is in averga larger or decrease if x is smaller. RichardsonDerivator(const ROOT::Math::IGenFunction& f, double h = 0.001, bool copyFunc = false); Construct from function and step size. RichardsonDerivator(const ROOT::Math::RichardsonDerivator& rhs). Copy constructor. RichardsonDerivator & operator=(const ROOT::Math::RichardsonDerivator& rhs). Assignment operator. double Error() const; Returns the estimate of the absolute Error of the last derivative calculation. . { return fLastError; }. double Derivative1(double x). Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, deriva",MatchSource.WIKI,root/html532/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html
https://root.cern/root/html532/ROOT__Math__RootFinder.html:3169,Availability,failure,failure,3169,"d . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. int Status() const. Return the status of the last estimate of the Root; = 0 OK, not zero failure. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 33942 2010-06-16 13:12:17Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html
https://root.cern/root/html532/ROOT__Math__RootFinder.html:437,Modifiability,plug-in,plug-in,437,". ROOT::Math::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RootFinder. class ROOT::Math::RootFinder. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d",MatchSource.WIKI,root/html532/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html
https://root.cern/root/html532/ROOT__Math__RootFinder.html:1887,Modifiability,Inherit,Inheritance,1887,". This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration",MatchSource.WIKI,root/html532/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html
https://root.cern/root/html532/ROOT__Math__RootFinder.html:1900,Modifiability,Inherit,Inherited,1900,". This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration",MatchSource.WIKI,root/html532/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html
https://root.cern/root/html532/ROOT__Math__RootFinder.html:407,Performance,load,loaded,407,". ROOT::Math::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RootFinder. class ROOT::Math::RootFinder. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d",MatchSource.WIKI,root/html532/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html
https://root.cern/root/html532/ROOT__Math__RootFinder.html:2914,Performance,perform,performed,2914,"d . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. int Status() const. Return the status of the last estimate of the Root; = 0 OK, not zero failure. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 33942 2010-06-16 13:12:17Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html
https://root.cern/root/html532/ROOT__Math__RootFinder.html:2957,Performance,Perform,Perform,2957,"d . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. int Status() const. Return the status of the last estimate of the Root; = 0 OK, not zero failure. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 33942 2010-06-16 13:12:17Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html
https://root.cern/root/html532/ROOT__Math__Roots.html:324,Usability,simpl,simplest,324,". ROOT::Math::Roots. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots. namespace ROOT::Math::Roots. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods). Class Charts; Function documentation. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots.html
https://root.cern/root/html532/ROOT__Math__Roots__Bisection.html:1815,Modifiability,Inherit,Inheritance,1815,"g the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Bisection(); ROOT::Math::Roots::BisectionBisection(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BisectionBisection(const ROOT::Math::Roots::Bisection&); ROOT::Math::Roots::Bisection&operator=(const ROOT::Math::Roots::Bisection&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bisection(). virtual ~Bisection(). Bisection(const ROOT::Math::Roots::Bisection& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Bisection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Bisection.html
https://root.cern/root/html532/ROOT__Math__Roots__Bisection.html:1828,Modifiability,Inherit,Inherited,1828,"g the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Bisection(); ROOT::Math::Roots::BisectionBisection(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BisectionBisection(const ROOT::Math::Roots::Bisection&); ROOT::Math::Roots::Bisection&operator=(const ROOT::Math::Roots::Bisection&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bisection(). virtual ~Bisection(). Bisection(const ROOT::Math::Roots::Bisection& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Bisection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Bisection.html
https://root.cern/root/html532/ROOT__Math__Roots__Bisection.html:383,Usability,simpl,simplest,383,". ROOT::Math::Roots::Bisection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Bisection. class ROOT::Math::Roots::Bisection: public ROOT::Math::GSLRootFinder. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Bisection(); ROOT::Math::Roots::BisectionBisection(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BisectionBisection(const ROOT::Math::Roots::Bisection&); ROOT::Math::Roots::Bisection&operator=(const ROOT::Math::Roots::Bisection&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bisection(). virtual ~Bisection(). Bisection(const ROOT::Math::Roots::Bisection& ); usually copying is non tr",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Bisection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Bisection.html
https://root.cern/root/html532/ROOT__Math__Roots__Brent.html:1771,Modifiability,Inherit,Inheritance,1771,"tion algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Brent(); ROOT::Math::Roots::BrentBrent(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BrentBrent(const ROOT::Math::Roots::Brent&); ROOT::Math::Roots::Brent&operator=(const ROOT::Math::Roots::Brent&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Brent(). virtual ~Brent(). Brent(const ROOT::Math::Roots::Brent& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Brent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Brent.html
https://root.cern/root/html532/ROOT__Math__Roots__Brent.html:1784,Modifiability,Inherit,Inherited,1784,"tion algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Brent(); ROOT::Math::Roots::BrentBrent(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BrentBrent(const ROOT::Math::Roots::Brent&); ROOT::Math::Roots::Brent&operator=(const ROOT::Math::Roots::Brent&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Brent(). virtual ~Brent(). Brent(const ROOT::Math::Roots::Brent& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Brent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Brent.html
https://root.cern/root/html532/ROOT__Math__Roots__Brent.html:371,Usability,simpl,simplest,371,". ROOT::Math::Roots::Brent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Brent. class ROOT::Math::Roots::Brent: public ROOT::Math::GSLRootFinder. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Brent(); ROOT::Math::Roots::BrentBrent(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BrentBrent(const ROOT::Math::Roots::Brent&); ROOT::Math::Roots::Brent&operator=(const ROOT::Math::Roots::Brent&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Brent(). virtual ~Brent(). Brent(const ROOT::Math::Roots::Brent& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A.",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Brent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Brent.html
https://root.cern/root/html532/ROOT__Math__Roots__FalsePos.html:1804,Modifiability,Inherit,Inheritance,1804,"or bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~FalsePos(); ROOT::Math::Roots::FalsePosFalsePos(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::FalsePosFalsePos(const ROOT::Math::Roots::FalsePos&); ROOT::Math::Roots::FalsePos&operator=(const ROOT::Math::Roots::FalsePos&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FalsePos(). virtual ~FalsePos(). FalsePos(const ROOT::Math::Roots::FalsePos& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__FalsePos.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__FalsePos.html
https://root.cern/root/html532/ROOT__Math__Roots__FalsePos.html:1817,Modifiability,Inherit,Inherited,1817,"or bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~FalsePos(); ROOT::Math::Roots::FalsePosFalsePos(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::FalsePosFalsePos(const ROOT::Math::Roots::FalsePos&); ROOT::Math::Roots::FalsePos&operator=(const ROOT::Math::Roots::FalsePos&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FalsePos(). virtual ~FalsePos(). FalsePos(const ROOT::Math::Roots::FalsePos& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__FalsePos.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__FalsePos.html
https://root.cern/root/html532/ROOT__Math__Roots__FalsePos.html:380,Usability,simpl,simplest,380,". ROOT::Math::Roots::FalsePos. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::FalsePos. class ROOT::Math::Roots::FalsePos: public ROOT::Math::GSLRootFinder. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~FalsePos(); ROOT::Math::Roots::FalsePosFalsePos(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::FalsePosFalsePos(const ROOT::Math::Roots::FalsePos&); ROOT::Math::Roots::FalsePos&operator=(const ROOT::Math::Roots::FalsePos&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FalsePos(). virtual ~FalsePos(). FalsePos(const ROOT::Math::Roots::FalsePos& ); usually copying is non trivial, so we ma",MatchSource.WIKI,root/html532/ROOT__Math__Roots__FalsePos.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__FalsePos.html
https://root.cern/root/html532/ROOT__Math__Roots__Newton.html:1947,Modifiability,Inherit,Inheritance,1947,"ing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Newton(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; ROOT::Math::Roots::NewtonNewton(); virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::NewtonNewton(const ROOT::Math::Roots::Newton&); ROOT::Math::Roots::Newton&operator=(const ROOT::Math::Roots::Newton&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Newton(). virtual ~Newton(). Newton(const ROOT::Math::Roots::Newton& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Newton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Newton.html
https://root.cern/root/html532/ROOT__Math__Roots__Newton.html:1960,Modifiability,Inherit,Inherited,1960,"ing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Newton(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; ROOT::Math::Roots::NewtonNewton(); virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::NewtonNewton(const ROOT::Math::Roots::Newton&); ROOT::Math::Roots::Newton&operator=(const ROOT::Math::Roots::Newton&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Newton(). virtual ~Newton(). Newton(const ROOT::Math::Roots::Newton& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Newton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Newton.html
https://root.cern/root/html532/ROOT__Math__Roots__Newton.html:379,Usability,simpl,simplest,379,". ROOT::Math::Roots::Newton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Newton. class ROOT::Math::Roots::Newton: public ROOT::Math::GSLRootFinderDeriv. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Newton(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; ROOT::Math::Roots::NewtonNewton(); virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::NewtonNewton(const ROOT::Math::Roots::Newton&); ROOT::Math::Roots::Newton&operator=(const ROOT::Math::Roots::Newton&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. F",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Newton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Newton.html
https://root.cern/root/html532/ROOT__Math__Roots__Secant.html:1947,Modifiability,Inherit,Inheritance,1947,"ing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Secant(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; ROOT::Math::Roots::SecantSecant(); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Secant&operator=(const ROOT::Math::Roots::Secant&); ROOT::Math::Roots::SecantSecant(const ROOT::Math::Roots::Secant&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Secant(). virtual ~Secant(). Secant(const ROOT::Math::Roots::Secant& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Secant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Secant.html
https://root.cern/root/html532/ROOT__Math__Roots__Secant.html:1960,Modifiability,Inherit,Inherited,1960,"ing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Secant(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; ROOT::Math::Roots::SecantSecant(); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Secant&operator=(const ROOT::Math::Roots::Secant&); ROOT::Math::Roots::SecantSecant(const ROOT::Math::Roots::Secant&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Secant(). virtual ~Secant(). Secant(const ROOT::Math::Roots::Secant& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Secant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Secant.html
https://root.cern/root/html532/ROOT__Math__Roots__Secant.html:379,Usability,simpl,simplest,379,". ROOT::Math::Roots::Secant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Secant. class ROOT::Math::Roots::Secant: public ROOT::Math::GSLRootFinderDeriv. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Secant(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; ROOT::Math::Roots::SecantSecant(); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Secant&operator=(const ROOT::Math::Roots::Secant&); ROOT::Math::Roots::SecantSecant(const ROOT::Math::Roots::Secant&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. F",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Secant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Secant.html
https://root.cern/root/html532/ROOT__Math__Roots__Steffenson.html:1991,Modifiability,Inherit,Inheritance,1991,"ormation; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Steffenson(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const; ROOT::Math::Roots::SteffensonSteffenson(). protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Steffenson&operator=(const ROOT::Math::Roots::Steffenson&); ROOT::Math::Roots::SteffensonSteffenson(const ROOT::Math::Roots::Steffenson&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Steffenson(). virtual ~Steffenson(). Steffenson(const ROOT::Math::Roots::Steffenson& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Steffenson.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Steffenson.html
https://root.cern/root/html532/ROOT__Math__Roots__Steffenson.html:2004,Modifiability,Inherit,Inherited,2004,"ormation; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Steffenson(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const; ROOT::Math::Roots::SteffensonSteffenson(). protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Steffenson&operator=(const ROOT::Math::Roots::Steffenson&); ROOT::Math::Roots::SteffensonSteffenson(const ROOT::Math::Roots::Steffenson&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Steffenson(). virtual ~Steffenson(). Steffenson(const ROOT::Math::Roots::Steffenson& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Steffenson.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Steffenson.html
https://root.cern/root/html532/ROOT__Math__Roots__Steffenson.html:391,Usability,simpl,simplest,391,". ROOT::Math::Roots::Steffenson. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Steffenson. class ROOT::Math::Roots::Steffenson: public ROOT::Math::GSLRootFinderDeriv. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Steffenson(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const; ROOT::Math::Roots::SteffensonSteffenson(). protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Steffenson&operator=(const ROOT::Math::Roots::Steffenson&); ROOT::Math::Roots::SteffensonSteffenson(const ROOT::Math::Roots::Steffenson&). Class Charts. Inheritanc",MatchSource.WIKI,root/html532/ROOT__Math__Roots__Steffenson.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Roots__Steffenson.html
https://root.cern/root/html532/ROOT__Math__Rotation3D.html:5801,Modifiability,Inherit,Inheritance,5801,"D::Scalar zz); voidSetComponents(double* begin, double* end); voidSetComponents(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3); voidSetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz). Data Members; public:. enum ERotation3DMatrixIndex { kXX; kXY; kXZ; kYX; kYY; kYZ; kZX; kZY; kZZ; };. private:. ROOT::Math::Rotation3D::ScalarfM[9]9 elements (3x3 matrix) representing the rotation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Rotation3D(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). Rotation3D(double* begin, double* end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of nine Scalars. { SetComponents(begin,end); }. Rotation3D( Rotation3D const & r ). copy constructor. explicit Rotation3D( AxisAngle const & a ). Construct from an AxisAngle. { gv_detail::convert(a, *this); }. explicit Rotation3D( EulerAngles const & e ). Construct from EulerAngles. { gv_detail::convert(e, *this); }. explicit Rotation3D( RotationZYX const & e ). Construct from RotationZYX. { gv_detail::convert(e, *this); }. explicit Rotation3D( Quaternion const & q ). Construct from a Quaternion. { gv_detail::convert(q, *this); }. explicit Rotation3D( RotationZ const & r ). Construct from an axial rotation. { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationY const & r ); { gv_d",MatchSource.WIKI,root/html532/ROOT__Math__Rotation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Rotation3D.html
https://root.cern/root/html532/ROOT__Math__Rotation3D.html:5814,Modifiability,Inherit,Inherited,5814,"D::Scalar zz); voidSetComponents(double* begin, double* end); voidSetComponents(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3); voidSetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz). Data Members; public:. enum ERotation3DMatrixIndex { kXX; kXY; kXZ; kYX; kYY; kYZ; kZX; kZY; kZZ; };. private:. ROOT::Math::Rotation3D::ScalarfM[9]9 elements (3x3 matrix) representing the rotation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Rotation3D(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). Rotation3D(double* begin, double* end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of nine Scalars. { SetComponents(begin,end); }. Rotation3D( Rotation3D const & r ). copy constructor. explicit Rotation3D( AxisAngle const & a ). Construct from an AxisAngle. { gv_detail::convert(a, *this); }. explicit Rotation3D( EulerAngles const & e ). Construct from EulerAngles. { gv_detail::convert(e, *this); }. explicit Rotation3D( RotationZYX const & e ). Construct from RotationZYX. { gv_detail::convert(e, *this); }. explicit Rotation3D( Quaternion const & q ). Construct from a Quaternion. { gv_detail::convert(q, *this); }. explicit Rotation3D( RotationZ const & r ). Construct from an axial rotation. { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationY const & r ); { gv_d",MatchSource.WIKI,root/html532/ROOT__Math__Rotation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Rotation3D.html
https://root.cern/root/html532/ROOT__Math__Rotation3D.html:7203,Performance,perform,performed,7203,"tion3D const & r ). copy constructor. explicit Rotation3D( AxisAngle const & a ). Construct from an AxisAngle. { gv_detail::convert(a, *this); }. explicit Rotation3D( EulerAngles const & e ). Construct from EulerAngles. { gv_detail::convert(e, *this); }. explicit Rotation3D( RotationZYX const & e ). Construct from RotationZYX. { gv_detail::convert(e, *this); }. explicit Rotation3D( Quaternion const & q ). Construct from a Quaternion. { gv_detail::convert(q, *this); }. explicit Rotation3D( RotationZ const & r ). Construct from an axial rotation. { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationY const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationX const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D(const ForeignMatrix & m). Construct from a linear algebra matrix of size at least 3x3,; which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; Precondition: The matrix is assumed to be orthonormal. No checking; or re-adjusting is performed. { SetComponents(m); }. Rotation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3). Construct from three orthonormal vectors (which must have methods; x(), y() and z()) which will be used as the columns of the rotation; matrix. The orthonormality will be checked, and values adjusted; so that the result will always be a good rotation matrix. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz); compil",MatchSource.WIKI,root/html532/ROOT__Math__Rotation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Rotation3D.html
https://root.cern/root/html532/ROOT__Math__Rotation3D.html:8370,Safety,avoid,avoid,8370,"ateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3). Construct from three orthonormal vectors (which must have methods; x(), y() and z()) which will be used as the columns of the rotation; matrix. The orthonormality will be checked, and values adjusted; so that the result will always be a good rotation matrix. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz); compiler generated destruuctor is ok. Raw constructor from nine Scalar components (without any checking). operator=( Rotation3D const & rhs ); need to implement assignment operator to avoid using the templated one. Assignment operator. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz). operator=( AxisAngle const & a ). Assign from an AxisAngle. { return operator=(Rotation3D(a)); }. operator=( EulerAngles const & e ). Assign from EulerAngles. { return operator=(Rotation3D(e)); }. operator=( RotationZYX const & r ). Assign from RotationZYX. { return operator=(Rotation3D(r)); }. operator=( Quaternion const & q ). Assign from a Quaternion. {return operator=(Rotation3D(q)); }. operator=( RotationZ const & r ). Assign from an axial rotation. { return operator=(Rotation3D(r)); }. operator=( RotationY const & r ); { return operator=(Rotation3D(r)); }. operator=( RotationX cons",MatchSource.WIKI,root/html532/ROOT__Math__Rotation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Rotation3D.html
https://root.cern/root/html532/ROOT__Math__RotationX.html:2273,Modifiability,Inherit,Inheritance,2273,"cementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::RotationX&operator*=(const ROOT::Math::RotationX& r); ROOT::Math::RotationX&operator=(const ROOT::Math::RotationX&); booloperator==(const ROOT::Math::RotationX& rhs) const; voidRectify(); ROOT::Math::RotationXRotationX(); ROOT::Math::RotationXRotationX(ROOT::Math::RotationX::Scalar angle); ROOT::Math::RotationXRotationX(const ROOT::Math::RotationX&); voidSetAngle(ROOT::Math::RotationX::Scalar angle); voidSetComponents(ROOT::Math::RotationX::Scalar angle); ROOT::Math::RotationX::ScalarSinAngle() const. Data Members; private:. ROOT::Math::RotationX::ScalarfAnglerotation angle ; ROOT::Math::RotationX::ScalarfCoscosine of the rotaiton angle ; ROOT::Math::RotationX::ScalarfSinsine of the rotation angle . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationX(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. explicit RotationX( Scalar angle ). Construct from an angle. Rectify(). void SetAngle(ROOT::Math::RotationX::Scalar angle); ======== Components ==============. Set given the angle. void SetComponents(ROOT::Math::RotationX::Scalar angle); { SetAngle(angle); }. void GetAngle(ROOT::Math::RotationX::Scalar& angle) const. Get the angle. { angle = atan2 (fSin,fCos); }. void GetComponents(ROOT::Math::RotationX::Scalar& angle) const; { GetAngle(angle); }. Scalar Angle() const. Angle of rotation. { return atan2 (fSin,fCos); }. Scalar SinAngle() const. Sine or Cosine of the rotation angle. { return fSin; }. Scalar CosAngle() const; { return fCos; }. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert a rotation in place. { fAngle = -fAngle; fSin = -fSin; }. RotationX Invers",MatchSource.WIKI,root/html532/ROOT__Math__RotationX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationX.html
https://root.cern/root/html532/ROOT__Math__RotationX.html:2286,Modifiability,Inherit,Inherited,2286,"cementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::RotationX&operator*=(const ROOT::Math::RotationX& r); ROOT::Math::RotationX&operator=(const ROOT::Math::RotationX&); booloperator==(const ROOT::Math::RotationX& rhs) const; voidRectify(); ROOT::Math::RotationXRotationX(); ROOT::Math::RotationXRotationX(ROOT::Math::RotationX::Scalar angle); ROOT::Math::RotationXRotationX(const ROOT::Math::RotationX&); voidSetAngle(ROOT::Math::RotationX::Scalar angle); voidSetComponents(ROOT::Math::RotationX::Scalar angle); ROOT::Math::RotationX::ScalarSinAngle() const. Data Members; private:. ROOT::Math::RotationX::ScalarfAnglerotation angle ; ROOT::Math::RotationX::ScalarfCoscosine of the rotaiton angle ; ROOT::Math::RotationX::ScalarfSinsine of the rotation angle . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationX(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. explicit RotationX( Scalar angle ). Construct from an angle. Rectify(). void SetAngle(ROOT::Math::RotationX::Scalar angle); ======== Components ==============. Set given the angle. void SetComponents(ROOT::Math::RotationX::Scalar angle); { SetAngle(angle); }. void GetAngle(ROOT::Math::RotationX::Scalar& angle) const. Get the angle. { angle = atan2 (fSin,fCos); }. void GetComponents(ROOT::Math::RotationX::Scalar& angle) const; { GetAngle(angle); }. Scalar Angle() const. Angle of rotation. { return atan2 (fSin,fCos); }. Scalar SinAngle() const. Sine or Cosine of the rotation angle. { return fSin; }. Scalar CosAngle() const; { return fCos; }. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert a rotation in place. { fAngle = -fAngle; fSin = -fSin; }. RotationX Invers",MatchSource.WIKI,root/html532/ROOT__Math__RotationX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationX.html
https://root.cern/root/html532/ROOT__Math__RotationY.html:2273,Modifiability,Inherit,Inheritance,2273,"cementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::RotationY&operator*=(const ROOT::Math::RotationY& r); ROOT::Math::RotationY&operator=(const ROOT::Math::RotationY&); booloperator==(const ROOT::Math::RotationY& rhs) const; voidRectify(); ROOT::Math::RotationYRotationY(); ROOT::Math::RotationYRotationY(ROOT::Math::RotationY::Scalar angle); ROOT::Math::RotationYRotationY(const ROOT::Math::RotationY&); voidSetAngle(ROOT::Math::RotationY::Scalar angle); voidSetComponents(ROOT::Math::RotationY::Scalar angle); ROOT::Math::RotationY::ScalarSinAngle() const. Data Members; private:. ROOT::Math::RotationY::ScalarfAnglerotation angle ; ROOT::Math::RotationY::ScalarfCoscosine of the rotaiton angle ; ROOT::Math::RotationY::ScalarfSinsine of the rotation angle . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationY(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. explicit RotationY( Scalar angle ). Construct from an angle. Rectify(). void SetAngle(ROOT::Math::RotationY::Scalar angle); ======== Components ==============. Set given the angle. void SetComponents(ROOT::Math::RotationY::Scalar angle); { SetAngle(angle); }. void GetAngle(ROOT::Math::RotationY::Scalar& angle) const. Get the angle. { angle = atan2 (fSin,fCos); }. void GetComponents(ROOT::Math::RotationY::Scalar& angle) const; { GetAngle(angle); }. Scalar Angle() const. Angle of rotation. { return atan2 (fSin,fCos); }. Scalar SinAngle() const. Sine or Cosine of the rotation angle. { return fSin; }. Scalar CosAngle() const; { return fCos; }. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert a rotation in place. { fAngle = -fAngle; fSin = -fSin; }. RotationY Invers",MatchSource.WIKI,root/html532/ROOT__Math__RotationY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationY.html
https://root.cern/root/html532/ROOT__Math__RotationY.html:2286,Modifiability,Inherit,Inherited,2286,"cementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::RotationY&operator*=(const ROOT::Math::RotationY& r); ROOT::Math::RotationY&operator=(const ROOT::Math::RotationY&); booloperator==(const ROOT::Math::RotationY& rhs) const; voidRectify(); ROOT::Math::RotationYRotationY(); ROOT::Math::RotationYRotationY(ROOT::Math::RotationY::Scalar angle); ROOT::Math::RotationYRotationY(const ROOT::Math::RotationY&); voidSetAngle(ROOT::Math::RotationY::Scalar angle); voidSetComponents(ROOT::Math::RotationY::Scalar angle); ROOT::Math::RotationY::ScalarSinAngle() const. Data Members; private:. ROOT::Math::RotationY::ScalarfAnglerotation angle ; ROOT::Math::RotationY::ScalarfCoscosine of the rotaiton angle ; ROOT::Math::RotationY::ScalarfSinsine of the rotation angle . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationY(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. explicit RotationY( Scalar angle ). Construct from an angle. Rectify(). void SetAngle(ROOT::Math::RotationY::Scalar angle); ======== Components ==============. Set given the angle. void SetComponents(ROOT::Math::RotationY::Scalar angle); { SetAngle(angle); }. void GetAngle(ROOT::Math::RotationY::Scalar& angle) const. Get the angle. { angle = atan2 (fSin,fCos); }. void GetComponents(ROOT::Math::RotationY::Scalar& angle) const; { GetAngle(angle); }. Scalar Angle() const. Angle of rotation. { return atan2 (fSin,fCos); }. Scalar SinAngle() const. Sine or Cosine of the rotation angle. { return fSin; }. Scalar CosAngle() const; { return fCos; }. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert a rotation in place. { fAngle = -fAngle; fSin = -fSin; }. RotationY Invers",MatchSource.WIKI,root/html532/ROOT__Math__RotationY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationY.html
https://root.cern/root/html532/ROOT__Math__RotationZ.html:2273,Modifiability,Inherit,Inheritance,2273,"cementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::RotationZ&operator*=(const ROOT::Math::RotationZ& r); ROOT::Math::RotationZ&operator=(const ROOT::Math::RotationZ&); booloperator==(const ROOT::Math::RotationZ& rhs) const; voidRectify(); ROOT::Math::RotationZRotationZ(); ROOT::Math::RotationZRotationZ(ROOT::Math::RotationZ::Scalar angle); ROOT::Math::RotationZRotationZ(const ROOT::Math::RotationZ&); voidSetAngle(ROOT::Math::RotationZ::Scalar angle); voidSetComponents(ROOT::Math::RotationZ::Scalar angle); ROOT::Math::RotationZ::ScalarSinAngle() const. Data Members; private:. ROOT::Math::RotationZ::ScalarfAnglerotation angle ; ROOT::Math::RotationZ::ScalarfCoscosine of the rotaiton angle ; ROOT::Math::RotationZ::ScalarfSinsine of the rotation angle . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationZ(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. explicit RotationZ( Scalar angle ). Construct from an angle. Rectify(). void SetAngle(ROOT::Math::RotationZ::Scalar angle); ======== Components ==============. Set given the angle. void SetComponents(ROOT::Math::RotationZ::Scalar angle); { SetAngle(angle); }. void GetAngle(ROOT::Math::RotationZ::Scalar& angle) const. Get the angle. { angle = atan2 (fSin,fCos); }. void GetComponents(ROOT::Math::RotationZ::Scalar& angle) const; { GetAngle(angle); }. Scalar Angle() const. Angle of rotation. { return atan2 (fSin,fCos); }. Scalar SinAngle() const. Sine or Cosine of the rotation angle. { return fSin; }. Scalar CosAngle() const; { return fCos; }. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert a rotation in place. { fAngle = -fAngle; fSin = -fSin; }. RotationZ Invers",MatchSource.WIKI,root/html532/ROOT__Math__RotationZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationZ.html
https://root.cern/root/html532/ROOT__Math__RotationZ.html:2286,Modifiability,Inherit,Inherited,2286,"cementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::RotationZ&operator*=(const ROOT::Math::RotationZ& r); ROOT::Math::RotationZ&operator=(const ROOT::Math::RotationZ&); booloperator==(const ROOT::Math::RotationZ& rhs) const; voidRectify(); ROOT::Math::RotationZRotationZ(); ROOT::Math::RotationZRotationZ(ROOT::Math::RotationZ::Scalar angle); ROOT::Math::RotationZRotationZ(const ROOT::Math::RotationZ&); voidSetAngle(ROOT::Math::RotationZ::Scalar angle); voidSetComponents(ROOT::Math::RotationZ::Scalar angle); ROOT::Math::RotationZ::ScalarSinAngle() const. Data Members; private:. ROOT::Math::RotationZ::ScalarfAnglerotation angle ; ROOT::Math::RotationZ::ScalarfCoscosine of the rotaiton angle ; ROOT::Math::RotationZ::ScalarfSinsine of the rotation angle . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationZ(); ========== Constructors and Assignment =====================. Default constructor (identity rotation). { }. explicit RotationZ( Scalar angle ). Construct from an angle. Rectify(). void SetAngle(ROOT::Math::RotationZ::Scalar angle); ======== Components ==============. Set given the angle. void SetComponents(ROOT::Math::RotationZ::Scalar angle); { SetAngle(angle); }. void GetAngle(ROOT::Math::RotationZ::Scalar& angle) const. Get the angle. { angle = atan2 (fSin,fCos); }. void GetComponents(ROOT::Math::RotationZ::Scalar& angle) const; { GetAngle(angle); }. Scalar Angle() const. Angle of rotation. { return atan2 (fSin,fCos); }. Scalar SinAngle() const. Sine or Cosine of the rotation angle. { return fSin; }. Scalar CosAngle() const; { return fCos; }. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert a rotation in place. { fAngle = -fAngle; fSin = -fSin; }. RotationZ Invers",MatchSource.WIKI,root/html532/ROOT__Math__RotationZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationZ.html
https://root.cern/root/html532/ROOT__Math__RotationZYX.html:3927,Modifiability,Inherit,Inheritance,3927,"ROOT::Math::RotationZYX::ScalarPhi() const; ROOT::Math::RotationZYX::ScalarPsi() const; voidRectify(); ROOT::Math::RotationZYXRotationZYX(); ROOT::Math::RotationZYXRotationZYX(const ROOT::Math::RotationZYX&); ROOT::Math::RotationZYXRotationZYX(ROOT::Math::RotationZYX::Scalar phi, ROOT::Math::RotationZYX::Scalar theta, ROOT::Math::RotationZYX::Scalar psi); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::RotationZYX::Scalar phi, ROOT::Math::RotationZYX::Scalar theta, ROOT::Math::RotationZYX::Scalar psi); voidSetPhi(ROOT::Math::RotationZYX::Scalar phi); voidSetPsi(ROOT::Math::RotationZYX::Scalar psi); voidSetTheta(ROOT::Math::RotationZYX::Scalar theta); ROOT::Math::RotationZYX::ScalarTheta() const. private:. static doublePi(). Data Members; private:. doublefPhiZ rotation angle (yaw) defined in (-PI,PI]; doublefPsiX'' rotation angle (roll) defined in (-PI,PI]; doublefThetaY' rotation angle (pitch) defined in [-PI/2,PI/2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationZYX(); ========== Constructors and Assignment =====================. Default constructor. { }. RotationZYX(ROOT::Math::RotationZYX::Scalar phi, ROOT::Math::RotationZYX::Scalar theta, ROOT::Math::RotationZYX::Scalar psi). Constructor from phi, theta and psi. {Rectify();}. RotationZYX(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of three Scalars, to be treated as; the angles phi, theta and psi. { SetComponents(begin,end); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components place angles in canonical ranges. RotationZYX & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the three Euler angles given a pair of pointers or iterators; defining the beginning and end of an",MatchSource.WIKI,root/html532/ROOT__Math__RotationZYX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationZYX.html
https://root.cern/root/html532/ROOT__Math__RotationZYX.html:3940,Modifiability,Inherit,Inherited,3940,"ROOT::Math::RotationZYX::ScalarPhi() const; ROOT::Math::RotationZYX::ScalarPsi() const; voidRectify(); ROOT::Math::RotationZYXRotationZYX(); ROOT::Math::RotationZYXRotationZYX(const ROOT::Math::RotationZYX&); ROOT::Math::RotationZYXRotationZYX(ROOT::Math::RotationZYX::Scalar phi, ROOT::Math::RotationZYX::Scalar theta, ROOT::Math::RotationZYX::Scalar psi); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::RotationZYX::Scalar phi, ROOT::Math::RotationZYX::Scalar theta, ROOT::Math::RotationZYX::Scalar psi); voidSetPhi(ROOT::Math::RotationZYX::Scalar phi); voidSetPsi(ROOT::Math::RotationZYX::Scalar psi); voidSetTheta(ROOT::Math::RotationZYX::Scalar theta); ROOT::Math::RotationZYX::ScalarTheta() const. private:. static doublePi(). Data Members; private:. doublefPhiZ rotation angle (yaw) defined in (-PI,PI]; doublefPsiX'' rotation angle (roll) defined in (-PI,PI]; doublefThetaY' rotation angle (pitch) defined in [-PI/2,PI/2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RotationZYX(); ========== Constructors and Assignment =====================. Default constructor. { }. RotationZYX(ROOT::Math::RotationZYX::Scalar phi, ROOT::Math::RotationZYX::Scalar theta, ROOT::Math::RotationZYX::Scalar psi). Constructor from phi, theta and psi. {Rectify();}. RotationZYX(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of three Scalars, to be treated as; the angles phi, theta and psi. { SetComponents(begin,end); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components place angles in canonical ranges. RotationZYX & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the three Euler angles given a pair of pointers or iterators; defining the beginning and end of an",MatchSource.WIKI,root/html532/ROOT__Math__RotationZYX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RotationZYX.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_2_.html:1215,Modifiability,Inherit,Inheritance,1215,". ROOT::Math::RowOffsets<2>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<2>. class ROOT::Math::RowOffsets<2>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<2>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<2>&operator=(const ROOT::Math::RowOffsets<2>&); ROOT::Math::RowOffsets<2>RowOffsets<2>(); ROOT::Math::RowOffsets<2>RowOffsets<2>(const ROOT::Math::RowOffsets<2>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<2>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_2_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_2_.html:1228,Modifiability,Inherit,Inherited,1228,". ROOT::Math::RowOffsets<2>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<2>. class ROOT::Math::RowOffsets<2>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<2>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<2>&operator=(const ROOT::Math::RowOffsets<2>&); ROOT::Math::RowOffsets<2>RowOffsets<2>(); ROOT::Math::RowOffsets<2>RowOffsets<2>(const ROOT::Math::RowOffsets<2>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<2>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_2_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_3_.html:1215,Modifiability,Inherit,Inheritance,1215,". ROOT::Math::RowOffsets<3>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<3>. class ROOT::Math::RowOffsets<3>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<3>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<3>&operator=(const ROOT::Math::RowOffsets<3>&); ROOT::Math::RowOffsets<3>RowOffsets<3>(); ROOT::Math::RowOffsets<3>RowOffsets<3>(const ROOT::Math::RowOffsets<3>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<3>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_3_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_3_.html:1228,Modifiability,Inherit,Inherited,1228,". ROOT::Math::RowOffsets<3>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<3>. class ROOT::Math::RowOffsets<3>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<3>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<3>&operator=(const ROOT::Math::RowOffsets<3>&); ROOT::Math::RowOffsets<3>RowOffsets<3>(); ROOT::Math::RowOffsets<3>RowOffsets<3>(const ROOT::Math::RowOffsets<3>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<3>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_3_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_4_.html:1215,Modifiability,Inherit,Inheritance,1215,". ROOT::Math::RowOffsets<4>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<4>. class ROOT::Math::RowOffsets<4>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<4>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<4>&operator=(const ROOT::Math::RowOffsets<4>&); ROOT::Math::RowOffsets<4>RowOffsets<4>(); ROOT::Math::RowOffsets<4>RowOffsets<4>(const ROOT::Math::RowOffsets<4>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<4>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_4_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_4_.html:1228,Modifiability,Inherit,Inherited,1228,". ROOT::Math::RowOffsets<4>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<4>. class ROOT::Math::RowOffsets<4>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<4>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<4>&operator=(const ROOT::Math::RowOffsets<4>&); ROOT::Math::RowOffsets<4>RowOffsets<4>(); ROOT::Math::RowOffsets<4>RowOffsets<4>(const ROOT::Math::RowOffsets<4>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<4>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_4_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_5_.html:1215,Modifiability,Inherit,Inheritance,1215,". ROOT::Math::RowOffsets<5>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<5>. class ROOT::Math::RowOffsets<5>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<5>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<5>&operator=(const ROOT::Math::RowOffsets<5>&); ROOT::Math::RowOffsets<5>RowOffsets<5>(); ROOT::Math::RowOffsets<5>RowOffsets<5>(const ROOT::Math::RowOffsets<5>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<5>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_5_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_5_.html:1228,Modifiability,Inherit,Inherited,1228,". ROOT::Math::RowOffsets<5>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<5>. class ROOT::Math::RowOffsets<5>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<5>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<5>&operator=(const ROOT::Math::RowOffsets<5>&); ROOT::Math::RowOffsets<5>RowOffsets<5>(); ROOT::Math::RowOffsets<5>RowOffsets<5>(const ROOT::Math::RowOffsets<5>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<5>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_5_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_6_.html:1215,Modifiability,Inherit,Inheritance,1215,". ROOT::Math::RowOffsets<6>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<6>. class ROOT::Math::RowOffsets<6>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<6>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<6>&operator=(const ROOT::Math::RowOffsets<6>&); ROOT::Math::RowOffsets<6>RowOffsets<6>(); ROOT::Math::RowOffsets<6>RowOffsets<6>(const ROOT::Math::RowOffsets<6>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<6>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_6_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_6_.html:1228,Modifiability,Inherit,Inherited,1228,". ROOT::Math::RowOffsets<6>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<6>. class ROOT::Math::RowOffsets<6>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<6>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<6>&operator=(const ROOT::Math::RowOffsets<6>&); ROOT::Math::RowOffsets<6>RowOffsets<6>(); ROOT::Math::RowOffsets<6>RowOffsets<6>(const ROOT::Math::RowOffsets<6>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<6>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_6_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_7_.html:1215,Modifiability,Inherit,Inheritance,1215,". ROOT::Math::RowOffsets<7>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<7>. class ROOT::Math::RowOffsets<7>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<7>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<7>&operator=(const ROOT::Math::RowOffsets<7>&); ROOT::Math::RowOffsets<7>RowOffsets<7>(); ROOT::Math::RowOffsets<7>RowOffsets<7>(const ROOT::Math::RowOffsets<7>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<7>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_7_.html
https://root.cern/root/html532/ROOT__Math__RowOffsets_7_.html:1228,Modifiability,Inherit,Inherited,1228,". ROOT::Math::RowOffsets<7>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::RowOffsets<7>. class ROOT::Math::RowOffsets<7>. MatRepStd; Standard Matrix representation for a general D1 x D2 matrix.; This class is itself a template on the contained type T, the number of rows and the number of columns.; Its data member is an array T[nrows*ncols] containing the matrix data.; The data are stored in the row-major C convention.; For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8 \end{array} \right); \f]. @ingroup MatRep. Function Members (Methods); public:. ~RowOffsets<7>(); intapply(unsigned int i) const; intoperator()(unsigned int i, unsigned int j) const; ROOT::Math::RowOffsets<7>&operator=(const ROOT::Math::RowOffsets<7>&); ROOT::Math::RowOffsets<7>RowOffsets<7>(); ROOT::Math::RowOffsets<7>RowOffsets<7>(const ROOT::Math::RowOffsets<7>&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const T& operator()(unsigned int i, unsigned int j) const. T apply(unsigned int i) const; { return fArray[i]; }. MatRepStd<T, D1, D2>& operator=(const ROOT::Math::RowOffsets<7>& ). » Last changed: root/smatrix:$Id: MatrixRepresentationsStatic.h 34964 2010-08-24 13:58:51Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__RowOffsets_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__RowOffsets_7_.html
https://root.cern/root/html532/ROOT__Math__SMatrixIdentity.html:1172,Modifiability,Inherit,Inheritance,1172,". ROOT::Math::SMatrixIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrixIdentity. class ROOT::Math::SMatrixIdentity. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixIdentity(); ROOT::Math::SMatrixIdentity&operator=(const ROOT::Math::SMatrixIdentity&); ROOT::Math::SMatrixIdentitySMatrixIdentity(); ROOT::Math::SMatrixIdentitySMatrixIdentity(const ROOT::Math::SMatrixIdentity&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrixIdentity& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrixIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrixIdentity.html
https://root.cern/root/html532/ROOT__Math__SMatrixIdentity.html:1185,Modifiability,Inherit,Inherited,1185,". ROOT::Math::SMatrixIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrixIdentity. class ROOT::Math::SMatrixIdentity. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixIdentity(); ROOT::Math::SMatrixIdentity&operator=(const ROOT::Math::SMatrixIdentity&); ROOT::Math::SMatrixIdentitySMatrixIdentity(); ROOT::Math::SMatrixIdentitySMatrixIdentity(const ROOT::Math::SMatrixIdentity&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrixIdentity& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrixIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrixIdentity.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:9750,Availability,error,error,9750,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:9819,Availability,failure,failure,9819,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:10165,Availability,error,error,10165,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:10234,Availability,failure,failure,10234,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11355,Availability,error,error,11355,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:5991,Integrability,interface,interface,5991,"r<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:6444,Integrability,interface,interface,6444,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:6486,Integrability,interface,interface,6486,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:6548,Integrability,interface,interface,6548,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:6608,Integrability,interface,interface,6608,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:8300,Integrability,rout,routine,8300,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:5185,Modifiability,Inherit,Inheritance,5185," >(); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:5198,Modifiability,Inherit,Inherited,5198," >(); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:10002,Performance,perform,performing,10002,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11710,Safety,avoid,avoid,11710,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:5627,Security,Access,Access,5627,"trix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:5650,Security,access,access,5650,"trix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:5755,Security,access,accessing,5755,"trix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:6020,Security,access,access,6020,"r<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7056,Security,access,access,7056,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7170,Security,access,access,7170," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7286,Security,access,access,7286,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7464,Security,access,access,7464," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7388,Testability,assert,assert,7388,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7565,Testability,assert,assert,7565,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:9299,Availability,error,error,9299,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:9368,Availability,failure,failure,9368,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:9714,Availability,error,error,9714,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:9783,Availability,failure,failure,9783,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:10904,Availability,error,error,10904,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5540,Integrability,interface,interface,5540,"Vector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5993,Integrability,interface,interface,5993,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:6035,Integrability,interface,interface,6035,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:6097,Integrability,interface,interface,6097,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:6157,Integrability,interface,interface,6157,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:7849,Integrability,rout,routine,7849,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:4828,Modifiability,Inherit,Inheritance,4828,"RepSym<Double32_t,3> >(); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:4841,Modifiability,Inherit,Inherited,4841,"RepSym<Double32_t,3> >(); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:9551,Performance,perform,performing,9551,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:11259,Safety,avoid,avoid,11259,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5176,Security,Access,Access,5176,"Sym<Double32_t,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5199,Security,access,access,5199,"Sym<Double32_t,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5304,Security,access,accessing,5304,"Sym<Double32_t,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5569,Security,access,access,5569,"Vector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:6605,Security,access,access,6605,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:6719,Security,access,access,6719," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:6835,Security,access,access,6835,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:7013,Security,access,access,7013," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:6937,Testability,assert,assert,6937,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:7114,Testability,assert,assert,7114,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:9750,Availability,error,error,9750,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:9819,Availability,failure,failure,9819,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:10165,Availability,error,error,10165,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:10234,Availability,failure,failure,10234,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:11355,Availability,error,error,11355,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:5991,Integrability,interface,interface,5991,"r<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:6444,Integrability,interface,interface,6444,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:6486,Integrability,interface,interface,6486,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:6548,Integrability,interface,interface,6548,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:6608,Integrability,interface,interface,6608,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:8300,Integrability,rout,routine,8300,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:5185,Modifiability,Inherit,Inheritance,5185," >(); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:5198,Modifiability,Inherit,Inherited,5198," >(); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:10002,Performance,perform,performing,10002,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:11710,Safety,avoid,avoid,11710,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:5627,Security,Access,Access,5627,"trix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:5650,Security,access,access,5650,"trix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:5755,Security,access,accessing,5755,"trix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:6020,Security,access,access,6020,"r<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:7056,Security,access,access,7056,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:7170,Security,access,access,7170," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:7286,Security,access,access,7286,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:7464,Security,access,access,7464," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:7388,Testability,assert,assert,7388,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:7565,Testability,assert,assert,7565,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:9299,Availability,error,error,9299,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:9368,Availability,failure,failure,9368,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:9714,Availability,error,error,9714,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:9783,Availability,failure,failure,9783,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:10904,Availability,error,error,10904,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5540,Integrability,interface,interface,5540,"Vector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5993,Integrability,interface,interface,5993,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:6035,Integrability,interface,interface,6035,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:6097,Integrability,interface,interface,6097,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:6157,Integrability,interface,interface,6157,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:7849,Integrability,rout,routine,7849,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:4828,Modifiability,Inherit,Inheritance,4828,"RepSym<Double32_t,4> >(); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:4841,Modifiability,Inherit,Inherited,4841,"RepSym<Double32_t,4> >(); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:9551,Performance,perform,performing,9551,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:11259,Safety,avoid,avoid,11259,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5176,Security,Access,Access,5176,"Sym<Double32_t,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5199,Security,access,access,5199,"Sym<Double32_t,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5304,Security,access,accessing,5304,"Sym<Double32_t,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5569,Security,access,access,5569,"Vector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:6605,Security,access,access,6605,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:6719,Security,access,access,6719," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:6835,Security,access,access,6835,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:7013,Security,access,access,7013," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:6937,Testability,assert,assert,6937,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:7114,Testability,assert,assert,7114,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:9750,Availability,error,error,9750,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:9819,Availability,failure,failure,9819,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:10165,Availability,error,error,10165,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:10234,Availability,failure,failure,10234,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:11355,Availability,error,error,11355,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:5991,Integrability,interface,interface,5991,"r<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:6444,Integrability,interface,interface,6444,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:6486,Integrability,interface,interface,6486,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:6548,Integrability,interface,interface,6548,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:6608,Integrability,interface,interface,6608,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:8300,Integrability,rout,routine,8300,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:5185,Modifiability,Inherit,Inheritance,5185," >(); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:5198,Modifiability,Inherit,Inherited,5198," >(); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:10002,Performance,perform,performing,10002,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:11710,Safety,avoid,avoid,11710,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:5627,Security,Access,Access,5627,"trix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:5650,Security,access,access,5650,"trix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:5755,Security,access,accessing,5755,"trix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:6020,Security,access,access,6020,"r<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:7056,Security,access,access,7056,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:7170,Security,access,access,7170," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:7286,Security,access,access,7286,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:7464,Security,access,access,7464," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:7388,Testability,assert,assert,7388,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:7565,Testability,assert,assert,7565,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:9299,Availability,error,error,9299,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:9368,Availability,failure,failure,9368,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:9714,Availability,error,error,9714,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:9783,Availability,failure,failure,9783,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:10904,Availability,error,error,10904,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5540,Integrability,interface,interface,5540,"Vector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5993,Integrability,interface,interface,5993,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:6035,Integrability,interface,interface,6035,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:6097,Integrability,interface,interface,6097,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:6157,Integrability,interface,interface,6157,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:7849,Integrability,rout,routine,7849,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:4828,Modifiability,Inherit,Inheritance,4828,"RepSym<Double32_t,5> >(); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:4841,Modifiability,Inherit,Inherited,4841,"RepSym<Double32_t,5> >(); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:9551,Performance,perform,performing,9551,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:11259,Safety,avoid,avoid,11259,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5176,Security,Access,Access,5176,"Sym<Double32_t,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5199,Security,access,access,5199,"Sym<Double32_t,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5304,Security,access,accessing,5304,"Sym<Double32_t,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5569,Security,access,access,5569,"Vector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:6605,Security,access,access,6605,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:6719,Security,access,access,6719," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:6835,Security,access,access,6835,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:7013,Security,access,access,7013," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:6937,Testability,assert,assert,6937,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:7114,Testability,assert,assert,7114,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:9750,Availability,error,error,9750,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:9819,Availability,failure,failure,9819,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:10165,Availability,error,error,10165,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:10234,Availability,failure,failure,10234,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:11355,Availability,error,error,11355,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:5991,Integrability,interface,interface,5991,"r<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:6444,Integrability,interface,interface,6444,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:6486,Integrability,interface,interface,6486,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:6548,Integrability,interface,interface,6548,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:6608,Integrability,interface,interface,6608,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:8300,Integrability,rout,routine,8300,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:5185,Modifiability,Inherit,Inheritance,5185," >(); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:5198,Modifiability,Inherit,Inherited,5198," >(); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:10002,Performance,perform,performing,10002,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:11710,Safety,avoid,avoid,11710,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:5627,Security,Access,Access,5627,"trix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:5650,Security,access,access,5650,"trix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:5755,Security,access,accessing,5755,"trix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:6020,Security,access,access,6020,"r<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:7056,Security,access,access,7056,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:7170,Security,access,access,7170," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:7286,Security,access,access,7286,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:7464,Security,access,access,7464," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:7388,Testability,assert,assert,7388,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:7565,Testability,assert,assert,7565,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:9299,Availability,error,error,9299,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:9368,Availability,failure,failure,9368,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:9714,Availability,error,error,9714,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:9783,Availability,failure,failure,9783,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() c",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:10904,Availability,error,error,10904,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5540,Integrability,interface,interface,5540,"Vector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5993,Integrability,interface,interface,5993,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsign",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:6035,Integrability,interface,interface,6035,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to ma",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:6097,Integrability,interface,interface,6097,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:6157,Integrability,interface,interface,6157,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:7849,Integrability,rout,routine,7849,"heck index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:4828,Modifiability,Inherit,Inheritance,4828,"RepSym<Double32_t,6> >(); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:4841,Modifiability,Inherit,Inherited,4841,"RepSym<Double32_t,6> >(); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:9551,Performance,perform,performing,9551,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:11259,Safety,avoid,avoid,11259,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5176,Security,Access,Access,5176,"Sym<Double32_t,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5199,Security,access,access,5199,"Sym<Double32_t,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5304,Security,access,accessing,5304,"Sym<Double32_t,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5569,Security,access,access,5569,"Vector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:6605,Security,access,access,6605,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:6719,Security,access,access,6719," the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:6835,Security,access,access,6835,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:7013,Security,access,access,7013," interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by th",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:6937,Testability,assert,assert,6937,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:7114,Testability,assert,assert,7114,"ace. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Inver",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:9417,Availability,error,error,9417,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:9486,Availability,failure,failure,9486,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:9832,Availability,error,error,9832,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:9901,Availability,failure,failure,9901,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:11014,Availability,error,error,11014,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5686,Integrability,interface,interface,5686,"::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6139,Integrability,interface,interface,6139,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6181,Integrability,interface,interface,6181,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6243,Integrability,interface,interface,6243,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6303,Integrability,interface,interface,6303,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7967,Integrability,rout,routine,7967," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:4880,Modifiability,Inherit,Inheritance,4880,",2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:4893,Modifiability,Inherit,Inherited,4893,",2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:9669,Performance,perform,performing,9669,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:11365,Safety,avoid,avoid,11365,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5322,Security,Access,Access,5322,"e,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5345,Security,access,access,5345,"e,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5450,Security,access,accessing,5450,"e,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5715,Security,access,access,5715,"::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6739,Security,access,access,6739,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6853,Security,access,access,6853,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6969,Security,access,access,6969,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7147,Security,access,access,7147,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7071,Testability,assert,assert,7071,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7248,Testability,assert,assert,7248,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9043,Availability,error,error,9043,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9112,Availability,failure,failure,9112,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9458,Availability,error,error,9458,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9527,Availability,failure,failure,9527,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:10640,Availability,error,error,10640,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5312,Integrability,interface,interface,5312,"st ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5765,Integrability,interface,interface,5765,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5807,Integrability,interface,interface,5807,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5869,Integrability,interface,interface,5869,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5929,Integrability,interface,interface,5929,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:7593,Integrability,rout,routine,7593," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:4600,Modifiability,Inherit,Inheritance,4600,"OT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:4613,Modifiability,Inherit,Inherited,4613,"OT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9295,Performance,perform,performing,9295,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:10991,Safety,avoid,avoid,10991,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:4948,Security,Access,Access,4948,"(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:4971,Security,access,access,4971,"(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5076,Security,access,accessing,5076,"(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5341,Security,access,access,5341,"st ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6365,Security,access,access,6365,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6479,Security,access,access,6479,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6595,Security,access,access,6595,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6773,Security,access,access,6773,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6697,Testability,assert,assert,6697,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6874,Testability,assert,assert,6874,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html:1773,Modifiability,Inherit,Inheritance,1773," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html:1786,Modifiability,Inherit,Inherited,1786," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html:1678,Modifiability,Inherit,Inheritance,1678,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html:1691,Modifiability,Inherit,Inherited,1691,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9417,Availability,error,error,9417,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9486,Availability,failure,failure,9486,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9832,Availability,error,error,9832,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9901,Availability,failure,failure,9901,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:11014,Availability,error,error,11014,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5686,Integrability,interface,interface,5686,"::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6139,Integrability,interface,interface,6139,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6181,Integrability,interface,interface,6181,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6243,Integrability,interface,interface,6243,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6303,Integrability,interface,interface,6303,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7967,Integrability,rout,routine,7967," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:4880,Modifiability,Inherit,Inheritance,4880,",3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:4893,Modifiability,Inherit,Inherited,4893,",3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9669,Performance,perform,performing,9669,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:11365,Safety,avoid,avoid,11365,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5322,Security,Access,Access,5322,"e,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5345,Security,access,access,5345,"e,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5450,Security,access,accessing,5450,"e,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5715,Security,access,access,5715,"::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6739,Security,access,access,6739,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6853,Security,access,access,6853,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6969,Security,access,access,6969,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7147,Security,access,access,7147,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7071,Testability,assert,assert,7071,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7248,Testability,assert,assert,7248,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9043,Availability,error,error,9043,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9112,Availability,failure,failure,9112,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9458,Availability,error,error,9458,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9527,Availability,failure,failure,9527,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:10640,Availability,error,error,10640,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5312,Integrability,interface,interface,5312,"st ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5765,Integrability,interface,interface,5765,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5807,Integrability,interface,interface,5807,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5869,Integrability,interface,interface,5869,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5929,Integrability,interface,interface,5929,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:7593,Integrability,rout,routine,7593," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:4600,Modifiability,Inherit,Inheritance,4600,"OT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:4613,Modifiability,Inherit,Inherited,4613,"OT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9295,Performance,perform,performing,9295,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:10991,Safety,avoid,avoid,10991,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:4948,Security,Access,Access,4948,"(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:4971,Security,access,access,4971,"(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5076,Security,access,accessing,5076,"(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5341,Security,access,access,5341,"st ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6365,Security,access,access,6365,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6479,Security,access,access,6479,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6595,Security,access,access,6595,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6773,Security,access,access,6773,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6697,Testability,assert,assert,6697,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6874,Testability,assert,assert,6874,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html:1773,Modifiability,Inherit,Inheritance,1773," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html:1786,Modifiability,Inherit,Inherited,1786," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html:1678,Modifiability,Inherit,Inheritance,1678,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html:1691,Modifiability,Inherit,Inherited,1691,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9307,Availability,error,error,9307,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9376,Availability,failure,failure,9376,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9722,Availability,error,error,9722,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9791,Availability,failure,failure,9791,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:10904,Availability,error,error,10904,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5576,Integrability,interface,interface,5576,"::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6029,Integrability,interface,interface,6029,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6071,Integrability,interface,interface,6071,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6133,Integrability,interface,interface,6133,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6193,Integrability,interface,interface,6193,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7857,Integrability,rout,routine,7857," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:4770,Modifiability,Inherit,Inheritance,4770,",3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:4783,Modifiability,Inherit,Inherited,4783,",3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9559,Performance,perform,performing,9559,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:11255,Safety,avoid,avoid,11255,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5212,Security,Access,Access,5212,"e,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5235,Security,access,access,5235,"e,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5340,Security,access,accessing,5340,"e,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5605,Security,access,access,5605,"::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6629,Security,access,access,6629,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6743,Security,access,access,6743,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6859,Security,access,access,6859,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7037,Security,access,access,7037,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6961,Testability,assert,assert,6961,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7138,Testability,assert,assert,7138,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9307,Availability,error,error,9307,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9376,Availability,failure,failure,9376,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9722,Availability,error,error,9722,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9791,Availability,failure,failure,9791,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:10904,Availability,error,error,10904,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5576,Integrability,interface,interface,5576,"::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6029,Integrability,interface,interface,6029,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6071,Integrability,interface,interface,6071,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6133,Integrability,interface,interface,6133,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6193,Integrability,interface,interface,6193,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7857,Integrability,rout,routine,7857," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:4770,Modifiability,Inherit,Inheritance,4770,",4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:4783,Modifiability,Inherit,Inherited,4783,",4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9559,Performance,perform,performing,9559,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:11255,Safety,avoid,avoid,11255,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5212,Security,Access,Access,5212,"e,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5235,Security,access,access,5235,"e,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5340,Security,access,accessing,5340,"e,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5605,Security,access,access,5605,"::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6629,Security,access,access,6629,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6743,Security,access,access,6743,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6859,Security,access,access,6859,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7037,Security,access,access,7037,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6961,Testability,assert,assert,6961,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7138,Testability,assert,assert,7138,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9417,Availability,error,error,9417,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9486,Availability,failure,failure,9486,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9832,Availability,error,error,9832,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9901,Availability,failure,failure,9901,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:11014,Availability,error,error,11014,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5686,Integrability,interface,interface,5686,"::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6139,Integrability,interface,interface,6139,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6181,Integrability,interface,interface,6181,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6243,Integrability,interface,interface,6243,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6303,Integrability,interface,interface,6303,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7967,Integrability,rout,routine,7967," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:4880,Modifiability,Inherit,Inheritance,4880,",4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:4893,Modifiability,Inherit,Inherited,4893,",4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9669,Performance,perform,performing,9669,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:11365,Safety,avoid,avoid,11365,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5322,Security,Access,Access,5322,"e,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5345,Security,access,access,5345,"e,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5450,Security,access,accessing,5450,"e,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5715,Security,access,access,5715,"::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6739,Security,access,access,6739,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6853,Security,access,access,6853,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6969,Security,access,access,6969,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7147,Security,access,access,7147,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7071,Testability,assert,assert,7071,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7248,Testability,assert,assert,7248,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9043,Availability,error,error,9043,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9112,Availability,failure,failure,9112,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9458,Availability,error,error,9458,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9527,Availability,failure,failure,9527,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:10640,Availability,error,error,10640,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5312,Integrability,interface,interface,5312,"st ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5765,Integrability,interface,interface,5765,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5807,Integrability,interface,interface,5807,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5869,Integrability,interface,interface,5869,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5929,Integrability,interface,interface,5929,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:7593,Integrability,rout,routine,7593," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:4600,Modifiability,Inherit,Inheritance,4600,"OT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:4613,Modifiability,Inherit,Inherited,4613,"OT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9295,Performance,perform,performing,9295,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:10991,Safety,avoid,avoid,10991,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:4948,Security,Access,Access,4948,"(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:4971,Security,access,access,4971,"(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5076,Security,access,accessing,5076,"(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5341,Security,access,access,5341,"st ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6365,Security,access,access,6365,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6479,Security,access,access,6479,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6595,Security,access,access,6595,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6773,Security,access,access,6773,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6697,Testability,assert,assert,6697,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6874,Testability,assert,assert,6874,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html:1773,Modifiability,Inherit,Inheritance,1773," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html:1786,Modifiability,Inherit,Inherited,1786," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html:1678,Modifiability,Inherit,Inheritance,1678,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html:1691,Modifiability,Inherit,Inherited,1691,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9417,Availability,error,error,9417,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9486,Availability,failure,failure,9486,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9832,Availability,error,error,9832,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9901,Availability,failure,failure,9901,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:11014,Availability,error,error,11014,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5686,Integrability,interface,interface,5686,"::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6139,Integrability,interface,interface,6139,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6181,Integrability,interface,interface,6181,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6243,Integrability,interface,interface,6243,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6303,Integrability,interface,interface,6303,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7967,Integrability,rout,routine,7967," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:4880,Modifiability,Inherit,Inheritance,4880,",5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:4893,Modifiability,Inherit,Inherited,4893,",5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9669,Performance,perform,performing,9669,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:11365,Safety,avoid,avoid,11365,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5322,Security,Access,Access,5322,"e,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5345,Security,access,access,5345,"e,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5450,Security,access,accessing,5450,"e,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5715,Security,access,access,5715,"::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6739,Security,access,access,6739,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6853,Security,access,access,6853,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6969,Security,access,access,6969,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7147,Security,access,access,7147,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7071,Testability,assert,assert,7071,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7248,Testability,assert,assert,7248,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9043,Availability,error,error,9043,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9112,Availability,failure,failure,9112,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9458,Availability,error,error,9458,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9527,Availability,failure,failure,9527,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:10640,Availability,error,error,10640,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5312,Integrability,interface,interface,5312,"st ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5765,Integrability,interface,interface,5765,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5807,Integrability,interface,interface,5807,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5869,Integrability,interface,interface,5869,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5929,Integrability,interface,interface,5929,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:7593,Integrability,rout,routine,7593," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:4600,Modifiability,Inherit,Inheritance,4600,"OT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:4613,Modifiability,Inherit,Inherited,4613,"OT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9295,Performance,perform,performing,9295,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:10991,Safety,avoid,avoid,10991,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:4948,Security,Access,Access,4948,"(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:4971,Security,access,access,4971,"(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5076,Security,access,accessing,5076,"(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5341,Security,access,access,5341,"st ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6365,Security,access,access,6365,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6479,Security,access,access,6479,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6595,Security,access,access,6595,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6773,Security,access,access,6773,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6697,Testability,assert,assert,6697,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6874,Testability,assert,assert,6874,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html:1773,Modifiability,Inherit,Inheritance,1773," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html:1786,Modifiability,Inherit,Inherited,1786," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html:1678,Modifiability,Inherit,Inheritance,1678,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html:1691,Modifiability,Inherit,Inherited,1691,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9417,Availability,error,error,9417,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9486,Availability,failure,failure,9486,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9832,Availability,error,error,9832,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9901,Availability,failure,failure,9901,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:11014,Availability,error,error,11014,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5686,Integrability,interface,interface,5686,"::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6139,Integrability,interface,interface,6139,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6181,Integrability,interface,interface,6181,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6243,Integrability,interface,interface,6243,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6303,Integrability,interface,interface,6303,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7967,Integrability,rout,routine,7967," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:4880,Modifiability,Inherit,Inheritance,4880,",6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:4893,Modifiability,Inherit,Inherited,4893,",6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9669,Performance,perform,performing,9669,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:11365,Safety,avoid,avoid,11365,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5322,Security,Access,Access,5322,"e,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5345,Security,access,access,5345,"e,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5450,Security,access,accessing,5450,"e,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5715,Security,access,access,5715,"::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6739,Security,access,access,6739,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6853,Security,access,access,6853,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6969,Security,access,access,6969,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7147,Security,access,access,7147,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7071,Testability,assert,assert,7071,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7248,Testability,assert,assert,7248,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9043,Availability,error,error,9043,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9112,Availability,failure,failure,9112,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9458,Availability,error,error,9458,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9527,Availability,failure,failure,9527,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:10640,Availability,error,error,10640,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5312,Integrability,interface,interface,5312,"st ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5765,Integrability,interface,interface,5765,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5807,Integrability,interface,interface,5807,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5869,Integrability,interface,interface,5869,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5929,Integrability,interface,interface,5929,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:7593,Integrability,rout,routine,7593," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:4600,Modifiability,Inherit,Inheritance,4600,"OT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:4613,Modifiability,Inherit,Inherited,4613,"OT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9295,Performance,perform,performing,9295,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:10991,Safety,avoid,avoid,10991,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:4948,Security,Access,Access,4948,"(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:4971,Security,access,access,4971,"(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5076,Security,access,accessing,5076,"(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5341,Security,access,access,5341,"st ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6365,Security,access,access,6365,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6479,Security,access,access,6479,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6595,Security,access,access,6595,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6773,Security,access,access,6773,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6697,Testability,assert,assert,6697,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6874,Testability,assert,assert,6874,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html:1773,Modifiability,Inherit,Inheritance,1773," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html:1786,Modifiability,Inherit,Inherited,1786," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html:1678,Modifiability,Inherit,Inheritance,1678,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html:1691,Modifiability,Inherit,Inherited,1691,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9417,Availability,error,error,9417,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9486,Availability,failure,failure,9486,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9832,Availability,error,error,9832,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9901,Availability,failure,failure,9901,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:11014,Availability,error,error,11014,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5686,Integrability,interface,interface,5686,"::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6139,Integrability,interface,interface,6139,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6181,Integrability,interface,interface,6181,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6243,Integrability,interface,interface,6243,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6303,Integrability,interface,interface,6303,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7967,Integrability,rout,routine,7967," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:4880,Modifiability,Inherit,Inheritance,4880,",7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:4893,Modifiability,Inherit,Inherited,4893,",7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9669,Performance,perform,performing,9669,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:11365,Safety,avoid,avoid,11365,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5322,Security,Access,Access,5322,"e,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5345,Security,access,access,5345,"e,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5450,Security,access,accessing,5450,"e,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5715,Security,access,access,5715,"::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6739,Security,access,access,6739,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6853,Security,access,access,6853,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6969,Security,access,access,6969,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7147,Security,access,access,7147,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7071,Testability,assert,assert,7071,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7248,Testability,assert,assert,7248,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9043,Availability,error,error,9043,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9112,Availability,failure,failure,9112,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9458,Availability,error,error,9458,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9527,Availability,failure,failure,9527,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:10640,Availability,error,error,10640,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5312,Integrability,interface,interface,5312,"st ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5765,Integrability,interface,interface,5765,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5807,Integrability,interface,interface,5807,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5869,Integrability,interface,interface,5869,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5929,Integrability,interface,interface,5929,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:7593,Integrability,rout,routine,7593," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:4600,Modifiability,Inherit,Inheritance,4600,"OT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:4613,Modifiability,Inherit,Inherited,4613,"OT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9295,Performance,perform,performing,9295,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:10991,Safety,avoid,avoid,10991,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:4948,Security,Access,Access,4948,"(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:4971,Security,access,access,4971,"(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5076,Security,access,accessing,5076,"(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5341,Security,access,access,5341,"st ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6365,Security,access,access,6365,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6479,Security,access,access,6479,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6595,Security,access,access,6595,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6773,Security,access,access,6773,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6697,Testability,assert,assert,6697,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6874,Testability,assert,assert,6874,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html:1773,Modifiability,Inherit,Inheritance,1773," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html:1786,Modifiability,Inherit,Inherited,1786," D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html:1678,Modifiability,Inherit,Inheritance,1678,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html:1691,Modifiability,Inherit,Inherited,1691,". Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9338,Availability,error,error,9338,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9407,Availability,failure,failure,9407,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9753,Availability,error,error,9753,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9822,Availability,failure,failure,9822,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:10935,Availability,error,error,10935,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5607,Integrability,interface,interface,5607,"::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6060,Integrability,interface,interface,6060,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6102,Integrability,interface,interface,6102,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6164,Integrability,interface,interface,6164,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6224,Integrability,interface,interface,6224,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7888,Integrability,rout,routine,7888," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:4801,Modifiability,Inherit,Inheritance,4801,",9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:4814,Modifiability,Inherit,Inherited,4814,",9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9590,Performance,perform,performing,9590,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:11286,Safety,avoid,avoid,11286,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5243,Security,Access,Access,5243,"e,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5266,Security,access,access,5266,"e,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5371,Security,access,accessing,5371,"e,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5636,Security,access,access,5636,"::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6660,Security,access,access,6660,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6774,Security,access,access,6774,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6890,Security,access,access,6890,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7068,Security,access,access,7068,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6992,Testability,assert,assert,6992,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7169,Testability,assert,assert,7169,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html:1793,Modifiability,Inherit,Inheritance,1793,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html:1806,Modifiability,Inherit,Inherited,1806,"ass.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); double&operator[](int j); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html:1694,Modifiability,Inherit,Inheritance,1694,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html:1707,Modifiability,Inherit,Inherited,1707,"ss description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const. class ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const double&operator[](int j) const; ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9312,Availability,error,error,9312,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9381,Availability,failure,failure,9381,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9727,Availability,error,error,9727,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9796,Availability,failure,failure,9796,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10907,Availability,error,error,10907,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5588,Integrability,interface,interface,5588,"th::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6041,Integrability,interface,interface,6041,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6083,Integrability,interface,interface,6083,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6145,Integrability,interface,interface,6145,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6205,Integrability,interface,interface,6205,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7862,Integrability,rout,routine,7862," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:4782,Modifiability,Inherit,Inheritance,4782," ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:4795,Modifiability,Inherit,Inherited,4795," ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9564,Performance,perform,performing,9564,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11257,Safety,avoid,avoid,11257,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5224,Security,Access,Access,5224,"SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5247,Security,access,access,5247,"SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5352,Security,access,accessing,5352,"SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5617,Security,access,access,5617,"th::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6638,Security,access,access,6638,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6752,Security,access,access,6752,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6868,Security,access,access,6868,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7046,Security,access,access,7046,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6970,Testability,assert,assert,6970,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7147,Testability,assert,assert,7147,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html:1772,Modifiability,Inherit,Inheritance,1772,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html:1785,Modifiability,Inherit,Inherited,1785,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html:1677,Modifiability,Inherit,Inheritance,1677," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html:1690,Modifiability,Inherit,Inherited,1690," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:8944,Availability,error,error,8944,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9013,Availability,failure,failure,9013,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9359,Availability,error,error,9359,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9428,Availability,failure,failure,9428,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:10539,Availability,error,error,10539,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5220,Integrability,interface,interface,5220,"(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5673,Integrability,interface,interface,5673,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5715,Integrability,interface,interface,5715,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5777,Integrability,interface,interface,5777,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5837,Integrability,interface,interface,5837,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:7494,Integrability,rout,routine,7494," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4508,Modifiability,Inherit,Inheritance,4508,"igned int therow) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4521,Modifiability,Inherit,Inherited,4521,"igned int therow) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9196,Performance,perform,performing,9196,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:10889,Safety,avoid,avoid,10889,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4856,Security,Access,Access,4856,"pSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4879,Security,access,access,4879,"pSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4984,Security,access,accessing,4984,"pSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5249,Security,access,access,5249,"(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6270,Security,access,access,6270,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6384,Security,access,access,6384,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6500,Security,access,access,6500,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6678,Security,access,access,6678,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6602,Testability,assert,assert,6602,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6779,Testability,assert,assert,6779,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html:1752,Modifiability,Inherit,Inheritance,1752," generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html:1765,Modifiability,Inherit,Inherited,1765," generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html:1661,Modifiability,Inherit,Inheritance,1661," ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html:1674,Modifiability,Inherit,Inherited,1674," ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9312,Availability,error,error,9312,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9381,Availability,failure,failure,9381,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9727,Availability,error,error,9727,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9796,Availability,failure,failure,9796,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:10907,Availability,error,error,10907,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5588,Integrability,interface,interface,5588,"th::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6041,Integrability,interface,interface,6041,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6083,Integrability,interface,interface,6083,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6145,Integrability,interface,interface,6145,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6205,Integrability,interface,interface,6205,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:7862,Integrability,rout,routine,7862," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:4782,Modifiability,Inherit,Inheritance,4782," ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:4795,Modifiability,Inherit,Inherited,4795," ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9564,Performance,perform,performing,9564,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:11257,Safety,avoid,avoid,11257,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5224,Security,Access,Access,5224,"SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5247,Security,access,access,5247,"SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5352,Security,access,accessing,5352,"SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5617,Security,access,access,5617,"th::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6638,Security,access,access,6638,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6752,Security,access,access,6752,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6868,Security,access,access,6868,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:7046,Security,access,access,7046,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6970,Testability,assert,assert,6970,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:7147,Testability,assert,assert,7147,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html:1772,Modifiability,Inherit,Inheritance,1772,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html:1785,Modifiability,Inherit,Inherited,1785,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html:1677,Modifiability,Inherit,Inheritance,1677," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html:1690,Modifiability,Inherit,Inherited,1690," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:8944,Availability,error,error,8944,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9013,Availability,failure,failure,9013,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9359,Availability,error,error,9359,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9428,Availability,failure,failure,9428,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:10539,Availability,error,error,10539,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5220,Integrability,interface,interface,5220,"(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5673,Integrability,interface,interface,5673,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5715,Integrability,interface,interface,5715,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5777,Integrability,interface,interface,5777,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5837,Integrability,interface,interface,5837,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:7494,Integrability,rout,routine,7494," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4508,Modifiability,Inherit,Inheritance,4508,"igned int therow) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4521,Modifiability,Inherit,Inherited,4521,"igned int therow) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9196,Performance,perform,performing,9196,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:10889,Safety,avoid,avoid,10889,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4856,Security,Access,Access,4856,"pSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4879,Security,access,access,4879,"pSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4984,Security,access,accessing,4984,"pSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5249,Security,access,access,5249,"(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6270,Security,access,access,6270,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6384,Security,access,access,6384,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6500,Security,access,access,6500,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6678,Security,access,access,6678,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6602,Testability,assert,assert,6602,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6779,Testability,assert,assert,6779,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html:1752,Modifiability,Inherit,Inheritance,1752," generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html:1765,Modifiability,Inherit,Inherited,1765," generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html:1661,Modifiability,Inherit,Inheritance,1661," ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html:1674,Modifiability,Inherit,Inherited,1674," ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9205,Availability,error,error,9205,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9274,Availability,failure,failure,9274,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9620,Availability,error,error,9620,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9689,Availability,failure,failure,9689,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:10800,Availability,error,error,10800,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5481,Integrability,interface,interface,5481,"th::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5934,Integrability,interface,interface,5934,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5976,Integrability,interface,interface,5976,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6038,Integrability,interface,interface,6038,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6098,Integrability,interface,interface,6098,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:7755,Integrability,rout,routine,7755," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:4675,Modifiability,Inherit,Inheritance,4675," ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:4688,Modifiability,Inherit,Inherited,4688," ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9457,Performance,perform,performing,9457,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:11150,Safety,avoid,avoid,11150,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5117,Security,Access,Access,5117,"SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5140,Security,access,access,5140,"SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5245,Security,access,accessing,5245,"SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5510,Security,access,access,5510,"th::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6531,Security,access,access,6531,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6645,Security,access,access,6645,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6761,Security,access,access,6761,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6939,Security,access,access,6939,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6863,Testability,assert,assert,6863,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:7040,Testability,assert,assert,7040,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html:1772,Modifiability,Inherit,Inheritance,1772,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html:1785,Modifiability,Inherit,Inherited,1785,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html:1677,Modifiability,Inherit,Inheritance,1677," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html:1690,Modifiability,Inherit,Inherited,1690," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9205,Availability,error,error,9205,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9274,Availability,failure,failure,9274,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9620,Availability,error,error,9620,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9689,Availability,failure,failure,9689,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:10800,Availability,error,error,10800,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5481,Integrability,interface,interface,5481,"th::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5934,Integrability,interface,interface,5934,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5976,Integrability,interface,interface,5976,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6038,Integrability,interface,interface,6038,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6098,Integrability,interface,interface,6098,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:7755,Integrability,rout,routine,7755," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:4675,Modifiability,Inherit,Inheritance,4675," ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:4688,Modifiability,Inherit,Inherited,4688," ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9457,Performance,perform,performing,9457,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:11150,Safety,avoid,avoid,11150,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5117,Security,Access,Access,5117,"SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5140,Security,access,access,5140,"SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5245,Security,access,accessing,5245,"SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5510,Security,access,access,5510,"th::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6531,Security,access,access,6531,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6645,Security,access,access,6645,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6761,Security,access,access,6761,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6939,Security,access,access,6939,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6863,Testability,assert,assert,6863,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:7040,Testability,assert,assert,7040,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html:1772,Modifiability,Inherit,Inheritance,1772,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html:1785,Modifiability,Inherit,Inherited,1785,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html:1677,Modifiability,Inherit,Inheritance,1677," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html:1690,Modifiability,Inherit,Inherited,1690," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9312,Availability,error,error,9312,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9381,Availability,failure,failure,9381,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9727,Availability,error,error,9727,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9796,Availability,failure,failure,9796,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:10907,Availability,error,error,10907,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5588,Integrability,interface,interface,5588,"th::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6041,Integrability,interface,interface,6041,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6083,Integrability,interface,interface,6083,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6145,Integrability,interface,interface,6145,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6205,Integrability,interface,interface,6205,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:7862,Integrability,rout,routine,7862," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:4782,Modifiability,Inherit,Inheritance,4782," ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:4795,Modifiability,Inherit,Inherited,4795," ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9564,Performance,perform,performing,9564,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:11257,Safety,avoid,avoid,11257,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5224,Security,Access,Access,5224,"SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5247,Security,access,access,5247,"SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5352,Security,access,accessing,5352,"SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5617,Security,access,access,5617,"th::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6638,Security,access,access,6638,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6752,Security,access,access,6752,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6868,Security,access,access,6868,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:7046,Security,access,access,7046,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6970,Testability,assert,assert,6970,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:7147,Testability,assert,assert,7147,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html:1772,Modifiability,Inherit,Inheritance,1772,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html:1785,Modifiability,Inherit,Inherited,1785,"e D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html:1677,Modifiability,Inherit,Inheritance,1677," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html:1690,Modifiability,Inherit,Inherited,1690," . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:8944,Availability,error,error,8944,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9013,Availability,failure,failure,9013,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9359,Availability,error,error,9359,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9428,Availability,failure,failure,9428,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:10539,Availability,error,error,10539,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5220,Integrability,interface,interface,5220,"(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5673,Integrability,interface,interface,5673,"ossible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5715,Integrability,interface,interface,5715,"OT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5777,Integrability,interface,interface,5777,"xpr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5837,Integrability,interface,interface,5837,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:7494,Integrability,rout,routine,7494," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4508,Modifiability,Inherit,Inheritance,4508,"igned int therow) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4521,Modifiability,Inherit,Inherited,4521,"igned int therow) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9196,Performance,perform,performing,9196,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:10889,Safety,avoid,avoid,10889,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4856,Security,Access,Access,4856,"pSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4879,Security,access,access,4879,"pSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4984,Security,access,accessing,4984,"pSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5249,Security,access,access,5249,"(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6270,Security,access,access,6270,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6384,Security,access,access,6384,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6500,Security,access,access,6500,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6678,Security,access,access,6678,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6602,Testability,assert,assert,6602,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6779,Testability,assert,assert,6779,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html:1752,Modifiability,Inherit,Inheritance,1752," generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html:1765,Modifiability,Inherit,Inherited,1765," generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow& ). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html:1661,Modifiability,Inherit,Inheritance,1661," ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html:1674,Modifiability,Inherit,Inherited,1674," ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SMATRIX; » ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const. class ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const. SMatrix: a generic fixed size D1 x D2 Matrix class.; The class is template on the scalar type, on the matrix sizes:; D1 = number of rows and D2 = number of columns; amd on the representation storage type.; By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9312,Availability,error,error,9312,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9381,Availability,failure,failure,9381,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9727,Availability,error,error,9727,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9796,Availability,failure,failure,9796,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:10907,Availability,error,error,10907,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:5588,Integrability,interface,interface,5588,"th::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6041,Integrability,interface,interface,6041,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6083,Integrability,interface,interface,6083,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6145,Integrability,interface,interface,6145,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6205,Integrability,interface,interface,6205,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:7862,Integrability,rout,routine,7862," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:4782,Modifiability,Inherit,Inheritance,4782," ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SVector<float,5*(5+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:4795,Modifiability,Inherit,Inherited,4795," ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SVector<float,5*(5+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9564,Performance,perform,performing,9564,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
